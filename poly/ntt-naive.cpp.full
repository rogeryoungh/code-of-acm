const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b > 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 预处理逆元、阶乘、阶乘逆元

V<int> iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u < l)
		return;
	iv = fac = ifac = V<int>(n + 1, 1);
	for (int i = 1; i <= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n] = qpow(fac[n]), iv[n] = qpow(n);
	for (int i = n - 1; i > 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
		iv[i] = 1ll * ifac[i] * fac[i - 1] % P;
	}
	pre_all(u);
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

struct Poly : V<Z> { // n2 板子，我也不知道有啥用
	using vector::vector;
	int deg() const {
		return size();
	}
};

Poly deriv(const Poly &f, int m) {
	Poly r(m);
	for (int i = 1; i < std::min(f.deg(), m + 1); i++)
		r[i - 1] = f[i] * i;
	return f;
}
Poly integr(const Poly &f, int m) {
	Poly r(m);
	for (int i = std::min(f.deg(), m - 1); i > 0; --i)
		r[i] = iv[i] * f[i - 1];
	return f;
}
Poly inv(const Poly &f, int m) {
	Poly r(m);
	Z iv0 = r[0] = f[0].inv();
	for (int i = 1; i < m; i++) {
		for (int j = 1; j < std::min(i + 1, f.deg()); j++)
			r[i] += f[j] * r[i - j];
		r[i] = -r[i] * iv0;
	}
	return r;
}

Poly div(int m, const Poly &f, const Poly &g) {
	Poly r(m);
	Z iv0 = g[0].inv();
	r[0] = f[0] * iv0;
	for (int i = 1; i < m; i++) {
		for (int j = 1; j < std::min(i + 1, g.deg()); j++)
			r[i] += g[j] * r[i - j];
		r[i] = f[i] - r[i] * iv0;
	}
	return r;
}

Poly ln(const Poly &f, int m) {
	assert(f[0].v == 1);
	return integr(div(m, deriv(f, m), f), m);
}

Poly exp(const Poly &f, int m) {
	Poly r(m), df = f;
	for (int i = 0; i < f.deg(); i++)
		df[i] *= i;
	r[0] = 1;
	for (int i = 1; i < m; i++) {
		for (int j = 1; j < std::min(i + 1, f.deg()); j++)
			r[i] += df[j] * r[i - j];
		r[i] = r[i] * iv[i];
	}
	return r;
}

Poly operator*(const Poly &f, const Poly &g) {
	Poly r(f.size() + g.size() - 1);
	for (int i = 0; i < f.size(); i++) {
		for (int j = 0; j < g.size(); j++) {
			r[i + j] += f[i] * g[j];
		}
	}
	return r;
}

Poly operator+(const Poly &f, const Poly &g) {
	Poly r(std::max(f.size(), g.size()));
	for (int i = 0; i < f.size(); i++)
		r[i] += f[i];
	for (int i = 0; i < g.size(); i++)
		r[i] += g[i];
	return r;
}

Poly operator-(const Poly &f, const Poly &g) {
	Poly r(std::max(f.size(), g.size()));
	for (int i = 0; i < f.size(); i++)
		r[i] -= f[i];
	for (int i = 0; i < g.size(); i++)
		r[i] -= g[i];
	return r;
}