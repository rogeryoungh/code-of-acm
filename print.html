<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Roger Young 的板子</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<style>
main p > code {
    color: #f14668 !important;
    background: unset  !important;
}
main pre > code {
    padding: 10px !important;
}
main p a, main ul a {
    color: #0099ff !important;
}
.katex-display {
    overflow: auto hidden;
}
</style>

<link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.css">
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.js"></script>
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/contrib/auto-render.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
        delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true },
            {left: "\\begin{equation}", right: "\\end{equation}", display: true},
        ],
        macros: {
            "\\RR": "\\mathbb{R}",
            "\\NN": "\\mathbb{N}",
            "\\QQ": "\\mathbb{Q}",
            "\\ZZ": "\\mathbb{Z}",
            "\\CC": "\\mathbb{C}",
            "\\ee": "\\mathrm{e}",
            "\\dd": "\\mathrm{d}",
            "\\eps": "\\varepsilon",
        },
        globalGroup: true,
        throwOnError: false
    });
});
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/mdbook-admonish.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="basic/index.html"><strong aria-hidden="true">1.</strong> 基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic/vec2.html"><strong aria-hidden="true">1.1.</strong> 二维数组</a></li><li class="chapter-item "><a href="basic/fastio.html"><strong aria-hidden="true">1.2.</strong> 快读</a></li><li class="chapter-item "><a href="basic/qpow.html"><strong aria-hidden="true">1.3.</strong> 快速幂</a></li><li class="chapter-item "><a href="basic/lower-upper.html"><strong aria-hidden="true">1.4.</strong> 二分</a></li></ol></li><li class="chapter-item expanded "><a href="math/index.html"><strong aria-hidden="true">2.</strong> 数学</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/matrix.html"><strong aria-hidden="true">2.1.</strong> 矩阵</a></li><li class="chapter-item "><a href="math/qmatrix.html"><strong aria-hidden="true">2.2.</strong> 矩阵快速幂</a></li><li class="chapter-item "><a href="math/exgcd.html"><strong aria-hidden="true">2.3.</strong> 扩展欧几里得（EXGCD）</a></li><li class="chapter-item "><a href="math/sieve-euler.html"><strong aria-hidden="true">2.4.</strong> Euler 筛（朴素）</a></li><li class="chapter-item "><a href="math/sieve-euler-lpf.html"><strong aria-hidden="true">2.5.</strong> Euler 筛（LPF）</a></li><li class="chapter-item "><a href="math/sieve-eratosthenes.html"><strong aria-hidden="true">2.6.</strong> Eratosthenes（朴素）</a></li><li class="chapter-item "><a href="math/factor.html"><strong aria-hidden="true">2.7.</strong> 因式分解（筛优化）</a></li><li class="chapter-item "><a href="math/gauss.html"><strong aria-hidden="true">2.8.</strong> 高斯消元（f64）</a></li><li class="chapter-item "><a href="math/crt.html"><strong aria-hidden="true">2.9.</strong> 中国剩余定理（CRT）</a></li><li class="chapter-item "><a href="math/excrt.html"><strong aria-hidden="true">2.10.</strong> 扩展中国剩余定理</a></li><li class="chapter-item "><a href="math/miller-rabbin.html"><strong aria-hidden="true">2.11.</strong> 素性测试（Miller Rabbin）</a></li><li class="chapter-item "><a href="math/pollard-rho.html"><strong aria-hidden="true">2.12.</strong> 因式分解（Pollard Rho）</a></li><li class="chapter-item "><a href="math/floor-sum.html"><strong aria-hidden="true">2.13.</strong> Floor Sum（类欧）</a></li><li class="chapter-item "><a href="math/cipolla.html"><strong aria-hidden="true">2.14.</strong> 二次剩余（Cipolla）</a></li></ol></li><li class="chapter-item expanded "><a href="modint/index.html"><strong aria-hidden="true">3.</strong> 取模整数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modint/basic.html"><strong aria-hidden="true">3.1.</strong> 基础类</a></li><li class="chapter-item "><a href="modint/runtime.html"><strong aria-hidden="true">3.2.</strong> Runtime Montgomery Modint</a></li></ol></li><li class="chapter-item expanded "><a href="string/index.html"><strong aria-hidden="true">4.</strong> 字符串</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="string/kmp.html"><strong aria-hidden="true">4.1.</strong> KMP</a></li><li class="chapter-item "><a href="string/z-algorithm.html"><strong aria-hidden="true">4.2.</strong> Z 函数</a></li><li class="chapter-item "><a href="string/sa-doubling.html"><strong aria-hidden="true">4.3.</strong> 后缀数组</a></li><li class="chapter-item "><a href="string/manacher.html"><strong aria-hidden="true">4.4.</strong> Manacher</a></li></ol></li><li class="chapter-item expanded "><a href="graph/index.html"><strong aria-hidden="true">5.</strong> 图论</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/bellman-ford.html"><strong aria-hidden="true">5.1.</strong> 最短路（Bellman Ford）</a></li><li class="chapter-item "><a href="graph/queue-bellman-ford.html"><strong aria-hidden="true">5.2.</strong> 最短路（队列优化 Bellman Ford）</a></li><li class="chapter-item "><a href="graph/dijkstra.html"><strong aria-hidden="true">5.3.</strong> 最短路（Dijkstra）</a></li><li class="chapter-item "><a href="graph/kruskal.html"><strong aria-hidden="true">5.4.</strong> 最小生成树（kruskal）</a></li><li class="chapter-item "><a href="graph/lca-binary-lifting.html"><strong aria-hidden="true">5.5.</strong> LCA（倍增）</a></li><li class="chapter-item "><a href="graph/lca-sparse-table.html"><strong aria-hidden="true">5.6.</strong> LCA（ST）</a></li><li class="chapter-item "><a href="graph/hld.html"><strong aria-hidden="true">5.7.</strong> 树链剖分</a></li></ol></li><li class="chapter-item expanded "><a href="poly/index.html"><strong aria-hidden="true">6.</strong> 多项式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="poly/fft-mul.html"><strong aria-hidden="true">6.1.</strong> FFT 乘法</a></li><li class="chapter-item "><a href="poly/ntt-mul-i32.html"><strong aria-hidden="true">6.2.</strong> NTT 乘法（i32）</a></li><li class="chapter-item "><a href="poly/ntt-newton.html"><strong aria-hidden="true">6.3.</strong> NTT 多项式牛顿迭代</a></li><li class="chapter-item "><a href="poly/ntt-newton-fast.html"><strong aria-hidden="true">6.4.</strong> NTT 多项式牛顿迭代（卡常）</a></li><li class="chapter-item "><a href="poly/ntt-newton-blockwise-fast.html"><strong aria-hidden="true">6.5.</strong> NTT 多项式牛顿迭代（分块卡常）</a></li></ol></li><li class="chapter-item expanded "><a href="ds/index.html"><strong aria-hidden="true">7.</strong> 数据结构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ds/dsu.html"><strong aria-hidden="true">7.1.</strong> 并查集</a></li><li class="chapter-item "><a href="ds/dsu-size.html"><strong aria-hidden="true">7.2.</strong> 带权并查集</a></li><li class="chapter-item "><a href="ds/sparse-table.html"><strong aria-hidden="true">7.3.</strong> ST</a></li><li class="chapter-item "><a href="ds/sliding.html"><strong aria-hidden="true">7.4.</strong> 滑动窗口</a></li><li class="chapter-item "><a href="ds/fwtree.html"><strong aria-hidden="true">7.5.</strong> 树状数组</a></li><li class="chapter-item "><a href="ds/heap.html"><strong aria-hidden="true">7.6.</strong> 堆</a></li><li class="chapter-item "><a href="ds/segment-tree.html"><strong aria-hidden="true">7.7.</strong> 线段树</a></li><li class="chapter-item "><a href="ds/lazy-segment-tree.html"><strong aria-hidden="true">7.8.</strong> 懒标记线段树</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Roger Young 的板子</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rogeryoungh/code-of-acm/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>我的初始文件。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;

int ____ = cin.tie(nullptr)-&gt;sync_with_stdio(false);

// END OF HEADER | Author: Roger Young

int main() {
	int T;
	cin &gt;&gt; T;
	while (T--) {
		cout &lt;&lt; &quot;X&quot; &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二维数组"><a class="header" href="#二维数组">二维数组</a></h1>
<p>一个简单的动态二维数组，基于 <code>vector</code>。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	vector&lt;T&gt; m;
	VV(int a, int b) : x(a), y(b), m(a * b) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快读"><a class="header" href="#快读">快读</a></h1>
<p>这个快读目前不能自动输出，有待以后改进。</p>
<pre><code class="language-cpp">struct FastI {
	char s[1 &lt;&lt; 20], *t = s;
	FastI() {
		fread(s, 1, sizeof(s), stdin);
	}
	template &lt;class T, bool is_int = is_integral&lt;T&gt;::value&gt;
	FastI &amp;operator&gt;&gt;(T &amp;x) {
		x = 0;
		while (!isdigit(*t))
			t++;
		while (isdigit(*t))
			x = x * 10 + *t++ - '0';
		return *this;
	}
};

struct FastO {
	char s[1 &lt;&lt; 20], *t = s;
	~FastO() {
		fwrite(s, 1, t - s, stdout);
	}
	void puts(const char *x) {
		while (*x != 0)
			*t++ = *x++;
	}
	void output(uint64_t x) {
		static char u[22];
		char *i = u + 20;
		do {
			*--i = x % 10 + '0', x /= 10;
		} while (x &gt; 0);
		puts(i);
	}
	FastO &amp;operator&lt;&lt;(uint64_t x) {
		return output(x), *this;
	}
	FastO &amp;operator&lt;&lt;(char x) {
		return *t++ = x, *this;
	}
	FastO &amp;operator&lt;&lt;(int64_t x) {
		if (x &lt; 0) {
			*--t = '-', x = -x;
		}
		return output(x), *this;
	}
	FastO &amp;operator&lt;&lt;(const char *x) {
		return puts(x), *this;
	}
};

FastI fin;
FastO fout;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速幂"><a class="header" href="#快速幂">快速幂</a></h1>
<p>一个简单的动态二维数组，基于 <code>vector</code>。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = m != 1;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题"><a class="header" href="#测试例题">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 快速幂</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二分"><a class="header" href="#二分">二分</a></h1>
<p>函数 <code>lower</code> 寻找区间 $[l, r)$ 中 <code>true -&gt; false</code> 的最后一个 <code>true</code>。</p>
<p>函数 <code>upper</code> 寻找区间 $[l, r)$ 中 <code>false -&gt; true</code> 的第一个 <code>true</code>。</p>
<p>若无答案，则返回 $r$。</p>
<pre><code class="language-cpp">// @description 二分

template &lt;class Comp&gt; // last true
ll lower(ll l, ll r, Comp check) {
	if (l &gt;= r or not check(l))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m) ? l : r) = m;
	}
	return l;
}

template &lt;class Comp&gt; // first true
ll upper(ll l, ll r, Comp check) {
	if (l &gt;= r or not check(r - 1))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m - 1) ? r : l) = m;
	}
	return l;
}
</code></pre>
<h2 id="测试例题-1"><a class="header" href="#测试例题-1">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1873">P1873 EKO / 砍树</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学"><a class="header" href="#数学">数学</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵"><a class="header" href="#矩阵">矩阵</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	vector&lt;T&gt; m;
	VV(int a, int b) : x(a), y(b), m(a * b) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description 矩阵乘法

template &lt;class T&gt;
VV&lt;T&gt; operator*(const VV&lt;T&gt; &amp;lhs, const VV&lt;T&gt; &amp;rhs) {
	assert(lhs.y == rhs.x);
	VV&lt;T&gt; u(lhs.x, rhs.y);
	for (int i = 0; i &lt; lhs.x; i++) {
		for (int k = 0; k &lt; rhs.x; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.y; j++)
				u[i][j] += rhs[k][j] * t;
		}
	}
	return u;
}

template &lt;class T&gt;
istream &amp;operator&gt;&gt;(istream &amp;is, VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, const VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.y == 0];
	return os;
}
</code></pre>
<h2 id="测试例题-2"><a class="header" href="#测试例题-2">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵快速幂"><a class="header" href="#矩阵快速幂">矩阵快速幂</a></h1>
<pre><code class="language-cpp">// @description 矩阵快速幂

template &lt;class T&gt;
struct QMtx {
	int n;
	vector&lt;T&gt; m;
	QMtx(int a) : n(a), m(n * n) {}
	auto operator[](int i) {
		return m.begin() + i * n;
	}
	auto operator[](int i) const {
		return m.begin() + i * n;
	}
	static QMtx E(int n) {
		QMtx e(n);
		for (int i = 0; i &lt; n; i++) {
			e[i][i] = 1;
		}
		return e;
	}
	QMtx pow(ll w);
};

template &lt;class T&gt;
QMtx&lt;T&gt; operator*(const QMtx&lt;T&gt; &amp;lhs, const QMtx&lt;T&gt; &amp;rhs) {
	assert(lhs.n == rhs.n);
	int n = lhs.n;
	QMtx&lt;T&gt; u(n);
	for (int i = 0; i &lt; n; i++) {
		for (int k = 0; k &lt; n; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.n; j++) {
				u[i][j] += rhs[k][j] * t;
			}
		}
	}
	return u;
}

template &lt;class T&gt;
QMtx&lt;T&gt; QMtx&lt;T&gt;::pow(ll w) {
	QMtx ret = QMtx::E(n), a = *this;
	for (; w &gt; 0; w &gt;&gt;= 1) {
		if (w &amp; 1)
			ret = a * ret;
		a = a * a;
	}
	return ret;
}

template &lt;class T&gt;
istream &amp;operator&gt;&gt;(istream &amp;is, QMtx&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.n * m.n; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, const QMtx&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.n * m.n; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.n == 0];
	return os;
}
</code></pre>
<h2 id="测试例题-3"><a class="header" href="#测试例题-3">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展欧几里得exgcd"><a class="header" href="#扩展欧几里得exgcd">扩展欧几里得（EXGCD）</a></h1>
<p>求出方程</p>
<p>$$
ax + by = \gcd(a, b)
$$</p>
<p>的一个解 $(x, y)$，并且求出 $\gcd(a, b)$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		return {1, 0, a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛朴素"><a class="header" href="#euler-筛朴素">Euler 筛（朴素）</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 线性筛

vector&lt;bool&gt; not_p;
vector&lt;int&gt; primes;
void Euler(int n) {
	not_p.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (not not_p[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			not_p[i * pj] = true;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-4"><a class="header" href="#测试例题-4">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛lpf"><a class="header" href="#euler-筛lpf">Euler 筛（LPF）</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数，并且筛出最小质因子（least prime factor）。</p>
<pre><code class="language-cpp">// @description 线性筛(LPF)

vector&lt;int&gt; lpf, primes;
void Euler(int n) {
	lpf.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (!lpf[i])
			lpf[i] = i, primes.push_back(i);
		for (auto pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			lpf[i * pj] = pj;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-5"><a class="header" href="#测试例题-5">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eratosthenes朴素"><a class="header" href="#eratosthenes朴素">Eratosthenes（朴素）</a></h1>
<p>在 $O(n \log \log n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 埃氏筛

vector&lt;bool&gt; not_p;
vector&lt;int&gt; primes;
void Eratosthenes(int n) {
	not_p.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (not not_p[i]) {
			primes.push_back(i);
			for (int j = i; j &lt;= (n - 1) / i; j++)
				not_p[i * j] = true;
		}
	}
}
</code></pre>
<h2 id="测试例题-6"><a class="header" href="#测试例题-6">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="因式分解筛优化"><a class="header" href="#因式分解筛优化">因式分解（筛优化）</a></h1>
<pre><code class="language-cpp">// @description 线性筛

vector&lt;bool&gt; not_p;
vector&lt;int&gt; primes;
void Euler(int n) {
	not_p.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (not not_p[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			not_p[i * pj] = true;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	vector&lt;int&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		while (n % i == 0) {
			ans.push_back(i);
			n /= i;
		}
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}

// @description 质因子(p^k)

auto factor_pii(ll n) {
	vector&lt;pair&lt;int, int&gt;&gt; ans;
	for (int p : primes) {
		if (p * p &gt; n)
			break;
		int cnt = 0;
		while (n % p == 0) {
			n /= p, cnt++;
		}
		if (cnt &gt; 0)
			ans.emplace_back(p, cnt);
	}
	if (n &gt; 1)
		ans.emplace_back(n, 1);
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高斯消元f64"><a class="header" href="#高斯消元f64">高斯消元（f64）</a></h1>
<p>求解 $n$ 元方程组</p>
<p>$$
\begin{cases}
A_{1,1} x_1 + \cdots + A_{1,n} x_n &amp;= A_{1, n+1} \\
\cdots &amp;= \cdots \\
A_{n,1} x_1 + \cdots + A_{n,n} x_n &amp;= A_{n, n+1} \\
\end{cases}
$$</p>
<p>输入以 $0$-index 的矩阵 $A$ 表示。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	vector&lt;T&gt; m;
	VV(int a, int b) : x(a), y(b), m(a * b) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

const double eps = 1E-6;

auto Gauss(VV&lt;double&gt; v) {
	assert(v.x == v.y - 1);
	int n = v.x;
	for (int i = 0; i &lt; n; i++) {
		int mi = i;
		for (int j = i + 1; j &lt; n; j++)
			if (fabs(v[j][i]) &gt; fabs(v[mi][i]))
				mi = j;
		for (int j = 0; j &lt; n + 1; j++)
			swap(v[i][j], v[mi][j]);
		if (fabs(v[i][i]) &lt; eps)
			return VV&lt;double&gt;(0, 0);
		for (int j = 0; j &lt; n; j++) {
			if (j != i) {
				double tmp = v[j][i] / v[i][i];
				for (int k = i + 1; k &lt; n + 1; k++)
					v[j][k] -= v[i][k] * tmp;
			}
		}
	}
	return v;
}
</code></pre>
<h1 id="测试例题-7"><a class="header" href="#测试例题-7">测试例题</a></h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3389">P3389 高斯消元法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中国剩余定理"><a class="header" href="#中国剩余定理">中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>保证 $\{m_i\}$ 互质。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		return {1, 0, a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 中国剩余定理

template &lt;class PAIR&gt;
ll crt(const vector&lt;PAIR&gt; &amp;am) {
	ll prod = 1, ret = 0;
	for (auto [a, m] : am)
		prod *= m;
	for (auto [a, m] : am) {
		ll u = prod / m, v = inv_gcd(u, m);
		ret = (ret + a * u * v) % prod;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-8"><a class="header" href="#测试例题-8">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1495">P1495 中国剩余定理（CRT）/ 曹冲养猪</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展中国剩余定理"><a class="header" href="#扩展中国剩余定理">扩展中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>不保证 $\{m_i\}$ 互质，但保证 $\operatorname{lcm}(m_i) &lt; 10^{18}$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		return {1, 0, a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 扩展中国剩余定理

using i128 = __int128_t;

template&lt;class PAIR&gt;
ll excrt(const vector&lt;PAIR&gt; &amp;am) {
	auto [ans, M] = am[0];
	for (auto [a, m] : am) {
		if (M % m == 0 &amp;&amp; ans % m == a)
			continue;
		ll B = (a - ans % m + m) % m;
		auto [x, y, g] = exgcd(M, m);
		if (B % g != 0)
			return -1;
		x = i128(x) * (B / g) % (m / g);
		ans += M * x, M *= m /g;
		ans = (ans + M) % M;
	}
	return ans;
}
</code></pre>
<h2 id="测试例题-9"><a class="header" href="#测试例题-9">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4777">P4777 扩展中国剩余定理（EXCRT）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="素性测试miller-rabbin"><a class="header" href="#素性测试miller-rabbin">素性测试（Miller Rabbin）</a></h1>
<p>快速判断 $10^{18}$ 内的数字是否为素数。</p>
<p>若选取 $k$ 个素数为基底，那么复杂度大概是 $O(k \log n)$，错误率为 $4^{-k}$。</p>
<p>下方代码的基底在 $2^{64}$ 内没有例外。更多基底有关的可以查看 <a href="https://miller-rabin.appspot.com">SPRP Base</a>。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = m != 1;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(ret) * a % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}
</code></pre>
<h2 id="备注"><a class="header" href="#备注">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline u64 mod_mul(u64 a, u64 b, u64 n) {
	u64 c = a * b - u64(f80(a) / n * b + 0.5l) * n;
	if (c &lt; n)  return c;
	return c + n;
}
</code></pre>
<h2 id="测试例题-10"><a class="header" href="#测试例题-10">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/143">LOJ143 质数判定</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="因式分解pollard-rho"><a class="header" href="#因式分解pollard-rho">因式分解（Pollard Rho）</a></h1>
<p>Pollard Rho 算法可以在 $O(n^{0.25})$ 的期望复杂度内计算出 $n$ 的一个因子，可以用于 $10^{18}$ 内的因式分解。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = m != 1;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(ret) * a % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}

// @description Pollard Rho

ll pollard_rho(ll N) {
	if (N % 2 == 0)
		return 2;
	if (miller_rabbin(N))
		return N;
	while (true) {
		auto f = [N, c = rand() % (N - 1) + 1](ll x) {
			return (i128(x) * x + c) % N;
		};
		ll x = 0, y = 0, p = 1, q = 1;
		do {
			int w = 128;
			do {
				p = q, x = f(x), y = f(f(y));
				q = i128(p) * abs(x - y) % N;
			} while (w-- &amp;&amp; q != 0);
			ll d = std::__gcd(p, N);
			if (d &gt; 1 &amp;&amp; d != N)
				return d;
		} while (x != y);
	}
}

auto factor(ll x) {
	vector&lt;ll&gt; v;
	if (x == 1)
		return v;
	std::function&lt;void(ll)&gt; dfs = [&amp;](ll u) {
		ll fac = pollard_rho(u);
		if (fac == u)
			v.push_back(u);
		else
			dfs(fac), dfs(u / fac);
	};
	dfs(x);
	sort(v.begin(), v.end());
	return v;
}
</code></pre>
<h2 id="备注-1"><a class="header" href="#备注-1">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline u64 mod_mul(u64 a, u64 b, u64 n) {
	u64 c = a * b - u64(f80(a) / n * b + 0.5l) * n;
	if (c &lt; n)  return c;
	return c + n;
}
</code></pre>
<h2 id="测试例题-11"><a class="header" href="#测试例题-11">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4718">P4718 Pollard-Rho算法</a></li>
<li><a href="https://judge.yosupo.jp/problem/factorize">yosupo Factorize</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor-sum"><a class="header" href="#floor-sum">Floor Sum</a></h1>
<p>在 $O(\log n)$ 的时间内计算</p>
<p>$$
\sum_{x=0}^n \left\lfloor \frac{ax + b}{c} \right\rfloor
$$</p>
<pre><code class="language-cpp">// @description 类欧几里得算法

ll floor_sum(ll a, ll b, ll c, ll n) {
	ll m = (a * n + b) / c, S1 = n * (n + 1) / 2;
	if (a == 0) {
		return b / c * (n + 1);
	} else if (a &gt;= c || b &gt;= c) {
		ll f = S1 * (a / c) + b / c * (n + 1);
		return f + floor_sum(a % c, b % c, c, n);
	} else {
		return m * n - floor_sum(c, c - b - 1, a, m - 1);
	}
}
</code></pre>
<h2 id="测试例题-12"><a class="header" href="#测试例题-12">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5171">P5171 Earthquake</a></li>
<li><a href="https://judge.yosupo.jp/problem/sum_of_floor_of_linear">yosupo Sum of Floor of Linear</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二次剩余cipolla"><a class="header" href="#二次剩余cipolla">二次剩余（Cipolla）</a></h1>
<p>Cipolla 算法可以在 $O(\log P)$ 的时间内求出</p>
<p>$$
x^2 \equiv N \pmod P
$$</p>
<p>即模平方根。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = m != 1;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 二次剩余(cipolla)

int legendre(int a, int p) {
	return qpow(a, (p - 1) / 2, p);
}

int cipolla(int n, int p) {
	if (n == 0)
		return 0;
	if (legendre(n, p) != 1)
		return -1;
	if (p == 2)
		return 1;
	for (int a = 0; a &lt; p; a++) {
		int i = (a * a - n + p) % p;
		using FP2 = pair&lt;ll, ll&gt;;
		auto mul = [p, i](const FP2 &amp;l, const FP2 &amp;r) {
			auto [la, lb] = l;
			auto [ra, rb] = r;
			return FP2{(la * ra + lb * rb % p * i) % p, (lb * ra + la * rb) % p};
		};
		if (legendre(i, p) == p - 1) {
			FP2 x = {1, 1}, u = {a, 1};
			for (int b = (p + 1) / 2; b; b /= 2) {
				if (b % 2 == 1)
					x = mul(x, u);
				u = mul(u, u);
			}
			return min(x.first, p - x.first);
		}
	}
	return -1;
}
</code></pre>
<h2 id="测试例题-13"><a class="header" href="#测试例题-13">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5491">P5491 二次剩余</a></li>
<li><a href="https://judge.yosupo.jp/problem/sqrt_mod">yosupo Sqrt Mod</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="取模整数"><a class="header" href="#取模整数">取模整数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础类"><a class="header" href="#基础类">基础类</a></h1>
<pre><code class="language-cpp">#include &lt;istream&gt;
using namespace std;
using ll = int64_t;

const int P = 998244353;

// @description 取模整数

#define OPERATOR(U, op)                                       \
	friend inline U operator op(const U &amp;lhs, const U &amp;rhs) { \
		return U(lhs) op## = rhs;                             \
	}

struct Z {
	int v;
	Z(int a = 0) : v(a) {}
	Z(ll a) : v(a % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, +);
	OPERATOR(Z, -);
	OPERATOR(Z, *);
	Z pow(int n) const {
		int ret = P != 1, a = v;
		for (; n; n /= 2) {
			if (n % 2 == 1)
				ret = 1ll * ret * a % P;
			a = 1ll * a * a % P;
		}
		return ret;
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, /);
};

istream &amp;operator&gt;&gt;(istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

ostream &amp;operator&lt;&lt;(ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-montgomery-modint"><a class="header" href="#runtime-montgomery-modint">Runtime Montgomery Modint</a></h1>
<pre><code class="language-cpp">template &lt;int&gt;
class RuntimeMontgomeryModInt {
  public:
	using i32 = std::int32_t;
	using u32 = std::uint32_t;
	using u64 = std::uint64_t;
	using m32 = RuntimeMontgomeryModInt;

	using value_type = u32;

	static u32 get_mod() {
		return mod;
	}

	static bool set_mod(u32 m) {
		if ((m &amp; 1) == 0 || m == 1 || (m &amp; (3U &lt;&lt; 30)) != 0)
			return false;
		mod = m, mod2 = mod &lt;&lt; 1;
		u32 two = 2, iv = mod * (two - mod * mod);
		iv *= two - mod * iv;
		iv *= two - mod * iv;
		r = iv * (mod * iv - two);
		r2 = -u64(mod) % mod;
		return true;
	}

	RuntimeMontgomeryModInt() = default;
	~RuntimeMontgomeryModInt() = default;

	template &lt;typename T&gt;
	RuntimeMontgomeryModInt(T v) : v_(reduce(u64(v % i32(mod) + i32(mod)) * r2)) {}

	RuntimeMontgomeryModInt(const m32 &amp;) = default;

	u32 get() const {
		return norm(reduce(v_));
	}

	template &lt;typename T&gt;
	explicit operator T() const {
		return T(get());
	}

	m32 operator-() const {
		m32 res;
		res.v_ = (mod2 &amp; -(v_ != 0)) - v_;
		return res;
	}

	m32 inv() const {
		i32 x1 = 1, x3 = 0, a = get(), b = mod;
		while (b != 0) {
			i32 q = a / b, x1_old = x1, a_old = a;
			x1 = x3, x3 = x1_old - x3 * q, a = b, b = a_old - b * q;
		}
		return m32(x1);
	}

	m32 &amp;operator=(const m32 &amp;) = default;

	m32 &amp;operator+=(const m32 &amp;rhs) {
		v_ += rhs.v_ - mod2;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator-=(const m32 &amp;rhs) {
		v_ -= rhs.v_;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator*=(const m32 &amp;rhs) {
		v_ = reduce(u64(v_) * rhs.v_);
		return *this;
	}
	m32 &amp;operator/=(const m32 &amp;rhs) {
		return operator*=(rhs.inv());
	}
	friend m32 operator+(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) += rhs;
	}
	friend m32 operator-(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) -= rhs;
	}
	friend m32 operator*(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) *= rhs;
	}
	friend m32 operator/(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) /= rhs;
	}
	friend bool operator==(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) == norm(rhs.v_);
	}
	friend bool operator!=(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) != norm(rhs.v_);
	}

	friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, m32 &amp;rhs) {
		i32 x;
		is &gt;&gt; x;
		rhs = m32(x);
		return is;
	}
	friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const m32 &amp;rhs) {
		return os &lt;&lt; rhs.get();
	}

	m32 pow(u64 y) const {
		for (m32 res(1), x(*this);; x *= x) {
			if (y &amp; 1)
				res *= x;
			if ((y &gt;&gt;= 1) == 0)
				return res;
		}
	}

  private:
	static u32 reduce(u64 x) {
		return (x + u64(u32(x) * r) * mod) &gt;&gt; 32;
	}
	static u32 norm(u32 x) {
		return x - (mod &amp; -((mod - 1 - x) &gt;&gt; 31));
	}

	u32 v_;

	static inline u32 r, r2, mod, mod2;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<pre><code class="language-cpp">auto pre_kmp(const string &amp;s) {
	int n = s.length();
	vector&lt;int&gt; pi(n + 1);
	for (int i = 1; i &lt; n; i++) {
		int j = pi[i];
		while (j &gt; 0 &amp;&amp; s[i] != s[j])
			j = pi[j];
		pi[i + 1] = j + (s[i] == s[j]);
	}
	return pi;
}

void kmp(const string &amp;s, const string &amp;t) {
	auto pi = pre_kmp(s);
	int p = 0, n = t.length(), sn = s.length();
	for (int i = 0; i &lt; n; i++) {
		int j = p;
		while (j &gt; 0 &amp;&amp; t[i] != s[j])
			j = pi[j];
		p = j + (t[i] == s[j]);
		if (p == sn) {
			cout &lt;&lt; i - sn + 2 &lt;&lt; &quot;\n&quot;;
		}
	}
	for (int i = 1; i &lt;= sn; i++) {
		cout &lt;&lt; pi[i] &lt;&lt; &quot; &quot;;
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="z-函数"><a class="header" href="#z-函数">Z 函数</a></h1>
<pre><code class="language-cpp">auto pre_z_algo(const string &amp;s) {
	int n = s.length();
	vector&lt;int&gt; z(n);
	z[0] = n;
	for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = z[i], u = r - i;
		if (u &gt; 0)
			k = min(u, z[i - l]);
		while (i + k &lt; n &amp;&amp; s[k] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return z;
}

void z_algo(const string &amp;s, const string &amp;t) {
	auto z = pre_z_algo(s);
	ll ans1 = 0, ans2 = 0;
	for (int i = 0; i &lt; z.size(); i++) {
		ans1 ^= 1ll * (i + 1) * (z[i] + 1);
	}
	int n = t.length();
	for (int i = 0, l = 0, r = 0; i &lt; n; i++) {
		int k = 0, u = r - i;
		if (u &gt; 0)
			k = min(u, z[i - l]);
		while (i + k &lt; n &amp;&amp; s[k] == t[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
		ans2 ^= 1ll * (i + 1) * (k + 1);
	}
	cout &lt;&lt; ans1 &lt;&lt; '\n' &lt;&lt; ans2 &lt;&lt; '\n';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后缀数组"><a class="header" href="#后缀数组">后缀数组</a></h1>
<pre><code class="language-cpp">template &lt;class iter&gt;
auto sa_doubleing(iter first, iter last, int m = 128) {
	int n = last - first;
	vector&lt;int&gt; cnt(max(n, m)), sa(n), rk(n + 1, -1), id(n + 1, -1);
	copy(first, last, rk.begin());
	for (int i = 0; i &lt; n; i++)
		cnt[rk[i]]++;
	for (int i = 1; i &lt; m; i++)
		cnt[i] += cnt[i - 1];
	for (int i = n - 1; i &gt;= 0; i--)
		sa[--cnt[rk[i]]] = i;
	for (int k = 1; k &lt; n; k &lt;&lt;= 1) {
		int p = 0;
		for (int i = n - k; i &lt; n; i++)
			id[p++] = i;
		for (int i = 0; i &lt; n; i++)
			if (sa[i] &gt;= k)
				id[p++] = sa[i] - k;
		fill(cnt.begin(), cnt.end(), 0);
		for (int i = 0; i &lt; n; i++)
			cnt[rk[i]]++;
		for (int i = 1; i &lt; m; i++)
			cnt[i] += cnt[i - 1];
		for (int i = n - 1; i &gt;= 0; i--)
			sa[--cnt[rk[id[i]]]] = id[i];
		fill(id.begin(), id.end(), -1);
		swap(rk, id);
		rk[sa[0]] = 0, p = 0;
		for (int i = 1; i &lt; n; i++) {
			bool f = id[sa[i]] == id[sa[i - 1]] &amp;&amp; id[sa[i] + k] == id[sa[i - 1] + k];
			rk[sa[i]] = f ? p : ++p;
		}
		if (p == n - 1)
			break;
		m = p + 1;
	}
	return sa;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<pre><code class="language-cpp">// @problem https://www.luogu.com.cn/problem/P3805

// @description Manacher

template &lt;int off&gt;
auto manacher(const string &amp;s) {
	int n = s.size();
	vector&lt;int&gt; m(n);
	m[0] = off == 0;
	for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = m[i], u = r - i;
		if (u &gt; 0)
			k = min(u, m[2 * l - i]);
		while (0 &lt;= i - k - off &amp;&amp; i + k &lt; n &amp;&amp; s[i - k - off] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return m;
}

vector&lt;int&gt; manacher_odd(const string &amp;s) {
	return manacher&lt;0&gt;(s);
}

vector&lt;int&gt; manacher_even(const string &amp;s) {
	return manacher&lt;1&gt;(s);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图论"><a class="header" href="#图论">图论</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bellman-ford"><a class="header" href="#bellman-ford">Bellman Ford</a></h1>
<pre><code class="language-cpp">const int N = 1E5 + 5;
using pii = pair&lt;int, int&gt;;
vector&lt;pii&gt; G[N];

// @problem https://www.luogu.com.cn/problem/P3371
// @problem https://www.luogu.com.cn/problem/P1629 也不是不能用

// @description Bellman Ford 最短路

auto bellman_ford(int n, int s) {
	vector&lt;int&gt; dis(n + 1, 1E9);
	dis[s] = 0;
	for (int k = 1; k &lt; n; k++) {
		bool flag = true;
		for (int i = 1; i &lt;= n; i++) {
			for (auto [v, w] : G[i]) {
				int d2 = dis[i] + w;
				if (d2 &lt; dis[v]) {
					dis[v] = d2, flag = false;
				}
			}
		}
		if (flag) {
			break;
		}
	}
	return dis;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路队列优化-bellman-ford"><a class="header" href="#最短路队列优化-bellman-ford">最短路（队列优化 Bellman Ford）</a></h1>
<pre><code class="language-cpp">const int N = 1E5 + 5;
using pii = pair&lt;int, int&gt;;
vector&lt;pii&gt; G[N];

// @problem https://www.luogu.com.cn/problem/P1629 也不是不能用

// @description 队列优化 Bellman Ford 最短路

auto queue_bellman_ford(int n, int s) {
	queue&lt;int&gt; q;
	vector&lt;int&gt; dis(n + 1, 1E9);
	dis[s] = 0;
	q.push(s);
	while (!q.empty()) {
		int i = q.front();
		q.pop();
		for (auto [v, w] : G[i]) {
			int d2 = dis[i] + w;
			if (d2 &lt; dis[v]) {
				dis[v] = d2;
				q.push(v);
			}
		}
	}
	return dis;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路dijkstra"><a class="header" href="#最短路dijkstra">最短路（Dijkstra）</a></h1>
<pre><code class="language-cpp">const int N = 1E5 + 10;
using pii = pair&lt;int, int&gt;;
vector&lt;pii&gt; G[N];

// @problem https://www.luogu.com.cn/problem/P3371
// @problem https://www.luogu.com.cn/problem/P4779
// @problem https://www.luogu.com.cn/problem/P1629 也不是不能用

// @description Dijkstra 最短路

auto dijkstra(int n, int s) {
	vector&lt;int&gt; dis(n + 1, 1E9);
	vector&lt;char&gt; vis(n + 1);
	dis[s] = 0;
	priority_queue&lt;pii, vector&lt;pii&gt;, std::greater&lt;pii&gt;&gt; pq;
	pq.push({0, s});
	while (!pq.empty()) {
		auto [w, u] = pq.top();
		pq.pop();
		if (vis[u]) {
			continue;
		}
		vis[u] = true;
		for (auto [v, wi] : G[u]) {
			int len = w + wi;
			if (len &lt; dis[v]) {
				dis[v] = len;
				pq.push({len, v});
			}
		}
	}
	return dis;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最小生成树kruskal"><a class="header" href="#最小生成树kruskal">最小生成树（kruskal）</a></h1>
<pre><code class="language-cpp">ll kruskal(int n) {
	std::sort(G.begin(), G.end(), [](Edge a, Edge b) {
		return get&lt;2&gt;(a) &lt; get&lt;2&gt;(b);
	});
	ll ans = 0, cnt = 0;
	DSU dsu(n + 1);
	for (auto [u, v, w] : G) {
		if (dsu.find(u) == dsu.find(v)) {
			continue;
		}
		ans += w, cnt++;
		dsu.merge(u, v);
		if (cnt == n - 1) {
			return ans;
		}
	}
	return -1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca倍增"><a class="header" href="#lca倍增">LCA（倍增）</a></h1>
<pre><code class="language-cpp">const int N = 5E5 + 10;
vector&lt;int&gt; G[N];

// @problem https://www.luogu.com.cn/problem/P3379

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	vector&lt;T&gt; m;
	VV(int a, int b) : x(a), y(b), m(a * b) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(倍增)

struct LCA {
	const int lgn;
	VV&lt;int&gt; f;
	vector&lt;int&gt; dep;
	LCA(int n, int s = 1) : lgn(1 + std::__lg(n)), f(n, lgn), dep(n) {
		dfs(s, 0);
		for (int i = 1; i &lt; lgn; i++) {
			for (int j = 0; j &lt; n; j++) {
				f[j][i] = f[f[j][i - 1]][i - 1];
			}
		}
	}
	void dfs(int x, int fa) {
		f[x][0] = fa;
		dep[x] = dep[fa] + 1;
		for (int u : G[x]) {
			if (u != fa) {
				dfs(u, x);
			}
		}
	}
	int query(int x, int y) {
		if (dep[x] &gt; dep[y])
			swap(x, y);
		while (dep[x] &lt; dep[y]) {
			y = f[y][std::__lg(dep[y] - dep[x])];
		}
		for (int i = lgn - 1; i &gt;= 0; i--) {
			if (f[x][i] != f[y][i]) {
				x = f[x][i], y = f[y][i];
			}
		}
		return x == y ? x : f[x][0];
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lcast"><a class="header" href="#lcast">LCA（ST）</a></h1>
<pre><code class="language-cpp">using pii = pair&lt;int, int&gt;;

const int N = 5E5 + 10;
std::vector&lt;int&gt; G[N];

// @problem https://www.luogu.com.cn/problem/P3379
// @dependices &quot;ds/vec2.cpp&quot;
// @dependices &quot;ds/sparse-table.cpp&quot;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	vector&lt;T&gt; m;
	VV(int a, int b) : x(a), y(b), m(a * b) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(Sparse Table)

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	template &lt;class iter&gt;
	void init(iter first, iter last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = min(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) {
		int s = std::__lg(r - l + 1);
		return min(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};

struct LCA {
	vector&lt;int&gt; dfn;
	vector&lt;pii&gt; rnk;
	SparseTable&lt;pii&gt; st;
	int cnt = 0;

	LCA(int n, int s = 1) : dfn(n), rnk(n), st(n) {
		dfs(s, 0);
		st.init(rnk.begin(), rnk.end());
	}

	void dfs(int x, int fa) {
		dfn[x] = ++cnt;
		rnk[cnt] = {dfn[fa], fa};
		for (int u : G[x]) {
			if (u != fa) {
				dfs(u, x);
			}
		}
	}
	int query(int x, int y) {
		if (x == y)
			return x;
		x = dfn[x], y = dfn[y];
		if (x &gt; y) {
			swap(x, y);
		}
		return st.query(x + 1, y).second;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树链剖分"><a class="header" href="#树链剖分">树链剖分</a></h1>
<pre><code class="language-cpp">const int N = 1E5 + 5;
vector&lt;int&gt; G[N];

// @problem https://www.luogu.com.cn/problem/P3379

// @description 树链剖分 LCA

struct HLD {
	vector&lt;int&gt; sz, dep, fa, son, top, dfn;
	int cnt = 0;
	HLD(int n, int r = 1) : sz(n), dep(n), fa(n), son(n), top(n), dfn(n) {
		dfs1(r), dfs2(r, r);
	}
	void dfs1(int u, int f = 0) {
		dep[u] = dep[f] + 1;
		fa[u] = f, sz[u] = 1, top[u] = u;
		for (int v : G[u]) {
			if (v != f) {
				dfs1(v, u);
				sz[u] += sz[v];
				if (sz[v] &gt; sz[son[u]]) {
					son[u] = v;
				}
			}
		}
	}
	void dfs2(int u, int tp, int f = 0) {
		top[u] = tp, dfn[u] = ++cnt;
		if (son[u] != 0) {
			dfs2(son[u], tp, u);
			for (int v : G[u]) {
				if (v != f &amp;&amp; v != son[u]) {
					dfs2(v, v, u);
				}
			}
		}
	}
	int qpath(int x, int y) {
		while (top[x] != top[y]) {
			if (dep[top[x]] &gt; dep[top[y]]) {
				swap(x, y);
			}
			y = fa[top[y]];
		}

		return dep[x] &lt; dep[y] ? x : y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式"><a class="header" href="#多项式">多项式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fft-乘法"><a class="header" href="#fft-乘法">FFT 乘法</a></h1>
<pre><code class="language-cpp">using i128 = __int128_t;

using img = std::complex&lt;double&gt;;

using Poly = std::vector&lt;img&gt;;
Poly w;

int get_lim(int sum) {
	int lim = 1, k = 0;
	while (lim &lt; sum)
		lim &lt;&lt;= 1, k++;
	return lim;
}

const double PI = acos(-1.0);

void pre_w(int n) {
	static int LIM = (w = {(img){1, 0}, (img){1, 0}}, 2);
	int lim = get_lim(n);
	if (lim &lt;= LIM)
		return;
	w.resize(lim);
	for (int l = LIM; l &lt; lim; l *= 2) {
		img p; // w[j + l] = w_{2l} ^ j
		p = img(cos(PI / l), sin(PI / l));
		for (int i = 0; i &lt; l; i += 2) {
			w[(l + i)] = w[(l + i) / 2];
			w[l + i + 1] = w[l + i] * p;
		}
	}
	LIM = lim;
}

void fft(Poly &amp;f) {
	int deg = f.size();
	pre_w(deg);
	for (int l = deg &gt;&gt; 1; l; l &gt;&gt;= 1)
		for (int i = 0; i &lt; deg; i += (l &lt;&lt; 1))
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j] + f[i + j + l];
				f[i + j + l] = w[j + l] * (f[i + j] - f[i + j + l]);
				f[i + j] = x;
			}
}

void ifft(Poly &amp;f) {
	int deg = f.size();
	pre_w(deg);
	for (int l = 1; l &lt; deg; l &lt;&lt;= 1)
		for (int i = 0; i &lt; deg; i += (l &lt;&lt; 1))
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j], y = f[i + j + l] * w[j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	for (int i = 0; i &lt; deg; i++)
		f[i] /= deg;
	std::reverse(f.begin() + 1, f.end());
}

vector&lt;int&gt; mul(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) {
	int n = a.size(), m = b.size(), lim = get_lim(n + m - 1);
	Poly f(lim);
	for (int i = 0; i &lt; n; i++)
		f[i] += img(a[i], 0);
	for (int i = 0; i &lt; m; i++)
		f[i] += img(0, b[i]);
	fft(f);
	for (int i = 0; i &lt; lim; i++)
		f[i] = f[i] * f[i];
	ifft(f);
	vector&lt;int&gt; ans(n + m - 1);
	for (int i = 0; i &lt; n + m - 1; i++)
		ans[i] = int(f[i].imag() / 2 + 0.5);
	return ans;
}

vector&lt;i128&gt; intmod_mul(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b, int p) {
	const int LIM = 1 &lt;&lt; 16;
	int n = a.size(), m = b.size(), lim = get_lim(n + m - 1);
	Poly A1(lim), A2(lim), Q(lim);
	for (int i = 0; i &lt; n; i++) {
		A1[i] = img(a[i] / LIM, a[i] % LIM);
		A2[i] = img(a[i] / LIM, -a[i] % LIM);
	}
	for (int i = 0; i &lt; m; i++) {
		Q[i] = img(b[i] / LIM, b[i] % LIM);
	}
	fft(A1), fft(A2), fft(Q);
	for (int i = 0; i &lt; lim; i++)
		A1[i] *= Q[i];
	for (int i = 0; i &lt; lim; i++)
		A2[i] *= Q[i];
	ifft(A1);
	ifft(A2);
	vector&lt;i128&gt; ans(n + m - 1);

	for (int i = 0; i &lt; m + n - 1; i++) {
		i128 a1b1 = (A1[i].real() + A2[i].real() + 1) / 2;
		i128 a1b2 = (A1[i].imag() + A2[i].imag() + 1) / 2;
		i128 a2b1 = (A1[i].imag() - A2[i].imag() + 1) / 2;
		i128 a2b2 = (A2[i].real() - A1[i].real() + 1) / 2;
		ans[i] = (a1b1 * LIM + a1b2 + a2b1) * LIM + a2b2;
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-乘法i32"><a class="header" href="#ntt-乘法i32">NTT 乘法（i32）</a></h1>
<pre><code class="language-cpp">// @description 多项式乘法
// @problem https://loj.ac/p/150

const int P = 998244353;

int qpow(int a, int b = P - 2, int m = P) {
	int ret = m != 1;
	for (; b; b &gt;&gt;= 1) {
		if (b &amp; 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

using Poly = vector&lt;int&gt;;
Poly w{1, 1}, Inv{1, 1}, fac{1}, ifac{1};

inline int get_lim(int m) {
	return 2 &lt;&lt; std::__lg(m - (m &gt; 1));
}

inline int mo(int u) {
	return u &gt;= P ? u - P : u;
}

void pre_w(int n) {
	static int lim = 2;
	n = get_lim(n);
	if (n &lt;= lim)
		return;
	w.resize(n);
	for (int l = lim; l &lt; n; l *= 2) {
		int p = qpow(3, (P - 1) / l / 2);
		for (int i = 0; i &lt; l; i += 2) {
			w[(l + i)] = w[(l + i) / 2];
			w[l + i + 1] = 1ll * w[l + i] * p % P;
		}
	}
	lim = n;
}

static int ntt_size = 0;

template &lt;class iter&gt;
void ntt(iter f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l &gt;&gt;= 1)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j], y = f[i + j + l];
				f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
				f[i + j] = mo(x + y);
			}
}

template &lt;class iter&gt;
void intt(iter f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l &lt;&lt;= 1)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j];
				int y = 1ll * w[j + l] * f[i + j + l] % P;
				f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * ivn % P;
	reverse(f + 1, f + n);
}

Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
	f.resize(n), g.resize(n);
	ntt(f.begin(), n), ntt(g.begin(), n);
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * g[i] % P;
	intt(f.begin(), n);
	return f;
}

Poly operator*(Poly f, Poly g) {
	int m = f.size() + g.size() - 1;
	mul(f, g, get_lim(m));
	return f.resize(m), f;
}

Poly operator+(Poly f, Poly g) {
	int n = max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++) {
		f[i] = mo(f[i] + g[i]);
	}
	return f;
}

Poly operator-(Poly f, Poly g) {
	int n = max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++) {
		f[i] = mo(f[i] - g[i] + P);
	}
	return f;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式牛顿迭代"><a class="header" href="#ntt-多项式牛顿迭代">NTT 多项式牛顿迭代</a></h1>
<pre><code class="language-cpp">// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

const int P = 998244353;

int qpow(int a, int b = P - 2, int m = P) {
	int ret = m != 1;
	for (; b; b &gt;&gt;= 1) {
		if (b &amp; 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

#define OPERATOR(U, op)                                       \
	friend inline U operator op(const U &amp;lhs, const U &amp;rhs) { \
		return U(lhs) op## = rhs;                             \
	}

struct Z {
	int v;
	Z(int a = 0) : v(a) {}
	Z(ll a) : v(a % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, +);
	OPERATOR(Z, -);
	OPERATOR(Z, *);
	Z pow(int n) const {
		int ret = P != 1, a = v;
		for (; n; n /= 2) {
			if (n % 2 == 1)
				ret = 1ll * ret * a % P;
			a = 1ll * a * a % P;
		}
		return ret;
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, /);
};

istream &amp;operator&gt;&gt;(istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

ostream &amp;operator&lt;&lt;(ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

vector&lt;Z&gt; w{1, 1}, iv{1, 1}, fac{1}, ifac{1};

inline int get_lim(int m) {
	return 2 &lt;&lt; std::__lg(m - (m &gt; 1));
}

void pre_w(int n) {
	int lim = w.size();
	n = get_lim(n);
	if (n &lt;= lim)
		return;
	w.resize(n);
	for (int l = lim; l &lt; n; l *= 2) {
		Z p = qpow(3, (P - 1) / l / 2);
		for (int i = 0; i &lt; l; i += 2) {
			w[(l + i)] = w[(l + i) / 2];
			w[l + i + 1] = w[l + i] * p;
		}
	}
	lim = n;
}

void pre_all(int n) {
	iv.resize(n + 1), fac.resize(n + 1), ifac.resize(n + 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = i * fac[i - 1];
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
}

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

static int ntt_size = 0;

template &lt;class iter&gt;
void ntt(iter f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l &gt;&gt;= 1)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

template &lt;class iter&gt;
void intt(iter f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l &lt;&lt;= 1)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	reverse(f + 1, f + n);
}

struct Poly : vector&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}

	OPERATOR(Poly, +);
	OPERATOR(Poly, -);
	Poly operator*(Z k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		for (int i = min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly ln(int m) const {
		assert(T[0].v == 1);
		return deriv(m).div(m - 1, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 48E
		assert(T[0].v == 0);
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = x * (cut(t) - x.ln(t) + Poly{1}), x.redeg(t);
		}
		return x.redeg(m);
	}
	Poly sqrt(int m) const { // 36E
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = (x + cut(t).div(t, x)) * qpow(2);
		}
		return x.redeg(m);
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	Poly shift(int c) {
		int n = deg();
		Poly A(n), B(n);
		Z ci = 1;
		for (int i = 0; i &lt; n; i++) {
			A[i] = T[i] * fac[i];
			B[i] = ci * ifac[i];
			ci *= c;
		}
		reverse(A.begin(), A.end());
		A = A * B;
		for (int i = 0; i &lt; n; i++) {
			B[i] = A[n - i - 1] * ifac[i];
		}
		return B;
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
	Poly pow_safe(int m, ll k) const {
		int pos = 0;
		while (pos &lt; deg() &amp;&amp; T[pos].v == 0) {
			++pos;
		}
		if (pos == deg() || pos &gt; (m - 1) / k) {
			return Poly(m, 0);
		}
		Z x = T[pos];
		Poly f = Poly(begin() + pos, end()) * x.inv();
		f = f.pow(m - pos * k, k % P) * x.pow(k % (P - 1));
		f.insert(f.begin(), pos * k, 0);
		assert(f.deg() == m);
		return f;
	}
#undef T
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式牛顿迭代卡常"><a class="header" href="#ntt-多项式牛顿迭代卡常">NTT 多项式牛顿迭代（卡常）</a></h1>
<pre><code class="language-cpp">// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

const int P = 998244353;

int qpow(int a, int b = P - 2, int m = P) {
	int ret = m != 1;
	for (; b; b &gt;&gt;= 1) {
		if (b &amp; 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

#define OPERATOR(U, op)                                       \
	friend inline U operator op(const U &amp;lhs, const U &amp;rhs) { \
		return U(lhs) op## = rhs;                             \
	}

struct Z {
	int v;
	Z(int a = 0) : v(a) {}
	Z(ll a) : v(a % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, +);
	OPERATOR(Z, -);
	OPERATOR(Z, *);
	Z pow(int n) const {
		int ret = P != 1, a = v;
		for (; n; n /= 2) {
			if (n % 2 == 1)
				ret = 1ll * ret * a % P;
			a = 1ll * a * a % P;
		}
		return ret;
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, /);
};

istream &amp;operator&gt;&gt;(istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

ostream &amp;operator&lt;&lt;(ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

vector&lt;Z&gt; w{1, 1}, iv{1, 1}, fac{1}, ifac{1};

inline int get_lim(int m) {
	return 2 &lt;&lt; std::__lg(m - (m &gt; 1));
}

void pre_w(int n) {
	int lim = w.size();
	n = get_lim(n);
	if (n &lt;= lim)
		return;
	w.resize(n);
	for (int l = lim; l &lt; n; l *= 2) {
		Z p = qpow(3, (P - 1) / l / 2);
		for (int i = 0; i &lt; l; i += 2) {
			w[(l + i)] = w[(l + i) / 2];
			w[l + i + 1] = w[l + i] * p;
		}
	}
	lim = n;
}

void pre_all(int n) {
	iv.resize(n + 1), fac.resize(n + 1), ifac.resize(n + 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = i * fac[i - 1];
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
}

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

static int ntt_size = 0;

template &lt;class iter&gt;
void ntt(iter f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l &gt;&gt;= 1)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

template &lt;class iter&gt;
void intt(iter f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l &lt;&lt;= 1)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	reverse(f + 1, f + n);
}

struct Poly : vector&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	OPERATOR(Poly, +);
	OPERATOR(Poly, -);
	Poly operator*(Z k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		for (int i = min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly &amp;invD(Poly f2, Poly nx, int t) {
		mul(f2, nx, t).fill0L(t); // 6E
		mul(f2, nx, t);			  // 4E
		redeg(t);
		for (int i = t / 2; i &lt; t; i++) {
			T[i] = -f2[i];
		}
		return T;
	}
	Poly inv(int m) const { // 10E
		Poly x = {qpow(T[0].v)};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x.invD(cut(t), x.cut(m), t);
		}
		return x.redeg(m);
	}
	Poly div(int m, Poly g) const { // 13E
		if (deg() == 0)
			return {};
		int t = get_lim(m);
		Poly x = cut(t / 2), u = g.inv(t / 2); // 10E
		Poly q = mul(x, u, t).cut(t / 2);	   // 6E
		mul(q, g, t).fill0L(t);				   // 6E
		for (int i = t / 2; i &lt; min(t, deg()); i++)
			q[i] -= T[i];
		mul(q, u, t); // 4E
		for (int i = t / 2; i &lt; t; i++)
			x[i] = -q[i];
		return x.cut(m);
	}
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 17E
		if (m == 1)
			return {1};
		Poly f = {1, T[1]}, g = {1}, nf, ng = g;
		for (int t = 4; t &lt; m * 2; t &lt;&lt;= 1) {
			nf = Poly(f).ntt(t);		// 2E
			ng = g.invD(nf, ng, t / 2); // 3E
			Poly q = cut(t / 2);
			for (int i = 0; i &lt; q.deg(); i++)
				q[i] *= i;
			mul(q, nf, t / 2); // 2E
			for (int i = 0; i &lt; t / 2; i++)
				q[i] -= i * f[i];
			mul(q, ng, t); // 6E
			for (int i = t / 2; i &lt; min(t, deg()); i++)
				q[i] = T[i] + q[i - t / 2] * iv[i];
			mul(q.fill0L(t), nf, t); // 4E
			f.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				f[i] = q[i];
		}
		return f.cut(m);
	}
	Poly sqrt(int m) const { // 11E
		Poly x = {1}, g = x.inv(1), ng = g;
		for (int t = 2; t &lt; m * 2; t &lt;&lt;= 1) {
			Poly f = Poly(x).ntt(t / 2); // 2E
			if (t &gt;= 4)
				ng = g.invD(f, ng, t / 2); // 3E
			mul(f, f, t / 2).redeg(t);				  // 1E
			for (int i = t / 2; i &lt; min(t, deg()); i++)
				f[i] = T[i - t / 2] + T[i] - f[i - t / 2];
			mul(f.fill0L(t), ng, t); // 6E
			x.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				x[i] = f[i] * iv[2];
		}
		return x.cut(deg());
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式牛顿迭代分块卡常"><a class="header" href="#ntt-多项式牛顿迭代分块卡常">NTT 多项式牛顿迭代（分块卡常）</a></h1>
<pre><code class="language-cpp">// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

const int P = 998244353;

int qpow(int a, int b = P - 2, int m = P) {
	int ret = m != 1;
	for (; b; b &gt;&gt;= 1) {
		if (b &amp; 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

#define OPERATOR(U, op)                                       \
	friend inline U operator op(const U &amp;lhs, const U &amp;rhs) { \
		return U(lhs) op## = rhs;                             \
	}

struct Z {
	int v;
	Z(int a = 0) : v(a) {}
	Z(ll a) : v(a % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, +);
	OPERATOR(Z, -);
	OPERATOR(Z, *);
	Z pow(int n) const {
		int ret = P != 1, a = v;
		for (; n; n /= 2) {
			if (n % 2 == 1)
				ret = 1ll * ret * a % P;
			a = 1ll * a * a % P;
		}
		return ret;
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, /);
};

istream &amp;operator&gt;&gt;(istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

ostream &amp;operator&lt;&lt;(ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

vector&lt;Z&gt; w{1, 1}, iv{1, 1}, fac{1}, ifac{1};

inline int get_lim(int n) {
	int m = 1;
	while (m &lt; n)
		m *= 2;
	return m;
}

void pre_w(int n) {
	int lim = w.size();
	n = get_lim(n);
	if (n &lt;= lim)
		return;
	w.resize(n);
	for (int l = lim; l &lt; n; l *= 2) {
		Z p = qpow(3, (P - 1) / l / 2);
		for (int i = 0; i &lt; l; i += 2) {
			w[(l + i)] = w[(l + i) / 2];
			w[l + i + 1] = w[l + i] * p;
		}
	}
	lim = n;
}

void pre_all(int n) {
	iv.resize(n + 1), fac.resize(n + 1), ifac.resize(n + 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = i * fac[i - 1];
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
}

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

static int ntt_size = 0;

template &lt;class iter&gt;
void ntt(iter f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l &gt;&gt;= 1)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

template &lt;class iter&gt;
void intt(iter f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l &lt;&lt;= 1)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	reverse(f + 1, f + n);
}

struct Poly : vector&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	OPERATOR(Poly, +);
	OPERATOR(Poly, -);
	Poly operator*(Z k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		for (int i = min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly inv(int m) const;
	Poly div(int m, Poly g) const;
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const;
	Poly sqrt(int m) const;
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};

Poly Poly::inv(int u) const { // 10E
	if (u == 1) {
		return {front().inv()};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);
	nf[0] = cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = cut(m, k * m).ntt(m * 2);			  // 2E
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2); // 2E
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2); // 2E
		mul(psi, ng[0], m * 2);		   // 4E
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::sqrt(int u) const { // 8E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = sqrt(m), h = x.inv(m).ntt(m * 2);
	vector&lt;Poly&gt; ng(R);

	for (int k = 1; x.deg() &lt; u; k++) {
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			if (j &gt;= 1) {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] + ng[k - 1 - j][i]);
				for (int i = m; i &lt; m * 2; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] - ng[k - 1 - j][i]);
			} else {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * ng[k - 1 - j][i];
				for (int i = m; i &lt; m * 2; i++)
					psi[i] += ng[j][i] * ng[k - 1 - j][i];
			}
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i] * iv[2];
	}
	return x.cut(u);
}

Poly Poly::div(int u, Poly f) const { // 10E
	if (u == 1) {
		return {front() * f[0].inv()};
	}
	f.redeg(u);
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = div(m, f), h = f.inv(m).ntt(m * 2);

	vector&lt;Poly&gt; nf(R), ng(R);

	nf[0] = f.cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = f.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::exp(int u) const { // 14E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = exp(m), y = x.inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);

	Poly df = *this;
	for (int i = 0; i &lt; df.deg(); i++)
		df[i] *= i;
	y.ntt(m * 2);
	nf[0] = df.cut(m).ntt(m * 2);

	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = df.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, m * (k - 1)).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);

		mul(psi, y, m * 2).fill0H(m * 2);
		for (int i = 0; i &lt; m * 2; i++)
			psi[i] *= iv[m * k + i];
		mul(psi, ng[0], m * 2).fill0H(m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并查集"><a class="header" href="#并查集">并查集</a></h1>
<pre><code class="language-cpp">// @description 朴素并查集

struct DSU {
	vector&lt;int&gt; fa;
	DSU(int n) : fa(n) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		fa[x] = y;
	}
};
</code></pre>
<h2 id="测试例题-14"><a class="header" href="#测试例题-14">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/unionfind">yosupo Unionfind</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="带权并查集"><a class="header" href="#带权并查集">带权并查集</a></h1>
<pre><code class="language-cpp">// @description 带权并查集

struct DSU {
	vector&lt;int&gt; fa, sz;
	DSU(int n) : fa(n), sz(n, 1) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	int size(int x) {
		return sz[find(x)];
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		if (x == y)
			return;
		if (sz[x] &gt; sz[y])
			swap(x, y);
		sz[y] += sz[x], fa[x] = y;
		sz[x] = 0;
	}
};
</code></pre>
<h2 id="测试例题-15"><a class="header" href="#测试例题-15">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1536">P1536 村村通</a>（也不是不能用）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="st"><a class="header" href="#st">ST</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	vector&lt;T&gt; m;
	VV(int a, int b) : x(a), y(b), m(a * b) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description Sparse Table

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	template &lt;class iter&gt;
	void init(iter first, iter last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = max(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) {
		int s = std::__lg(r - l + 1);
		return max(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};
</code></pre>
<h2 id="测试例题-16"><a class="header" href="#测试例题-16">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3865">P3865 ST 表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="滑动窗口"><a class="header" href="#滑动窗口">滑动窗口</a></h1>
<pre><code class="language-cpp">// @description 滑动窗口

template &lt;class T&gt;
auto sliding(const vector&lt;T&gt; &amp;v, int k) {
	int l = 0, r = -1, n = v.size();
	vector&lt;int&gt; q(n), ret(n);
	for (int i = 0; i &lt; n; i++) {
		while (l &lt;= r &amp;&amp; i - k &gt;= q[l])
			l++;
		while (l &lt;= r &amp;&amp; v[i] &lt; v[q[r]])
			r--;
		q[++r] = i;
		ret[i] = q[l];
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-17"><a class="header" href="#测试例题-17">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树状数组"><a class="header" href="#树状数组">树状数组</a></h1>
<pre><code class="language-cpp">// @description 树状数组

template &lt;class T&gt;
struct fwtree {
	int n;
	vector&lt;T&gt; v;
	fwtree(int a = 0) : n(a), v(n + 1) {}
	void add(int i, T x) {
		for (i++; i &lt;= n; i += i &amp; -i) {
			v[i] += x;
		}
	}
	template &lt;class iter&gt;
	void init(iter first, iter last) {
		copy(first, last, v.begin() + 1);
		for (int i = 1; i &lt;= n; i++) {
			int j = i + (i &amp; -i);
			if (j &lt;= n) {
				v[j] += v[i];
			}
		}
	}
	T sum(int i) const {
		assert(i &lt; n);
		T sum = T();
		for (i++; i &gt; 0; i -= i &amp; -i)
			sum += v[i];
		return sum;
	}
	T sum(int l, int r) {
		assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt; n);
		return sum(r) - sum(l - 1);
	}
};
</code></pre>
<h2 id="测试例题-18"><a class="header" href="#测试例题-18">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/point_add_range_sum">yosupo Point Add Range Sum</a></li>
<li><a href="https://loj.ac/p/130">LOJ130 树状数组 1 ：单点修改，区间查询</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="堆"><a class="header" href="#堆">堆</a></h1>
<pre><code class="language-cpp">// @description 小根堆

template &lt;class T&gt;
struct Heap {
	vector&lt;T&gt; v;
	Heap() : v(1) {}
	bool update(int p) {
		bool f = v[p] &lt; v[p / 2];
		if (f) {
			swap(v[p], v[p / 2]);
		}
		return !f;
	}
	T top() {
		return v[1];
	}
	void put(T x) {
		v.push_back(x);
		int p = v.size() - 1;
		while (p &gt; 1) {
			if (update(p))
				return;
			p /= 2;
		}
	}
	void pop() {
		v[1] = v.back();
		v.pop_back();
		int sz = v.size(), p = 2;
		while (p &lt; sz) {
			if (p + 1 &lt; sz &amp;&amp; v[p + 1] &lt; v[p])
				p++;
			if (update(p))
				return;
			p *= 2;
		}
	}
};
</code></pre>
<h2 id="测试例题-19"><a class="header" href="#测试例题-19">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3378">P3378 堆</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线段树"><a class="header" href="#线段树">线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树

template &lt;class T, T E = T()&gt;
struct SegmentTree {
	vector&lt;T&gt; val;
	int N;
#define ls (p * 2)
#define rs (p * 2 + 1)
	SegmentTree(int n = 0) {
		// 0 ~ N - 1
		N = 2 &lt;&lt; std::__lg(n + 1);
		val.resize(N * 2, E);
	}
	void build(const vector&lt;T&gt; &amp;a) {
		std::copy(a.begin(), a.end(), val.begin() + N);
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
	void modify(int i, T x) {
		modify(i, x, 1, 0, N);
	}
	T query(int l, int r) {
		return query(l, r + 1, 1, 0, N);
	}

  private:
	void pull(int p) {
		val[p] = val[ls] + val[rs];
	}
	void modify(int i, T x, int p, int L, int R) {
		if (R - L == 1) {
			val[p] += x;
			return;
		}
		int M = (L + R) / 2;
		if (i &lt; M)
			modify(i, x, ls, L, M);
		if (i &gt;= M)
			modify(i, x, rs, M, R);
		pull(p);
	}
	T query(int l, int r, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			return val[p];
		}
		int M = (L + R) / 2;
		T v = E;
		if (l &lt; M)
			v = v + query(l, r, ls, L, M);
		if (r &gt; M)
			v = v + query(l, r, rs, M, R);
		return v;
	}
#undef ls
#undef rs
};
</code></pre>
<h2 id="测试例题-20"><a class="header" href="#测试例题-20">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="懒标记线段树"><a class="header" href="#懒标记线段树">懒标记线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树(懒标记)

template &lt;class T, T E = T()&gt;
struct SegmentTree {
	vector&lt;T&gt; val, add;
	int N;
#define ls (p * 2)
#define rs (p * 2 + 1)

	SegmentTree(int n = 0) {
		// 0 ~ N - 1
		N = 2 &lt;&lt; std::__lg(n + 1);
		val.resize(N * 2, E);
		add.resize(N * 2, E);
	}
	void build(const vector&lt;T&gt; &amp;a) {
		std::copy(a.begin(), a.end(), val.begin() + N);
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
	void modify(int l, int r, T x) {
		modify(l, r + 1, x, 1, 0, N);
	}
	T query(int l, int r) {
		return query(l, r + 1, 1, 0, N);
	}

  private:
	void pull(int p) {
		val[p] = val[ls] + val[rs];
	}
	void push(int p, int len) {
		T &amp;tag = add[p];
		if (tag) {
			add[ls] += tag;
			add[rs] += tag;
			val[ls] += tag * (len / 2);
			val[rs] += tag * (len / 2);
			tag = 0;
		}
	}
	void modify(int l, int r, T x, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			val[p] += x * (R - L);
			add[p] += x;
			return;
		}
		push(p, R - L);
		int M = (L + R) / 2;
		if (l &lt; M)
			modify(l, r, x, ls, L, M);
		if (r &gt; M)
			modify(l, r, x, rs, M, R);
		pull(p);
	}
	T query(int l, int r, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			return val[p];
		}
		push(p, R - L);
		int M = (L + R) / 2;
		T v = T();
		if (l &lt; M)
			v += query(l, r, ls, L, M);
		if (r &gt; M)
			v += query(l, r, rs, M, R);
		return v;
	}
#undef ls
#undef rs
};
</code></pre>
<h2 id="测试例题-21"><a class="header" href="#测试例题-21">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3372">P3372 线段树 1</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
