<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Roger Young 的板子</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<style>
  main p>code {
    color: #f14668 !important;
    background: unset !important;
  }

  main pre>code {
    tab-size: 2;
  }

  main p a,
  main ul a {
    color: #0099ff !important;
  }

  .katex-display {
    overflow: auto hidden;
  }
</style>

<link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.css">
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.js"></script>
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/contrib/auto-render.min.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true },
        { left: "\\begin{equation}", right: "\\end{equation}", display: true },
      ],
      macros: {
        "\\RR": "\\mathbb{R}",
        "\\NN": "\\mathbb{N}",
        "\\QQ": "\\mathbb{Q}",
        "\\ZZ": "\\mathbb{Z}",
        "\\CC": "\\mathbb{C}",
        "\\ee": "\\mathrm{e}",
        "\\dd": "\\mathrm{d}",
        "\\eps": "\\varepsilon",
      },
      globalGroup: true,
      throwOnError: false
    });
  });
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/mdbook-admonish.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="basic/index.html"><strong aria-hidden="true">1.</strong> 基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/vec2.html"><strong aria-hidden="true">1.1.</strong> 二维数组</a></li><li class="chapter-item expanded "><a href="basic/fastio.html"><strong aria-hidden="true">1.2.</strong> 快读</a></li><li class="chapter-item expanded "><a href="basic/qpow.html"><strong aria-hidden="true">1.3.</strong> 快速幂</a></li><li class="chapter-item expanded "><a href="basic/lower-upper.html"><strong aria-hidden="true">1.4.</strong> 二分</a></li></ol></li><li class="chapter-item expanded "><a href="math/index.html"><strong aria-hidden="true">2.</strong> 数学</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="math/matrix/index.html"><strong aria-hidden="true">2.1.</strong> 矩阵</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/matrix/matrix.html"><strong aria-hidden="true">2.1.1.</strong> 矩阵</a></li><li class="chapter-item "><a href="math/matrix/qmatrix.html"><strong aria-hidden="true">2.1.2.</strong> 矩阵快速幂</a></li><li class="chapter-item "><a href="math/matrix/gauss-f64.html"><strong aria-hidden="true">2.1.3.</strong> 高斯消元・f64</a></li><li class="chapter-item "><a href="math/matrix/gauss-modint.html"><strong aria-hidden="true">2.1.4.</strong> 高斯消元・modint</a></li></ol></li><li class="chapter-item expanded "><a href="math/exgcd.html"><strong aria-hidden="true">2.2.</strong> 扩展欧几里得・EXGCD</a></li><li class="chapter-item expanded "><a href="math/sieve/euler.html"><strong aria-hidden="true">2.3.</strong> 筛法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/sieve/euler.html"><strong aria-hidden="true">2.3.1.</strong> Euler 筛・朴素</a></li><li class="chapter-item "><a href="math/sieve/euler-lpf.html"><strong aria-hidden="true">2.3.2.</strong> Euler 筛・LPF</a></li><li class="chapter-item "><a href="math/sieve/eratosthenes.html"><strong aria-hidden="true">2.3.3.</strong> Eratosthenes・朴素</a></li><li class="chapter-item "><a href="math/sieve/eratosthenes-fast.html"><strong aria-hidden="true">2.3.4.</strong> Eratosthenes・卡常</a></li></ol></li><li class="chapter-item expanded "><a href="math/factor/sieve.html"><strong aria-hidden="true">2.4.</strong> 质因分解</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/factor/bruce-force.html"><strong aria-hidden="true">2.4.1.</strong> 暴力</a></li><li class="chapter-item "><a href="math/factor/sieve.html"><strong aria-hidden="true">2.4.2.</strong> 筛优化</a></li><li class="chapter-item "><a href="math/factor/lpf.html"><strong aria-hidden="true">2.4.3.</strong> LPF 优化</a></li><li class="chapter-item "><a href="math/factor/pollard-rho.html"><strong aria-hidden="true">2.4.4.</strong> Pollard Rho</a></li></ol></li><li class="chapter-item expanded "><a href="math/crt.html"><strong aria-hidden="true">2.5.</strong> 中国剩余定理・CRT</a></li><li class="chapter-item expanded "><a href="math/excrt.html"><strong aria-hidden="true">2.6.</strong> 扩展中国剩余定理</a></li><li class="chapter-item expanded "><a href="math/miller-rabbin.html"><strong aria-hidden="true">2.7.</strong> 素性测试・Miller Rabbin</a></li><li class="chapter-item expanded "><a href="math/floor-sum.html"><strong aria-hidden="true">2.8.</strong> Floor Sum・类欧</a></li><li class="chapter-item expanded "><a href="math/cipolla.html"><strong aria-hidden="true">2.9.</strong> 二次剩余・Cipolla</a></li><li class="chapter-item expanded "><a href="math/constant/index.html"><strong aria-hidden="true">2.10.</strong> 数学常数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/constant/stirling.html"><strong aria-hidden="true">2.10.1.</strong> 斯特林数</a></li><li class="chapter-item "><a href="math/constant/euler-phi.html"><strong aria-hidden="true">2.10.2.</strong> Euler $\varphi(n)$</a></li><li class="chapter-item "><a href="math/constant/powers.html"><strong aria-hidden="true">2.10.3.</strong> 幂表</a></li><li class="chapter-item "><a href="math/constant/tetration-mod.html"><strong aria-hidden="true">2.10.4.</strong> 指数塔</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="math-modint/index.html"><strong aria-hidden="true">3.</strong> 数学・Modint</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="math-modint/basic.html"><strong aria-hidden="true">3.1.</strong> 基础类</a></li><li class="chapter-item expanded "><a href="math-modint/runtime.html"><strong aria-hidden="true">3.2.</strong> Runtime Montgomery Modint</a></li><li class="chapter-item expanded "><a href="math-modint/pre-all.html"><strong aria-hidden="true">3.3.</strong> 预处理常数</a></li><li class="chapter-item expanded "><a href="math-modint/interpolation/index.html"><strong aria-hidden="true">3.4.</strong> 插值</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math-modint/interpolation/lagrange1.html"><strong aria-hidden="true">3.4.1.</strong> Lagrange 插值（求值）</a></li><li class="chapter-item "><a href="math-modint/interpolation/lagrange2.html"><strong aria-hidden="true">3.4.2.</strong> Lagrange 插值（求系数）</a></li><li class="chapter-item "><a href="math-modint/interpolation/lagrange3.html"><strong aria-hidden="true">3.4.3.</strong> Lagrange 插值（连续）</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="math-P/index.html"><strong aria-hidden="true">4.</strong> 数学・P</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="math-P/qpow.html"><strong aria-hidden="true">4.1.</strong> 快速幂</a></li><li class="chapter-item expanded "><a href="math-P/pre.html"><strong aria-hidden="true">4.2.</strong> 预处理常数・单独</a></li><li class="chapter-item expanded "><a href="math-P/pre-all.html"><strong aria-hidden="true">4.3.</strong> 预处理常数・全部</a></li><li class="chapter-item expanded "><a href="math-P/interpolation/index.html"><strong aria-hidden="true">4.4.</strong> 插值</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math-P/interpolation/lagrange1.html"><strong aria-hidden="true">4.4.1.</strong> Lagrange 插值（求值）</a></li><li class="chapter-item "><a href="math-P/interpolation/lagrange2.html"><strong aria-hidden="true">4.4.2.</strong> Lagrange 插值（求系数）</a></li><li class="chapter-item "><a href="math-P/interpolation/lagrange3.html"><strong aria-hidden="true">4.4.3.</strong> Lagrange 插值（连续）</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="string/index.html"><strong aria-hidden="true">5.</strong> 字符串</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="string/kmp.html"><strong aria-hidden="true">5.1.</strong> KMP</a></li><li class="chapter-item expanded "><a href="string/z-algorithm.html"><strong aria-hidden="true">5.2.</strong> Z 函数</a></li><li class="chapter-item expanded "><a href="string/sa-doubling.html"><strong aria-hidden="true">5.3.</strong> 后缀数组</a></li><li class="chapter-item expanded "><a href="string/manacher.html"><strong aria-hidden="true">5.4.</strong> Manacher</a></li></ol></li><li class="chapter-item expanded "><a href="graph/index.html"><strong aria-hidden="true">6.</strong> 图论</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph/shortest-path/index.html"><strong aria-hidden="true">6.1.</strong> 最短路</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/shortest-path/bellman-ford-vec.html"><strong aria-hidden="true">6.1.1.</strong> Bellman Ford・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/queue-bellman-ford-vec.html"><strong aria-hidden="true">6.1.2.</strong> 队列优化 Bellman Ford・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/dijkstra-vec.html"><strong aria-hidden="true">6.1.3.</strong> Dijkstra・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/floyd-adj.html"><strong aria-hidden="true">6.1.4.</strong> Floyd・ADJ</a></li></ol></li><li class="chapter-item expanded "><a href="graph/lca/index.html"><strong aria-hidden="true">6.2.</strong> LCA</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/lca/binary-lifting.html"><strong aria-hidden="true">6.2.1.</strong> 倍增</a></li><li class="chapter-item "><a href="graph/lca/sparse-table.html"><strong aria-hidden="true">6.2.2.</strong> ST</a></li></ol></li><li class="chapter-item expanded "><a href="graph/scc/index.html"><strong aria-hidden="true">6.3.</strong> SCC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/scc/tarjan.html"><strong aria-hidden="true">6.3.1.</strong> Tarjan</a></li><li class="chapter-item "><a href="graph/scc/kosaraju.html"><strong aria-hidden="true">6.3.2.</strong> Kosaraju</a></li></ol></li><li class="chapter-item expanded "><a href="graph/kruskal.html"><strong aria-hidden="true">6.4.</strong> 最小生成树・kruskal</a></li><li class="chapter-item expanded "><a href="graph/hld.html"><strong aria-hidden="true">6.5.</strong> 树链剖分</a></li><li class="chapter-item expanded "><a href="graph/dinic.html"><strong aria-hidden="true">6.6.</strong> Dinic</a></li></ol></li><li class="chapter-item expanded "><a href="poly/index.html"><strong aria-hidden="true">7.</strong> 多项式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="poly/fft-mul.html"><strong aria-hidden="true">7.1.</strong> FFT 乘法</a></li><li class="chapter-item expanded "><a href="poly/ntt-mul-i32.html"><strong aria-hidden="true">7.2.</strong> NTT 乘法・i32</a></li><li class="chapter-item expanded "><a href="poly/ntt-mul-mod3.html"><strong aria-hidden="true">7.3.</strong> NTT 乘法・三模</a></li><li class="chapter-item expanded "><a href="poly/ntt-naive.html"><strong aria-hidden="true">7.4.</strong> NTT $O(n^2)$</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton.html"><strong aria-hidden="true">7.5.</strong> NTT 牛顿迭代</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton-fast.html"><strong aria-hidden="true">7.6.</strong> NTT 牛顿迭代・卡常</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton-blockwise-fast.html"><strong aria-hidden="true">7.7.</strong> NTT 牛顿迭代・分块卡常</a></li><li class="chapter-item expanded "><a href="poly/ntt-taylor-shift.html"><strong aria-hidden="true">7.8.</strong> NTT 平移</a></li><li class="chapter-item expanded "><a href="poly/ntt-eval.html"><strong aria-hidden="true">7.9.</strong> NTT 多点求值 & 快速插值</a></li><li class="chapter-item expanded "><a href="poly/ntt-chirpz.html"><strong aria-hidden="true">7.10.</strong> NTT Chirp Z 变换</a></li><li class="chapter-item expanded "><a href="poly/relax/index.html"><strong aria-hidden="true">7.11.</strong> NTT 在线卷积</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="poly/relax/ntt-semi.html"><strong aria-hidden="true">7.11.1.</strong> 半在线卷积</a></li><li class="chapter-item "><a href="poly/relax/ntt-semi-fast.html"><strong aria-hidden="true">7.11.2.</strong> 半在线卷积・卡常</a></li><li class="chapter-item "><a href="poly/relax/ntt-relax.html"><strong aria-hidden="true">7.11.3.</strong> 全在线卷积</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ds/index.html"><strong aria-hidden="true">8.</strong> 数据结构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ds/dsu.html"><strong aria-hidden="true">8.1.</strong> 并查集</a></li><li class="chapter-item expanded "><a href="ds/dsu-size.html"><strong aria-hidden="true">8.2.</strong> 带权并查集</a></li><li class="chapter-item expanded "><a href="ds/sparse-table.html"><strong aria-hidden="true">8.3.</strong> ST</a></li><li class="chapter-item expanded "><a href="ds/sliding.html"><strong aria-hidden="true">8.4.</strong> 滑动窗口</a></li><li class="chapter-item expanded "><a href="ds/fwtree.html"><strong aria-hidden="true">8.5.</strong> 树状数组</a></li><li class="chapter-item expanded "><a href="ds/heap.html"><strong aria-hidden="true">8.6.</strong> 堆</a></li><li class="chapter-item expanded "><a href="ds/segment-tree.html"><strong aria-hidden="true">8.7.</strong> 线段树</a></li><li class="chapter-item expanded "><a href="ds/lazy-segment-tree.html"><strong aria-hidden="true">8.8.</strong> 懒标记线段树</a></li></ol></li><li class="chapter-item expanded "><a href="geo/index.html"><strong aria-hidden="true">9.</strong> 计算几何</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="geo/fpoint.html"><strong aria-hidden="true">9.1.</strong> F 点 & 线段</a></li><li class="chapter-item expanded "><a href="geo/polygon.html"><strong aria-hidden="true">9.2.</strong> F 多边形</a></li><li class="chapter-item expanded "><a href="geo/intersect.html"><strong aria-hidden="true">9.3.</strong> F 冲突判定</a></li><li class="chapter-item expanded "><a href="geo/ipoint.html"><strong aria-hidden="true">9.4.</strong> I 点 & 线段</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Roger Young 的板子</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rogeryoungh/code-of-acm/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>我的初始文件。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

template &lt;class T&gt;
using V = std::vector&lt;T&gt;;
using ll = long long;

int ____ = std::cin.tie(nullptr)-&gt;sync_with_stdio(false);

// END OF HEADER | Author: Roger Young

int main() {
	int T;
	std::cin &gt;&gt; T;
	while (T--) {
		std::cout &lt;&lt; &quot;X&quot; &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二维数组"><a class="header" href="#二维数组">二维数组</a></h1>
<p>一个简单的动态二维数组，基于 <code>vector</code>。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快读"><a class="header" href="#快读">快读</a></h1>
<p>这个快读目前不能自动输出，有待以后改进。</p>
<pre><code class="language-cpp">struct BasicBuffer {
	std::vector&lt;char&gt; s;
	BasicBuffer() : s(1 &lt;&lt; 18) {}
	char *p = s.data(), *beg = p, *end = p + s.size();
	inline char getc() {
		if (p == end)
			readAll();
		return *p++;
	}
	inline void putc(char c) {
		if (p == end)
			writeAll();
		*p++ = c;
	}
	inline void puts(const char *x) {
		while (*x != 0)
			putc(*x++);
	}
	void readAll() {
		std::fread(beg, 1, end - beg, stdin);
		p = s.data();
	}
	void writeAll() {
		std::fwrite(beg, 1, p - beg, stdout);
		p = s.data();
	}
};

struct FastI : BasicBuffer {
	FastI() {
		readAll();
	}
	ll read() {
		ll x = 0;
		char c = getc();
		bool sgn = true;
		while (!std::isdigit(c))
			sgn = sgn &amp;&amp; c != '-', c = getc();
		while (std::isdigit(c))
			x = x * 10 + c - '0', c = getc();
		return sgn ? x : -x;
	}
	template &lt;class T&gt;
	FastI &amp;operator&gt;&gt;(T &amp;x) {
		return x = read(), *this;
	}
	FastI &amp;operator&gt;&gt;(char &amp;x) {
		return x = getc(), *this;
	}
};

struct FastO : BasicBuffer {
	std::array&lt;char, 32&gt; u{};
	~FastO() {
		writeAll();
	}
	void output(ll x) {
		char *i = u.data() + 20;
		if (x &lt; 0)
			putc('-'), x = -x;
		do
			*--i = x % 10 + '0', x /= 10;
		while (x &gt; 0);
		puts(i);
	}
	template &lt;class T&gt;
	FastO &amp;operator&lt;&lt;(const T &amp;x) {
		return output(x), *this;
	}
	FastO &amp;operator&lt;&lt;(char x) {
		return putc(x), *this;
	}
	FastO &amp;operator&lt;&lt;(const char *x) {
		return puts(x), *this;
	}
	FastO &amp;operator&lt;&lt;(const std::string &amp;x) {
		return puts(x.c_str()), *this;
	}
};

FastI fin;
FastO fout;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速幂"><a class="header" href="#快速幂">快速幂</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题"><a class="header" href="#测试例题">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 快速幂</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二分"><a class="header" href="#二分">二分</a></h1>
<p>函数 <code>lower</code> 寻找区间 $[l, r)$ 中 <code>true -&gt; false</code> 的最后一个 <code>true</code>。</p>
<p>函数 <code>upper</code> 寻找区间 $[l, r)$ 中 <code>false -&gt; true</code> 的第一个 <code>true</code>。</p>
<p>若无答案，则返回 $r$。</p>
<pre><code class="language-cpp">// @description 二分

ll lower(ll l, ll r, auto check) { // last true
	if (l &gt;= r or not check(l))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m) ? l : r) = m;
	}
	return l;
}

ll upper(ll l, ll r, auto check) { // first true
	if (l &gt;= r or not check(r - 1))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m - 1) ? r : l) = m;
	}
	return l;
}
</code></pre>
<h2 id="测试例题-1"><a class="header" href="#测试例题-1">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1873">P1873 EKO / 砍树</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学"><a class="header" href="#数学">数学</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵"><a class="header" href="#矩阵">矩阵</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵-1"><a class="header" href="#矩阵-1">矩阵</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description 矩阵乘法

template &lt;class T&gt;
VV&lt;T&gt; operator*(const VV&lt;T&gt; &amp;lhs, const VV&lt;T&gt; &amp;rhs) {
	assert(lhs.y == rhs.x);
	VV&lt;T&gt; u(lhs.x, rhs.y);
	for (int i = 0; i &lt; lhs.x; i++) {
		for (int k = 0; k &lt; rhs.x; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.y; j++)
				u[i][j] += rhs[k][j] * t;
		}
	}
	return u;
}

template &lt;class T&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;is, VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.y == 0];
	return os;
}
</code></pre>
<h2 id="测试例题-2"><a class="header" href="#测试例题-2">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵快速幂"><a class="header" href="#矩阵快速幂">矩阵快速幂</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description 矩阵乘法

template &lt;class T&gt;
VV&lt;T&gt; operator*(const VV&lt;T&gt; &amp;lhs, const VV&lt;T&gt; &amp;rhs) {
	assert(lhs.y == rhs.x);
	VV&lt;T&gt; u(lhs.x, rhs.y);
	for (int i = 0; i &lt; lhs.x; i++) {
		for (int k = 0; k &lt; rhs.x; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.y; j++)
				u[i][j] += rhs[k][j] * t;
		}
	}
	return u;
}

template &lt;class T&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;is, VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.y == 0];
	return os;
}

// @description 矩阵快速幂

template &lt;class T&gt;
auto make_matrix_E(int n) {
	VV&lt;T&gt; ret(n, n);
	for (int i = 0; i &lt; n; i++)
		ret[i][i] = 1;
	return ret;
}

template &lt;class T&gt;
auto matrix_pow(VV&lt;T&gt; a, ll w) {
	auto ret = make_matrix_E&lt;T&gt;(a.x);
	for (; w &gt; 0; w /= 2) {
		if (w % 2 == 1)
			ret = a * ret;
		a = a * a;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-3"><a class="header" href="#测试例题-3">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高斯消元f64"><a class="header" href="#高斯消元f64">高斯消元・f64</a></h1>
<p>求解 $n$ 元方程组</p>
<p>$$
\begin{cases}
A_{1,1} x_1 + \cdots + A_{1,n} x_n &amp;= A_{1, n+1} \\
\cdots &amp;= \cdots \\
A_{n,1} x_1 + \cdots + A_{n,n} x_n &amp;= A_{n, n+1} \\
\end{cases}
$$</p>
<p>输入以 $0$-index 的矩阵 $A$ 表示。</p>
<pre><code class="language-cpp">using f64 = double;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

const f64 eps = 1E-6;

std::optional&lt;VV&lt;f64&gt;&gt; gauss(VV&lt;f64&gt; v) {
	for (int i = 0; i &lt; v.x; i++) {
		int mi = i;
		for (int j = i + 1; j &lt; v.x; j++)
			if (std::abs(v[j][i]) &gt; std::abs(v[mi][i]))
				mi = j;
		for (int j = 0; j &lt; v.y; j++)
			std::swap(v[i][j], v[mi][j]);
		if (std::abs(v[i][i]) &lt; eps)
			return std::nullopt;
		auto ivi = 1 / v[i][i];
		for (int k = v.y - 1; k &gt;= i; k--)
			v[i][k] *= ivi;
		for (int j = 0; j &lt; v.x; j++) {
			if (j != i) {
				auto tmp = v[j][i];
				for (int k = 0; k &lt; v.y; k++)
					v[j][k] -= v[i][k] * tmp;
			}
		}
	}
	return v;
}
</code></pre>
<h1 id="测试例题-4"><a class="header" href="#测试例题-4">测试例题</a></h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3389">P3389 高斯消元法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高斯消元f64-1"><a class="header" href="#高斯消元f64-1">高斯消元・f64</a></h1>
<p>求解 $n$ 元方程组</p>
<p>$$
\begin{cases}
A_{1,1} x_1 + \cdots + A_{1,n} x_n &amp;= A_{1, n+1} \\
\cdots &amp;= \cdots \\
A_{n,1} x_1 + \cdots + A_{n,n} x_n &amp;= A_{n, n+1} \\
\end{cases}
$$</p>
<p>输入以 $0$-index 的矩阵 $A$ 表示。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

std::optional&lt;VV&lt;Z&gt;&gt; gauss(VV&lt;Z&gt; v) {
	for (int i = 0; i &lt; v.x; i++) {
		int mi = i;
		for (int j = i + 1; j &lt; v.x; j++) {
			if (v[j][i].v != 0) {
				mi = j;
			}
		}
		for (int j = 0; j &lt; v.y; j++)
			std::swap(v[i][j], v[mi][j]);
		if (v[i][i].v == 0)
			return std::nullopt;
		auto ivi = 1 / v[i][i];
		for (int k = v.y - 1; k &gt;= i; k--)
			v[i][k] *= ivi;
		for (int j = 0; j &lt; v.x; j++) {
			if (j != i) {
				auto tmp = v[j][i];
				for (int k = 0; k &lt; v.y; k++)
					v[j][k] -= v[i][k] * tmp;
			}
		}
	}
	return v;
}
</code></pre>
<h1 id="测试例题-5"><a class="header" href="#测试例题-5">测试例题</a></h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3389">P3389 高斯消元法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展欧几里得exgcd"><a class="header" href="#扩展欧几里得exgcd">扩展欧几里得・EXGCD</a></h1>
<p>求出方程</p>
<p>$$
ax + by = \gcd(a, b)
$$</p>
<p>的一个解 $(x, y)$，并且求出 $\gcd(a, b)$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛"><a class="header" href="#euler-筛">Euler 筛</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-6"><a class="header" href="#测试例题-6">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛-1"><a class="header" href="#euler-筛-1">Euler 筛</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-7"><a class="header" href="#测试例题-7">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛lpf"><a class="header" href="#euler-筛lpf">Euler 筛・LPF</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数，并且筛出最小质因子（least prime factor）。</p>
<pre><code class="language-cpp">// @description 线性筛(LPF)

V&lt;int&gt; lpf, primes;
void Euler(int n) {
	lpf.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (!lpf[i])
			lpf[i] = i, primes.push_back(i);
		for (auto pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			lpf[i * pj] = pj;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-8"><a class="header" href="#测试例题-8">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eratosthenes朴素"><a class="header" href="#eratosthenes朴素">Eratosthenes（朴素）</a></h1>
<p>在 $O(n \log \log n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 埃氏筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Eratosthenes(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i]) {
			primes.push_back(i);
			for (ll j = ll(i) * i; j &lt; n; j += i)
				isp[j] = false;
		}
	}
}
</code></pre>
<h2 id="测试例题-9"><a class="header" href="#测试例题-9">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="筛法eratosthenes卡常"><a class="header" href="#筛法eratosthenes卡常">筛法・Eratosthenes・卡常</a></h1>
<pre><code class="language-cpp">// @description 埃氏筛(卡常)

V&lt;bool&gt; isp;
V&lt;int&gt; primes; // 个数不精确！
void Eratosthenes(int n) {
	isp.resize(n + 6, true);
	auto f = [&amp;](int i) {
		if (isp[i]) {
			primes.push_back(i);
			for (ll j = ll(i) * i; j &lt; n; j += i)
				isp[j] = false;
		}
	};
	f(2), f(3);
	for (int i = 5; i &lt; n; i += 6) {
		f(i), f(i + 2);
	}
}
</code></pre>
<h2 id="测试例题-10"><a class="header" href="#测试例题-10">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解筛优化"><a class="header" href="#质因分解筛优化">质因分解・筛优化</a></h1>
<p>需要筛出 $O(\sqrt{N})$ 内的质数，后可以在 $O\left(\sqrt{\frac{N}{\log N}}\right)$ 内求出 $N$ 的所有质因子。</p>
<p>常数相对于不筛有玄学改进。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}

// @description 质因子(p^k)

auto factor_pii(ll n) {
	V&lt;ll&gt; ret = factor(n);
	V&lt;std::pair&lt;ll, int&gt;&gt; ans;
	if (ret.empty())
		return ans;
	ans.emplace_back(ret[0], 1);
	for (int i = 1; i &lt; ret.size(); i++) {
		if (ret[i] == ret[i - 1])
			ans.back().second++;
		else
		 	ans.emplace_back(ret[i], 1);
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解暴力"><a class="header" href="#质因分解暴力">质因分解・暴力</a></h1>
<p>可以在 $O(\sqrt{n})$ 的时间复杂度内求出 $n$ 的所有质因子。</p>
<pre><code class="language-cpp">// @description 因式分解

auto factor(ll n) {
	vector&lt;ll&gt; ret;
	for (int i = 2; 1ll * i * i &lt;= n; i++) {
		for (; n % i == 0; n /= i)
			ret.push_back(i);
	}
	if (n &gt; 1)
		ret.push_back(n);
	return ret;
}

// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}

// @description 质因子(p^k)

auto factor_pii(ll n) {
	V&lt;ll&gt; ret = factor(n);
	V&lt;std::pair&lt;ll, int&gt;&gt; ans;
	if (ret.empty())
		return ans;
	ans.emplace_back(ret[0], 1);
	for (int i = 1; i &lt; ret.size(); i++) {
		if (ret[i] == ret[i - 1])
			ans.back().second++;
		else
		 	ans.emplace_back(ret[i], 1);
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解筛优化-1"><a class="header" href="#质因分解筛优化-1">质因分解・筛优化</a></h1>
<p>需要筛出 $O(\sqrt{N})$ 内的质数，后可以在 $O\left(\sqrt{\frac{N}{\log N}}\right)$ 内求出 $N$ 的所有质因子。</p>
<p>常数相对于不筛有玄学改进。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}

// @description 质因子(p^k)

auto factor_pii(ll n) {
	V&lt;ll&gt; ret = factor(n);
	V&lt;std::pair&lt;ll, int&gt;&gt; ans;
	if (ret.empty())
		return ans;
	ans.emplace_back(ret[0], 1);
	for (int i = 1; i &lt; ret.size(); i++) {
		if (ret[i] == ret[i - 1])
			ans.back().second++;
		else
		 	ans.emplace_back(ret[i], 1);
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解lpf-优化"><a class="header" href="#质因分解lpf-优化">质因分解・LPF 优化</a></h1>
<p>需要 $O(N)$ 预处理，后可以在 $O(\log{n})$ 内求出 $n(n \leqslant N)$ 的所有质因子。</p>
<p>仅在 $N$ 较小时有用。</p>
<pre><code class="language-cpp">// @description 线性筛(LPF)

V&lt;int&gt; lpf, primes;
void Euler(int n) {
	lpf.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (!lpf[i])
			lpf[i] = i, primes.push_back(i);
		for (auto pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			lpf[i * pj] = pj;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	vector&lt;ll&gt; ret;
	for (; n &gt; 1; n /= lpf[n])
		ret.push_back(lpf[n]);
	return ret;
}

// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}

// @description 质因子(p^k)

auto factor_pii(ll n) {
	V&lt;ll&gt; ret = factor(n);
	V&lt;std::pair&lt;ll, int&gt;&gt; ans;
	if (ret.empty())
		return ans;
	ans.emplace_back(ret[0], 1);
	for (int i = 1; i &lt; ret.size(); i++) {
		if (ret[i] == ret[i - 1])
			ans.back().second++;
		else
		 	ans.emplace_back(ret[i], 1);
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解pollard-rho"><a class="header" href="#质因分解pollard-rho">质因分解・Pollard Rho</a></h1>
<p>Pollard Rho 算法可以在 $O(n^{0.25})$ 的期望复杂度内计算出 $n$ 的一个因子，可以用于 $10^{18}$ 内的因式分解。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = 1 % m;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(a) * ret % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}

// @description Pollard Rho

ll pollard_rho(ll N) {
	if (N % 2 == 0)
		return 2;
	if (miller_rabbin(N))
		return N;
	while (true) {
		auto f = [N, c = rand() % (N - 1) + 1](ll x) {
			return (i128(x) * x + c) % N;
		};
		ll x = 0, y = 0, p = 1, q = 1;
		do {
			int w = 128;
			do {
				p = q, x = f(x), y = f(f(y));
				q = i128(p) * std::abs(x - y) % N;
			} while (w-- &amp;&amp; q != 0);
			ll d = std::__gcd(p, N);
			if (d &gt; 1 &amp;&amp; d != N)
				return d;
		} while (x != y);
	}
}

auto factor(ll x) {
	V&lt;ll&gt; v;
	if (x == 1)
		return v;
	std::function&lt;void(ll)&gt; dfs = [&amp;](ll u) {
		ll fac = pollard_rho(u);
		if (fac == u)
			v.push_back(u);
		else
			dfs(fac), dfs(u / fac);
	};
	dfs(x);
	sort(v.begin(), v.end());
	return v;
}
</code></pre>
<h2 id="备注"><a class="header" href="#备注">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline ll mul_mod(ll a, ll b, ll m) {
	ll c = a * b - ll(f80(a) / m * b + 0.5) * m;
	return c &lt; 0 ? c + m : (c &gt;= m ? c - m : c);
}
</code></pre>
<h2 id="测试例题-11"><a class="header" href="#测试例题-11">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4718">P4718 Pollard-Rho算法</a></li>
<li><a href="https://judge.yosupo.jp/problem/factorize">yosupo Factorize</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中国剩余定理"><a class="header" href="#中国剩余定理">中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>保证 $\{m_i\}$ 互质。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 中国剩余定理

template &lt;class PAIR&gt;
ll crt(const V&lt;PAIR&gt; &amp;am) {
	ll prod = 1, ret = 0;
	for (auto [a, m] : am)
		prod *= m;
	for (auto [a, m] : am) {
		ll u = prod / m, v = inv_gcd(u, m);
		ret = (ret + a * u * v) % prod;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-12"><a class="header" href="#测试例题-12">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1495">P1495 中国剩余定理（CRT）/ 曹冲养猪</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展中国剩余定理"><a class="header" href="#扩展中国剩余定理">扩展中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>不保证 $\{m_i\}$ 互质，但保证 $\operatorname{lcm}(m_i) &lt; 10^{18}$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 扩展中国剩余定理

using i128 = __int128_t;

template&lt;class PAIR&gt;
ll excrt(const V&lt;PAIR&gt; &amp;am) {
	auto [ans, M] = am[0];
	for (auto [a, m] : am) {
		if (M % m == 0 &amp;&amp; ans % m == a)
			continue;
		ll B = (a - ans % m + m) % m;
		auto [x, y, g] = exgcd(M, m);
		if (B % g != 0)
			return -1;
		x = i128(x) * (B / g) % (m / g);
		ans += M * x, M *= m /g;
		ans = (ans + M) % M;
	}
	return ans;
}
</code></pre>
<h2 id="测试例题-13"><a class="header" href="#测试例题-13">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4777">P4777 扩展中国剩余定理（EXCRT）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="素性测试miller-rabbin"><a class="header" href="#素性测试miller-rabbin">素性测试（Miller Rabbin）</a></h1>
<p>快速判断 $10^{18}$ 内的数字是否为素数。</p>
<p>若选取 $k$ 个素数为基底，那么复杂度大概是 $O(k \log n)$，错误率为 $4^{-k}$。</p>
<p>下方代码的基底在 $2^{64}$ 内没有例外。更多基底有关的可以查看 <a href="https://miller-rabin.appspot.com">SPRP Base</a>。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = 1 % m;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(a) * ret % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}
</code></pre>
<h2 id="备注-1"><a class="header" href="#备注-1">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline ll mul_mod(ll a, ll b, ll m) {
	ll c = a * b - ll(f80(a) / m * b + 0.5) * m;
	return c &lt; 0 ? c + m : (c &gt;= m ? c - m : c);
}
</code></pre>
<h2 id="测试例题-14"><a class="header" href="#测试例题-14">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/143">LOJ143 质数判定</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor-sum"><a class="header" href="#floor-sum">Floor Sum</a></h1>
<p>在 $O(\log n)$ 的时间内计算</p>
<p>$$
\sum_{x=0}^n \left\lfloor \frac{ax + b}{c} \right\rfloor
$$</p>
<pre><code class="language-cpp">// @description 类欧几里得算法

ll floor_sum(ll a, ll b, ll c, ll n) {
	ll m = (a * n + b) / c, S1 = n * (n + 1) / 2;
	if (a == 0) {
		return b / c * (n + 1);
	} else if (a &gt;= c || b &gt;= c) {
		ll f = S1 * (a / c) + b / c * (n + 1);
		return f + floor_sum(a % c, b % c, c, n);
	} else {
		return m * n - floor_sum(c, c - b - 1, a, m - 1);
	}
}
</code></pre>
<h2 id="测试例题-15"><a class="header" href="#测试例题-15">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5171">P5171 Earthquake</a></li>
<li><a href="https://judge.yosupo.jp/problem/sum_of_floor_of_linear">yosupo Sum of Floor of Linear</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二次剩余cipolla"><a class="header" href="#二次剩余cipolla">二次剩余（Cipolla）</a></h1>
<p>Cipolla 算法可以在 $O(\log P)$ 的时间内求出</p>
<p>$$
x^2 \equiv N \pmod P
$$</p>
<p>即模平方根。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 二次剩余(cipolla)

int legendre(int a, int p) {
	return qpow(a, (p - 1) / 2, p);
}

std::optional&lt;int&gt; cipolla(int n, int p) {
	if (n == 0)
		return 0;
	if (legendre(n, p) != 1)
		return std::nullopt;
	if (p == 2)
		return 1;
	for (int a = 0; a &lt; p; a++) {
		int i = (a * a - n + p) % p;
		using FP2 = std::pair&lt;ll, ll&gt;;
		auto mul = [p, i](const FP2 &amp;l, const FP2 &amp;r) {
			auto [la, lb] = l;
			auto [ra, rb] = r;
			return FP2{(la * ra + lb * rb % p * i) % p, (lb * ra + la * rb) % p};
		};
		if (legendre(i, p) == p - 1) {
			FP2 x = {1, 1}, u = {a, 1};
			for (int b = (p + 1) / 2; b; b /= 2) {
				if (b % 2 == 1)
					x = mul(x, u);
				u = mul(u, u);
			}
			return std::min(x.first, p - x.first);
		}
	}
	return std::nullopt;
}
</code></pre>
<h2 id="测试例题-16"><a class="header" href="#测试例题-16">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5491">P5491 二次剩余</a></li>
<li><a href="https://judge.yosupo.jp/problem/sqrt_mod">yosupo Sqrt Mod</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学常数"><a class="header" href="#数学常数">数学常数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="斯特林数"><a class="header" href="#斯特林数">斯特林数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly ln(int m) const {
		assert(T[0].v == 1);
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 48E
		assert(T[0].v == 0);
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = x * (cut(t) - x.ln(t) + Poly{1}), x.redeg(t);
		}
		return x.redeg(m);
	}
	Poly sqrt(int m) const { // 36E
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = (x + cut(t).div(t, x)) * ((P + 1) / 2);
		}
		return x.redeg(m);
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
	friend auto operator%(const Poly &amp;f, const Poly &amp;g) {
		Poly Q = f / g;
		return make_pair(Q, (f - Q * g).redeg(g.deg() - 1));
	}
#undef T
};

Poly taylor_shift(const Poly &amp;f, Z c) {
	int n = f.deg();
	Poly A(n), B(n);
	Z ci = 1;
	for (int i = 0; i &lt; n; i++) {
		A[i] = f[i] * fac[i];
		B[i] = ci * ifac[i];
		ci *= c;
	}
	std::reverse(A.begin(), A.end());
	A = A * B;
	for (int i = 0; i &lt; n; i++) {
		B[i] = A[n - i - 1] * ifac[i];
	}
	return B;
}

Poly pow_safe(const Poly &amp;g, int m, int k1, int k2) { // k % P, k % (P - 1)
	int pos = 0;
	while (pos &lt; g.deg() &amp;&amp; g[pos].v == 0) {
		++pos;
	}
	if (pos == g.deg() || pos &gt; (m - 1) / k1) {
		return Poly(m, 0);
	}
	Z x = g[pos];
	Poly f = Poly(g.begin() + pos, g.end()) * x.inv();
	f = f.pow(m - pos * k1, k1) * x.pow(k2);
	f.insert(f.begin(), pos * k1, 0);
	assert(f.deg() == m);
	return f;
}

Poly stirling1st_row(int n) {
	if (n == 0)
		return {0};
	Poly f = stirling1st_row(n / 2);
	Poly r = f * taylor_shift(f, n / 2);
	if (n % 2 == 1) {
		r *= Poly{n - 1, 1};
	}
	return r;
}

Poly stirling1st_col(int n, int k) {
	n++;
	Poly r = {1, P - 1};
	r = pow_safe(r.ln(n), n, k, k);
	Z xk = Z(P - 1).pow(k) * ifac[k];
	for (int i = 0; i &lt; n; i++) {
		r[i] *= fac[i] * xk;
	}
	return r;
}

Poly stirling2st_row(int n) {
	n++;
	Poly A(n), B(n);
	for (int i = 0; i &lt; n; i++) {
		A[i] = i % 2 == 1 ? -ifac[i] : ifac[i];
		B[i] = Z(i).pow(n - 1) * ifac[i];
	}
	return (A * B).redeg(n);
}

Poly stirling2st_col(int n, int k) {
	if (n &lt; k)
		return Poly(n + 1);
	std::function&lt;Poly(int)&gt; sol = [&amp;](int u) -&gt; Poly {
		if (u == 0)
			return {1};
		Poly f = sol(u / 2);
		f *= taylor_shift(f, P - u / 2);
		if (u % 2 == 1)
			f *= Poly{-u, 1};
		return f;
	};
	Poly f = sol(k).rev().inv(n - k + 1);
	f.insert(f.begin(), k, 0);
	return f;
}
</code></pre>
<h2 id="测试例题-17"><a class="header" href="#测试例题-17">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5395">P5395 第二类斯特林数·行</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5396">P5396 第二类斯特林数·列</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5409">P5409 第一类斯特林数·列</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5409">P5409 第一类斯特林数·列</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-varphin-函数"><a class="header" href="#euler-varphin-函数">Euler $\varphi(n)$ 函数</a></h1>
<p>需要用筛预处理 $O(\sqrt{N})$ 内的质数，每次求值复杂度 $O(\sqrt{N})$。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

ll euler_phi(ll x) {
	ll ans = 1;
	for (int p : primes) {
		if (1ll * p * p &gt; x)
			break;
		if (x % p == 0)
			x /= p, ans *= p - 1;
		while (x % p == 0)
			x /= p, ans *= p;
	}
	if (x &gt; 1)
		ans *= x - 1;
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="幂表"><a class="header" href="#幂表">幂表</a></h1>
<p>在 $O(n)$ 的时间内，求 $0^k, 1^k, \cdots, n^k$。</p>
<p>除了卡常以外没什么用。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

auto powers(int n, int k, int mod) {
	V&lt;bool&gt; isp(n + 1, true);
	V&lt;int&gt; pw(n + 1, 1);
	for (int p = 2; p &lt;= n; ++p)
		if (isp[p]) {
			for (ll j = ll(p) * p; j &lt;= n; j += p)
				isp[j] = false;
			int q = qpow(p, k, mod);
			for (int i = 1; i &lt;= n / p; ++i)
				pw[i * p] = ll(q) * pw[i] % mod;
		}
	pw[0] = qpow(0, k, mod);
	return pw;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指数塔"><a class="header" href="#指数塔">指数塔</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

int euler_phi(ll x) {
	ll ans = 1;
	for (int p : primes) {
		if (1ll * p * p &gt; x)
			break;
		if (x % p == 0)
			x /= p, ans *= p - 1;
		while (x % p == 0)
			x /= p, ans *= p;
	}
	if (x &gt; 1)
		ans *= x - 1;
	return ans;
}

int tetration_mod(int a, int b, int m) {
	if (m == 1)
		return 0;
	if (a == 0)
		return (b + 1) % 2;
	if (b == 0)
		return 1;
	if (b == 1)
		return a % m;
	if (a == 2 &amp;&amp; b &lt;= 4) {
		static const std::array ans = {1, 2, 4, 16, 65536};
		return ans[b] % m;
	}
	int phi = euler_phi(m);
	int d = tetration_mod(a, b - 1, phi) + phi;
	return qpow(a % m, d, m);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="取模整数"><a class="header" href="#取模整数">取模整数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础类"><a class="header" href="#基础类">基础类</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-montgomery-modint"><a class="header" href="#runtime-montgomery-modint">Runtime Montgomery Modint</a></h1>
<pre><code class="language-cpp">template &lt;int&gt;
class RuntimeMontgomeryModInt {
  public:
	using i32 = std::int32_t;
	using u32 = std::uint32_t;
	using u64 = std::uint64_t;
	using m32 = RuntimeMontgomeryModInt;

	using value_type = u32;

	static u32 get_mod() {
		return mod;
	}

	static bool set_mod(u32 m) {
		if (m % 2 == 0 || m == 1 || (m &amp; (3U &lt;&lt; 30)) != 0)
			return false;
		mod = m, mod2 = mod &lt;&lt; 1;
		u32 two = 2, iv = mod * (two - mod * mod);
		iv *= two - mod * iv;
		iv *= two - mod * iv;
		r = iv * (mod * iv - two);
		r2 = -u64(mod) % mod;
		return true;
	}

	RuntimeMontgomeryModInt() = default;
	~RuntimeMontgomeryModInt() = default;

	template &lt;typename T&gt;
	RuntimeMontgomeryModInt(T v) : v_(reduce(u64(v % i32(mod) + i32(mod)) * r2)) {}

	RuntimeMontgomeryModInt(const m32 &amp;) = default;

	u32 get() const {
		return norm(reduce(v_));
	}

	template &lt;typename T&gt;
	explicit operator T() const {
		return T(get());
	}

	m32 operator-() const {
		m32 res;
		res.v_ = (mod2 &amp; -(v_ != 0)) - v_;
		return res;
	}

	m32 inv() const {
		i32 x1 = 1, x3 = 0, a = get(), b = mod;
		while (b != 0) {
			i32 q = a / b, x1_old = x1, a_old = a;
			x1 = x3, x3 = x1_old - x3 * q, a = b, b = a_old - b * q;
		}
		return m32(x1);
	}

	m32 &amp;operator=(const m32 &amp;) = default;

	m32 &amp;operator+=(const m32 &amp;rhs) {
		v_ += rhs.v_ - mod2;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator-=(const m32 &amp;rhs) {
		v_ -= rhs.v_;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator*=(const m32 &amp;rhs) {
		v_ = reduce(u64(v_) * rhs.v_);
		return *this;
	}
	m32 &amp;operator/=(const m32 &amp;rhs) {
		return operator*=(rhs.inv());
	}
	friend m32 operator+(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) += rhs;
	}
	friend m32 operator-(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) -= rhs;
	}
	friend m32 operator*(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) *= rhs;
	}
	friend m32 operator/(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) /= rhs;
	}
	friend bool operator==(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) == norm(rhs.v_);
	}
	friend bool operator!=(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) != norm(rhs.v_);
	}

	friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, m32 &amp;rhs) {
		i32 x;
		is &gt;&gt; x;
		rhs = m32(x);
		return is;
	}
	friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const m32 &amp;rhs) {
		return os &lt;&lt; rhs.get();
	}

	m32 pow(u64 y) const {
		for (m32 res(1), x(*this);; x *= x) {
			if (y &amp; 1)
				res *= x;
			if ((y /= 2) == 0)
				return res;
		}
	}

  private:
	static u32 reduce(u64 x) {
		return (x + u64(u32(x) * r) * mod) &gt;&gt; 32;
	}
	static u32 norm(u32 x) {
		return x - (mod &amp; -((mod - 1 - x) &gt;&gt; 31));
	}

	u32 v_;

	static inline u32 r, r2, mod, mod2;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数"><a class="header" href="#预处理常数">预处理常数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插值"><a class="header" href="#插值">插值</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值求值"><a class="header" href="#lagrange-插值求值">Lagrange 插值（求值）</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

Z lagrange(const V&lt;Z&gt; &amp;x, const V&lt;Z&gt; &amp;y, Z k) {
	int n = x.size();
	Z sum = 0;
	for (int i = 0; i &lt; n; i++) {
		Z s1 = 1, s2 = 1;
		for (int j = 0; j &lt; n; j++)
			if (j != i)
				s1 *= k - x[j], s2 *= x[i] - x[j];
		sum += s1 / s2 * y[i];
	}
	return sum;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值求系数"><a class="header" href="#lagrange-插值求系数">Lagrange 插值（求系数）</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

auto lagrange(const V&lt;Z&gt; &amp;x, const V&lt;Z&gt; &amp;y) {
	int n = x.size();
	V&lt;Z&gt; d(n), u(n + 1), t(n);
	u[0] = 1;
	for (int i = 0; i &lt; n; i++) {
		for (int j = i + 1; j &gt;= 1; j--)
			u[j] = u[j - 1] - u[j] * x[i];
		u[0] *= -x[i];
	}
	for (int i = 0; i &lt; n; i++) {
		Z s2 = 1;
		for (int j = n; j &gt;= 1; j--) {
			t[j - 1] = j == n ? u[n] : u[j] + x[i] * t[j];
			if (j - 1 != i)
				s2 = s2 * (x[i] - x[j - 1]);
		}
		s2 = s2.inv();
		for (int j = 0; j &lt; n; j++)
			d[j] += t[j] * s2 * y[i];
	}
	return d;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值连续"><a class="header" href="#lagrange-插值连续">Lagrange 插值（连续）</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

Z lagrange(const V&lt;Z&gt; &amp;y, int x) {
	int n = y.size();
	if (0 &lt;= x &amp;&amp; x &lt; n)
		return y[x];
	V&lt;Z&gt; pl(n + 2, 1), pr(n + 2, 1), fac(n + 2, 1);
	for (int i = 0; i &lt; n; i++)
		pl[i + 1] = pl[i] * (x - i);
	for (int i = n - 1; i &gt;= 0; i--)
		pr[i] = pr[i + 1] * (x - i);
	for (int i = 1; i &lt; n; i++)
		fac[i] = fac[i - 1] * i;
	Z ans = 0;
	for (int i = 0; i &lt; n; i++) {
		Z s1 = pl[i] * pr[i + 1];
		Z t = (n - i) % 2 == 0 ? -1 : 1;
		Z s2 = fac[i] * fac[n - i - 1] * t;
		ans += s1 / s2 * y[i];
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学p"><a class="header" href="#数学p">数学・P</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速幂-1"><a class="header" href="#快速幂-1">快速幂</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-18"><a class="header" href="#测试例题-18">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 快速幂</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数-1"><a class="header" href="#预处理常数-1">预处理常数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

V&lt;int&gt; iv{1, 1}, fac{1}, ifac{1};

// @description 预处理逆元

void pre_inv(int n) {
	iv.resize(n + 1);
	for (int i = 2; i &lt;= n; i++) {
		iv[i] = 1ll * iv[P % i] * (P - P / i) % P;
	}
}

// @description 预处理阶乘

void pre_fac(int n) {
	fac.resize(n + 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
}

// @description 预处理阶乘逆元

void pre_ifac(int n) {
	ifac.resize(n + 1);
	ifac[n] = qpow(fac[n]);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	}
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数全部"><a class="header" href="#预处理常数全部">预处理常数・全部</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;int&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt; l)
		return;
	iv = fac = ifac = V&lt;int&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n] = qpow(fac[n]), iv[n] = qpow(n);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
		iv[i] = 1ll * ifac[i] * fac[i - 1] % P;
	}
	pre_all(u);
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插值-1"><a class="header" href="#插值-1">插值</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值"><a class="header" href="#lagrange-插值">Lagrange 插值</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 拉格朗日插值

int lagrange(const V&lt;int&gt; &amp;x, const V&lt;int&gt; &amp;y, int k) {
	int sum = 0, n = x.size();
	for (int i = 0; i &lt; n; i++) {
		int s1 = 1, s2 = 1;
		for (int j = 0; j &lt; n; j++) {
			if (j == i)
				continue;
			s1 = 1ll * s1 * (k - x[j] + P) % P;
			s2 = 1ll * s2 * (x[i] - x[j] + P) % P;
		}
		sum += 1ll * s1 * qpow(s2) % P * y[i] % P;
	}
	return sum % P;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值-1"><a class="header" href="#lagrange-插值-1">Lagrange 插值</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 拉格朗日插值

auto lagrange(const V&lt;int&gt; &amp;x, const V&lt;int&gt; &amp;y) {
	int n = x.size();
	V&lt;int&gt; d(n), u(n + 1), t(n);
	u[0] = 1;
	for (int i = 0; i &lt; n; i++) {
		for (int j = i + 1; j &gt;= 1; j--)
			u[j] = (u[j - 1] + 1ll * (P - u[j]) * x[i]) % P;
		u[0] = 1ll * u[0] * (P - x[i]) % P;
	}
	for (int i = 0; i &lt; n; i++) {
		int s2 = 1;
		for (int j = n; j &gt;= 1; j--) {
			t[j - 1] = j == n ? u[n] : (u[j] + 1ll * x[i] * t[j]) % P;
			if (j - 1 != i)
				s2 = 1ll * s2 * (x[i] - x[j - 1] + P) % P;
		}
		s2 = qpow(s2);
		for (int j = 0; j &lt; n; j++)
			d[j] = (d[j] + 1ll * t[j] * s2 % P * y[i]) % P;
	}
	return d;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值-2"><a class="header" href="#lagrange-插值-2">Lagrange 插值</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 拉格朗日插值

int lagrange(const V&lt;int&gt; &amp;y, int x) {
	int n = y.size();
	if (0 &lt;= x &amp;&amp; x &lt; n)
		return y[x];
	V&lt;int&gt; pl(n + 2, 1), pr(n + 2, 1), fac(n + 2, 1);
	for (int i = 0; i &lt; n; i++)
		pl[i + 1] = 1ll * pl[i] * (x - i) % P;
	for (int i = n - 1; i &gt;= 0; i--)
		pr[i] = 1ll * pr[i + 1] * (x - i) % P;
	for (int i = 1; i &lt; n; i++)
		fac[i] = 1ll * fac[i - 1] * i % P;
	int ans = 0;
	for (int i = 0; i &lt; n; i++) {
		int s1 = 1ll * pl[i] * pr[i + 1] % P;
		int t = (n - i) % 2 == 0 ? P - 1 : 1;
		int s2 = 1ll * fac[i] * fac[n - i - 1] % P * t % P;
		ans = (ans + 1ll * s1 % P * qpow(s2) % P * y[i]) % P;
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<pre><code class="language-cpp">auto pre_kmp(const std::string &amp;s) {
	int n = s.length();
	V&lt;int&gt; pi(n + 1);
	for (int i = 1; i &lt; n; i++) {
		int j = pi[i];
		while (j &gt; 0 &amp;&amp; s[i] != s[j])
			j = pi[j];
		pi[i + 1] = j + (s[i] == s[j]);
	}
	return pi;
}

auto kmp(const std::string &amp;s, const std::string &amp;t) {
	auto pi = pre_kmp(s);
	int n = t.length();
	V&lt;int&gt; p(n + 1);
	for (int i = 0; i &lt; n; i++) {
		int j = p[i];
		while (j &gt; 0 &amp;&amp; t[i] != s[j])
			j = pi[j];
		p[i + 1] = j + (t[i] == s[j]);
	}
	return std::make_pair(pi, p);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="z-函数"><a class="header" href="#z-函数">Z 函数</a></h1>
<pre><code class="language-cpp">auto pre_z_algo(const std::string &amp;s) {
	int n = s.length();
	V&lt;int&gt; z(n + 1);
	z[1] = n;
	for (int i = 1, l = -1, r = 0; i &lt; n; i++) {
		int &amp;k = z[i + 1], u = r - i;
		if (u &gt; 0)
			k = std::min(u, z[i - l + 1]);
		while (i + k &lt; n &amp;&amp; s[k] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return z;
}

auto z_algo(const std::string &amp;s, const std::string &amp;t) {
	auto z = pre_z_algo(s);
	int n = t.length();
	V&lt;int&gt; z2(n + 1);
	for (int i = 0, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = z2[i + 1], u = r - i;
		if (u &gt; 0)
			k = std::min(u, z[i - l + 1]);
		while (i + k &lt; n &amp;&amp; s[k] == t[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return std::make_pair(z, z2);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后缀数组"><a class="header" href="#后缀数组">后缀数组</a></h1>
<pre><code class="language-cpp">auto sa_doubleing(auto first, auto last, int m = 128) {
	int n = last - first;
	V&lt;int&gt; cnt(std::max(n, m)), sa(n), rk(n + 1, -1), id(n + 1, -1);
	std::copy(first, last, rk.begin());
	for (int i = 0; i &lt; n; i++)
		cnt[rk[i]]++;
	for (int i = 1; i &lt; m; i++)
		cnt[i] += cnt[i - 1];
	for (int i = n - 1; i &gt;= 0; i--)
		sa[--cnt[rk[i]]] = i;
	for (int k = 1; k &lt; n; k *= 2) {
		int p = 0;
		for (int i = n - k; i &lt; n; i++)
			id[p++] = i;
		for (int i = 0; i &lt; n; i++)
			if (sa[i] &gt;= k)
				id[p++] = sa[i] - k;
		std::fill(cnt.begin(), cnt.end(), 0);
		for (int i = 0; i &lt; n; i++)
			cnt[rk[i]]++;
		for (int i = 1; i &lt; m; i++)
			cnt[i] += cnt[i - 1];
		for (int i = n - 1; i &gt;= 0; i--)
			sa[--cnt[rk[id[i]]]] = id[i];
		std::fill(id.begin(), id.end(), -1);
		std::swap(rk, id);
		rk[sa[0]] = 0, p = 0;
		for (int i = 1; i &lt; n; i++) {
			bool f = id[sa[i]] == id[sa[i - 1]] &amp;&amp; id[sa[i] + k] == id[sa[i - 1] + k];
			rk[sa[i]] = f ? p : ++p;
		}
		if (p == n - 1)
			break;
		m = p + 1;
	}
	return sa;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<pre><code class="language-cpp">// @description Manacher

template &lt;int o&gt;
auto manacher(const std::string &amp;s) {
	int n = s.size();
	V&lt;int&gt; m(n);
	m[0] = o == 0;
	for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = m[i], u = r - i;
		if (u &gt; 0)
			k = std::min(u, m[2 * l - i]);
		while (0 &lt;= i - k - o &amp;&amp; i + k &lt; n &amp;&amp; s[i - k - o] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return m;
}

V&lt;int&gt; manacher_odd(const std::string &amp;s) {
	return manacher&lt;0&gt;(s);
}

V&lt;int&gt; manacher_even(const std::string &amp;s) {
	return manacher&lt;1&gt;(s);
}
</code></pre>
<h2 id="测试例题-19"><a class="header" href="#测试例题-19">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3805">P3805 manacher 算法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图论"><a class="header" href="#图论">图论</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路"><a class="header" href="#最短路">最短路</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路bellman-fordvec"><a class="header" href="#最短路bellman-fordvec">最短路・Bellman Ford・VEC</a></h1>
<p>对于 $n$ 个点 $m$ 条边的图，可以在 $O(nm)$ 的时间内求出来源点 $s$ 到所有点的最短路，并且求出路径。</p>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description Bellman Ford 最短路

template &lt;class D&gt;
auto bellman_ford(const Edges&lt;D&gt; &amp;E, int s) {
	int n = E.size();
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	dis[s] = 0, from[s] = s;
	bool flag = true;
	for (int k = 0; k &lt; n &amp;&amp; flag; k++) {
		flag = false;
		for (int u = 0; u &lt; n; u++) {
			for (auto [v, w] : E[u]) {
				int d2 = dis[u] + w;
				if (dis[v] &gt; d2)
					dis[v] = d2, from[v] = u, flag = true;
			}
		}
	}
	return std::make_pair(dis, from);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路队列优化-bellman-fordvec"><a class="header" href="#最短路队列优化-bellman-fordvec">最短路・队列优化 Bellman Ford・VEC</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 队列优化 Bellman Ford 最短路

template &lt;class D&gt;
auto queue_bellman_ford(const Edges&lt;D&gt; &amp;G, int s) {
	int n = G.size();
	std::queue&lt;int&gt; q;
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	dis[s] = 0, from[s] = s;
	q.push(s);
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (auto [v, w] : G[u]) {
			int d2 = dis[u] + w;
			if (dis[v] &gt; d2)
				dis[v] = d2, from[v] = u, q.push(v);
		}
	}
	return std::make_pair(dis, from);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路dijkstra"><a class="header" href="#最短路dijkstra">最短路・Dijkstra</a></h1>
<p>对于 $n$ 个点 $m$ 条边的图，可以在 $O(n \log m)$ 的时间内求出来源点 $s$ 到所有点的最短路，并且求出路径。</p>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description Dijkstra 最短路

template &lt;class D&gt;
auto dijkstra(const Edges&lt;D&gt; &amp;E, int s) {
	int n = E.size();
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	V&lt;bool&gt; vis(n);
	dis[s] = 0, from[s] = s;
	using pdi = std::pair&lt;D, int&gt;;
	std::priority_queue&lt;pdi, V&lt;pdi&gt;, std::greater&lt;pdi&gt;&gt; pq;
	pq.emplace(0, s);
	while (!pq.empty()) {
		auto [w, u] = pq.top();
		pq.pop();
		if (vis[u])
			continue;
		vis[u] = true;
		for (auto [v, wi] : E[u]) {
			D d2 = w + wi;
			if (dis[v] &gt; d2)
				dis[v] = d2, from[v] = u, pq.emplace(d2, v);
		}
	}
	return make_pair(dis, from);
}

auto get_path(const V&lt;int&gt; &amp;from, int x, int y) {
	V&lt;int&gt; r;
	for (; x != y; y = from[y])
		r.push_back(y);
	r.push_back(y);
	std::reverse(r.begin(), r.end());
	return r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路floydadj"><a class="header" href="#最短路floydadj">最短路・Floyd・ADJ</a></h1>
<p>对于 $n$ 个点的图，可以在 $O(n^3)$ 的时间内求出任意两点的最短路，并记录其中一条路径。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

template &lt;class D&gt;
using Edges = VV&lt;D&gt;; // 默认 x == y

template &lt;class D&gt;
auto get_edges(int n) {
	VV&lt;D&gt; f(n, n, std::numeric_limits&lt;D&gt;::max() / 2);
	for (int i = 0; i &lt; n; i++)
		f[i][i] = 0;
	return f;
}

// @description Floyd 最短路

template &lt;class D&gt;
auto floyd(const Edges&lt;D&gt; &amp;E) {
	int n = E.x;
	auto f = E;
	VV&lt;int&gt; pass(n, n, -1);
	for (int k = 0; k &lt; n; k++) {
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				D d2 = f[i][k] + f[k][j];
				if (f[i][j] &gt; d2)
					f[i][j] = d2, pass[i][j] = k;
			}
		}
	}
	return make_pair(f, pass);
}

auto get_path(const VV&lt;int&gt; &amp;pass, int x, int y) {
	V&lt;int&gt; path = {x};
	std::function&lt;void(int, int)&gt; dfs = [&amp;](int a, int b) {
		if (pass[a][b] != -1) {
			int p = pass[a][b];
			dfs(a, p), path.push_back(p), dfs(p, b);
		}
	};
	if (x != y)
		dfs(x, y), path.push_back(y);
	return path;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca"><a class="header" href="#lca">LCA</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca倍增"><a class="header" href="#lca倍增">LCA・倍增</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(倍增)

struct LCA {
	const int n, lgn;
	VV&lt;int&gt; f;
	V&lt;int&gt; dep;
	LCA(int n_) : n(n_), lgn(1 + std::__lg(n)), f(n, lgn), dep(n) {}
	int query(int x, int y) {
		if (dep[x] &gt; dep[y])
			std::swap(x, y);
		while (dep[x] &lt; dep[y])
			y = f[y][std::__lg(dep[y] - dep[x])];
		for (int i = lgn - 1; i &gt;= 0; i--) {
			if (f[x][i] != f[y][i]) {
				x = f[x][i], y = f[y][i];
			}
		}
		return x == y ? x : f[x][0];
	}
};

template &lt;class D&gt;
struct LCAImpl : LCA {
	const Edges&lt;D&gt; &amp;E;
	LCAImpl(const Edges&lt;D&gt; &amp;E_, int s = 1) : LCA(E_.size()), E(E_) {
		dfs(s, 0);
		for (int i = 1; i &lt; lgn; i++) {
			for (int j = 0; j &lt; n; j++) {
				f[j][i] = f[f[j][i - 1]][i - 1];
			}
		}
	}
	void dfs(int u, int fa) {
		f[u][0] = fa;
		dep[u] = dep[fa] + 1;
		for (auto e : E[u]) {
			if (e.to != fa) {
				dfs(e.to, u);
			}
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lcast"><a class="header" href="#lcast">LCA（ST）</a></h1>
<pre><code class="language-cpp">using pii = std::pair&lt;int, int&gt;;

template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(Sparse Table)

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	void init(auto first, auto last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = min(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) const {
		int s = std::__lg(r - l + 1);
		return min(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};

struct LCA {
	const int n;
	V&lt;int&gt; dfn;
	SparseTable&lt;pii&gt; st;
	LCA(int n_) : n(n_), dfn(n), st(n) {}
	int query(int x, int y) const {
		if (x == y)
			return x;
		x = dfn[x], y = dfn[y];
		if (x &gt; y)
			std::swap(x, y);
		return st.query(x + 1, y).second;
	}
};

template &lt;class D&gt;
struct LCAImpl : LCA {
	const Edges&lt;D&gt; &amp;E;
	V&lt;pii&gt; rnk;
	int cnt = 0;
	LCAImpl(const Edges&lt;D&gt; &amp;E_, int s = 1) : LCA(E_.size()), E(E_), rnk(n) {
		dfs(s, 0);
		st.init(rnk.begin(), rnk.end());
	}
	void dfs(int u, int fa) {
		dfn[u] = ++cnt;
		rnk[cnt] = {dfn[fa], fa};
		for (auto e : E[u]) {
			if (e.to != fa) {
				dfs(e.to, u);
			}
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scc"><a class="header" href="#scc">SCC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tarjan"><a class="header" href="#tarjan">Tarjan</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

struct SCC {
	V&lt;int&gt; id;
	V&lt;V&lt;int&gt;&gt; group;
	SCC(int n) : id(n) {}
};

template &lt;class D&gt;
struct SCCImpl : SCC {
	const Edges&lt;D&gt; &amp;E;
	const int n;
	V&lt;int&gt; low, dfn, stk;
	V&lt;bool&gt; flag;
	int cnt = 0, c2 = 0;
	void tarjan(int u) {
		low[u] = dfn[u] = ++cnt;
		stk.push_back(u), flag[u] = true;
		for (auto e : E[u]) {
			if (dfn[e.to] == 0) {
				tarjan(e.to);
				low[u] = std::min(low[u], low[e.to]);
			} else if (flag[e.to]) {
				low[u] = std::min(low[u], dfn[e.to]);
			}
		}
		if (dfn[u] == low[u]) {
			c2++;
			while (true) {
				int v = stk.back();
				stk.pop_back();
				id[v] = c2;
				flag[v] = false;
				if (u == v)
					break;
			}
		}
	}
	SCCImpl(const Edges&lt;D&gt; &amp;E_) : SCC(E_.size()), E(E_), n(E.size()), low(n), dfn(n), flag(n) {
		for (int i = 1; i &lt; n; i++) {
			if (dfn[i] == 0)
				tarjan(i);
		}
		group.resize(c2 + 1);
		for (int i = 1; i &lt; n; i++) {
			id[i] = c2 + 1 - id[i]; // 拓扑序
			group[id[i]].push_back(i);
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kosaraju"><a class="header" href="#kosaraju">Kosaraju</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

struct SCC {
	V&lt;int&gt; id;
	V&lt;V&lt;int&gt;&gt; group;
	SCC(int n) : id(n) {}
};

template &lt;class D&gt;
struct SCCImpl : SCC {
	const Edges&lt;D&gt; &amp;E, &amp;IE;
	const int n;
	V&lt;bool&gt; vis;
	V&lt;int&gt; stk;
	int cnt = 0;
	void dfs1(int u) {
		vis[u] = true;
		for (auto e : E[u])
			if (!vis[e.to])
				dfs1(e.to);
		stk.push_back(u);
	}
	void dfs2(int u) {
		id[u] = cnt;
		for (auto e : IE[u])
			if (id[e.to] == 0)
				dfs2(e.to);
	}
	SCCImpl(const Edges&lt;D&gt; &amp;E_, const Edges&lt;D&gt; &amp;IE_)
		: SCC(E_.size()), E(E_), IE(IE_), n(E.size()), vis(n) {
		for (int i = 1; i &lt; n; i++)
			if (!vis[i])
				dfs1(i);
		std::reverse(stk.begin(), stk.end());
		for (int u : stk) {
			if (id[u] == 0) {
				++cnt;
				dfs2(u);
			}
		}
		group.resize(cnt + 1);
		for (int i = 1; i &lt; n; i++) {
			group[id[i]].push_back(i);
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最小生成树kruskal"><a class="header" href="#最小生成树kruskal">最小生成树（kruskal）</a></h1>
<pre><code class="language-cpp">// @description 朴素并查集

struct DSU {
	V&lt;int&gt; fa;
	DSU(int n) : fa(n) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		fa[x] = y;
	}
};

ll kruskal(int n) {
	std::sort(G.begin(), G.end(), [](Edge a, Edge b) {
		return get&lt;2&gt;(a) &lt; get&lt;2&gt;(b);
	});
	ll ans = 0, cnt = 0;
	DSU dsu(n + 1);
	for (auto [u, v, w] : G) {
		if (dsu.find(u) == dsu.find(v)) {
			continue;
		}
		ans += w, cnt++;
		dsu.merge(u, v);
		if (cnt == n - 1) {
			return ans;
		}
	}
	return -1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树链剖分"><a class="header" href="#树链剖分">树链剖分</a></h1>
<pre><code class="language-cpp">const int N = 1E5 + 5;
V&lt;int&gt; G[N];

// @problem https://www.luogu.com.cn/problem/P3379

// @description 树链剖分 LCA

struct HLD {
	V&lt;int&gt; sz, dep, fa, son, top, dfn;
	int cnt = 0;
	HLD(int n, int r = 1) : sz(n), dep(n), fa(n), son(n), top(n), dfn(n) {
		dfs1(r), dfs2(r, r);
	}
	void dfs1(int u, int f = 0) {
		dep[u] = dep[f] + 1;
		fa[u] = f, sz[u] = 1, top[u] = u;
		for (int v : G[u]) {
			if (v != f) {
				dfs1(v, u);
				sz[u] += sz[v];
				if (sz[v] &gt; sz[son[u]]) {
					son[u] = v;
				}
			}
		}
	}
	void dfs2(int u, int tp, int f = 0) {
		top[u] = tp, dfn[u] = ++cnt;
		if (son[u] != 0) {
			dfs2(son[u], tp, u);
			for (int v : G[u]) {
				if (v != f &amp;&amp; v != son[u]) {
					dfs2(v, v, u);
				}
			}
		}
	}
	int qpath(int x, int y) {
		while (top[x] != top[y]) {
			if (dep[top[x]] &gt; dep[top[y]]) {
				std::swap(x, y);
			}
			y = fa[top[y]];
		}
		return dep[x] &lt; dep[y] ? x : y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dinic"><a class="header" href="#dinic">Dinic</a></h1>
<p>感谢 gkjj 送的 Dinic。</p>
<pre><code class="language-cpp">struct Dinic {
	const int inf = 1e9;
	struct edge {
		int to, cap, rev;
	};
	V&lt;V&lt;edge&gt;&gt; G;
	V&lt;int&gt; lev, cur;
	Dinic(int n) : G(n), lev(n), cur(n) {}

	inline void add(int x, int y, int c) {
		G[x].push_back({y, c, (int)G[y].size()});
		G[y].push_back({x, 0, (int)G[x].size() - 1});
	}

	void bfs(int s) {
		std::queue&lt;int&gt; qu;
		std::fill(lev.begin(), lev.end(), -1);
		for (lev[s] = 0, qu.push(s); qu.size();) {
			int x = qu.front();
			qu.pop();
			for (auto [to, cap, rev] : G[x])
				if (cap &gt; 0 &amp;&amp; lev[to] &lt; 0)
					lev[to] = lev[x] + 1, qu.push(to);
		}
	}

	int dfs(int x, int t, int f) {
		if (x == t)
			return f;
		for (int &amp;i = cur[x], d; i &lt; G[x].size(); i++) {
			auto &amp;[to, cap, rev] = G[x][i];
			if (cap &gt; 0 &amp;&amp; lev[x] &lt; lev[to])
				if ((d = dfs(to, t, std::min(f, cap))) &gt; 0) {
					cap -= d;
					G[to][rev].cap += d;
					return d;
				}
		}
		return 0;
	}

	ll maxflow(int s, int t) {
		for (ll flow = 0, f;;) {
			bfs(s);
			if (lev[t] &lt; 0)
				return flow;
			std::fill(cur.begin(), cur.end(), 0);
			while ((f = dfs(s, t, inf)) &gt; 0)
				flow += f;
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式"><a class="header" href="#多项式">多项式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fft-乘法"><a class="header" href="#fft-乘法">FFT 乘法</a></h1>
<p>FFT 乘法及拆系数 $5$ 次乘法，可以做 <code>int</code> 范围内的卷积。可能存在误差。</p>
<pre><code class="language-cpp">using f64 = double;

using img = std::complex&lt;f64&gt;;
using Poly = V&lt;int&gt;;

V&lt;img&gt; w{{1, 0}, {1, 0}};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

const f64 PI = acos(-1.0);

void pre_w(int u) {
	int l = w.size(), l2 = l * 2;
	if (u &lt;= l)
		return;
	w.resize(l2);
	img p = img(cos(PI / l), sin(PI / l));
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(u);
}

static int ntt_size = 0;

void fft(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j] + f[i + j + l];
				f[i + j + l] = w[j + l] * (f[i + j] - f[i + j + l]);
				f[i + j] = x;
			}
}

void ifft(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j], y = f[i + j + l] * w[j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	for (int i = 0; i &lt; n; i++)
		f[i] /= n;
	std::reverse(f + 1, f + n);
}

Poly mul(const Poly &amp;a, const Poly &amp;b) {
	int n = a.size(), m = b.size(), N = get_lim(n + m - 1);
	V&lt;img&gt; f(N);
	for (int i = 0; i &lt; n; i++)
		f[i] += img(a[i], 0);
	for (int i = 0; i &lt; m; i++)
		f[i] += img(0, b[i]);
	fft(f.begin(), N);
	for (int i = 0; i &lt; N; i++)
		f[i] *= f[i];
	ifft(f.begin(), N);
	Poly ans(n + m - 1);
	for (int i = 0; i &lt; n + m - 1; i++)
		ans[i] = int(f[i].imag() / 2 + 0.5);
	return ans;
}

Poly mul5(const Poly &amp;a, const Poly &amp;b, int p) {
	enum : int { B = 1 &lt;&lt; 15 };
	int n = a.size(), m = b.size(), N = get_lim(n + m - 1);
	V&lt;img&gt; a0(N), a1(N), Q(N);
	for (int i = 0; i &lt; n; i++)
		a0[i] = a[i] % B, a1[i] = a[i] / B;
	for (int i = 0; i &lt; m; i++)
		Q[i] = img(b[i] % B, b[i] / B);
	fft(a0.begin(), N), fft(a1.begin(), N), fft(Q.begin(), N);
	for (int i = 0; i &lt; N; i++)
		a0[i] *= Q[i], a1[i] *= Q[i];
	ifft(a0.begin(), N), ifft(a1.begin(), N);
	Poly ans(n + m - 1);
	for (int i = 0; i &lt; m + n - 1; i++) {
		ll a1b1 = a1[i].imag() + .5;
		ll a1b0 = a1[i].real() + .5;
		ll a0b1 = a0[i].imag() + .5;
		ll a0b0 = a0[i].real() + .5;
		ans[i] = ((a1b1 * B % p + a0b1 + a1b0) * B + a0b0) % p;
	}
	return ans;
}
</code></pre>
<pre><code>poly/fft-mul.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                    MUL * |       1 |     0.000 |     200 |      - |  5000000.0
         MUL5 MOD 1E9 + 7 |       1 |     0.001 |     600 |  3.000 |  1666666.7
                    MUL * |       2 |     0.000 |     100 |      - | 10000000.0
         MUL5 MOD 1E9 + 7 |       2 |     0.001 |     400 |  4.000 |  2500000.0
                    MUL * |      64 |     0.005 |      75 |      - | 13333333.3
         MUL5 MOD 1E9 + 7 |      64 |     0.013 |     210 |  2.812 |  4740740.7
                    MUL * |     512 |     0.041 |      80 |      - | 12367149.8
         MUL5 MOD 1E9 + 7 |     512 |     0.123 |     240 |  2.969 |  4165920.8
                    MUL * |    4096 |     0.398 |      97 |      - | 10304221.1
         MUL5 MOD 1E9 + 7 |    4096 |     1.138 |     277 |  2.863 |  3598601.3
                    MUL * |   16384 |     1.800 |     109 |      - |  9100548.7
         MUL5 MOD 1E9 + 7 |   16384 |     5.247 |     320 |  2.915 |  3122313.0
                    MUL * |   32768 |     3.833 |     116 |      - |  8548990.9
         MUL5 MOD 1E9 + 7 |   32768 |    11.058 |     337 |  2.885 |  2963393.6
                    MUL * |   65536 |     8.408 |     128 |      - |  7794716.0
         MUL5 MOD 1E9 + 7 |   65536 |    23.281 |     355 |  2.769 |  2814974.3
                    MUL * |  131072 |    18.669 |     142 |      - |  7021014.9
         MUL5 MOD 1E9 + 7 |  131072 |    49.878 |     380 |  2.672 |  2627837.7
                    MUL * |  262144 |    39.921 |     152 |      - |  6566602.4
         MUL5 MOD 1E9 + 7 |  262144 |   109.283 |     416 |  2.738 |  2398758.3
                    MUL * |  524288 |    89.107 |     169 |      - |  5883792.3
         MUL5 MOD 1E9 + 7 |  524288 |   250.347 |     477 |  2.810 |  2094241.2
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-乘法i32"><a class="header" href="#ntt-乘法i32">NTT 乘法・i32</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 多项式乘法

struct Poly : V&lt;int&gt; {
	using vector::vector;
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n);
};
Poly w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

inline int mo(int u) {
	return u &gt;= P ? u - P : u;
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	int p = qpow(3, (P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = 1ll * w[i] * p % P;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j], y = f[i + j + l];
				f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
				f[i + j] = mo(x + y);
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j];
				int y = 1ll * w[j + l] * f[i + j + l] % P;
				f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * ivn % P;
	std::reverse(f + 1, f + n);
}

Poly &amp;Poly::mul(Poly &amp;f, Poly &amp;g, int n) {
	f.resize(n), g.resize(n);
	ntt(f.begin(), n), ntt(g.begin(), n);
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * g[i] % P;
	return intt(f.begin(), n), f;
}

Poly operator*(Poly f, Poly g) {
	int m = f.size() + g.size() - 1;
	Poly::mul(f, g, get_lim(m));
	return f.resize(m), f;
}

Poly operator+(Poly f, Poly g) {
	int n = std::max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++)
		f[i] = mo(f[i] + g[i]);
	return f;
}

Poly operator-(Poly f, Poly g) {
	int n = std::max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++)
		f[i] = mo(f[i] - g[i] + P);
	return f;
}
</code></pre>
<pre><code>poly/ntt-mul-i32.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
          MUL MOD 1E9+7 * |       1 |     0.001 |     500 |      - |  2000000.0
          MUL MOD 1E9+7 * |       2 |     0.001 |     400 |      - |  2500000.0
          MUL MOD 1E9+7 * |      64 |     0.006 |      90 |      - | 11034482.8
          MUL MOD 1E9+7 * |     512 |     0.044 |      85 |      - | 11689230.8
          MUL MOD 1E9+7 * |    4096 |     0.440 |     107 |      - |  9313154.8
          MUL MOD 1E9+7 * |   16384 |     1.981 |     120 |      - |  8269589.4
          MUL MOD 1E9+7 * |   32768 |     4.542 |     138 |      - |  7214315.9
          MUL MOD 1E9+7 * |   65536 |     9.518 |     145 |      - |  6885577.1
          MUL MOD 1E9+7 * |  131072 |    19.809 |     151 |      - |  6616674.8
          MUL MOD 1E9+7 * |  262144 |    42.152 |     160 |      - |  6218996.8
          MUL MOD 1E9+7 * |  524288 |    90.026 |     171 |      - |  5823728.7
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-乘法三模"><a class="header" href="#ntt-乘法三模">NTT 乘法・三模</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 多项式乘法(int mod)

using Poly = V&lt;int&gt;;

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

template &lt;int P&gt;
struct NTT {
	inline static Poly w{1, 1};

	inline static int ntt_size = 0;

	static inline int mo(int u) {
		return u &gt;= P ? u - P : u;
	}

	static void pre_w(int n) {
		int l = w.size(), l2 = l * 2;
		if (n &lt;= l)
			return;
		w.resize(l2);
		int p = qpow(3, (P - 1) / l2, P);
		for (int i = l; i &lt; l2; i += 2) {
			w[i] = w[i / 2];
			w[i + 1] = 1ll * w[i] * p % P;
		}
		pre_w(n);
	}

	static void ntt(auto f, int n) {
		pre_w(n), ntt_size += n;
		for (int l = n / 2; l; l /= 2)
			for (int i = 0; i &lt; n; i += l * 2)
				for (int j = 0; j &lt; l; j++) {
					int x = f[i + j], y = f[i + j + l];
					f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
					f[i + j] = mo(x + y);
				}
	}

	static void intt(auto f, int n) {
		pre_w(n), ntt_size += n;
		for (int l = 1; l &lt; n; l *= 2)
			for (int i = 0; i &lt; n; i += l * 2)
				for (int j = 0; j &lt; l; j++) {
					int x = f[i + j];
					int y = 1ll * w[j + l] * f[i + j + l] % P;
					f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
				}
		const int ivn = P - (P - 1) / n;
		for (int i = 0; i &lt; n; i++)
			f[i] = 1ll * f[i] * ivn % P;
		std::reverse(f + 1, f + n);
	};
};

template &lt;int P&gt;
Poly mul(Poly &amp;f, Poly g, int n) {
	for (int i = 0; i &lt; n; i++)
		f[i] %= P, g[i] %= P;
	NTT&lt;P&gt;::ntt(f.begin(), n), NTT&lt;P&gt;::ntt(g.begin(), n);
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * g[i] % P;
	return NTT&lt;P&gt;::intt(f.begin(), n), f;
}

Poly mul3(Poly f, Poly g, int p) {
	constexpr std::array&lt;int, 3&gt; M = {985661441, 998244353, 1004535809};
	int m = f.size() + g.size() - 1, N = get_lim(m);
	f.resize(N), g.resize(N);

	std::array&lt;Poly, 3&gt; a = {f, f, f};
	mul&lt;M[0]&gt;(a[0], g, N);
	mul&lt;M[1]&gt;(a[1], g, N);
	mul&lt;M[2]&gt;(a[2], g, N);

	Poly ans(m);

	const ll M12 = ll(M[0]) * M[1] % p;
	const ll inv_1 = qpow(M[0], M[1] - 2, M[1]);
	const ll inv_2 = qpow(ll(M[0]) * M[1] % M[2], M[2] - 2, M[2]);

	for (int i = 0; i &lt; m; i++) {
		ll x = (a[1][i] - a[0][i] + M[1]) * inv_1 % M[1] * M[0] + a[0][i];
		ans[i] = ((a[2][i] - x % M[2] + M[2]) * inv_2 % M[2] * M12 + x) % p;
	}
	return ans;
}
</code></pre>
<pre><code>poly/ntt-mul-mod3.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
          MUL MOD 1E9+7 * |       1 |     0.002 |    2400 |      - |   416666.7
          MUL MOD 1E9+7 * |       2 |     0.002 |    1050 |      - |   952381.0
          MUL MOD 1E9+7 * |      64 |     0.019 |     303 |      - |  3298969.1
          MUL MOD 1E9+7 * |     512 |     0.175 |     341 |      - |  2932349.8
          MUL MOD 1E9+7 * |    4096 |     1.640 |     400 |      - |  2497516.8
          MUL MOD 1E9+7 * |   16384 |     7.266 |     443 |      - |  2254784.3
          MUL MOD 1E9+7 * |   32768 |    15.437 |     471 |      - |  2122696.5
          MUL MOD 1E9+7 * |   65536 |    32.516 |     496 |      - |  2015495.8
          MUL MOD 1E9+7 * |  131072 |    68.336 |     521 |      - |  1918049.4
          MUL MOD 1E9+7 * |  262144 |   147.931 |     564 |      - |  1772070.8
          MUL MOD 1E9+7 * |  524288 |   316.218 |     603 |      - |  1657994.8
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntton2"><a class="header" href="#ntton2">NTT・$O(n^2)$</a></h1>
<p>NTT 的 $O(n^2)$ 板子，我也不知道有啥用，大概用来快速验证吧。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;int&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt; l)
		return;
	iv = fac = ifac = V&lt;int&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n] = qpow(fac[n]), iv[n] = qpow(n);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
		iv[i] = 1ll * ifac[i] * fac[i - 1] % P;
	}
	pre_all(u);
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

struct Poly : V&lt;int&gt; { // O(n2) 板子，我也不知道有啥用
	using vector::vector;
	int deg() const {
		return size();
	}
};

Poly deriv(const Poly &amp;f, int m) {
	Poly r(m);
	for (int i = 1; i &lt; std::min(f.deg(), m + 1); i++)
		r[i - 1] = 1ll * f[i] * i % P;
	return f;
}
Poly integr(const Poly &amp;f, int m) {
	Poly r(m);
	pre_all(m);
	for (int i = std::min(f.deg(), m - 1); i &gt; 0; --i)
		r[i] = 1ll * iv[i] * f[i - 1] % P;
	return f;
}
Poly inv(const Poly &amp;f, int m) {
	Poly r(m);
	int iv0 = r[0] = qpow(f[0]);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, f.deg()); j++)
			r[i] = (r[i] + 1ll * f[j] * r[i - j]) % P;
		r[i] = 1ll * (P - r[i]) * iv0 % P;
	}
	return r;
}

Poly div(int m, const Poly &amp;f, const Poly &amp;g) {
	Poly r(m);
	int iv0 = qpow(g[0]);
	r[0] = 1ll * f[0] * iv0 % P;
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, g.deg()); j++)
			r[i] = (r[i] + 1ll * g[j] * r[i - j]) % P;
		r[i] = mo(f[i] - 1ll * r[i] * iv0 % P);
	}
	return r;
}

Poly ln(const Poly &amp;f, int m) {
	assert(f[0] == 1);
	return integr(div(m, deriv(f, m), f), m);
}

Poly exp(const Poly &amp;f, int m) {
	Poly r(m), df = f;
	for (int i = 0; i &lt; f.deg(); i++)
		df[i] = 1ll * i * df[i] % P;
	r[0] = 1;
	pre_all(m);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, f.deg()); j++)
			r[i] = (r[i] + 1ll * df[j] * r[i - j]) % P;
		r[i] = 1ll * r[i] * iv[i] % P;
	}
	return r;
}

Poly sqrt(const Poly &amp;f, int m) {
	Poly r(m);
	r[0] = 1; // sqrt(f[0])
	int iv0 = qpow(2ll * r[0] % P);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt;= i - 1; j++)
			r[i] = (r[i] + 1ll * r[j] * r[i - j]) % P;
		r[i] = 1ll * (f[i] - r[i] + P) * iv0 % P;
	}
	return r;
}

Poly operator*(const Poly &amp;f, const Poly &amp;g) {
	Poly r(f.size() + g.size() - 1);
	for (int i = 0; i &lt; f.size(); i++) {
		for (int j = 0; j &lt; g.size(); j++) {
			r[i + j] = (r[i + j] + 1ll * f[i] * g[j]) % P;
		}
	}
	return r;
}

Poly operator+(const Poly &amp;f, const Poly &amp;g) {
	Poly r(std::max(f.size(), g.size()));
	std::copy(f.begin(), f.end(), r.begin());
	for (int i = 0; i &lt; g.size(); i++)
		r[i] = mo(r[i] + g[i]);
	return r;
}

Poly operator-(const Poly &amp;f, const Poly &amp;g) {
	Poly r(std::max(f.size(), g.size()));
	std::copy(f.begin(), f.end(), r.begin());
	for (int i = 0; i &lt; g.size(); i++)
		r[i] = mo(r[i] - g[i] + P);
	return r;
}
</code></pre>
<pre><code>poly/ntt-naive.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                    MUL * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.000 |     200 |  2.000 |  5000000.0
                      EXP |       1 |     0.000 |     100 |  1.000 | 10000000.0
                     SQRT |       1 |     0.000 |     200 |  2.000 |  5000000.0
                    MUL * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.000 |     100 |  2.000 | 10000000.0
                      EXP |       2 |     0.000 |      50 |  1.000 | 20000000.0
                     SQRT |       2 |     0.000 |     100 |  2.000 | 10000000.0
                    MUL * |      64 |     0.006 |     100 |      - |  9998437.7
                      INV |      64 |     0.009 |     137 |  1.375 |  7271900.9
                      EXP |      64 |     0.009 |     140 |  1.406 |  7111111.1
                     SQRT |      64 |     0.009 |     132 |  1.328 |  7529411.8
                    MUL * |     512 |     0.400 |     780 |      - |  1281258.8
                      INV |     512 |     0.531 |    1036 |  1.328 |   964927.2
                      EXP |     512 |     0.534 |    1042 |  1.336 |   959322.5
                     SQRT |     512 |     0.530 |    1035 |  1.327 |   965656.9
                    MUL * |    4096 |    25.443 |    6211 |      - |   160989.6
                      INV |    4096 |    33.811 |    8254 |  1.329 |   121143.0
                      EXP |    4096 |    33.824 |    8257 |  1.329 |   121096.8
                     SQRT |    4096 |    33.821 |    8257 |  1.329 |   121107.1
                    MUL * |   16384 |   405.404 |   24743 |      - |    40414.0
                      INV |   16384 |   540.773 |   33006 |  1.334 |    30297.4
                      EXP |   16384 |   541.107 |   33026 |  1.335 |    30278.7
                     SQRT |   16384 |   541.025 |   33021 |  1.335 |    30283.3
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代"><a class="header" href="#ntt-牛顿迭代">NTT 牛顿迭代</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly ln(int m) const {
		assert(T[0].v == 1);
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 48E
		assert(T[0].v == 0);
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = x * (cut(t) - x.ln(t) + Poly{1}), x.redeg(t);
		}
		return x.redeg(m);
	}
	Poly sqrt(int m) const { // 36E
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = (x + cut(t).div(t, x)) * ((P + 1) / 2);
		}
		return x.redeg(m);
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
	friend auto operator%(const Poly &amp;f, const Poly &amp;g) {
		Poly Q = f / g;
		return make_pair(Q, (f - Q * g).redeg(g.deg() - 1));
	}
#undef T
};
</code></pre>
<pre><code>poly/ntt-newton.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                   MUL 6E |       1 |     0.001 |     800 |  8.000 |  1250000.0
                  INV 12E |       1 |     0.001 |     500 |  5.000 |  2000000.0
                  LOG 18E |       1 |     0.001 |    1000 | 10.000 |  1000000.0
                  EXP 48E |       1 |     0.001 |     900 |  9.000 |  1111111.1
                 SQRT 36E |       1 |     0.000 |     400 |  4.000 |  2500000.0
                 NTT 1E * |       2 |     0.000 |       0 |      - |        inf
                   MUL 6E |       2 |     0.001 |     350 |    inf |  2857142.9
                  INV 12E |       2 |     0.001 |     450 |    inf |  2222222.2
                  LOG 18E |       2 |     0.001 |     700 |    inf |  1428571.4
                  EXP 48E |       2 |     0.001 |     700 |    inf |  1428571.4
                 SQRT 36E |       2 |     0.003 |    1450 |    inf |   689655.2
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                   MUL 6E |      64 |     0.006 |      87 |  8.000 | 11428571.4
                  INV 12E |      64 |     0.013 |     195 | 17.859 |  5119590.4
                  LOG 18E |      64 |     0.016 |     243 | 22.286 |  4102564.1
                  EXP 48E |      64 |     0.048 |     746 | 68.287 |  1338884.1
                 SQRT 36E |      64 |     0.031 |     489 | 44.714 |  2044728.4
                 NTT 1E * |     512 |     0.006 |      12 |      - | 82580645.2
                   MUL 6E |     512 |     0.046 |      90 |  7.468 | 11058076.5
                  INV 12E |     512 |     0.092 |     178 | 14.775 |  5589397.6
                  LOG 18E |     512 |     0.142 |     277 | 22.936 |  3600511.9
                  EXP 48E |     512 |     0.355 |     693 | 57.307 |  1441011.4
                 SQRT 36E |     512 |     0.262 |     512 | 42.307 |  1951933.6
                 NTT 1E * |    4096 |     0.062 |      15 |      - | 66277244.7
                   MUL 6E |    4096 |     0.453 |     110 |  7.333 |  9037792.8
                  INV 12E |    4096 |     0.872 |     212 | 14.108 |  4697705.6
                  LOG 18E |    4096 |     1.355 |     330 | 21.918 |  3023940.5
                  EXP 48E |    4096 |     3.390 |     827 | 54.854 |  1208238.2
                 SQRT 36E |    4096 |     2.526 |     616 | 40.874 |  1621507.8
                 NTT 1E * |   16384 |     0.289 |      17 |      - | 56769633.2
                   MUL 6E |   16384 |     2.038 |     124 |  7.061 |  8040295.7
                  INV 12E |   16384 |     3.930 |     239 | 13.619 |  4168565.3
                  LOG 18E |   16384 |     6.064 |     370 | 21.010 |  2702067.1
                  EXP 48E |   16384 |    15.281 |     932 | 52.949 |  1072155.4
                 SQRT 36E |   16384 |    11.456 |     699 | 39.694 |  1430180.1
                 NTT 1E * |   32768 |     0.617 |      18 |      - | 53124863.2
                   MUL 6E |   32768 |     4.362 |     133 |  7.072 |  7511502.9
                  INV 12E |   32768 |     8.442 |     257 | 13.687 |  3881523.0
                  LOG 18E |   32768 |    12.907 |     393 | 20.926 |  2538752.6
                  EXP 48E |   32768 |    32.470 |     990 | 52.641 |  1009188.1
                 SQRT 36E |   32768 |    24.205 |     738 | 39.242 |  1353774.2
                 NTT 1E * |   65536 |     1.318 |      20 |      - | 49730502.5
                   MUL 6E |   65536 |     9.145 |     139 |  6.940 |  7166039.1
                  INV 12E |   65536 |    17.657 |     269 | 13.399 |  3711572.1
                  LOG 18E |   65536 |    27.332 |     417 | 20.740 |  2397786.3
                  EXP 48E |   65536 |    68.911 |    1051 | 52.291 |   951025.1
                 SQRT 36E |   65536 |    51.539 |     786 | 39.109 |  1271573.3
                 NTT 1E * |  131072 |     2.792 |      21 |      - | 46953143.2
                   MUL 6E |  131072 |    19.443 |     148 |  6.965 |  6741193.9
                  INV 12E |  131072 |    38.769 |     295 | 13.888 |  3380821.3
                  LOG 18E |  131072 |    57.883 |     441 | 20.735 |  2264433.4
                  EXP 48E |  131072 |   146.307 |    1116 | 52.411 |   895868.1
                 SQRT 36E |  131072 |   109.492 |     835 | 39.223 |  1197091.9
                 NTT 1E * |  262144 |     5.923 |      22 |      - | 44258630.3
                   MUL 6E |  262144 |    42.973 |     163 |  7.255 |  6100266.2
                  INV 12E |  262144 |    81.069 |     309 | 13.687 |  3233598.4
                  LOG 18E |  262144 |   126.691 |     483 | 21.390 |  2069158.5
                  EXP 48E |  262144 |   315.066 |    1201 | 53.194 |   832029.4
                 SQRT 36E |  262144 |   233.997 |     892 | 39.506 |  1120288.9
                 NTT 1E * |  524288 |    12.496 |      23 |      - | 41958081.1
                   MUL 6E |  524288 |    91.659 |     174 |  7.335 |  5720008.7
                  INV 12E |  524288 |   173.639 |     331 | 13.896 |  3019408.0
                  LOG 18E |  524288 |   273.165 |     521 | 21.861 |  1919311.1
                  EXP 48E |  524288 |   674.173 |    1285 | 53.953 |   777676.2
                 SQRT 36E |  524288 |   501.280 |     956 | 40.117 |  1045897.7
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代卡常"><a class="header" href="#ntt-牛顿迭代卡常">NTT 牛顿迭代・卡常</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(deg());
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly &amp;invD(Poly f2, Poly nx, int t) {
		mul(f2, nx, t).fill0L(t); // 6E
		mul(f2, nx, t);			  // 4E
		redeg(t);
		for (int i = t / 2; i &lt; t; i++) {
			T[i] = -f2[i];
		}
		return T;
	}
	Poly inv(int m) const { // 10E
		Poly x = {qpow(T[0].v)};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x.invD(cut(t), x.cut(m), t);
		}
		return x.redeg(m);
	}
	Poly div(int m, Poly g) const { // 13E
		if (deg() == 0)
			return {};
		int t = get_lim(m);
		Poly x = cut(t / 2), u = g.inv(t / 2); // 10E
		Poly q = mul(x, u, t).cut(t / 2);	   // 6E
		mul(q, g, t).fill0L(t);				   // 6E
		for (int i = t / 2; i &lt; std::min(t, deg()); i++)
			q[i] -= T[i];
		mul(q, u, t); // 4E
		for (int i = t / 2; i &lt; t; i++)
			x[i] = -q[i];
		return x.cut(m);
	}
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 17E
		if (m == 1)
			return {1};
		assert(T[0].v == 0);
		Poly f = {1, T[1]}, g = {1}, nf, ng = g;
		pre_all(deg());
		for (int t = 4; t &lt; m * 2; t *= 2) {
			nf = Poly(f).ntt(t);		// 2E
			ng = g.invD(nf, ng, t / 2); // 3E
			Poly q = cut(t / 2);
			for (int i = 0; i &lt; q.deg(); i++)
				q[i] *= i;
			mul(q, nf, t / 2); // 2E
			for (int i = 0; i &lt; t / 2; i++)
				q[i] -= i * f[i];
			mul(q, ng, t); // 6E
			for (int i = t / 2; i &lt; std::min(t, deg()); i++)
				q[i] = T[i] + q[i - t / 2] * iv[i];
			mul(q.fill0L(t), nf, t); // 4E
			f.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				f[i] = q[i];
		}
		return f.cut(m);
	}
	Poly sqrt(int m) const { // 11E
		Poly x = {1}, g = x.inv(1), ng = g;
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly f = Poly(x).ntt(t / 2); // 2E
			if (t &gt;= 4)
				ng = g.invD(f, ng, t / 2); // 3E
			mul(f, f, t / 2).redeg(t);	   // 1E
			for (int i = t / 2; i &lt; std::min(t, deg()); i++)
				f[i] = T[i - t / 2] + T[i] - f[i - t / 2];
			mul(f.fill0L(t), ng, t); // 6E
			x.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				x[i] = f[i] * ((P + 1) / 2);
		}
		return x.cut(deg());
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};
</code></pre>
<pre><code>poly/ntt-newton-fast.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     400 |      - |  2500000.0
                   MUL 6E |       1 |     0.000 |     300 |  0.750 |  3333333.3
                  INV 10E |       1 |     0.000 |     400 |  1.000 |  2500000.0
                  LOG 13E |       1 |     0.001 |    1000 |  2.500 |  1000000.0
                  EXP 17E |       1 |     0.000 |     200 |  0.500 |  5000000.0
                 SQRT 11E |       1 |     0.001 |     801 |  2.002 |  1248439.5
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                   MUL 6E |       2 |     0.001 |     500 | 10.000 |  2000000.0
                  INV 10E |       2 |     0.001 |     250 |  5.000 |  4000000.0
                  LOG 13E |       2 |     0.002 |    1150 | 23.000 |   869565.2
                  EXP 17E |       2 |     0.000 |     150 |  3.000 |  6666666.7
                 SQRT 11E |       2 |     0.002 |     900 | 18.000 |  1111111.1
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                   MUL 6E |      64 |     0.006 |      95 |  8.714 | 10491803.3
                  INV 10E |      64 |     0.011 |     178 | 16.286 |  5614035.1
                  LOG 13E |      64 |     0.013 |     196 | 18.000 |  5079365.1
                  EXP 17E |      64 |     0.018 |     276 | 25.286 |  3615819.2
                 SQRT 11E |      64 |     0.014 |     214 | 19.571 |  4671532.8
                 NTT 1E * |     512 |     0.007 |      13 |      - | 75294117.6
                   MUL 6E |     512 |     0.049 |      95 |  7.206 | 10448766.4
                  INV 10E |     512 |     0.077 |     150 | 11.368 |  6623373.3
                  LOG 13E |     512 |     0.098 |     191 | 14.397 |  5229719.5
                  EXP 17E |     512 |     0.134 |     261 | 19.691 |  3823692.0
                 SQRT 11E |     512 |     0.084 |     164 | 12.383 |  6080615.7
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59361458.5
                   MUL 6E |    4096 |     0.474 |     115 |  6.872 |  8637559.9
                  INV 10E |    4096 |     0.701 |     171 | 10.155 |  5845482.9
                  LOG 13E |    4096 |     0.957 |     233 | 13.862 |  4282203.0
                  EXP 17E |    4096 |     1.198 |     292 | 17.359 |  3419542.7
                 SQRT 11E |    4096 |     0.766 |     186 | 11.099 |  5348564.2
                 NTT 1E * |   16384 |     0.320 |      19 |      - | 51167221.0
                   MUL 6E |   16384 |     2.174 |     132 |  6.790 |  7535860.2
                  INV 10E |   16384 |     3.228 |     197 | 10.082 |  5075028.9
                  LOG 13E |   16384 |     4.295 |     262 | 13.415 |  3814246.4
                  EXP 17E |   16384 |     5.495 |     335 | 17.160 |  2981730.3
                 SQRT 11E |   16384 |     3.503 |     213 | 10.939 |  4677451.7
                 NTT 1E * |   32768 |     0.684 |      20 |      - | 47912596.9
                   MUL 6E |   32768 |     4.577 |     139 |  6.692 |  7159618.8
                  INV 10E |   32768 |     6.847 |     208 | 10.011 |  4786011.2
                  LOG 13E |   32768 |     9.229 |     281 | 13.495 |  3550407.9
                  EXP 17E |   32768 |    11.662 |     355 | 17.051 |  2809929.1
                 SQRT 11E |   32768 |     7.444 |     227 | 10.884 |  4402153.3
                 NTT 1E * |   65536 |     1.457 |      22 |      - | 44991676.0
                   MUL 6E |   65536 |     9.754 |     148 |  6.696 |  6718835.7
                  INV 10E |   65536 |    14.582 |     222 | 10.011 |  4494198.3
                  LOG 13E |   65536 |    19.430 |     296 | 13.339 |  3372921.5
                  EXP 17E |   65536 |    24.807 |     378 | 17.031 |  2641799.4
                 SQRT 11E |   65536 |    15.865 |     242 | 10.892 |  4130729.6
                 NTT 1E * |  131072 |     3.082 |      23 |      - | 42527497.1
                   MUL 6E |  131072 |    20.664 |     157 |  6.705 |  6342870.2
                  INV 10E |  131072 |    30.880 |     235 | 10.019 |  4244553.9
                  LOG 13E |  131072 |    42.927 |     327 | 13.928 |  3053401.7
                  EXP 17E |  131072 |    52.832 |     403 | 17.142 |  2480942.9
                 SQRT 11E |  131072 |    34.965 |     266 | 11.345 |  3748629.6
                 NTT 1E * |  262144 |     6.536 |      24 |      - | 40107011.6
                   MUL 6E |  262144 |    44.134 |     168 |  6.752 |  5939746.0
                  INV 10E |  262144 |    66.722 |     254 | 10.208 |  3928906.9
                  LOG 13E |  262144 |    87.568 |     334 | 13.398 |  2993593.5
                  EXP 17E |  262144 |   111.811 |     426 | 17.107 |  2344524.5
                 SQRT 11E |  262144 |    73.921 |     281 | 11.310 |  3546248.6
                 NTT 1E * |  524288 |    13.794 |      26 |      - | 38008847.6
                   MUL 6E |  524288 |    95.748 |     182 |  6.941 |  5475691.2
                  INV 10E |  524288 |   139.640 |     266 | 10.123 |  3754562.2
                  LOG 13E |  524288 |   190.358 |     363 | 13.800 |  2754221.9
                  EXP 17E |  524288 |   239.881 |     457 | 17.390 |  2185614.3
                 SQRT 11E |  524288 |   155.660 |     296 | 11.285 |  3368160.8
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代分块卡常"><a class="header" href="#ntt-牛顿迭代分块卡常">NTT 牛顿迭代（分块卡常）</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = qpow(3, (P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	Poly operator*(Z k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(deg());
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly inv(int m) const;
	Poly div(int m, Poly g) const;
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const;
	Poly sqrt(int m) const;
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};

Poly Poly::inv(int u) const { // 10E
	if (u == 1) {
		return {front().inv()};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);
	nf[0] = cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = cut(m, k * m).ntt(m * 2);			  // 2E
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2); // 2E
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2); // 2E
		mul(psi, ng[0], m * 2);		   // 4E
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::sqrt(int u) const { // 8E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = sqrt(m), h = x.inv(m).ntt(m * 2);
	vector&lt;Poly&gt; ng(R);

	for (int k = 1; x.deg() &lt; u; k++) {
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			if (j &gt;= 1) {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] + ng[k - 1 - j][i]);
				for (int i = m; i &lt; m * 2; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] - ng[k - 1 - j][i]);
			} else {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * ng[k - 1 - j][i];
				for (int i = m; i &lt; m * 2; i++)
					psi[i] += ng[j][i] * ng[k - 1 - j][i];
			}
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; std::min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i] * iv[2];
	}
	return x.cut(u);
}

Poly Poly::div(int u, Poly f) const { // 10E
	if (u == 1) {
		return {front() * f[0].inv()};
	}
	f.redeg(u);
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = div(m, f), h = f.inv(m).ntt(m * 2);

	vector&lt;Poly&gt; nf(R), ng(R);

	nf[0] = f.cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = f.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; std::min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::exp(int u) const { // 14E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = exp(m), y = x.inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);

	Poly df = *this;
	for (int i = 0; i &lt; df.deg(); i++)
		df[i] *= i;
	y.ntt(m * 2);
	nf[0] = df.cut(m).ntt(m * 2);

	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = df.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, m * (k - 1)).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);

		mul(psi, y, m * 2).fill0H(m * 2);
		for (int i = 0; i &lt; m * 2; i++)
			psi[i] *= iv[m * k + i];
		mul(psi, ng[0], m * 2).fill0H(m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}
</code></pre>
<pre><code>poly/ntt-newton-blockwise-fast.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                   MUL 6E |       1 |     0.001 |     900 |  9.000 |  1111111.1
                  INV 10E |       1 |     0.000 |     200 |  2.000 |  5000000.0
                  LOG 10E |       1 |     0.002 |    1500 | 15.000 |   666666.7
                  EXP 14E |       1 |     0.000 |     100 |  1.000 | 10000000.0
                  SQRT 8E |       1 |     0.000 |     100 |  1.000 | 10000000.0
                 NTT 1E * |       2 |     0.000 |     100 |      - | 10000000.0
                   MUL 6E |       2 |     0.001 |     350 |  3.500 |  2857142.9
                  INV 10E |       2 |     0.002 |    1050 | 10.500 |   952381.0
                  LOG 10E |       2 |     0.002 |     850 |  8.500 |  1176470.6
                  EXP 14E |       2 |     0.003 |    1350 | 13.500 |   740740.7
                  SQRT 8E |       2 |     0.003 |    1550 | 15.500 |   645161.3
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                   MUL 6E |      64 |     0.006 |      87 |  8.000 | 11428571.4
                  INV 10E |      64 |     0.013 |     209 | 19.144 |  4775763.0
                  LOG 10E |      64 |     0.018 |     284 | 26.001 |  3516290.3
                  EXP 14E |      64 |     0.026 |     400 | 36.571 |  2500000.0
                  SQRT 8E |      64 |     0.014 |     223 | 20.429 |  4475524.5
                 NTT 1E * |     512 |     0.007 |      13 |      - | 75283046.6
                   MUL 6E |     512 |     0.049 |      96 |  7.264 | 10364162.7
                  INV 10E |     512 |     0.090 |     176 | 13.292 |  5663591.5
                  LOG 10E |     512 |     0.105 |     204 | 15.366 |  4899427.8
                  EXP 14E |     512 |     0.135 |     264 | 19.895 |  3784099.4
                  SQRT 8E |     512 |     0.084 |     164 | 12.381 |  6080687.9
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59361458.5
                   MUL 6E |    4096 |     0.476 |     116 |  6.893 |  8612134.4
                  INV 10E |    4096 |     0.788 |     192 | 11.415 |  5200517.0
                  LOG 10E |    4096 |     0.871 |     212 | 12.617 |  4704720.2
                  EXP 14E |    4096 |     1.138 |     277 | 16.493 |  3599236.9
                  SQRT 8E |    4096 |     0.718 |     175 | 10.406 |  5704632.1
                 NTT 1E * |   16384 |     0.319 |      19 |      - | 51295377.3
                   MUL 6E |   16384 |     2.181 |     133 |  6.830 |  7510638.6
                  INV 10E |   16384 |     3.438 |     209 | 10.763 |  4765755.4
                  LOG 10E |   16384 |     3.785 |     231 | 11.852 |  4328132.9
                  EXP 14E |   16384 |     5.102 |     311 | 15.973 |  3211359.6
                  SQRT 8E |   16384 |     3.084 |     188 |  9.657 |  5311971.3
                 NTT 1E * |   32768 |     0.683 |      20 |      - | 48010877.5
                   MUL 6E |   32768 |     4.586 |     139 |  6.719 |  7145411.6
                  INV 10E |   32768 |     7.289 |     222 | 10.679 |  4495709.6
                  LOG 10E |   32768 |     8.006 |     244 | 11.730 |  4092858.7
                  EXP 14E |   32768 |    10.663 |     325 | 15.623 |  3073089.2
                  SQRT 8E |   32768 |     6.528 |     199 |  9.565 |  5019443.3
                 NTT 1E * |   65536 |     1.455 |      22 |      - | 45038055.1
                   MUL 6E |   65536 |     9.753 |     148 |  6.702 |  6719594.1
                  INV 10E |   65536 |    15.322 |     233 | 10.530 |  4277117.8
                  LOG 10E |   65536 |    18.044 |     275 | 12.401 |  3631927.1
                  EXP 14E |   65536 |    22.670 |     345 | 15.579 |  2890856.7
                  SQRT 8E |   65536 |    13.704 |     209 |  9.418 |  4782135.1
                 NTT 1E * |  131072 |     3.089 |      23 |      - | 42435234.4
                   MUL 6E |  131072 |    20.727 |     158 |  6.710 |  6323713.4
                  INV 10E |  131072 |    32.558 |     248 | 10.541 |  4025779.2
                  LOG 10E |  131072 |    35.724 |     272 | 11.566 |  3669046.4
                  EXP 14E |  131072 |    48.144 |     367 | 15.587 |  2722508.1
                  SQRT 8E |  131072 |    28.956 |     220 |  9.375 |  4526606.8
                 NTT 1E * |  262144 |     6.544 |      24 |      - | 40056145.6
                   MUL 6E |  262144 |    44.917 |     171 |  6.863 |  5836227.7
                  INV 10E |  262144 |    71.042 |     271 | 10.855 |  3689994.4
                  LOG 10E |  262144 |    76.491 |     291 | 11.688 |  3427133.9
                  EXP 14E |  262144 |   102.331 |     390 | 15.636 |  2561713.9
                  SQRT 8E |  262144 |    61.662 |     235 |  9.422 |  4251279.5
                 NTT 1E * |  524288 |    13.820 |      26 |      - | 37937888.5
                   MUL 6E |  524288 |    95.336 |     181 |  6.899 |  5499372.6
                  INV 10E |  524288 |   147.375 |     281 | 10.664 |  3557515.2
                  LOG 10E |  524288 |   164.143 |     313 | 11.878 |  3194093.6
                  EXP 14E |  524288 |   217.975 |     415 | 15.773 |  2405263.2
                  SQRT 8E |  524288 |   132.687 |     253 |  9.601 |  3951328.3
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式平移"><a class="header" href="#ntt-多项式平移">NTT 多项式平移</a></h1>
<p>给定多项式 $f(x)$，求多项式 $f(x + c)$。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

Poly taylor_shift(const Poly &amp;f, Z c) {
	int n = f.deg();
	Poly A(n), B(n);
	Z ci = 1;
	for (int i = 0; i &lt; n; i++) {
		A[i] = f[i] * fac[i];
		B[i] = ci * ifac[i];
		ci *= c;
	}
	std::reverse(A.begin(), A.end());
	A = A * B;
	for (int i = 0; i &lt; n; i++) {
		B[i] = A[n - i - 1] * ifac[i];
	}
	return B;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式多点求值--快速插值"><a class="header" href="#ntt-多项式多点求值--快速插值">NTT 多项式多点求值 &amp; 快速插值</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly operator*(int k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

// @description 多项式多点求值

struct PolyEI {
	int raw_n, n;
	V&lt;Poly&gt; p;
	PolyEI(Poly a) : raw_n(a.deg()), n(get_lim(raw_n)), p(n * 2) {
		a.redeg(n);
		for (int i = 0; i &lt; n; i++)
			p[i + n] = {1, -a[i]};
		for (int i = n - 1; i; i--) {
			int ls = i * 2, rs = i * 2 + 1;
			int len = get_lim(p[ls].deg());
			p[ls].ntt(len), p[rs].ntt(len), p[i].redeg(len);
			for (int j = 0; j &lt; len; j++)
				p[i][j] = p[ls][j] * p[rs][j];
			p[i].intt(len);
			p[i].push_back(p[i][0] - 1), p[i][0] = 1;
		}
	}
	Poly eval(const Poly &amp;f) { // PolyEI(x).eval(f)
		int m = f.deg();
		if (m == 1)
			return Poly(raw_n, f[0]);
		Poly q = f.rev().div(m, p[1]).redeg(m);
		if (m &gt; n) {
			std::rotate(q.begin(), q.begin() + m - n, q.end());
			q.redeg(n);
		} else {
			q.redeg(n);
			std::rotate(q.begin(), q.begin() + m, q.end());
		}
		for (int k = n, o = 1; k &gt; 1; k /= 2)
			for (int i = 0; i &lt; n; i += k, o++) {
				if (i &gt;= raw_n)
					continue;
				Poly foo(k), bar(k);
				auto qi = q.begin() + i;
				ntt(qi, k);
				for (int j = 0; j &lt; k; j++) {
					foo[j] = qi[j] * p[o * 2 + 1][j];
					bar[j] = qi[j] * p[o * 2][j];
				}
				foo.intt(k), bar.intt(k);
				std::copy(foo.begin() + k / 2, foo.end(), qi);
				std::copy(bar.begin() + k / 2, bar.end(), qi + k / 2);
			}
		return q.cut(raw_n);
	}
	Poly inter(const Poly &amp;y) { // PolyEI(x).inter(y)
		Poly q = Poly(p[1]).redeg(raw_n + 1);
		q = eval(q.rev().deriv(raw_n + 1)).redeg(n);
		for (int i = 0; i &lt; raw_n; i++)
			q[i] = y[i] / q[i];
		for (int k = 1, h = n / 2; k &lt; n; k *= 2, h /= 2)
			for (int i = 0, o = h; i &lt; n; i += k * 2, o++) {
				if (i &gt;= raw_n)
					continue;
				auto qi = q.begin() + i;
				Poly foo(qi, qi + k), bar(qi + k, qi + k * 2);
				foo.ntt(k * 2), bar.ntt(k * 2);
				for (int j = 0; j &lt; k * 2; j++) {
					qi[j] = foo[j] * p[o * 2 + 1][j] + bar[j] * p[o * 2][j];
				}
				intt(qi, k * 2);
			}
		return q.cut(raw_n).rev();
	}
};
</code></pre>
<pre><code>poly/ntt-eval.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                     EVAL |       1 |     0.000 |     200 |  2.000 |  5000000.0
                    INTER |       1 |     0.001 |     700 |  7.000 |  1428571.4
                 NTT 1E * |       2 |     0.000 |     150 |      - |  6666666.7
                     EVAL |       2 |     0.002 |    1200 |  8.000 |   833333.3
                    INTER |       2 |     0.003 |    1450 |  9.670 |   689417.4
                 NTT 1E * |      64 |     0.001 |       9 |      - |106666666.7
                     EVAL |      64 |     0.053 |     828 | 88.335 |  1207524.4
                    INTER |      64 |     0.047 |     740 | 79.002 |  1350182.5
                 NTT 1E * |     512 |     0.007 |      13 |      - | 74202898.6
                     EVAL |     512 |     0.522 |    1019 | 75.653 |   980826.0
                    INTER |     512 |     0.530 |    1034 | 76.755 |   966750.9
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59274695.4
                     EVAL |    4096 |     5.640 |    1377 | 81.623 |   726202.6
                    INTER |    4096 |     5.640 |    1377 | 81.624 |   726189.9
                 NTT 1E * |   16384 |     0.320 |      19 |      - | 51263117.7
                     EVAL |   16384 |    27.480 |    1677 | 85.980 |   596218.0
                    INTER |   16384 |    27.390 |    1671 | 85.699 |   598177.2
                 NTT 1E * |   32768 |     0.682 |      20 |      - | 48074271.0
                     EVAL |   32768 |    60.291 |    1839 | 88.453 |   543500.5
                    INTER |   32768 |    60.395 |    1843 | 88.607 |   542558.3
                 NTT 1E * |   65536 |     1.452 |      22 |      - | 45127993.3
                     EVAL |   65536 |   131.667 |    2009 | 90.666 |   497740.5
                    INTER |   65536 |   131.510 |    2006 | 90.557 |   498335.9
                 NTT 1E * |  131072 |     3.083 |      23 |      - | 42510931.6
                     EVAL |  131072 |   287.017 |    2189 | 93.089 |   456670.4
                    INTER |  131072 |   286.908 |    2188 | 93.054 |   456842.8
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-chirp-z-变换"><a class="header" href="#ntt-chirp-z-变换">NTT Chirp Z 变换</a></h1>
<p>给定 $f(x)$ 和常数 $c$，计算 $f(c^0), f(c^1), \cdots, f(c^m)$。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

Poly chirpz(const Poly &amp;f, int m, Z c) {
	int n = f.deg(), N = get_lim(n + m - 1);
	Poly A = f, pw(n + m, 1), ipw(n + m, 1);
	Z ci = c, ivc = c.inv(), ici = ivc;
	for (int i = 2; i &lt; n + m; i++) {
		pw[i] = pw[i - 1] * ci;
		ipw[i] = ipw[i - 1] * ici;
		ci *= c, ici *= ivc;
	}
	for (int i = 0; i &lt; n; i++)
		A[i] *= ipw[i];
	std::reverse(A.begin(), A.end());
	Poly::mul(A, pw, N);
	Poly x(m);
	for (int i = 0; i &lt; m; i++) {
		x[i] = A[i + n - 1] * ipw[i];
	}
	return x;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-在线卷积"><a class="header" href="#ntt-在线卷积">NTT 在线卷积</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-半在线卷积"><a class="header" href="#ntt-半在线卷积">NTT 半在线卷积</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

struct PolySemi {
	int now = 0;
	enum : int { M = 32 };
	const Poly &amp;F;
	Poly G, conv;
	std::map&lt;int, Poly&gt; nf;
	PolySemi(const Poly &amp;f) : F(f), G(M), conv(M) {}
	void set(Z v) {
		G[now] = v;
		conv[now] += G[now] * F[0];
		now++;
	}
	Z next() { // return  (F * G)[now] - F[0] G[now]
		int len = now &amp; -now, l = now - len;
		if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else {
			Poly a = G.cut(len, l).ntt(len * 2), &amp;b = nf[len];
			if (l == 0) {
				b = F.cut(len * 2).ntt(len * 2);
				conv.redeg(now * 2);
				G.redeg(now * 2);
			}
			for (int i = 0; i &lt; len * 2; i++)
				a[i] *= b[i];
			a.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += a[i];
		}
		return conv[now];
	}
};

Poly semi_inv(Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = -F[0].inv();
	X.set(-iv0);
	for (int i = 1; i &lt; m; i++) {
		X.set(iv0 * X.next());
	}
	return X.G.redeg(m);
}

Poly semi_div(Poly H, Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = F[0].inv();
	X.set(iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly semi_exp(Poly F, int m) {
	for (int i = 0; i &lt; F.size(); i++)
		F[i] *= i;
	PolySemi X(F);
	X.set(1);
	for (int i = 1; i &lt; m; i++)
		X.set(iv[i] * X.next());
	return X.G.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-semi.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |       0 |      - |        inf
                      INV |       1 |     0.001 |     900 |    inf |  1111111.1
                      DIV |       1 |     0.001 |     900 |    inf |  1111111.1
                      EXP |       1 |     0.001 |     600 |    inf |  1666666.7
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.001 |     350 |  7.000 |  2857142.9
                      DIV |       2 |     0.001 |     650 | 13.000 |  1538461.5
                      EXP |       2 |     0.001 |     550 | 11.000 |  1818181.8
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                      INV |      64 |     0.006 |      93 |  8.571 | 10666666.7
                      DIV |      64 |     0.007 |     109 | 10.000 |  9142857.1
                      EXP |      64 |     0.007 |     103 |  9.429 |  9696969.7
                 NTT 1E * |     512 |     0.007 |      13 |      - | 75294117.6
                      INV |     512 |     0.096 |     186 | 14.044 |  5361144.3
                      DIV |     512 |     0.096 |     186 | 14.059 |  5355592.5
                      EXP |     512 |     0.096 |     187 | 14.118 |  5333222.2
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59274695.4
                      INV |    4096 |     1.211 |     295 | 17.529 |  3381429.5
                      DIV |    4096 |     1.222 |     298 | 17.679 |  3352919.3
                      EXP |    4096 |     1.229 |     300 | 17.790 |  3331920.6
                 NTT 1E * |   16384 |     0.319 |      19 |      - | 51327516.8
                      INV |   16384 |     6.271 |     382 | 19.645 |  2612699.0
                      DIV |   16384 |     6.280 |     383 | 19.674 |  2608913.0
                      EXP |   16384 |     6.303 |     384 | 19.745 |  2599475.1
                 NTT 1E * |   32768 |     0.687 |      20 |      - | 47668647.0
                      INV |   32768 |    14.059 |     429 | 20.453 |  2330675.0
                      DIV |   32768 |    14.146 |     431 | 20.579 |  2316341.2
                      EXP |   32768 |    14.213 |     433 | 20.676 |  2305487.0
                 NTT 1E * |   65536 |     1.451 |      22 |      - | 45177737.1
                      INV |   65536 |    31.464 |     480 | 21.690 |  2082878.4
                      DIV |   65536 |    31.652 |     482 | 21.820 |  2070487.1
                      EXP |   65536 |    31.663 |     483 | 21.827 |  2069826.6
                 NTT 1E * |  131072 |     3.081 |      23 |      - | 42544047.9
                      INV |  131072 |    70.361 |     536 | 22.838 |  1862862.5
                      DIV |  131072 |    70.322 |     536 | 22.825 |  1863885.1
                      EXP |  131072 |    72.080 |     549 | 23.396 |  1818427.4
                 NTT 1E * |  262144 |     6.553 |      24 |      - | 40005402.3
                      INV |  262144 |   158.453 |     604 | 24.181 |  1654398.3
                      DIV |  262144 |   158.686 |     605 | 24.217 |  1651968.0
                      EXP |  262144 |   157.647 |     601 | 24.058 |  1662857.9
                 NTT 1E * |  524288 |    13.827 |      26 |      - | 37918679.0
                      INV |  524288 |   348.561 |     664 | 25.209 |  1504152.0
                      DIV |  524288 |   350.318 |     668 | 25.336 |  1496604.5
                      EXP |  524288 |   349.802 |     667 | 25.299 |  1498813.9
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt半在线卷积卡常"><a class="header" href="#ntt半在线卷积卡常">NTT・半在线卷积・卡常</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

using pii = std::pair&lt;int, int&gt;;

struct PolySemi {
	int now = 0;
	enum : int { M = 32, B = 16 };
	const Poly &amp;F;
	Poly G, conv;
	std::map&lt;pii, Poly&gt; nf, nr;
	V&lt;int&gt; U;
	PolySemi(const Poly &amp;f) : F(f), G(M), conv(M), U(32, -1) {}
	Poly &amp;getNf(pii p) {
		auto &amp;u = nf[p];
		if (u.empty())
			u = F.cut(p.first, p.second).ntt(p.first);
		return u;
	}
	Poly &amp;getNr(pii p) {
		auto &amp;u = nr[p];
		if (u.empty())
			u = G.cut(p.first, p.second).ntt(p.first * 2);
		return u;
	}
	void set(Z v) {
		G[now] = v;
		conv[now] += G[now] * F[0];
		now++;
	}
	Z next() { // return sum{i in [0, now)} F[i] G[now - i]
		int len = now &amp; -now;
		if (len == now) {
			conv.resize(now * 2);
			G.redeg(now * 2);
		}
		if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else {
			int u = std::__lg(len / M) / std::__lg(B);
			int t = ++U[u] % (B - 1);
			len = (1 &lt;&lt; (u * std::__lg(B))) * M;
			int l = now - len;
			Poly s(len * 2);
			for (int i = 0; i &lt;= t; i++) {
				Poly &amp;a = getNr({len, l - i * len});
				Poly &amp;b = getNf({len * 2, len * i});
				for (int j = 0; j &lt; len * 2; j++)
					s[j] += a[j] * b[j];
			}
			s.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += s[i];
		}
		return conv[now];
	}
};

Poly semi_inv(Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = -F[0].inv();
	X.set(-iv0);
	for (int i = 1; i &lt; m; i++) {
		X.set(iv0 * X.next());
	}
	return X.G.redeg(m);
}

Poly semi_div(Poly H, Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = F[0].inv();
	X.set(iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly semi_exp(Poly F, int m) {
	for (int i = 0; i &lt; F.size(); i++)
		F[i] *= i;
	PolySemi X(F);
	X.set(1);
	for (int i = 1; i &lt; m; i++)
		X.set(iv[i] * X.next());
	return X.G.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-semi.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.001 |    1000 | 10.000 |  1000000.0
                      DIV |       1 |     0.001 |    1200 | 12.000 |   833333.3
                      EXP |       1 |     0.001 |    1000 | 10.000 |  1000000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.001 |     500 | 10.000 |  2000000.0
                      DIV |       2 |     0.001 |     450 |  9.000 |  2222222.2
                      EXP |       2 |     0.000 |     200 |  4.000 |  5000000.0
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                      INV |      64 |     0.010 |     150 | 13.714 |  6666666.7
                      DIV |      64 |     0.009 |     139 | 12.714 |  7191011.2
                      EXP |      64 |     0.007 |     104 |  9.571 |  9552238.8
                 NTT 1E * |     512 |     0.006 |      12 |      - | 82580645.2
                      INV |     512 |     0.081 |     158 | 13.113 |  6297585.5
                      DIV |     512 |     0.083 |     162 | 13.420 |  6153698.2
                      EXP |     512 |     0.087 |     169 | 14.000 |  5898481.6
                 NTT 1E * |    4096 |     0.062 |      15 |      - | 66277244.7
                      INV |    4096 |     0.981 |     239 | 15.874 |  4175258.9
                      DIV |    4096 |     0.964 |     235 | 15.594 |  4250210.4
                      EXP |    4096 |     0.975 |     237 | 15.773 |  4201814.3
                 NTT 1E * |   16384 |     0.290 |      17 |      - | 56593150.4
                      INV |   16384 |     4.935 |     301 | 17.046 |  3319968.9
                      DIV |   16384 |     4.953 |     302 | 17.110 |  3307635.8
                      EXP |   16384 |     5.028 |     306 | 17.368 |  3258494.4
                 NTT 1E * |   32768 |     0.616 |      18 |      - | 53167962.3
                      INV |   32768 |    10.815 |     330 | 17.549 |  3029728.9
                      DIV |   32768 |    10.817 |     330 | 17.551 |  3029308.5
                      EXP |   32768 |    10.892 |     332 | 17.673 |  3008504.3
                 NTT 1E * |   65536 |     1.314 |      20 |      - | 49870522.0
                      INV |   65536 |    22.858 |     348 | 17.394 |  2867092.5
                      DIV |   65536 |    23.018 |     351 | 17.516 |  2847162.7
                      EXP |   65536 |    22.981 |     350 | 17.487 |  2851808.8
                 NTT 1E * |  131072 |     2.797 |      21 |      - | 46864167.5
                      INV |  131072 |    49.338 |     376 | 17.641 |  2656610.1
                      DIV |  131072 |    49.393 |     376 | 17.660 |  2653673.4
                      EXP |  131072 |    49.557 |     378 | 17.719 |  2644848.6
                 NTT 1E * |  262144 |     5.918 |      22 |      - | 44293770.6
                      INV |  262144 |   114.331 |     436 | 19.318 |  2292859.5
                      DIV |  262144 |   114.652 |     437 | 19.372 |  2286425.8
                      EXP |  262144 |   114.956 |     438 | 19.424 |  2280389.2
                 NTT 1E * |  524288 |    12.545 |      23 |      - | 41793186.4
                      INV |  524288 |   247.420 |     471 | 19.723 |  2119017.4
                      DIV |  524288 |   247.814 |     472 | 19.754 |  2115649.2
                      EXP |  524288 |   247.818 |     472 | 19.755 |  2115617.6
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt全在线卷积"><a class="header" href="#ntt全在线卷积">NTT・全在线卷积</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

using pii = std::pair&lt;int, int&gt;;

struct PolyRelax {
	int now = 0;
	enum : int { M0 = 1024, M = 32 };
	Poly F, G, conv;
	std::map&lt;int, Poly&gt; nf, ng;

	PolyRelax() : F(M0), G(M0), conv(M0) {}

	Poly &amp;getNf(int len) {
		auto &amp;u = nf[len];
		if (u.empty())
			u = F.cut(len).ntt(len);
		return u;
	}

	Poly &amp;getNg(int len) {
		auto &amp;u = ng[len];
		if (u.empty())
			u = G.cut(len).ntt(len);
		return u;
	}

	void set(Z v1, Z v2) {
		F[now] = v1, G[now] = v2;
		conv[now] += G[now] * F[0];
		if (now != 0)
			conv[now] += F[now] * G[0];
		now++;
	}

	Z next() { // return (F * G)[now] - F[0] G[now] - F[now] G[0]
		int len = now &amp; -now, l = now - len;
		if (now &lt; M0) {
			for (int j = (now &amp; -M0) + 1; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else if (len == now) {
			conv.redeg(len * 2);
			F.redeg(len * 2);
			G.redeg(len * 2);
			Poly a = getNg(len), &amp;b = getNf(len);
			for (int i = 0; i &lt; len; i++)
				a[i] *= b[i];
			a.intt(len);
			for (int i = len; i &lt; len * 2; i++)
				conv[i] += a[i - len] - conv[i - len];
		} else if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j) {
				conv[now] += G[j] * F[now - j] + F[j] * G[now - j];
			}
		} else {
			Poly a = G.cut(len, l), &amp;b = getNf(len * 2);
			Poly c = F.cut(len, l), &amp;d = getNg(len * 2);
			a.ntt(len * 2), c.ntt(len * 2);
			for (int i = 0; i &lt; len * 2; ++i)
				a[i] = a[i] * b[i] + c[i] * d[i];
			a.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += a[i];
		}
		return conv[now];
	}
};

Poly relax_inv(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = -F[0].inv();
	X.set(F[0], -iv0);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv0 * (X.next() - F[i] * iv0));
	return X.G.redeg(m);
}

Poly relax_div(Poly H, Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = F[0].inv();
	X.set(F[0], iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly relax_exp(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	for (int i = 0; i &lt; F.deg(); i++)
		F[i] *= i;
	X.set(F[0], 1);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv[i] * (X.next() + F[i]));
	return X.G.redeg(m);
}

Poly relax_sqrt(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = 1; // F[0].sqrt()
	X.set(iv0, iv0);
	iv0 = (iv0 * 2).inv();
	for (int i = 1; i &lt; m; i++) {
		Z t = (F[i] - X.next()) * iv0;
		X.set(t, t);
	}
	return X.F.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-relax.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.003 |    2700 | 27.000 |   370370.4
                      DIV |       1 |     0.004 |    3600 | 36.000 |   277777.8
                      EXP |       1 |     0.003 |    2800 | 28.000 |   357142.9
                     SQRT |       1 |     0.002 |    2400 | 24.000 |   416666.7
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.003 |    1650 | 33.000 |   606060.6
                      DIV |       2 |     0.003 |    1650 | 33.000 |   606060.6
                      EXP |       2 |     0.003 |    1250 | 25.000 |   800000.0
                     SQRT |       2 |     0.004 |    1950 | 39.000 |   512820.5
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                      INV |      64 |     0.008 |     125 | 11.430 |  7999000.1
                      DIV |      64 |     0.008 |     121 | 11.143 |  8205128.2
                      EXP |      64 |     0.009 |     139 | 12.714 |  7191011.2
                     SQRT |      64 |     0.008 |     120 | 11.000 |  8311688.3
                 NTT 1E * |     512 |     0.007 |      13 |      - | 76417910.4
                      INV |     512 |     0.270 |     527 | 40.314 |  1895566.2
                      DIV |     512 |     0.255 |     498 | 38.120 |  2004659.3
                      EXP |     512 |     0.273 |     532 | 40.672 |  1878864.6
                     SQRT |     512 |     0.256 |     500 | 38.210 |  1999960.9
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59361458.5
                      INV |    4096 |     2.235 |     545 | 32.384 |  1833040.3
                      DIV |    4096 |     2.216 |     540 | 32.110 |  1848676.6
                      EXP |    4096 |     2.250 |     549 | 32.613 |  1820170.2
                     SQRT |    4096 |     2.180 |     532 | 31.593 |  1878951.7
                 NTT 1E * |   16384 |     0.319 |      19 |      - | 51375801.6
                      INV |   16384 |     8.341 |     509 | 26.155 |  1964309.1
                      DIV |   16384 |     8.271 |     504 | 25.937 |  1980790.5
                      EXP |   16384 |     8.336 |     508 | 26.139 |  1965463.8
                     SQRT |   16384 |     8.248 |     503 | 25.862 |  1986506.7
                 NTT 1E * |   32768 |     0.682 |      20 |      - | 48024950.5
                      INV |   32768 |    17.892 |     546 | 26.223 |  1831431.7
                      DIV |   32768 |    17.833 |     544 | 26.137 |  1837449.7
                      EXP |   32768 |    17.944 |     547 | 26.298 |  1826165.0
                     SQRT |   32768 |    17.907 |     546 | 26.245 |  1829877.1
                 NTT 1E * |   65536 |     1.452 |      22 |      - | 45143536.1
                      INV |   65536 |    39.514 |     602 | 27.219 |  1658547.5
                      DIV |   65536 |    39.488 |     602 | 27.201 |  1659643.8
                      EXP |   65536 |    39.977 |     610 | 27.538 |  1639326.2
                     SQRT |   65536 |    39.841 |     607 | 27.444 |  1644922.2
                 NTT 1E * |  131072 |     3.086 |      23 |      - | 42470984.9
                      INV |  131072 |    87.643 |     668 | 28.399 |  1495519.3
                      DIV |  131072 |    88.785 |     677 | 28.769 |  1476277.8
                      EXP |  131072 |    87.902 |     670 | 28.483 |  1491116.1
                     SQRT |  131072 |    87.769 |     669 | 28.440 |  1493374.0
                 NTT 1E * |  262144 |     6.547 |      24 |      - | 40039009.0
                      INV |  262144 |   199.121 |     759 | 30.413 |  1316508.8
                      DIV |  262144 |   199.385 |     760 | 30.453 |  1314759.6
                      EXP |  262144 |   198.004 |     755 | 30.243 |  1323931.0
                     SQRT |  262144 |   199.059 |     759 | 30.404 |  1316917.5
                 NTT 1E * |  524288 |    13.839 |      26 |      - | 37884700.6
                      INV |  524288 |   439.713 |     838 | 31.773 |  1192340.5
                      DIV |  524288 |   441.659 |     842 | 31.914 |  1187087.9
                      EXP |  524288 |   441.688 |     842 | 31.916 |  1187010.8
                     SQRT |  524288 |   440.266 |     839 | 31.813 |  1190843.1
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并查集"><a class="header" href="#并查集">并查集</a></h1>
<pre><code class="language-cpp">// @description 朴素并查集

struct DSU {
	V&lt;int&gt; fa;
	DSU(int n) : fa(n) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		fa[x] = y;
	}
};
</code></pre>
<h2 id="测试例题-20"><a class="header" href="#测试例题-20">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/unionfind">yosupo Unionfind</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="带权并查集"><a class="header" href="#带权并查集">带权并查集</a></h1>
<pre><code class="language-cpp">// @description 带权并查集

struct DSU {
	V&lt;int&gt; fa, sz;
	DSU(int n) : fa(n), sz(n, 1) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	int size(int x) {
		return sz[find(x)];
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		if (x == y)
			return;
		if (sz[x] &gt; sz[y])
			std::swap(x, y);
		sz[y] += sz[x], fa[x] = y;
		sz[x] = 0;
	}
};
</code></pre>
<h2 id="测试例题-21"><a class="header" href="#测试例题-21">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1536">P1536 村村通</a>（也不是不能用）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="st"><a class="header" href="#st">ST</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description Sparse Table

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	void init(auto first, auto last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = max(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) const {
		int s = std::__lg(r - l + 1);
		return max(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};
</code></pre>
<h2 id="测试例题-22"><a class="header" href="#测试例题-22">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3865">P3865 ST 表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="滑动窗口"><a class="header" href="#滑动窗口">滑动窗口</a></h1>
<pre><code class="language-cpp">// @description 滑动窗口

template &lt;class T&gt;
auto sliding(const V&lt;T&gt; &amp;v, int k) {
	int l = 0, r = -1, n = v.size();
	V&lt;int&gt; q(n), ret(n);
	for (int i = 0; i &lt; n; i++) {
		while (l &lt;= r &amp;&amp; i - k &gt;= q[l])
			l++;
		while (l &lt;= r &amp;&amp; v[i] &lt; v[q[r]])
			r--;
		q[++r] = i;
		ret[i] = q[l];
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-23"><a class="header" href="#测试例题-23">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树状数组"><a class="header" href="#树状数组">树状数组</a></h1>
<pre><code class="language-cpp">// @description 树状数组

template &lt;class T&gt;
struct fwtree {
	int n;
	V&lt;T&gt; v;
	// 1 ~ N - 1
	fwtree(int a = 0) : n(a), v(n) {}
	void add(int i, T x) {
		for (; i &lt; n; i += i &amp; -i) {
			v[i] += x;
		}
	}
	void build(auto first, auto last) {
		std::copy(first, last, v.begin());
		for (int i = 1; i &lt; n; i++) {
			int j = i + (i &amp; -i);
			if (j &lt; n) {
				v[j] += v[i];
			}
		}
	}
	T sum(int i) const {
		assert(i &lt; n);
		T sum = T();
		for (; i &gt; 0; i -= i &amp; -i)
			sum += v[i];
		return sum;
	}
	T sum(int l, int r) const {
		assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt; n);
		return sum(r) - sum(l - 1);
	}
};
</code></pre>
<h2 id="测试例题-24"><a class="header" href="#测试例题-24">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/point_add_range_sum">yosupo Point Add Range Sum</a></li>
<li><a href="https://loj.ac/p/130">LOJ130 树状数组 1 ：单点修改，区间查询</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="堆"><a class="header" href="#堆">堆</a></h1>
<pre><code class="language-cpp">// @description 小根堆

template &lt;class T&gt;
struct Heap {
	V&lt;T&gt; v;
	Heap() : v(1) {}
	bool update(int p) {
		bool f = v[p] &lt; v[p / 2];
		if (f) {
			std::swap(v[p], v[p / 2]);
		}
		return !f;
	}
	T top() {
		return v[1];
	}
	void put(T x) {
		v.push_back(x);
		int p = v.size() - 1;
		while (p &gt; 1) {
			if (update(p))
				return;
			p /= 2;
		}
	}
	void pop() {
		v[1] = v.back();
		v.pop_back();
		int sz = v.size(), p = 2;
		while (p &lt; sz) {
			if (p + 1 &lt; sz &amp;&amp; v[p + 1] &lt; v[p])
				p++;
			if (update(p))
				return;
			p *= 2;
		}
	}
};
</code></pre>
<h2 id="测试例题-25"><a class="header" href="#测试例题-25">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3378">P3378 堆</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线段树"><a class="header" href="#线段树">线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树

template &lt;class Val&gt;
struct SegmentTree {
	const int N;
	V&lt;Val&gt; val;
	// 0 ~ N - 1
	SegmentTree(int n) : N(2 &lt;&lt; std::__lg(n)), val(N * 2) {
		assert(n &gt; 0);
	}
	void build(auto first, auto last) {
		std::copy(first, last, val.begin() + N);
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
	void modify(int i, Val x) {
		modify(i, x, 1, 0, N);
	}
	Val query(int l, int r) {
		return query(l, r + 1, 1, 0, N);
	}
#define lson p * 2
#define rson p * 2 + 1
  private:
	void pull(int p) {
		val[p] = val[lson] + val[rson];
	}
	void modify(int i, Val x, int p, int L, int R) {
		if (R - L == 1) {
			val[p] += x;
		} else {
			int M = (L + R) / 2;
			if (i &lt; M)
				modify(i, x, lson, L, M);
			if (i &gt;= M)
				modify(i, x, rson, M, R);
			pull(p);
		}
	}
	Val query(int l, int r, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			return val[p];
		} else {
			int M = (L + R) / 2;
			Val ret = Val();
			if (l &lt; M)
				ret = ret + query(l, r, lson, L, M);
			if (r &gt; M)
				ret = ret + query(l, r, rson, M, R);
			return ret;
		}
	}
#undef lson
#undef rson
};
</code></pre>
<h2 id="测试例题-26"><a class="header" href="#测试例题-26">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="懒标记线段树"><a class="header" href="#懒标记线段树">懒标记线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树(懒标记)

template &lt;class Val, class Tag&gt;
struct LazySegmentTree {
	const int N;
	V&lt;Val&gt; val;
	V&lt;Tag&gt; tag;
	// 0 ~ N - 1
	LazySegmentTree(int n) : N(2 &lt;&lt; std::__lg(n)), val(N * 2), tag(N * 2) {
		assert(n &gt; 0);
	}
	void build(auto first, auto last) {
		std::copy(first, last, val.begin() + N);
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
	void modify(int l, int r, Tag t) {
		modify(l, r, t, 1, 0, N);
	}
	Val query(int l, int r) {
		return query(l, r, 1, 0, N);
	}
#define lson p * 2
#define rson p * 2 + 1
  private:
	void pull(int p) {
		val[p] = val[lson] + val[rson];
	}
	void push(int p) {
		Tag &amp;tp = tag[p];
		if (tp.flag) {
			val[lson].apply(tp), tag[lson].apply(tp);
			val[rson].apply(tp), tag[rson].apply(tp);
			tp.flag = false;
		}
	}
	void modify(int l, int r, Tag t, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			val[p].apply(t);
			tag[p].apply(t);
		} else {
			int M = (L + R) / 2;
			push(p);
			if (l &lt; M)
				modify(l, r, t, lson, L, M);
			if (r &gt; M)
				modify(l, r, t, rson, M, R);
			pull(p);
		}
	}
	Val query(int l, int r, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			return val[p];
		} else {
			int M = (L + R) / 2;
			Val ret = Val();
			push(p);
			if (l &lt; M)
				ret = ret + query(l, r, lson, L, M);
			if (r &gt; M)
				ret = ret + query(l, r, rson, M, R);
			return ret;
		}
	}
#undef lson
#undef rson
};
</code></pre>
<h2 id="测试例题-27"><a class="header" href="#测试例题-27">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3372">P3372 线段树 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算几何"><a class="header" href="#计算几何">计算几何</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="点"><a class="header" href="#点">点</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-多边形"><a class="header" href="#f-多边形">F 多边形</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}

using VP = V&lt;P&gt;;

template &lt;class RET&gt;
RET ring_act(const auto &amp;v, auto &amp;&amp;func) {
	RET ret{};
	for (int i = 0; i &lt; v.size() - 1; i++)
		ret += func(v[i], v[i + 1]);
	if (v.size() &gt;= 2)
		ret += func(v.back(), v.front());
	return ret;
}

D area(const VP &amp;v) {
	return ring_act&lt;D&gt;(v, crs) / 2;
}

// 必须排序且去重！
VP convex_down(const VP &amp;ps) {
	assert(ps.size() &gt;= 2);
	VP dw;
	for (P d : ps) {
		for (int n = dw.size(); n &gt; 1; n--, dw.pop_back()) {
			if (ccw(dw[n - 2], dw[n - 1], d) == 1)
				break;
		}
		dw.push_back(d);
	}
	return dw;
}

VP convex(VP ps) {
	std::sort(ps.begin(), ps.end());
	ps.erase(std::unique(ps.begin(), ps.end()), ps.end());
	if (ps.size() &lt;= 1)
		return ps;
	VP dw = convex_down(ps);
	std::reverse(ps.begin(), ps.end());
	VP up = convex_down(ps);
	dw.insert(dw.begin(), up.begin() + 1, up.end() - 1);
	return dw;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-冲突判定"><a class="header" href="#f-冲突判定">F 冲突判定</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}

P proj(const L &amp;l, const P &amp;p) {
	P v = l.vec();
	return l.s + v * dot(v, p - l.s) / v.norm();
}

bool insSL(const L &amp;s, const L &amp;l) {
	int a = ccw(l, s.s), b = ccw(l, s.t);
	return (a % 2 == 0 || b % 2 == 0 || a != b);
}

bool insSS(const L &amp;s, const L &amp;t) {
	int a = ccw(s, t.s), b = ccw(s, t.t);
	int c = ccw(t, s.s), d = ccw(t, s.t);
	return a * b &lt;= 0 &amp;&amp; c * d &lt;= 0;
}

D distLP(const L &amp;l, const P &amp;p) {
	return std::abs(crs(l.vec(), p - l.s)) / l.abs();
}

D distSP(const L &amp;s, const P &amp;p) {
	P q = proj(s, p);
	if (ccw(s, q) == 0)
		return (p - q).abs();
	else
		return std::min((s.s - p).abs(), (s.t - p).abs());
}

D distSS(const L &amp;s, const L &amp;t) {
	if (insSS(s, t))
		return 0;
	return std::min({
		distSP(s, t.s),
		distSP(s, t.t),
		distSP(t, s.s),
		distSP(t, s.t),
	});
}

int crossLL(const L &amp;l, const L &amp;m, P &amp;r) {
	P lv = l.vec(), mv = m.vec();
	D cr1 = crs(lv, mv), cr2 = crs(lv, l.t - m.s);
	if (sgn_crs(lv, mv) == 0) {
		r = l.s;
		if (sgn_crs(lv, l.t - m.s))
			return 0;
		return -1;
	}
	r = m.s + mv * cr2 / cr1;
	return 1;
}

int crossSS(L l, L m, P &amp;r) {
	int u = crossLL(l, m, r);
	if (u == 0)
		return 0;
	if (u == -1) {
		r = std::max(std::min(l.s, l.t), std::min(m.s, m.t));
		P q = std::min(std::max(l.s, l.t), std::max(m.s, m.t));
		return (q &lt; r) ? 0 : (q == r ? 1 : -1);
	}
	if (ccw(l, r) == 0 &amp;&amp; ccw(m, r) == 0)
		return 1;
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-点--线段"><a class="header" href="#i-点--线段">I 点 &amp; 线段</a></h1>
<pre><code class="language-cpp">// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	ll x{}, y{};
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const ll &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const ll &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return P{-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, ll, *);
	OPERATOR(P, ll, /);
	ll norm() const {
		return x * x + y * y;
	}
	double abs() const {
		return std::sqrt(norm());
	}
#undef T
};

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return std::tie(l.x, l.y) &lt; std::tie(r.x, r.y);
}

inline bool operator==(const P &amp;l, const P &amp;r) {
	return l.x == r.x &amp;&amp; l.y == r.y;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	ll A, B, C;
	void reduce() {
		ll g = std::gcd(std::abs(A), std::abs(B));
		g = std::gcd(g, std::abs(C));
		A /= g, B /= g, C /= g;
		if (A &lt; 0 || (A == 0 &amp;&amp; B &lt; 0)) {
			A = -A, B = -B, C = -C;
		}
	}
	ll eval(const P &amp;p) const {
		return A * p.x + B * p.y + C;
	}
	bool on(const P &amp;p) const {
		return eval(p) == 0;
	}
	static std::optional&lt;L&gt; from(P a, P d) {
		if (d == P{0, 0})
			return std::nullopt;
		L r = {d.y, -d.x, d.x * a.y - d.y * a.x};
		r.reduce();
		return r;
	}
	static std::optional&lt;L&gt; p2(P a, P b) {
		return from(a, b - a);
	}
	static std::optional&lt;L&gt; mid(P a, P b) {
		auto [dx, dy] = b - a;
		return from((a + b) / 2, {dy, -dx});
	}
};

bool operator&lt;(const L &amp;l, const L &amp;r) {
	return std::tie(l.A, l.B, l.C) &lt; std::tie(r.A, r.B, r.C);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const L &amp;l) {
	return os &lt;&lt; &quot;L(&quot; &lt;&lt; l.A &lt;&lt; &quot;, &quot; &lt;&lt; l.B &lt;&lt; &quot;, &quot; &lt;&lt; l.C &lt;&lt; &quot;)&quot;;
}

struct S {
	P s, t;
	S(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	double abs() const {
		return vec().abs();
	}
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
