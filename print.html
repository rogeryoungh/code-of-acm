<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Roger Young 的板子</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<style>
  main p>code {
    color: #f14668 !important;
    background: unset !important;
  }

  main pre>code {
    tab-size: 2;
  }

  main p a,
  main ul a {
    color: #0099ff !important;
  }

  .katex-display {
    overflow: auto hidden;
  }
</style>

<link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.css">
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.js"></script>
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/contrib/auto-render.min.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true },
        { left: "\\begin{equation}", right: "\\end{equation}", display: true },
      ],
      macros: {
        "\\RR": "\\mathbb{R}",
        "\\NN": "\\mathbb{N}",
        "\\QQ": "\\mathbb{Q}",
        "\\ZZ": "\\mathbb{Z}",
        "\\CC": "\\mathbb{C}",
        "\\ee": "\\mathrm{e}",
        "\\dd": "\\mathrm{d}",
        "\\eps": "\\varepsilon",
      },
      globalGroup: true,
      throwOnError: false
    });
  });
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/mdbook-admonish.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="basic/index.html"><strong aria-hidden="true">1.</strong> 基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/vec2.html"><strong aria-hidden="true">1.1.</strong> 二维数组</a></li><li class="chapter-item expanded "><a href="basic/fastio.html"><strong aria-hidden="true">1.2.</strong> 快读</a></li><li class="chapter-item expanded "><a href="basic/qpow.html"><strong aria-hidden="true">1.3.</strong> 快速幂</a></li><li class="chapter-item expanded "><a href="basic/lower-upper.html"><strong aria-hidden="true">1.4.</strong> 二分</a></li></ol></li><li class="chapter-item expanded "><a href="math/index.html"><strong aria-hidden="true">2.</strong> 数学</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="math/matrix/index.html"><strong aria-hidden="true">2.1.</strong> 矩阵</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/matrix/matrix.html"><strong aria-hidden="true">2.1.1.</strong> 矩阵</a></li><li class="chapter-item "><a href="math/matrix/qmatrix.html"><strong aria-hidden="true">2.1.2.</strong> 矩阵快速幂</a></li><li class="chapter-item "><a href="math/matrix/gauss-f64.html"><strong aria-hidden="true">2.1.3.</strong> 高斯消元・f64</a></li><li class="chapter-item "><a href="math/matrix/gauss-modint.html"><strong aria-hidden="true">2.1.4.</strong> 高斯消元・modint</a></li></ol></li><li class="chapter-item expanded "><a href="math/exgcd.html"><strong aria-hidden="true">2.2.</strong> 扩展欧几里得・EXGCD</a></li><li class="chapter-item expanded "><a href="math/sieve/euler.html"><strong aria-hidden="true">2.3.</strong> 筛法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/sieve/euler.html"><strong aria-hidden="true">2.3.1.</strong> Euler 筛・朴素</a></li><li class="chapter-item "><a href="math/sieve/euler-lpf.html"><strong aria-hidden="true">2.3.2.</strong> Euler 筛・LPF</a></li><li class="chapter-item "><a href="math/sieve/eratosthenes.html"><strong aria-hidden="true">2.3.3.</strong> Eratosthenes・朴素</a></li><li class="chapter-item "><a href="math/sieve/eratosthenes-fast.html"><strong aria-hidden="true">2.3.4.</strong> Eratosthenes・卡常</a></li></ol></li><li class="chapter-item expanded "><a href="math/factor/sieve.html"><strong aria-hidden="true">2.4.</strong> 质因分解</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/factor/bruce-force.html"><strong aria-hidden="true">2.4.1.</strong> 暴力</a></li><li class="chapter-item "><a href="math/factor/sieve.html"><strong aria-hidden="true">2.4.2.</strong> 筛优化</a></li><li class="chapter-item "><a href="math/factor/lpf.html"><strong aria-hidden="true">2.4.3.</strong> LPF 优化</a></li><li class="chapter-item "><a href="math/factor/pollard-rho.html"><strong aria-hidden="true">2.4.4.</strong> Pollard Rho</a></li></ol></li><li class="chapter-item expanded "><a href="math/crt.html"><strong aria-hidden="true">2.5.</strong> 中国剩余定理・CRT</a></li><li class="chapter-item expanded "><a href="math/excrt.html"><strong aria-hidden="true">2.6.</strong> 扩展中国剩余定理</a></li><li class="chapter-item expanded "><a href="math/miller-rabbin.html"><strong aria-hidden="true">2.7.</strong> 素性测试・Miller Rabbin</a></li><li class="chapter-item expanded "><a href="math/floor-sum.html"><strong aria-hidden="true">2.8.</strong> Floor Sum・类欧</a></li><li class="chapter-item expanded "><a href="math/cipolla.html"><strong aria-hidden="true">2.9.</strong> 二次剩余・Cipolla</a></li><li class="chapter-item expanded "><a href="math/constant/index.html"><strong aria-hidden="true">2.10.</strong> 数学常数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/constant/stirling.html"><strong aria-hidden="true">2.10.1.</strong> 斯特林数</a></li><li class="chapter-item "><a href="math/constant/euler-phi.html"><strong aria-hidden="true">2.10.2.</strong> Euler $\varphi(n)$</a></li><li class="chapter-item "><a href="math/constant/powers.html"><strong aria-hidden="true">2.10.3.</strong> 幂表</a></li><li class="chapter-item "><a href="math/constant/tetration-mod.html"><strong aria-hidden="true">2.10.4.</strong> 指数塔</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="math-modint/index.html"><strong aria-hidden="true">3.</strong> 数学・Modint</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="math-modint/basic.html"><strong aria-hidden="true">3.1.</strong> 基础类</a></li><li class="chapter-item expanded "><a href="math-modint/runtime.html"><strong aria-hidden="true">3.2.</strong> Runtime Montgomery Modint</a></li><li class="chapter-item expanded "><a href="math-modint/pre-all.html"><strong aria-hidden="true">3.3.</strong> 预处理常数</a></li><li class="chapter-item expanded "><a href="math-modint/interpolation-lagrange.html"><strong aria-hidden="true">3.4.</strong> Lagrange 插值</a></li></ol></li><li class="chapter-item expanded "><a href="math-P/index.html"><strong aria-hidden="true">4.</strong> 数学・P</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="math-P/qpow.html"><strong aria-hidden="true">4.1.</strong> 快速幂</a></li><li class="chapter-item expanded "><a href="math-P/pre.html"><strong aria-hidden="true">4.2.</strong> 预处理常数・单独</a></li><li class="chapter-item expanded "><a href="math-P/pre-all.html"><strong aria-hidden="true">4.3.</strong> 预处理常数・全部</a></li><li class="chapter-item expanded "><a href="math-P/interpolation-lagrange.html"><strong aria-hidden="true">4.4.</strong> Lagrange 插值</a></li></ol></li><li class="chapter-item expanded "><a href="string/index.html"><strong aria-hidden="true">5.</strong> 字符串</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="string/kmp.html"><strong aria-hidden="true">5.1.</strong> KMP</a></li><li class="chapter-item expanded "><a href="string/z-algorithm.html"><strong aria-hidden="true">5.2.</strong> Z 函数</a></li><li class="chapter-item expanded "><a href="string/sa-doubling.html"><strong aria-hidden="true">5.3.</strong> 后缀数组</a></li><li class="chapter-item expanded "><a href="string/manacher.html"><strong aria-hidden="true">5.4.</strong> Manacher</a></li></ol></li><li class="chapter-item expanded "><a href="graph/index.html"><strong aria-hidden="true">6.</strong> 图论</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph/shortest-path/index.html"><strong aria-hidden="true">6.1.</strong> 最短路</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/shortest-path/bellman-ford-vec.html"><strong aria-hidden="true">6.1.1.</strong> Bellman Ford・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/queue-bellman-ford-vec.html"><strong aria-hidden="true">6.1.2.</strong> 队列优化 Bellman Ford・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/dijkstra-vec.html"><strong aria-hidden="true">6.1.3.</strong> Dijkstra・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/floyd-adj.html"><strong aria-hidden="true">6.1.4.</strong> Floyd・ADJ</a></li></ol></li><li class="chapter-item expanded "><a href="graph/lca/index.html"><strong aria-hidden="true">6.2.</strong> LCA</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/lca/binary-lifting.html"><strong aria-hidden="true">6.2.1.</strong> 倍增</a></li><li class="chapter-item "><a href="graph/lca/sparse-table.html"><strong aria-hidden="true">6.2.2.</strong> ST</a></li></ol></li><li class="chapter-item expanded "><a href="graph/scc/index.html"><strong aria-hidden="true">6.3.</strong> SCC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/scc/tarjan.html"><strong aria-hidden="true">6.3.1.</strong> Tarjan</a></li><li class="chapter-item "><a href="graph/scc/kosaraju.html"><strong aria-hidden="true">6.3.2.</strong> Kosaraju</a></li></ol></li><li class="chapter-item expanded "><a href="graph/kruskal.html"><strong aria-hidden="true">6.4.</strong> 最小生成树・kruskal</a></li><li class="chapter-item expanded "><a href="graph/hld.html"><strong aria-hidden="true">6.5.</strong> 树链剖分</a></li><li class="chapter-item expanded "><a href="graph/dinic.html"><strong aria-hidden="true">6.6.</strong> Dinic</a></li></ol></li><li class="chapter-item expanded "><a href="poly/index.html"><strong aria-hidden="true">7.</strong> 多项式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="poly/fft-mul.html"><strong aria-hidden="true">7.1.</strong> FFT 乘法</a></li><li class="chapter-item expanded "><a href="poly/ntt-mul-i32.html"><strong aria-hidden="true">7.2.</strong> NTT 乘法・i32</a></li><li class="chapter-item expanded "><a href="poly/ntt-mul-mod3.html"><strong aria-hidden="true">7.3.</strong> NTT 乘法・三模</a></li><li class="chapter-item expanded "><a href="poly/ntt-naive.html"><strong aria-hidden="true">7.4.</strong> NTT $O(n^2)$</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton.html"><strong aria-hidden="true">7.5.</strong> NTT 牛顿迭代</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton-fast.html"><strong aria-hidden="true">7.6.</strong> NTT 牛顿迭代・卡常</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton-blockwise-fast.html"><strong aria-hidden="true">7.7.</strong> NTT 牛顿迭代・分块卡常</a></li><li class="chapter-item expanded "><a href="poly/ntt-taylor-shift.html"><strong aria-hidden="true">7.8.</strong> NTT 平移</a></li><li class="chapter-item expanded "><a href="poly/ntt-eval.html"><strong aria-hidden="true">7.9.</strong> NTT 多点求值 & 快速插值</a></li><li class="chapter-item expanded "><a href="poly/ntt-chirpz.html"><strong aria-hidden="true">7.10.</strong> NTT Chirp Z 变换</a></li><li class="chapter-item expanded "><a href="poly/relax/index.html"><strong aria-hidden="true">7.11.</strong> NTT 在线卷积</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="poly/relax/ntt-semi.html"><strong aria-hidden="true">7.11.1.</strong> 半在线卷积</a></li><li class="chapter-item "><a href="poly/relax/ntt-semi-fast.html"><strong aria-hidden="true">7.11.2.</strong> 半在线卷积・卡常</a></li><li class="chapter-item "><a href="poly/relax/ntt-relax.html"><strong aria-hidden="true">7.11.3.</strong> 全在线卷积</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ds/index.html"><strong aria-hidden="true">8.</strong> 数据结构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ds/dsu.html"><strong aria-hidden="true">8.1.</strong> 并查集</a></li><li class="chapter-item expanded "><a href="ds/dsu-size.html"><strong aria-hidden="true">8.2.</strong> 带权并查集</a></li><li class="chapter-item expanded "><a href="ds/sparse-table.html"><strong aria-hidden="true">8.3.</strong> ST</a></li><li class="chapter-item expanded "><a href="ds/sliding.html"><strong aria-hidden="true">8.4.</strong> 滑动窗口</a></li><li class="chapter-item expanded "><a href="ds/fwtree.html"><strong aria-hidden="true">8.5.</strong> 树状数组</a></li><li class="chapter-item expanded "><a href="ds/heap.html"><strong aria-hidden="true">8.6.</strong> 堆</a></li><li class="chapter-item expanded "><a href="ds/segment-tree.html"><strong aria-hidden="true">8.7.</strong> 线段树</a></li><li class="chapter-item expanded "><a href="ds/lazy-segment-tree.html"><strong aria-hidden="true">8.8.</strong> 懒标记线段树</a></li></ol></li><li class="chapter-item expanded "><a href="geo/index.html"><strong aria-hidden="true">9.</strong> 计算几何</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="geo/fpoint.html"><strong aria-hidden="true">9.1.</strong> F 点 & 线段</a></li><li class="chapter-item expanded "><a href="geo/polygon.html"><strong aria-hidden="true">9.2.</strong> F 多边形</a></li><li class="chapter-item expanded "><a href="geo/intersect.html"><strong aria-hidden="true">9.3.</strong> F 冲突判定</a></li><li class="chapter-item expanded "><a href="geo/ipoint.html"><strong aria-hidden="true">9.4.</strong> I 点 & 线段</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Roger Young 的板子</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rogeryoungh/code-of-acm/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>我的初始文件。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

template &lt;class T&gt;
using V = std::vector&lt;T&gt;;
using ll = long long;

int ____ = std::cin.tie(nullptr)-&gt;sync_with_stdio(false);

// END OF HEADER | Author: Roger Young

int main() {
	int T;
	std::cin &gt;&gt; T;
	while (T--) {
		std::cout &lt;&lt; &quot;X&quot; &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二维数组"><a class="header" href="#二维数组">二维数组</a></h1>
<p>一个简单的动态二维数组，基于 <code>vector</code>。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快读"><a class="header" href="#快读">快读</a></h1>
<p>这个快读目前不能自动输出，有待以后改进。</p>
<pre><code class="language-cpp">struct FastI {
	char s[1 &lt;&lt; 20], *t = s;
	FastI() {
		fread(s, 1, sizeof(s), stdin);
	}
	template &lt;class T, bool is_int = is_integral&lt;T&gt;::value&gt;
	FastI &amp;operator&gt;&gt;(T &amp;x) {
		x = 0;
		while (!isdigit(*t))
			t++;
		while (isdigit(*t))
			x = x * 10 + *t++ - '0';
		return *this;
	}
};

struct FastO {
	char s[1 &lt;&lt; 20], *t = s;
	~FastO() {
		fwrite(s, 1, t - s, stdout);
	}
	void puts(const char *x) {
		while (*x != 0)
			*t++ = *x++;
	}
	void output(uint64_t x) {
		static char u[22];
		char *i = u + 20;
		do {
			*--i = x % 10 + '0', x /= 10;
		} while (x &gt; 0);
		puts(i);
	}
	FastO &amp;operator&lt;&lt;(uint64_t x) {
		return output(x), *this;
	}
	FastO &amp;operator&lt;&lt;(char x) {
		return *t++ = x, *this;
	}
	FastO &amp;operator&lt;&lt;(int64_t x) {
		if (x &lt; 0) {
			*--t = '-', x = -x;
		}
		return output(x), *this;
	}
	FastO &amp;operator&lt;&lt;(const char *x) {
		return puts(x), *this;
	}
};

FastI fin;
FastO fout;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速幂"><a class="header" href="#快速幂">快速幂</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题"><a class="header" href="#测试例题">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 快速幂</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二分"><a class="header" href="#二分">二分</a></h1>
<p>函数 <code>lower</code> 寻找区间 $[l, r)$ 中 <code>true -&gt; false</code> 的最后一个 <code>true</code>。</p>
<p>函数 <code>upper</code> 寻找区间 $[l, r)$ 中 <code>false -&gt; true</code> 的第一个 <code>true</code>。</p>
<p>若无答案，则返回 $r$。</p>
<pre><code class="language-cpp">// @description 二分

ll lower(ll l, ll r, auto check) { // last true
	if (l &gt;= r or not check(l))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m) ? l : r) = m;
	}
	return l;
}

ll upper(ll l, ll r, auto check) { // first true
	if (l &gt;= r or not check(r - 1))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m - 1) ? r : l) = m;
	}
	return l;
}
</code></pre>
<h2 id="测试例题-1"><a class="header" href="#测试例题-1">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1873">P1873 EKO / 砍树</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学"><a class="header" href="#数学">数学</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵"><a class="header" href="#矩阵">矩阵</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵-1"><a class="header" href="#矩阵-1">矩阵</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description 矩阵乘法

template &lt;class T&gt;
VV&lt;T&gt; operator*(const VV&lt;T&gt; &amp;lhs, const VV&lt;T&gt; &amp;rhs) {
	assert(lhs.y == rhs.x);
	VV&lt;T&gt; u(lhs.x, rhs.y);
	for (int i = 0; i &lt; lhs.x; i++) {
		for (int k = 0; k &lt; rhs.x; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.y; j++)
				u[i][j] += rhs[k][j] * t;
		}
	}
	return u;
}

template &lt;class T&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;is, VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.y == 0];
	return os;
}
</code></pre>
<h2 id="测试例题-2"><a class="header" href="#测试例题-2">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵快速幂"><a class="header" href="#矩阵快速幂">矩阵快速幂</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description 矩阵乘法

template &lt;class T&gt;
VV&lt;T&gt; operator*(const VV&lt;T&gt; &amp;lhs, const VV&lt;T&gt; &amp;rhs) {
	assert(lhs.y == rhs.x);
	VV&lt;T&gt; u(lhs.x, rhs.y);
	for (int i = 0; i &lt; lhs.x; i++) {
		for (int k = 0; k &lt; rhs.x; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.y; j++)
				u[i][j] += rhs[k][j] * t;
		}
	}
	return u;
}

template &lt;class T&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;is, VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.y == 0];
	return os;
}

// @description 矩阵快速幂

template &lt;class T&gt;
auto make_matrix_E(int n) {
	VV&lt;T&gt; ret(n, n);
	for (int i = 0; i &lt; n; i++)
		ret[i][i] = 1;
	return ret;
}

template &lt;class T&gt;
auto matrix_pow(VV&lt;T&gt; a, ll w) {
	auto ret = make_matrix_E&lt;T&gt;(a.x);
	for (; w &gt; 0; w /= 2) {
		if (w % 2 == 1)
			ret = a * ret;
		a = a * a;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-3"><a class="header" href="#测试例题-3">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高斯消元f64"><a class="header" href="#高斯消元f64">高斯消元・f64</a></h1>
<p>求解 $n$ 元方程组</p>
<p>$$
\begin{cases}
A_{1,1} x_1 + \cdots + A_{1,n} x_n &amp;= A_{1, n+1} \\
\cdots &amp;= \cdots \\
A_{n,1} x_1 + \cdots + A_{n,n} x_n &amp;= A_{n, n+1} \\
\end{cases}
$$</p>
<p>输入以 $0$-index 的矩阵 $A$ 表示。</p>
<pre><code class="language-cpp">using f64 = double;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

const f64 eps = 1E-6;

std::optional&lt;VV&lt;f64&gt;&gt; gauss(VV&lt;f64&gt; v) {
	for (int i = 0; i &lt; v.x; i++) {
		int mi = i;
		for (int j = i + 1; j &lt; v.x; j++)
			if (std::abs(v[j][i]) &gt; std::abs(v[mi][i]))
				mi = j;
		for (int j = 0; j &lt; v.y; j++)
			std::swap(v[i][j], v[mi][j]);
		if (std::abs(v[i][i]) &lt; eps)
			return std::nullopt;
		auto ivi = 1 / v[i][i];
		for (int k = v.y - 1; k &gt;= i; k--)
			v[i][k] *= ivi;
		for (int j = 0; j &lt; v.x; j++) {
			if (j != i) {
				auto tmp = v[j][i];
				for (int k = 0; k &lt; v.y; k++)
					v[j][k] -= v[i][k] * tmp;
			}
		}
	}
	return v;
}
</code></pre>
<h1 id="测试例题-4"><a class="header" href="#测试例题-4">测试例题</a></h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3389">P3389 高斯消元法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高斯消元f64-1"><a class="header" href="#高斯消元f64-1">高斯消元・f64</a></h1>
<p>求解 $n$ 元方程组</p>
<p>$$
\begin{cases}
A_{1,1} x_1 + \cdots + A_{1,n} x_n &amp;= A_{1, n+1} \\
\cdots &amp;= \cdots \\
A_{n,1} x_1 + \cdots + A_{n,n} x_n &amp;= A_{n, n+1} \\
\end{cases}
$$</p>
<p>输入以 $0$-index 的矩阵 $A$ 表示。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

std::optional&lt;VV&lt;Z&gt;&gt; gauss(VV&lt;Z&gt; v) {
	for (int i = 0; i &lt; v.x; i++) {
		int mi = i;
		for (int j = i + 1; j &lt; v.x; j++) {
			if (v[j][i].v != 0) {
				mi = j;
			}
		}
		for (int j = 0; j &lt; v.y; j++)
			std::swap(v[i][j], v[mi][j]);
		if (v[i][i].v == 0)
			return std::nullopt;
		auto ivi = 1 / v[i][i];
		for (int k = v.y - 1; k &gt;= i; k--)
			v[i][k] *= ivi;
		for (int j = 0; j &lt; v.x; j++) {
			if (j != i) {
				auto tmp = v[j][i];
				for (int k = 0; k &lt; v.y; k++)
					v[j][k] -= v[i][k] * tmp;
			}
		}
	}
	return v;
}
</code></pre>
<h1 id="测试例题-5"><a class="header" href="#测试例题-5">测试例题</a></h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3389">P3389 高斯消元法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展欧几里得exgcd"><a class="header" href="#扩展欧几里得exgcd">扩展欧几里得・EXGCD</a></h1>
<p>求出方程</p>
<p>$$
ax + by = \gcd(a, b)
$$</p>
<p>的一个解 $(x, y)$，并且求出 $\gcd(a, b)$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛"><a class="header" href="#euler-筛">Euler 筛</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-6"><a class="header" href="#测试例题-6">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛-1"><a class="header" href="#euler-筛-1">Euler 筛</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-7"><a class="header" href="#测试例题-7">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛lpf"><a class="header" href="#euler-筛lpf">Euler 筛・LPF</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数，并且筛出最小质因子（least prime factor）。</p>
<pre><code class="language-cpp">// @description 线性筛(LPF)

V&lt;int&gt; lpf, primes;
void Euler(int n) {
	lpf.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (!lpf[i])
			lpf[i] = i, primes.push_back(i);
		for (auto pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			lpf[i * pj] = pj;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-8"><a class="header" href="#测试例题-8">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eratosthenes朴素"><a class="header" href="#eratosthenes朴素">Eratosthenes（朴素）</a></h1>
<p>在 $O(n \log \log n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 埃氏筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Eratosthenes(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i]) {
			primes.push_back(i);
			for (ll j = ll(i) * i; j &lt; n; j += i)
				isp[j] = false;
		}
	}
}
</code></pre>
<h2 id="测试例题-9"><a class="header" href="#测试例题-9">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="筛法eratosthenes卡常"><a class="header" href="#筛法eratosthenes卡常">筛法・Eratosthenes・卡常</a></h1>
<pre><code class="language-cpp">// @description 埃氏筛(卡常)

V&lt;bool&gt; isp;
V&lt;int&gt; primes; // 个数不精确！
void Eratosthenes(int n) {
	isp.resize(n + 6, true);
	auto f = [&amp;](int i) {
		if (isp[i]) {
			primes.push_back(i);
			for (ll j = ll(i) * i; j &lt; n; j += i)
				isp[j] = false;
		}
	};
	f(2), f(3);
	for (int i = 5; i &lt; n; i += 6) {
		f(i), f(i + 2);
	}
}
</code></pre>
<h2 id="测试例题-10"><a class="header" href="#测试例题-10">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解筛优化"><a class="header" href="#质因分解筛优化">质因分解・筛优化</a></h1>
<p>需要筛出 $O(\sqrt{N})$ 内的质数，后可以在 $O\left(\sqrt{\frac{N}{\log N}}\right)$ 内求出 $N$ 的所有质因子。</p>
<p>常数相对于不筛有玄学改进。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}

// @description 质因子(p^k)

auto factor_pii(ll n) {
	V&lt;ll&gt; ret = factor(n);
	V&lt;std::pair&lt;ll, int&gt;&gt; ans;
	if (ret.empty())
		return ans;
	ans.emplace_back(ret[0], 1);
	for (int i = 1; i &lt; ret.size(); i++) {
		if (ret[i] == ret[i - 1])
			ans.back().second++;
		else
		 	ans.emplace_back(ret[i], 1);
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解暴力"><a class="header" href="#质因分解暴力">质因分解・暴力</a></h1>
<p>可以在 $O(\sqrt{n})$ 的时间复杂度内求出 $n$ 的所有质因子。</p>
<pre><code class="language-cpp">// @description 因式分解

auto factor(ll n) {
	vector&lt;ll&gt; ret;
	for (int i = 2; 1ll * i * i &lt;= n; i++) {
		for (; n % i == 0; n /= i)
			ret.push_back(i);
	}
	if (n &gt; 1)
		ret.push_back(n);
	return ret;
}

// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}

// @description 质因子(p^k)

auto factor_pii(ll n) {
	V&lt;ll&gt; ret = factor(n);
	V&lt;std::pair&lt;ll, int&gt;&gt; ans;
	if (ret.empty())
		return ans;
	ans.emplace_back(ret[0], 1);
	for (int i = 1; i &lt; ret.size(); i++) {
		if (ret[i] == ret[i - 1])
			ans.back().second++;
		else
		 	ans.emplace_back(ret[i], 1);
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解筛优化-1"><a class="header" href="#质因分解筛优化-1">质因分解・筛优化</a></h1>
<p>需要筛出 $O(\sqrt{N})$ 内的质数，后可以在 $O\left(\sqrt{\frac{N}{\log N}}\right)$ 内求出 $N$ 的所有质因子。</p>
<p>常数相对于不筛有玄学改进。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}

// @description 质因子(p^k)

auto factor_pii(ll n) {
	V&lt;ll&gt; ret = factor(n);
	V&lt;std::pair&lt;ll, int&gt;&gt; ans;
	if (ret.empty())
		return ans;
	ans.emplace_back(ret[0], 1);
	for (int i = 1; i &lt; ret.size(); i++) {
		if (ret[i] == ret[i - 1])
			ans.back().second++;
		else
		 	ans.emplace_back(ret[i], 1);
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解lpf-优化"><a class="header" href="#质因分解lpf-优化">质因分解・LPF 优化</a></h1>
<p>需要 $O(N)$ 预处理，后可以在 $O(\log{n})$ 内求出 $n(n \leqslant N)$ 的所有质因子。</p>
<p>仅在 $N$ 较小时有用。</p>
<pre><code class="language-cpp">// @description 线性筛(LPF)

V&lt;int&gt; lpf, primes;
void Euler(int n) {
	lpf.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (!lpf[i])
			lpf[i] = i, primes.push_back(i);
		for (auto pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			lpf[i * pj] = pj;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	vector&lt;ll&gt; ret;
	for (; n &gt; 1; n /= lpf[n])
		ret.push_back(lpf[n]);
	return ret;
}

// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}

// @description 质因子(p^k)

auto factor_pii(ll n) {
	V&lt;ll&gt; ret = factor(n);
	V&lt;std::pair&lt;ll, int&gt;&gt; ans;
	if (ret.empty())
		return ans;
	ans.emplace_back(ret[0], 1);
	for (int i = 1; i &lt; ret.size(); i++) {
		if (ret[i] == ret[i - 1])
			ans.back().second++;
		else
		 	ans.emplace_back(ret[i], 1);
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解pollard-rho"><a class="header" href="#质因分解pollard-rho">质因分解・Pollard Rho</a></h1>
<p>Pollard Rho 算法可以在 $O(n^{0.25})$ 的期望复杂度内计算出 $n$ 的一个因子，可以用于 $10^{18}$ 内的因式分解。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = 1 % m;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(a) * ret % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}

// @description Pollard Rho

ll pollard_rho(ll N) {
	if (N % 2 == 0)
		return 2;
	if (miller_rabbin(N))
		return N;
	while (true) {
		auto f = [N, c = rand() % (N - 1) + 1](ll x) {
			return (i128(x) * x + c) % N;
		};
		ll x = 0, y = 0, p = 1, q = 1;
		do {
			int w = 128;
			do {
				p = q, x = f(x), y = f(f(y));
				q = i128(p) * std::abs(x - y) % N;
			} while (w-- &amp;&amp; q != 0);
			ll d = std::__gcd(p, N);
			if (d &gt; 1 &amp;&amp; d != N)
				return d;
		} while (x != y);
	}
}

auto factor(ll x) {
	V&lt;ll&gt; v;
	if (x == 1)
		return v;
	std::function&lt;void(ll)&gt; dfs = [&amp;](ll u) {
		ll fac = pollard_rho(u);
		if (fac == u)
			v.push_back(u);
		else
			dfs(fac), dfs(u / fac);
	};
	dfs(x);
	sort(v.begin(), v.end());
	return v;
}
</code></pre>
<h2 id="备注"><a class="header" href="#备注">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline ll mul_mod(ll a, ll b, ll m) {
	ll c = a * b - ll(f80(a) / m * b + 0.5) * m;
	return c &lt; 0 ? c + m : (c &gt;= m ? c - m : c);
}
</code></pre>
<h2 id="测试例题-11"><a class="header" href="#测试例题-11">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4718">P4718 Pollard-Rho算法</a></li>
<li><a href="https://judge.yosupo.jp/problem/factorize">yosupo Factorize</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中国剩余定理"><a class="header" href="#中国剩余定理">中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>保证 $\{m_i\}$ 互质。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 中国剩余定理

template &lt;class PAIR&gt;
ll crt(const V&lt;PAIR&gt; &amp;am) {
	ll prod = 1, ret = 0;
	for (auto [a, m] : am)
		prod *= m;
	for (auto [a, m] : am) {
		ll u = prod / m, v = inv_gcd(u, m);
		ret = (ret + a * u * v) % prod;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-12"><a class="header" href="#测试例题-12">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1495">P1495 中国剩余定理（CRT）/ 曹冲养猪</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展中国剩余定理"><a class="header" href="#扩展中国剩余定理">扩展中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>不保证 $\{m_i\}$ 互质，但保证 $\operatorname{lcm}(m_i) &lt; 10^{18}$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 扩展中国剩余定理

using i128 = __int128_t;

template&lt;class PAIR&gt;
ll excrt(const V&lt;PAIR&gt; &amp;am) {
	auto [ans, M] = am[0];
	for (auto [a, m] : am) {
		if (M % m == 0 &amp;&amp; ans % m == a)
			continue;
		ll B = (a - ans % m + m) % m;
		auto [x, y, g] = exgcd(M, m);
		if (B % g != 0)
			return -1;
		x = i128(x) * (B / g) % (m / g);
		ans += M * x, M *= m /g;
		ans = (ans + M) % M;
	}
	return ans;
}
</code></pre>
<h2 id="测试例题-13"><a class="header" href="#测试例题-13">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4777">P4777 扩展中国剩余定理（EXCRT）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="素性测试miller-rabbin"><a class="header" href="#素性测试miller-rabbin">素性测试（Miller Rabbin）</a></h1>
<p>快速判断 $10^{18}$ 内的数字是否为素数。</p>
<p>若选取 $k$ 个素数为基底，那么复杂度大概是 $O(k \log n)$，错误率为 $4^{-k}$。</p>
<p>下方代码的基底在 $2^{64}$ 内没有例外。更多基底有关的可以查看 <a href="https://miller-rabin.appspot.com">SPRP Base</a>。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = 1 % m;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(a) * ret % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}
</code></pre>
<h2 id="备注-1"><a class="header" href="#备注-1">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline ll mul_mod(ll a, ll b, ll m) {
	ll c = a * b - ll(f80(a) / m * b + 0.5) * m;
	return c &lt; 0 ? c + m : (c &gt;= m ? c - m : c);
}
</code></pre>
<h2 id="测试例题-14"><a class="header" href="#测试例题-14">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/143">LOJ143 质数判定</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor-sum"><a class="header" href="#floor-sum">Floor Sum</a></h1>
<p>在 $O(\log n)$ 的时间内计算</p>
<p>$$
\sum_{x=0}^n \left\lfloor \frac{ax + b}{c} \right\rfloor
$$</p>
<pre><code class="language-cpp">// @description 类欧几里得算法

ll floor_sum(ll a, ll b, ll c, ll n) {
	ll m = (a * n + b) / c, S1 = n * (n + 1) / 2;
	if (a == 0) {
		return b / c * (n + 1);
	} else if (a &gt;= c || b &gt;= c) {
		ll f = S1 * (a / c) + b / c * (n + 1);
		return f + floor_sum(a % c, b % c, c, n);
	} else {
		return m * n - floor_sum(c, c - b - 1, a, m - 1);
	}
}
</code></pre>
<h2 id="测试例题-15"><a class="header" href="#测试例题-15">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5171">P5171 Earthquake</a></li>
<li><a href="https://judge.yosupo.jp/problem/sum_of_floor_of_linear">yosupo Sum of Floor of Linear</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二次剩余cipolla"><a class="header" href="#二次剩余cipolla">二次剩余（Cipolla）</a></h1>
<p>Cipolla 算法可以在 $O(\log P)$ 的时间内求出</p>
<p>$$
x^2 \equiv N \pmod P
$$</p>
<p>即模平方根。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 二次剩余(cipolla)

int legendre(int a, int p) {
	return qpow(a, (p - 1) / 2, p);
}

std::optional&lt;int&gt; cipolla(int n, int p) {
	if (n == 0)
		return 0;
	if (legendre(n, p) != 1)
		return std::nullopt;
	if (p == 2)
		return 1;
	for (int a = 0; a &lt; p; a++) {
		int i = (a * a - n + p) % p;
		using FP2 = std::pair&lt;ll, ll&gt;;
		auto mul = [p, i](const FP2 &amp;l, const FP2 &amp;r) {
			auto [la, lb] = l;
			auto [ra, rb] = r;
			return FP2{(la * ra + lb * rb % p * i) % p, (lb * ra + la * rb) % p};
		};
		if (legendre(i, p) == p - 1) {
			FP2 x = {1, 1}, u = {a, 1};
			for (int b = (p + 1) / 2; b; b /= 2) {
				if (b % 2 == 1)
					x = mul(x, u);
				u = mul(u, u);
			}
			return std::min(x.first, p - x.first);
		}
	}
	return std::nullopt;
}
</code></pre>
<h2 id="测试例题-16"><a class="header" href="#测试例题-16">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5491">P5491 二次剩余</a></li>
<li><a href="https://judge.yosupo.jp/problem/sqrt_mod">yosupo Sqrt Mod</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学常数"><a class="header" href="#数学常数">数学常数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="斯特林数"><a class="header" href="#斯特林数">斯特林数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly ln(int m) const {
		assert(T[0].v == 1);
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 48E
		assert(T[0].v == 0);
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = x * (cut(t) - x.ln(t) + Poly{1}), x.redeg(t);
		}
		return x.redeg(m);
	}
	Poly sqrt(int m) const { // 36E
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = (x + cut(t).div(t, x)) * ((P + 1) / 2);
		}
		return x.redeg(m);
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
	friend auto operator%(const Poly &amp;f, const Poly &amp;g) {
		Poly Q = f / g;
		return make_pair(Q, (f - Q * g).redeg(g.deg() - 1));
	}
#undef T
};

Poly taylor_shift(const Poly &amp;f, Z c) {
	int n = f.deg();
	Poly A(n), B(n);
	Z ci = 1;
	for (int i = 0; i &lt; n; i++) {
		A[i] = f[i] * fac[i];
		B[i] = ci * ifac[i];
		ci *= c;
	}
	std::reverse(A.begin(), A.end());
	A = A * B;
	for (int i = 0; i &lt; n; i++) {
		B[i] = A[n - i - 1] * ifac[i];
	}
	return B;
}

Poly pow_safe(const Poly &amp;g, int m, int k1, int k2) { // k % P, k % (P - 1)
	int pos = 0;
	while (pos &lt; g.deg() &amp;&amp; g[pos].v == 0) {
		++pos;
	}
	if (pos == g.deg() || pos &gt; (m - 1) / k1) {
		return Poly(m, 0);
	}
	Z x = g[pos];
	Poly f = Poly(g.begin() + pos, g.end()) * x.inv();
	f = f.pow(m - pos * k1, k1) * x.pow(k2);
	f.insert(f.begin(), pos * k1, 0);
	assert(f.deg() == m);
	return f;
}

Poly stirling1st_row(int n) {
	if (n == 0)
		return {0};
	Poly f = stirling1st_row(n / 2);
	Poly r = f * taylor_shift(f, n / 2);
	if (n % 2 == 1) {
		r *= Poly{n - 1, 1};
	}
	return r;
}

Poly stirling1st_col(int n, int k) {
	n++;
	Poly r = {1, P - 1};
	r = pow_safe(r.ln(n), n, k, k);
	Z xk = Z(P - 1).pow(k) * ifac[k];
	for (int i = 0; i &lt; n; i++) {
		r[i] *= fac[i] * xk;
	}
	return r;
}

Poly stirling2st_row(int n) {
	n++;
	Poly A(n), B(n);
	for (int i = 0; i &lt; n; i++) {
		A[i] = i % 2 == 1 ? -ifac[i] : ifac[i];
		B[i] = Z(i).pow(n - 1) * ifac[i];
	}
	return (A * B).redeg(n);
}

Poly stirling2st_col(int n, int k) {
	if (n &lt; k)
		return Poly(n + 1);
	std::function&lt;Poly(int)&gt; sol = [&amp;](int u) -&gt; Poly {
		if (u == 0)
			return {1};
		Poly f = sol(u / 2);
		f *= taylor_shift(f, P - u / 2);
		if (u % 2 == 1)
			f *= Poly{-u, 1};
		return f;
	};
	Poly f = sol(k).rev().inv(n - k + 1);
	f.insert(f.begin(), k, 0);
	return f;
}
</code></pre>
<h2 id="测试例题-17"><a class="header" href="#测试例题-17">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5395">P5395 第二类斯特林数·行</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5396">P5396 第二类斯特林数·列</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5409">P5409 第一类斯特林数·列</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5409">P5409 第一类斯特林数·列</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-varphin-函数"><a class="header" href="#euler-varphin-函数">Euler $\varphi(n)$ 函数</a></h1>
<p>需要用筛预处理 $O(\sqrt{N})$ 内的质数，每次求值复杂度 $O(\sqrt{N})$。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

ll euler_phi(ll x) {
	ll ans = 1;
	for (int p : primes) {
		if (1ll * p * p &gt; x)
			break;
		if (x % p == 0)
			x /= p, ans *= p - 1;
		while (x % p == 0)
			x /= p, ans *= p;
	}
	if (x &gt; 1)
		ans *= x - 1;
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="幂表"><a class="header" href="#幂表">幂表</a></h1>
<p>在 $O(n)$ 的时间内，求 $0^k, 1^k, \cdots, n^k$。</p>
<p>除了卡常以外没什么用。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

auto powers(int n, int k, int mod) {
	V&lt;bool&gt; isp(n + 1, true);
	V&lt;int&gt; pw(n + 1, 1);
	for (int p = 2; p &lt;= n; ++p)
		if (isp[p]) {
			for (ll j = ll(p) * p; j &lt;= n; j += p)
				isp[j] = false;
			int q = qpow(p, k, mod);
			for (int i = 1; i &lt;= n / p; ++i)
				pw[i * p] = ll(q) * pw[i] % mod;
		}
	pw[0] = qpow(0, k, mod);
	return pw;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指数塔"><a class="header" href="#指数塔">指数塔</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

int euler_phi(ll x) {
	ll ans = 1;
	for (int p : primes) {
		if (1ll * p * p &gt; x)
			break;
		if (x % p == 0)
			x /= p, ans *= p - 1;
		while (x % p == 0)
			x /= p, ans *= p;
	}
	if (x &gt; 1)
		ans *= x - 1;
	return ans;
}

int tetration_mod(int a, int b, int m) {
	if (m == 1)
		return 0;
	if (a == 0)
		return (b + 1) % 2;
	if (b == 0)
		return 1;
	if (b == 1)
		return a % m;
	if (a == 2 &amp;&amp; b &lt;= 4) {
		static const std::array ans = {1, 2, 4, 16, 65536};
		return ans[b] % m;
	}
	int phi = euler_phi(m);
	int d = tetration_mod(a, b - 1, phi) + phi;
	return qpow(a % m, d, m);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="取模整数"><a class="header" href="#取模整数">取模整数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础类"><a class="header" href="#基础类">基础类</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-montgomery-modint"><a class="header" href="#runtime-montgomery-modint">Runtime Montgomery Modint</a></h1>
<pre><code class="language-cpp">template &lt;int&gt;
class RuntimeMontgomeryModInt {
  public:
	using i32 = std::int32_t;
	using u32 = std::uint32_t;
	using u64 = std::uint64_t;
	using m32 = RuntimeMontgomeryModInt;

	using value_type = u32;

	static u32 get_mod() {
		return mod;
	}

	static bool set_mod(u32 m) {
		if (m % 2 == 0 || m == 1 || (m &amp; (3U &lt;&lt; 30)) != 0)
			return false;
		mod = m, mod2 = mod &lt;&lt; 1;
		u32 two = 2, iv = mod * (two - mod * mod);
		iv *= two - mod * iv;
		iv *= two - mod * iv;
		r = iv * (mod * iv - two);
		r2 = -u64(mod) % mod;
		return true;
	}

	RuntimeMontgomeryModInt() = default;
	~RuntimeMontgomeryModInt() = default;

	template &lt;typename T&gt;
	RuntimeMontgomeryModInt(T v) : v_(reduce(u64(v % i32(mod) + i32(mod)) * r2)) {}

	RuntimeMontgomeryModInt(const m32 &amp;) = default;

	u32 get() const {
		return norm(reduce(v_));
	}

	template &lt;typename T&gt;
	explicit operator T() const {
		return T(get());
	}

	m32 operator-() const {
		m32 res;
		res.v_ = (mod2 &amp; -(v_ != 0)) - v_;
		return res;
	}

	m32 inv() const {
		i32 x1 = 1, x3 = 0, a = get(), b = mod;
		while (b != 0) {
			i32 q = a / b, x1_old = x1, a_old = a;
			x1 = x3, x3 = x1_old - x3 * q, a = b, b = a_old - b * q;
		}
		return m32(x1);
	}

	m32 &amp;operator=(const m32 &amp;) = default;

	m32 &amp;operator+=(const m32 &amp;rhs) {
		v_ += rhs.v_ - mod2;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator-=(const m32 &amp;rhs) {
		v_ -= rhs.v_;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator*=(const m32 &amp;rhs) {
		v_ = reduce(u64(v_) * rhs.v_);
		return *this;
	}
	m32 &amp;operator/=(const m32 &amp;rhs) {
		return operator*=(rhs.inv());
	}
	friend m32 operator+(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) += rhs;
	}
	friend m32 operator-(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) -= rhs;
	}
	friend m32 operator*(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) *= rhs;
	}
	friend m32 operator/(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) /= rhs;
	}
	friend bool operator==(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) == norm(rhs.v_);
	}
	friend bool operator!=(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) != norm(rhs.v_);
	}

	friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, m32 &amp;rhs) {
		i32 x;
		is &gt;&gt; x;
		rhs = m32(x);
		return is;
	}
	friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const m32 &amp;rhs) {
		return os &lt;&lt; rhs.get();
	}

	m32 pow(u64 y) const {
		for (m32 res(1), x(*this);; x *= x) {
			if (y &amp; 1)
				res *= x;
			if ((y /= 2) == 0)
				return res;
		}
	}

  private:
	static u32 reduce(u64 x) {
		return (x + u64(u32(x) * r) * mod) &gt;&gt; 32;
	}
	static u32 norm(u32 x) {
		return x - (mod &amp; -((mod - 1 - x) &gt;&gt; 31));
	}

	u32 v_;

	static inline u32 r, r2, mod, mod2;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数"><a class="header" href="#预处理常数">预处理常数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值"><a class="header" href="#lagrange-插值">Lagrange 插值</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

Z lagrange(const V&lt;Z&gt; &amp;x, const V&lt;Z&gt; &amp;y, Z k) {
	int n = x.size();
	Z sum = 0;
	for (int i = 0; i &lt; n; i++) {
		Z s1 = 1, s2 = 1;
		for (int j = 0; j &lt; n; j++) {
			if (j == i)
				continue;
			s1 *= k - x[j], s2 *= x[i] - x[j];
		}
		sum += s1 / s2 * y[i];
	}
	return sum;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学p"><a class="header" href="#数学p">数学・P</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速幂-1"><a class="header" href="#快速幂-1">快速幂</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-18"><a class="header" href="#测试例题-18">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 快速幂</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数-1"><a class="header" href="#预处理常数-1">预处理常数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

V&lt;int&gt; iv{1, 1}, fac{1}, ifac{1};

// @description 预处理逆元

void pre_inv(int n) {
	iv.resize(n + 1);
	for (int i = 2; i &lt;= n; i++) {
		iv[i] = 1ll * iv[P % i] * (P - P / i) % P;
	}
}

// @description 预处理阶乘

void pre_fac(int n) {
	fac.resize(n + 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
}

// @description 预处理阶乘逆元

void pre_ifac(int n) {
	ifac.resize(n + 1);
	ifac[n] = qpow(fac[n]);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	}
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数全部"><a class="header" href="#预处理常数全部">预处理常数・全部</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;int&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt; l)
		return;
	iv = fac = ifac = V&lt;int&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n] = qpow(fac[n]), iv[n] = qpow(n);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
		iv[i] = 1ll * ifac[i] * fac[i - 1] % P;
	}
	pre_all(u);
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值-1"><a class="header" href="#lagrange-插值-1">Lagrange 插值</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 拉格朗日插值

ll lagrange(const V&lt;ll&gt; &amp;x, const V&lt;ll&gt; &amp;y, ll k) {
	ll sum = 0, n = x.size();
	for (int i = 0; i &lt; n; i++) {
		int s1 = 1, s2 = 1;
		for (int j = 0; j &lt; n; j++) {
			if (j == i)
				continue;
			s1 = 1ll * s1 * (k - x[j] + P) % P;
			s2 = 1ll * s2 * (x[i] - x[j] + P) % P;
		}
		sum += 1ll * s1 * qpow(s2) % P * y[i] % P;
	}
	return sum % P;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<pre><code class="language-cpp">auto pre_kmp(const std::string &amp;s) {
	int n = s.length();
	V&lt;int&gt; pi(n + 1);
	for (int i = 1; i &lt; n; i++) {
		int j = pi[i];
		while (j &gt; 0 &amp;&amp; s[i] != s[j])
			j = pi[j];
		pi[i + 1] = j + (s[i] == s[j]);
	}
	return pi;
}

auto kmp(const std::string &amp;s, const std::string &amp;t) {
	auto pi = pre_kmp(s);
	int n = t.length();
	V&lt;int&gt; p(n + 1);
	for (int i = 0; i &lt; n; i++) {
		int j = p[i];
		while (j &gt; 0 &amp;&amp; t[i] != s[j])
			j = pi[j];
		p[i + 1] = j + (t[i] == s[j]);
	}
	return std::make_pair(pi, p);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="z-函数"><a class="header" href="#z-函数">Z 函数</a></h1>
<pre><code class="language-cpp">auto pre_z_algo(const std::string &amp;s) {
	int n = s.length();
	V&lt;int&gt; z(n + 1);
	z[1] = n;
	for (int i = 1, l = -1, r = 0; i &lt; n; i++) {
		int &amp;k = z[i + 1], u = r - i;
		if (u &gt; 0)
			k = std::min(u, z[i - l + 1]);
		while (i + k &lt; n &amp;&amp; s[k] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return z;
}

auto z_algo(const std::string &amp;s, const std::string &amp;t) {
	auto z = pre_z_algo(s);
	int n = t.length();
	V&lt;int&gt; z2(n + 1);
	for (int i = 0, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = z2[i + 1], u = r - i;
		if (u &gt; 0)
			k = std::min(u, z[i - l + 1]);
		while (i + k &lt; n &amp;&amp; s[k] == t[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return std::make_pair(z, z2);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后缀数组"><a class="header" href="#后缀数组">后缀数组</a></h1>
<pre><code class="language-cpp">auto sa_doubleing(auto first, auto last, int m = 128) {
	int n = last - first;
	V&lt;int&gt; cnt(std::max(n, m)), sa(n), rk(n + 1, -1), id(n + 1, -1);
	std::copy(first, last, rk.begin());
	for (int i = 0; i &lt; n; i++)
		cnt[rk[i]]++;
	for (int i = 1; i &lt; m; i++)
		cnt[i] += cnt[i - 1];
	for (int i = n - 1; i &gt;= 0; i--)
		sa[--cnt[rk[i]]] = i;
	for (int k = 1; k &lt; n; k *= 2) {
		int p = 0;
		for (int i = n - k; i &lt; n; i++)
			id[p++] = i;
		for (int i = 0; i &lt; n; i++)
			if (sa[i] &gt;= k)
				id[p++] = sa[i] - k;
		std::fill(cnt.begin(), cnt.end(), 0);
		for (int i = 0; i &lt; n; i++)
			cnt[rk[i]]++;
		for (int i = 1; i &lt; m; i++)
			cnt[i] += cnt[i - 1];
		for (int i = n - 1; i &gt;= 0; i--)
			sa[--cnt[rk[id[i]]]] = id[i];
		std::fill(id.begin(), id.end(), -1);
		std::swap(rk, id);
		rk[sa[0]] = 0, p = 0;
		for (int i = 1; i &lt; n; i++) {
			bool f = id[sa[i]] == id[sa[i - 1]] &amp;&amp; id[sa[i] + k] == id[sa[i - 1] + k];
			rk[sa[i]] = f ? p : ++p;
		}
		if (p == n - 1)
			break;
		m = p + 1;
	}
	return sa;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<pre><code class="language-cpp">// @description Manacher

template &lt;int o&gt;
auto manacher(const std::string &amp;s) {
	int n = s.size();
	V&lt;int&gt; m(n);
	m[0] = o == 0;
	for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = m[i], u = r - i;
		if (u &gt; 0)
			k = std::min(u, m[2 * l - i]);
		while (0 &lt;= i - k - o &amp;&amp; i + k &lt; n &amp;&amp; s[i - k - o] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return m;
}

V&lt;int&gt; manacher_odd(const std::string &amp;s) {
	return manacher&lt;0&gt;(s);
}

V&lt;int&gt; manacher_even(const std::string &amp;s) {
	return manacher&lt;1&gt;(s);
}
</code></pre>
<h2 id="测试例题-19"><a class="header" href="#测试例题-19">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3805">P3805 manacher 算法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图论"><a class="header" href="#图论">图论</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路"><a class="header" href="#最短路">最短路</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路bellman-fordvec"><a class="header" href="#最短路bellman-fordvec">最短路・Bellman Ford・VEC</a></h1>
<p>对于 $n$ 个点 $m$ 条边的图，可以在 $O(nm)$ 的时间内求出来源点 $s$ 到所有点的最短路，并且求出路径。</p>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description Bellman Ford 最短路

template &lt;class D&gt;
auto bellman_ford(const Edges&lt;D&gt; &amp;E, int s) {
	int n = E.size();
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	dis[s] = 0, from[s] = s;
	bool flag = true;
	for (int k = 0; k &lt; n &amp;&amp; flag; k++) {
		flag = false;
		for (int u = 0; u &lt; n; u++) {
			for (auto [v, w] : E[u]) {
				int d2 = dis[u] + w;
				if (dis[v] &gt; d2)
					dis[v] = d2, from[v] = u, flag = true;
			}
		}
	}
	return std::make_pair(dis, from);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路队列优化-bellman-fordvec"><a class="header" href="#最短路队列优化-bellman-fordvec">最短路・队列优化 Bellman Ford・VEC</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 队列优化 Bellman Ford 最短路

template &lt;class D&gt;
auto queue_bellman_ford(const Edges&lt;D&gt; &amp;G, int s) {
	int n = G.size();
	std::queue&lt;int&gt; q;
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	dis[s] = 0, from[s] = s;
	q.push(s);
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (auto [v, w] : G[u]) {
			int d2 = dis[u] + w;
			if (dis[v] &gt; d2)
				dis[v] = d2, from[v] = u, q.push(v);
		}
	}
	return std::make_pair(dis, from);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路dijkstra"><a class="header" href="#最短路dijkstra">最短路・Dijkstra</a></h1>
<p>对于 $n$ 个点 $m$ 条边的图，可以在 $O(n \log m)$ 的时间内求出来源点 $s$ 到所有点的最短路，并且求出路径。</p>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description Dijkstra 最短路

template &lt;class D&gt;
auto dijkstra(const Edges&lt;D&gt; &amp;E, int s) {
	int n = E.size();
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	V&lt;bool&gt; vis(n);
	dis[s] = 0, from[s] = s;
	using pdi = std::pair&lt;D, int&gt;;
	std::priority_queue&lt;pdi, V&lt;pdi&gt;, std::greater&lt;pdi&gt;&gt; pq;
	pq.emplace(0, s);
	while (!pq.empty()) {
		auto [w, u] = pq.top();
		pq.pop();
		if (vis[u])
			continue;
		vis[u] = true;
		for (auto [v, wi] : E[u]) {
			D d2 = w + wi;
			if (dis[v] &gt; d2)
				dis[v] = d2, from[v] = u, pq.emplace(d2, v);
		}
	}
	return make_pair(dis, from);
}

auto get_path(const V&lt;int&gt; &amp;from, int x, int y) {
	V&lt;int&gt; r;
	for (; x != y; y = from[y])
		r.push_back(y);
	r.push_back(y);
	std::reverse(r.begin(), r.end());
	return r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路floydadj"><a class="header" href="#最短路floydadj">最短路・Floyd・ADJ</a></h1>
<p>对于 $n$ 个点的图，可以在 $O(n^3)$ 的时间内求出任意两点的最短路，并记录其中一条路径。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

template &lt;class D&gt;
using Edges = VV&lt;D&gt;; // 默认 x == y

template &lt;class D&gt;
auto get_edges(int n) {
	VV&lt;D&gt; f(n, n, std::numeric_limits&lt;D&gt;::max() / 2);
	for (int i = 0; i &lt; n; i++)
		f[i][i] = 0;
	return f;
}

// @description Floyd 最短路

template &lt;class D&gt;
auto floyd(const Edges&lt;D&gt; &amp;E) {
	int n = E.x;
	auto f = E;
	VV&lt;int&gt; pass(n, n, -1);
	for (int k = 0; k &lt; n; k++) {
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				D d2 = f[i][k] + f[k][j];
				if (f[i][j] &gt; d2)
					f[i][j] = d2, pass[i][j] = k;
			}
		}
	}
	return make_pair(f, pass);
}

auto get_path(const VV&lt;int&gt; &amp;pass, int x, int y) {
	V&lt;int&gt; path = {x};
	std::function&lt;void(int, int)&gt; dfs = [&amp;](int a, int b) {
		if (pass[a][b] != -1) {
			int p = pass[a][b];
			dfs(a, p), path.push_back(p), dfs(p, b);
		}
	};
	if (x != y)
		dfs(x, y), path.push_back(y);
	return path;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca"><a class="header" href="#lca">LCA</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca倍增"><a class="header" href="#lca倍增">LCA・倍增</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(倍增)

struct LCA {
	const int n, lgn;
	VV&lt;int&gt; f;
	V&lt;int&gt; dep;
	LCA(int n_) : n(n_), lgn(1 + std::__lg(n)), f(n, lgn), dep(n) {}
	int query(int x, int y) {
		if (dep[x] &gt; dep[y])
			std::swap(x, y);
		while (dep[x] &lt; dep[y])
			y = f[y][std::__lg(dep[y] - dep[x])];
		for (int i = lgn - 1; i &gt;= 0; i--) {
			if (f[x][i] != f[y][i]) {
				x = f[x][i], y = f[y][i];
			}
		}
		return x == y ? x : f[x][0];
	}
};

template &lt;class D&gt;
struct LCAImpl : LCA {
	const Edges&lt;D&gt; &amp;E;
	LCAImpl(const Edges&lt;D&gt; &amp;E_, int s = 1) : LCA(E_.size()), E(E_) {
		dfs(s, 0);
		for (int i = 1; i &lt; lgn; i++) {
			for (int j = 0; j &lt; n; j++) {
				f[j][i] = f[f[j][i - 1]][i - 1];
			}
		}
	}
	void dfs(int u, int fa) {
		f[u][0] = fa;
		dep[u] = dep[fa] + 1;
		for (auto e : E[u]) {
			if (e.to != fa) {
				dfs(e.to, u);
			}
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lcast"><a class="header" href="#lcast">LCA（ST）</a></h1>
<pre><code class="language-cpp">using pii = std::pair&lt;int, int&gt;;

template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(Sparse Table)

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	void init(auto first, auto last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = min(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) const {
		int s = std::__lg(r - l + 1);
		return min(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};

struct LCA {
	const int n;
	V&lt;int&gt; dfn;
	SparseTable&lt;pii&gt; st;
	LCA(int n_) : n(n_), dfn(n), st(n) {}
	int query(int x, int y) const {
		if (x == y)
			return x;
		x = dfn[x], y = dfn[y];
		if (x &gt; y)
			std::swap(x, y);
		return st.query(x + 1, y).second;
	}
};

template &lt;class D&gt;
struct LCAImpl : LCA {
	const Edges&lt;D&gt; &amp;E;
	V&lt;pii&gt; rnk;
	int cnt = 0;
	LCAImpl(const Edges&lt;D&gt; &amp;E_, int s = 1) : LCA(E_.size()), E(E_), rnk(n) {
		dfs(s, 0);
		st.init(rnk.begin(), rnk.end());
	}
	void dfs(int u, int fa) {
		dfn[u] = ++cnt;
		rnk[cnt] = {dfn[fa], fa};
		for (auto e : E[u]) {
			if (e.to != fa) {
				dfs(e.to, u);
			}
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scc"><a class="header" href="#scc">SCC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tarjan"><a class="header" href="#tarjan">Tarjan</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

struct SCC {
	V&lt;int&gt; id;
	V&lt;V&lt;int&gt;&gt; group;
	SCC(int n) : id(n) {}
};

template &lt;class D&gt;
struct SCCImpl : SCC {
	const Edges&lt;D&gt; &amp;E;
	const int n;
	V&lt;int&gt; low, dfn, stk;
	V&lt;bool&gt; flag;
	int cnt = 0, c2 = 0;
	void tarjan(int u) {
		low[u] = dfn[u] = ++cnt;
		stk.push_back(u), flag[u] = true;
		for (auto e : E[u]) {
			if (dfn[e.to] == 0) {
				tarjan(e.to);
				low[u] = std::min(low[u], low[e.to]);
			} else if (flag[e.to]) {
				low[u] = std::min(low[u], dfn[e.to]);
			}
		}
		if (dfn[u] == low[u]) {
			c2++;
			while (true) {
				int v = stk.back();
				stk.pop_back();
				id[v] = c2;
				flag[v] = false;
				if (u == v)
					break;
			}
		}
	}
	SCCImpl(const Edges&lt;D&gt; &amp;E_) : SCC(E_.size()), E(E_), n(E.size()), low(n), dfn(n), flag(n) {
		for (int i = 1; i &lt; n; i++) {
			if (dfn[i] == 0)
				tarjan(i);
		}
		group.resize(c2 + 1);
		for (int i = 1; i &lt; n; i++) {
			id[i] = c2 + 1 - id[i]; // 拓扑序
			group[id[i]].push_back(i);
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kosaraju"><a class="header" href="#kosaraju">Kosaraju</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

struct SCC {
	V&lt;int&gt; id;
	V&lt;V&lt;int&gt;&gt; group;
	SCC(int n) : id(n) {}
};

template &lt;class D&gt;
struct SCCImpl : SCC {
	const Edges&lt;D&gt; &amp;E, &amp;IE;
	const int n;
	V&lt;bool&gt; vis;
	V&lt;int&gt; stk;
	int cnt = 0;
	void dfs1(int u) {
		vis[u] = true;
		for (auto e : E[u])
			if (!vis[e.to])
				dfs1(e.to);
		stk.push_back(u);
	}
	void dfs2(int u) {
		id[u] = cnt;
		for (auto e : IE[u])
			if (id[e.to] == 0)
				dfs2(e.to);
	}
	SCCImpl(const Edges&lt;D&gt; &amp;E_, const Edges&lt;D&gt; &amp;IE_)
		: SCC(E_.size()), E(E_), IE(IE_), n(E.size()), vis(n) {
		for (int i = 1; i &lt; n; i++)
			if (!vis[i])
				dfs1(i);
		std::reverse(stk.begin(), stk.end());
		for (int u : stk) {
			if (id[u] == 0) {
				++cnt;
				dfs2(u);
			}
		}
		group.resize(cnt + 1);
		for (int i = 1; i &lt; n; i++) {
			group[id[i]].push_back(i);
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最小生成树kruskal"><a class="header" href="#最小生成树kruskal">最小生成树（kruskal）</a></h1>
<pre><code class="language-cpp">// @description 朴素并查集

struct DSU {
	V&lt;int&gt; fa;
	DSU(int n) : fa(n) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		fa[x] = y;
	}
};

ll kruskal(int n) {
	std::sort(G.begin(), G.end(), [](Edge a, Edge b) {
		return get&lt;2&gt;(a) &lt; get&lt;2&gt;(b);
	});
	ll ans = 0, cnt = 0;
	DSU dsu(n + 1);
	for (auto [u, v, w] : G) {
		if (dsu.find(u) == dsu.find(v)) {
			continue;
		}
		ans += w, cnt++;
		dsu.merge(u, v);
		if (cnt == n - 1) {
			return ans;
		}
	}
	return -1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树链剖分"><a class="header" href="#树链剖分">树链剖分</a></h1>
<pre><code class="language-cpp">const int N = 1E5 + 5;
V&lt;int&gt; G[N];

// @problem https://www.luogu.com.cn/problem/P3379

// @description 树链剖分 LCA

struct HLD {
	V&lt;int&gt; sz, dep, fa, son, top, dfn;
	int cnt = 0;
	HLD(int n, int r = 1) : sz(n), dep(n), fa(n), son(n), top(n), dfn(n) {
		dfs1(r), dfs2(r, r);
	}
	void dfs1(int u, int f = 0) {
		dep[u] = dep[f] + 1;
		fa[u] = f, sz[u] = 1, top[u] = u;
		for (int v : G[u]) {
			if (v != f) {
				dfs1(v, u);
				sz[u] += sz[v];
				if (sz[v] &gt; sz[son[u]]) {
					son[u] = v;
				}
			}
		}
	}
	void dfs2(int u, int tp, int f = 0) {
		top[u] = tp, dfn[u] = ++cnt;
		if (son[u] != 0) {
			dfs2(son[u], tp, u);
			for (int v : G[u]) {
				if (v != f &amp;&amp; v != son[u]) {
					dfs2(v, v, u);
				}
			}
		}
	}
	int qpath(int x, int y) {
		while (top[x] != top[y]) {
			if (dep[top[x]] &gt; dep[top[y]]) {
				std::swap(x, y);
			}
			y = fa[top[y]];
		}
		return dep[x] &lt; dep[y] ? x : y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dinic"><a class="header" href="#dinic">Dinic</a></h1>
<p>感谢 gkjj 送的 Dinic。</p>
<pre><code class="language-cpp">struct Dinic {
	const int inf = 1e9;
	struct edge {
		int to, cap, rev;
	};
	V&lt;V&lt;edge&gt;&gt; G;
	V&lt;int&gt; lev, cur;
	Dinic(int n) : G(n), lev(n), cur(n) {}

	inline void add(int x, int y, int c) {
		G[x].push_back({y, c, (int)G[y].size()});
		G[y].push_back({x, 0, (int)G[x].size() - 1});
	}

	void bfs(int s) {
		std::queue&lt;int&gt; qu;
		std::fill(lev.begin(), lev.end(), -1);
		for (lev[s] = 0, qu.push(s); qu.size();) {
			int x = qu.front();
			qu.pop();
			for (auto [to, cap, rev] : G[x])
				if (cap &gt; 0 &amp;&amp; lev[to] &lt; 0)
					lev[to] = lev[x] + 1, qu.push(to);
		}
	}

	int dfs(int x, int t, int f) {
		if (x == t)
			return f;
		for (int &amp;i = cur[x], d; i &lt; G[x].size(); i++) {
			auto &amp;[to, cap, rev] = G[x][i];
			if (cap &gt; 0 &amp;&amp; lev[x] &lt; lev[to])
				if ((d = dfs(to, t, std::min(f, cap))) &gt; 0) {
					cap -= d;
					G[to][rev].cap += d;
					return d;
				}
		}
		return 0;
	}

	ll maxflow(int s, int t) {
		for (ll flow = 0, f;;) {
			bfs(s);
			if (lev[t] &lt; 0)
				return flow;
			std::fill(cur.begin(), cur.end(), 0);
			while ((f = dfs(s, t, inf)) &gt; 0)
				flow += f;
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式"><a class="header" href="#多项式">多项式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fft-乘法"><a class="header" href="#fft-乘法">FFT 乘法</a></h1>
<p>FFT 乘法及拆系数 $5$ 次乘法，可以做 <code>int</code> 范围内的卷积。可能存在误差。</p>
<pre><code class="language-cpp">using f64 = double;

using img = std::complex&lt;f64&gt;;
using Poly = V&lt;int&gt;;

V&lt;img&gt; w{{1, 0}, {1, 0}};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

const f64 PI = acos(-1.0);

void pre_w(int u) {
	int l = w.size(), l2 = l * 2;
	if (u &lt;= l)
		return;
	w.resize(l2);
	img p = img(cos(PI / l), sin(PI / l));
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(u);
}

static int ntt_size = 0;

void fft(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j] + f[i + j + l];
				f[i + j + l] = w[j + l] * (f[i + j] - f[i + j + l]);
				f[i + j] = x;
			}
}

void ifft(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j], y = f[i + j + l] * w[j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	for (int i = 0; i &lt; n; i++)
		f[i] /= n;
	std::reverse(f + 1, f + n);
}

Poly mul(const Poly &amp;a, const Poly &amp;b) {
	int n = a.size(), m = b.size(), N = get_lim(n + m - 1);
	V&lt;img&gt; f(N);
	for (int i = 0; i &lt; n; i++)
		f[i] += img(a[i], 0);
	for (int i = 0; i &lt; m; i++)
		f[i] += img(0, b[i]);
	fft(f.begin(), N);
	for (int i = 0; i &lt; N; i++)
		f[i] *= f[i];
	ifft(f.begin(), N);
	Poly ans(n + m - 1);
	for (int i = 0; i &lt; n + m - 1; i++)
		ans[i] = int(f[i].imag() / 2 + 0.5);
	return ans;
}

Poly mul5(const Poly &amp;a, const Poly &amp;b, int p) {
	enum : int { B = 1 &lt;&lt; 15 };
	int n = a.size(), m = b.size(), N = get_lim(n + m - 1);
	V&lt;img&gt; a0(N), a1(N), Q(N);
	for (int i = 0; i &lt; n; i++)
		a0[i] = a[i] % B, a1[i] = a[i] / B;
	for (int i = 0; i &lt; m; i++)
		Q[i] = img(b[i] % B, b[i] / B);
	fft(a0.begin(), N), fft(a1.begin(), N), fft(Q.begin(), N);
	for (int i = 0; i &lt; N; i++)
		a0[i] *= Q[i], a1[i] *= Q[i];
	ifft(a0.begin(), N), ifft(a1.begin(), N);
	Poly ans(n + m - 1);
	for (int i = 0; i &lt; m + n - 1; i++) {
		ll a1b1 = a1[i].imag() + .5;
		ll a1b0 = a1[i].real() + .5;
		ll a0b1 = a0[i].imag() + .5;
		ll a0b0 = a0[i].real() + .5;
		ans[i] = ((a1b1 * B % p + a0b1 + a1b0) * B + a0b0) % p;
	}
	return ans;
}
</code></pre>
<pre><code>poly/fft-mul.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                    MUL * |       1 |     0.000 |     100 |      - | 10000000.0
         MUL5 MOD 1E9 + 7 |       1 |     0.001 |     700 |  7.000 |  1428571.4
                    MUL * |       2 |     0.001 |     300 |      - |  3333333.3
         MUL5 MOD 1E9 + 7 |       2 |     0.001 |     450 |  1.500 |  2222222.2
                    MUL * |      64 |     0.004 |      64 |      - | 15609756.1
         MUL5 MOD 1E9 + 7 |      64 |     0.014 |     212 |  3.317 |  4705882.4
                    MUL * |     512 |     0.038 |      73 |      - | 13580541.6
         MUL5 MOD 1E9 + 7 |     512 |     0.112 |     218 |  2.968 |  4575473.0
                    MUL * |    4096 |     0.372 |      90 |      - | 11010663.9
         MUL5 MOD 1E9 + 7 |    4096 |     1.126 |     274 |  3.027 |  3637946.2
                    MUL * |   16384 |     1.753 |     107 |      - |  9345650.5
         MUL5 MOD 1E9 + 7 |   16384 |     5.078 |     309 |  2.897 |  3226247.9
                    MUL * |   32768 |     4.134 |     126 |      - |  7927159.5
         MUL5 MOD 1E9 + 7 |   32768 |    12.069 |     368 |  2.920 |  2715143.5
                    MUL * |   65536 |     9.033 |     137 |      - |  7255111.2
         MUL5 MOD 1E9 + 7 |   65536 |    25.409 |     387 |  2.813 |  2579281.7
                    MUL * |  131072 |    17.653 |     134 |      - |  7424931.7
         MUL5 MOD 1E9 + 7 |  131072 |    55.177 |     420 |  3.126 |  2375483.1
                    MUL * |  262144 |    39.848 |     152 |      - |  6578590.1
         MUL5 MOD 1E9 + 7 |  262144 |   124.137 |     473 |  3.115 |  2111738.2
                    MUL * |  524288 |    89.322 |     170 |      - |  5869654.0
         MUL5 MOD 1E9 + 7 |  524288 |   284.661 |     542 |  3.187 |  1841797.7
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-乘法i32"><a class="header" href="#ntt-乘法i32">NTT 乘法・i32</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 多项式乘法

struct Poly : V&lt;int&gt; {
	using vector::vector;
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n);
};
Poly w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

inline int mo(int u) {
	return u &gt;= P ? u - P : u;
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	int p = qpow(3, (P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = 1ll * w[i] * p % P;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j], y = f[i + j + l];
				f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
				f[i + j] = mo(x + y);
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j];
				int y = 1ll * w[j + l] * f[i + j + l] % P;
				f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * ivn % P;
	std::reverse(f + 1, f + n);
}

Poly &amp;Poly::mul(Poly &amp;f, Poly &amp;g, int n) {
	f.resize(n), g.resize(n);
	ntt(f.begin(), n), ntt(g.begin(), n);
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * g[i] % P;
	return intt(f.begin(), n), f;
}

Poly operator*(Poly f, Poly g) {
	int m = f.size() + g.size() - 1;
	Poly::mul(f, g, get_lim(m));
	return f.resize(m), f;
}

Poly operator+(Poly f, Poly g) {
	int n = std::max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++)
		f[i] = mo(f[i] + g[i]);
	return f;
}

Poly operator-(Poly f, Poly g) {
	int n = std::max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++)
		f[i] = mo(f[i] - g[i] + P);
	return f;
}
</code></pre>
<pre><code>poly/ntt-mul-i32.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
          MUL MOD 1E9+7 * |       1 |     0.001 |     700 |      - |  1428571.4
          MUL MOD 1E9+7 * |       2 |     0.001 |     300 |      - |  3333333.3
          MUL MOD 1E9+7 * |      64 |     0.006 |      87 |      - | 11428571.4
          MUL MOD 1E9+7 * |     512 |     0.042 |      81 |      - | 12278177.5
          MUL MOD 1E9+7 * |    4096 |     0.448 |     109 |      - |  9146879.3
          MUL MOD 1E9+7 * |   16384 |     2.397 |     146 |      - |  6835173.6
          MUL MOD 1E9+7 * |   32768 |     5.524 |     168 |      - |  5932437.1
          MUL MOD 1E9+7 * |   65536 |    11.196 |     170 |      - |  5853486.2
          MUL MOD 1E9+7 * |  131072 |    25.716 |     196 |      - |  5096816.8
          MUL MOD 1E9+7 * |  262144 |    52.639 |     200 |      - |  4979987.1
          MUL MOD 1E9+7 * |  524288 |   109.511 |     208 |      - |  4787523.6
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-乘法三模"><a class="header" href="#ntt-乘法三模">NTT 乘法・三模</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 多项式乘法(int mod)

using Poly = V&lt;int&gt;;

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

template &lt;int P&gt;
struct NTT {
	inline static Poly w{1, 1};

	inline static int ntt_size = 0;

	static inline int mo(int u) {
		return u &gt;= P ? u - P : u;
	}

	static void pre_w(int n) {
		int l = w.size(), l2 = l * 2;
		if (n &lt;= l)
			return;
		w.resize(l2);
		int p = qpow(3, (P - 1) / l2, P);
		for (int i = l; i &lt; l2; i += 2) {
			w[i] = w[i / 2];
			w[i + 1] = 1ll * w[i] * p % P;
		}
		pre_w(n);
	}

	static void ntt(auto f, int n) {
		pre_w(n), ntt_size += n;
		for (int l = n / 2; l; l /= 2)
			for (int i = 0; i &lt; n; i += l * 2)
				for (int j = 0; j &lt; l; j++) {
					int x = f[i + j], y = f[i + j + l];
					f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
					f[i + j] = mo(x + y);
				}
	}

	static void intt(auto f, int n) {
		pre_w(n), ntt_size += n;
		for (int l = 1; l &lt; n; l *= 2)
			for (int i = 0; i &lt; n; i += l * 2)
				for (int j = 0; j &lt; l; j++) {
					int x = f[i + j];
					int y = 1ll * w[j + l] * f[i + j + l] % P;
					f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
				}
		const int ivn = P - (P - 1) / n;
		for (int i = 0; i &lt; n; i++)
			f[i] = 1ll * f[i] * ivn % P;
		std::reverse(f + 1, f + n);
	};
};

template &lt;int P&gt;
Poly mul(Poly &amp;f, Poly g, int n) {
	for (int i = 0; i &lt; n; i++)
		f[i] %= P, g[i] %= P;
	NTT&lt;P&gt;::ntt(f.begin(), n), NTT&lt;P&gt;::ntt(g.begin(), n);
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * g[i] % P;
	return NTT&lt;P&gt;::intt(f.begin(), n), f;
}

Poly mul3(Poly f, Poly g, int p) {
	constexpr std::array&lt;int, 3&gt; M = {985661441, 998244353, 1004535809};
	int m = f.size() + g.size() - 1, N = get_lim(m);
	f.resize(N), g.resize(N);

	std::array&lt;Poly, 3&gt; a = {f, f, f};
	mul&lt;M[0]&gt;(a[0], g, N);
	mul&lt;M[1]&gt;(a[1], g, N);
	mul&lt;M[2]&gt;(a[2], g, N);

	Poly ans(m);

	const ll M12 = ll(M[0]) * M[1] % p;
	const ll inv_1 = qpow(M[0], M[1] - 2, M[1]);
	const ll inv_2 = qpow(ll(M[0]) * M[1] % M[2], M[2] - 2, M[2]);

	for (int i = 0; i &lt; m; i++) {
		ll x = (a[1][i] - a[0][i] + M[1]) * inv_1 % M[1] * M[0] + a[0][i];
		ans[i] = ((a[2][i] - x % M[2] + M[2]) * inv_2 % M[2] * M12 + x) % p;
	}
	return ans;
}
</code></pre>
<pre><code>poly/ntt-mul-mod3.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
          MUL MOD 1E9+7 * |       1 |     0.002 |    1900 |      - |   526315.8
          MUL MOD 1E9+7 * |       2 |     0.004 |    1750 |      - |   571428.6
          MUL MOD 1E9+7 * |      64 |     0.022 |     339 |      - |  2949308.8
          MUL MOD 1E9+7 * |     512 |     0.203 |     396 |      - |  2524642.4
          MUL MOD 1E9+7 * |    4096 |     1.607 |     392 |      - |  2549310.4
          MUL MOD 1E9+7 * |   16384 |     8.950 |     546 |      - |  1830604.3
          MUL MOD 1E9+7 * |   32768 |    18.854 |     575 |      - |  1738023.0
          MUL MOD 1E9+7 * |   65536 |    37.698 |     575 |      - |  1738451.8
          MUL MOD 1E9+7 * |  131072 |    83.456 |     636 |      - |  1570556.6
          MUL MOD 1E9+7 * |  262144 |   179.271 |     683 |      - |  1462281.0
          MUL MOD 1E9+7 * |  524288 |   371.583 |     708 |      - |  1410959.6
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntton2"><a class="header" href="#ntton2">NTT・$O(n^2)$</a></h1>
<p>NTT 的 $O(n^2)$ 板子，我也不知道有啥用，大概用来快速验证吧。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;int&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt; l)
		return;
	iv = fac = ifac = V&lt;int&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n] = qpow(fac[n]), iv[n] = qpow(n);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
		iv[i] = 1ll * ifac[i] * fac[i - 1] % P;
	}
	pre_all(u);
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

struct Poly : V&lt;int&gt; { // O(n2) 板子，我也不知道有啥用
	using vector::vector;
	int deg() const {
		return size();
	}
};

Poly deriv(const Poly &amp;f, int m) {
	Poly r(m);
	for (int i = 1; i &lt; std::min(f.deg(), m + 1); i++)
		r[i - 1] = 1ll * f[i] * i % P;
	return f;
}
Poly integr(const Poly &amp;f, int m) {
	Poly r(m);
	pre_all(m);
	for (int i = std::min(f.deg(), m - 1); i &gt; 0; --i)
		r[i] = 1ll * iv[i] * f[i - 1] % P;
	return f;
}
Poly inv(const Poly &amp;f, int m) {
	Poly r(m);
	int iv0 = r[0] = qpow(f[0]);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, f.deg()); j++)
			r[i] = (r[i] + 1ll * f[j] * r[i - j]) % P;
		r[i] = 1ll * (P - r[i]) * iv0 % P;
	}
	return r;
}

Poly div(int m, const Poly &amp;f, const Poly &amp;g) {
	Poly r(m);
	int iv0 = qpow(g[0]);
	r[0] = 1ll * f[0] * iv0 % P;
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, g.deg()); j++)
			r[i] = (r[i] + 1ll * g[j] * r[i - j]) % P;
		r[i] = mo(f[i] - 1ll * r[i] * iv0 % P);
	}
	return r;
}

Poly ln(const Poly &amp;f, int m) {
	assert(f[0] == 1);
	return integr(div(m, deriv(f, m), f), m);
}

Poly exp(const Poly &amp;f, int m) {
	Poly r(m), df = f;
	for (int i = 0; i &lt; f.deg(); i++)
		df[i] = 1ll * i * df[i] % P;
	r[0] = 1;
	pre_all(m);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, f.deg()); j++)
			r[i] = (r[i] + 1ll * df[j] * r[i - j]) % P;
		r[i] = 1ll * r[i] * iv[i] % P;
	}
	return r;
}

Poly sqrt(const Poly &amp;f, int m) {
	Poly r(m);
	r[0] = 1; // sqrt(f[0])
	int iv0 = qpow(2ll * r[0] % P);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt;= i - 1; j++)
			r[i] = (r[i] + 1ll * r[j] * r[i - j]) % P;
		r[i] = 1ll * (f[i] - r[i] + P) * iv0 % P;
	}
	return r;
}

Poly operator*(const Poly &amp;f, const Poly &amp;g) {
	Poly r(f.size() + g.size() - 1);
	for (int i = 0; i &lt; f.size(); i++) {
		for (int j = 0; j &lt; g.size(); j++) {
			r[i + j] = (r[i + j] + 1ll * f[i] * g[j]) % P;
		}
	}
	return r;
}

Poly operator+(const Poly &amp;f, const Poly &amp;g) {
	Poly r(std::max(f.size(), g.size()));
	std::copy(f.begin(), f.end(), r.begin());
	for (int i = 0; i &lt; g.size(); i++)
		r[i] = mo(r[i] + g[i]);
	return r;
}

Poly operator-(const Poly &amp;f, const Poly &amp;g) {
	Poly r(std::max(f.size(), g.size()));
	std::copy(f.begin(), f.end(), r.begin());
	for (int i = 0; i &lt; g.size(); i++)
		r[i] = mo(r[i] - g[i] + P);
	return r;
}
</code></pre>
<pre><code>poly/ntt-naive.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                    MUL * |       1 |     0.000 |     200 |      - |  5000000.0
                      INV |       1 |     0.000 |     200 |  1.000 |  5000000.0
                      EXP |       1 |     0.000 |     400 |  2.000 |  2500000.0
                     SQRT |       1 |     0.000 |     400 |  2.000 |  2500000.0
                    MUL * |       2 |     0.000 |     100 |      - | 10000000.0
                      INV |       2 |     0.000 |     200 |  2.000 |  5000000.0
                      EXP |       2 |     0.000 |     100 |  1.000 | 10000000.0
                     SQRT |       2 |     0.000 |     150 |  1.500 |  6666666.7
                    MUL * |      64 |     0.008 |     118 |      - |  8421052.6
                      INV |      64 |     0.010 |     153 |  1.289 |  6530612.2
                      EXP |      64 |     0.009 |     148 |  1.250 |  6736842.1
                     SQRT |      64 |     0.009 |     135 |  1.145 |  7356321.8
                    MUL * |     512 |     0.396 |     774 |      - |  1291944.0
                      INV |     512 |     0.507 |     989 |  1.278 |  1010653.3
                      EXP |     512 |     0.539 |    1051 |  1.359 |   950607.4
                     SQRT |     512 |     0.570 |    1113 |  1.439 |   897768.4
                    MUL * |    4096 |    27.835 |    6795 |      - |   147151.5
                      INV |    4096 |    38.197 |    9325 |  1.372 |   107233.2
                      EXP |    4096 |    38.219 |    9330 |  1.373 |   107170.7
                     SQRT |    4096 |    37.816 |    9232 |  1.359 |   108314.5
                    MUL * |   16384 |   477.113 |   29120 |      - |    34339.9
                      INV |   16384 |   653.563 |   39890 |  1.370 |    25068.7
                      EXP |   16384 |   648.330 |   39570 |  1.359 |    25271.1
                     SQRT |   16384 |   658.869 |   40214 |  1.381 |    24866.9
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代"><a class="header" href="#ntt-牛顿迭代">NTT 牛顿迭代</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly ln(int m) const {
		assert(T[0].v == 1);
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 48E
		assert(T[0].v == 0);
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = x * (cut(t) - x.ln(t) + Poly{1}), x.redeg(t);
		}
		return x.redeg(m);
	}
	Poly sqrt(int m) const { // 36E
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = (x + cut(t).div(t, x)) * ((P + 1) / 2);
		}
		return x.redeg(m);
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
	friend auto operator%(const Poly &amp;f, const Poly &amp;g) {
		Poly Q = f / g;
		return make_pair(Q, (f - Q * g).redeg(g.deg() - 1));
	}
#undef T
};
</code></pre>
<pre><code>poly/ntt-newton.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |       0 |      - |        inf
                   MUL 6E |       1 |     0.000 |     400 |    inf |  2500000.0
                  INV 12E |       1 |     0.001 |     500 |    inf |  2000000.0
                  LOG 18E |       1 |     0.001 |    1000 |    inf |  1000000.0
                  EXP 48E |       1 |     0.000 |     400 |    inf |  2500000.0
                 SQRT 36E |       1 |     0.001 |     500 |    inf |  2000000.0
                 NTT 1E * |       2 |     0.000 |       0 |      - |        inf
                   MUL 6E |       2 |     0.001 |     350 |    inf |  2857142.9
                  INV 12E |       2 |     0.001 |     450 |    inf |  2222222.2
                  LOG 18E |       2 |     0.001 |     700 |    inf |  1427551.7
                  EXP 48E |       2 |     0.002 |    1000 |    inf |  1000000.0
                 SQRT 36E |       2 |     0.001 |     650 |    inf |  1538461.5
                 NTT 1E * |      64 |     0.001 |       9 |      - |106666666.7
                   MUL 6E |      64 |     0.005 |      78 |  8.333 | 12800000.0
                  INV 12E |      64 |     0.011 |     178 | 19.000 |  5614035.1
                  LOG 18E |      64 |     0.020 |     312 | 33.335 |  3199840.0
                  EXP 48E |      64 |     0.045 |     704 | 75.168 |  1419037.3
                 SQRT 36E |      64 |     0.040 |     621 | 66.333 |  1608040.2
                 NTT 1E * |     512 |     0.006 |      12 |      - | 78769230.8
                   MUL 6E |     512 |     0.048 |      93 |  7.369 | 10688935.3
                  INV 12E |     512 |     0.096 |     187 | 14.785 |  5327783.6
                  LOG 18E |     512 |     0.145 |     282 | 22.262 |  3538355.2
                  EXP 48E |     512 |     0.404 |     788 | 62.139 |  1267634.2
                 SQRT 36E |     512 |     0.314 |     614 | 48.370 |  1628488.4
                 NTT 1E * |    4096 |     0.074 |      18 |      - | 55276653.2
                   MUL 6E |    4096 |     0.429 |     104 |  5.783 |  9558859.6
                  INV 12E |    4096 |     1.393 |     340 | 18.803 |  2939766.4
                  LOG 18E |    4096 |     1.437 |     350 | 19.387 |  2851160.5
                  EXP 48E |    4096 |     3.261 |     796 | 44.008 |  1256049.5
                 SQRT 36E |    4096 |     3.052 |     745 | 41.191 |  1341975.4
                 NTT 1E * |   16384 |     0.331 |      20 |      - | 49573073.7
                   MUL 6E |   16384 |     2.294 |     140 |  6.942 |  7141135.5
                  INV 12E |   16384 |     4.326 |     264 | 13.089 |  3787311.4
                  LOG 18E |   16384 |     6.769 |     413 | 20.482 |  2420361.4
                  EXP 48E |   16384 |    17.918 |    1093 | 54.215 |   914382.7
                 SQRT 36E |   16384 |    12.692 |     774 | 38.401 |  1290935.6
                 NTT 1E * |   32768 |     0.739 |      22 |      - | 44316774.1
                   MUL 6E |   32768 |     5.307 |     161 |  7.178 |  6173986.3
                  INV 12E |   32768 |    10.234 |     312 | 13.841 |  3201796.0
                  LOG 18E |   32768 |    15.360 |     468 | 20.773 |  2133335.6
                  EXP 48E |   32768 |    38.475 |    1174 | 52.035 |   851667.4
                 SQRT 36E |   32768 |    29.859 |     911 | 40.383 |  1097422.2
                 NTT 1E * |   65536 |     1.489 |      22 |      - | 44027950.1
                   MUL 6E |   65536 |    10.636 |     162 |  7.145 |  6161680.8
                  INV 12E |   65536 |    20.037 |     305 | 13.461 |  3270747.3
                  LOG 18E |   65536 |    31.795 |     485 | 21.361 |  2061180.3
                  EXP 48E |   65536 |    80.306 |    1225 | 53.951 |   816075.0
                 SQRT 36E |   65536 |    59.201 |     903 | 39.772 |  1107006.0
                 NTT 1E * |  131072 |     3.158 |      24 |      - | 41499270.0
                   MUL 6E |  131072 |    24.359 |     185 |  7.712 |  5380793.2
                  INV 12E |  131072 |    45.304 |     345 | 14.344 |  2893156.7
                  LOG 18E |  131072 |    69.754 |     532 | 22.085 |  1879053.0
                  EXP 48E |  131072 |   174.167 |    1328 | 55.144 |   752563.5
                 SQRT 36E |  131072 |   132.483 |    1010 | 41.946 |   989348.6
                 NTT 1E * |  262144 |     6.682 |      25 |      - | 39233505.1
                   MUL 6E |  262144 |    50.527 |     192 |  7.562 |  5188198.6
                  INV 12E |  262144 |    93.785 |     357 | 14.036 |  2795146.7
                  LOG 18E |  262144 |   146.703 |     559 | 21.956 |  1786902.7
                  EXP 48E |  262144 |   375.645 |    1432 | 56.220 |   697850.6
                 SQRT 36E |  262144 |   292.221 |    1114 | 43.735 |   897075.7
                 NTT 1E * |  524288 |    16.008 |      30 |      - | 32751237.5
                   MUL 6E |  524288 |   108.274 |     206 |  6.764 |  4842233.7
                  INV 12E |  524288 |   210.595 |     401 | 13.155 |  2489557.4
                  LOG 18E |  524288 |   321.639 |     613 | 20.092 |  1630051.7
                  EXP 48E |  524288 |   797.867 |    1521 | 49.841 |   657112.1
                 SQRT 36E |  524288 |   600.610 |    1145 | 37.519 |   872925.4
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代卡常"><a class="header" href="#ntt-牛顿迭代卡常">NTT 牛顿迭代・卡常</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(deg());
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly &amp;invD(Poly f2, Poly nx, int t) {
		mul(f2, nx, t).fill0L(t); // 6E
		mul(f2, nx, t);			  // 4E
		redeg(t);
		for (int i = t / 2; i &lt; t; i++) {
			T[i] = -f2[i];
		}
		return T;
	}
	Poly inv(int m) const { // 10E
		Poly x = {qpow(T[0].v)};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x.invD(cut(t), x.cut(m), t);
		}
		return x.redeg(m);
	}
	Poly div(int m, Poly g) const { // 13E
		if (deg() == 0)
			return {};
		int t = get_lim(m);
		Poly x = cut(t / 2), u = g.inv(t / 2); // 10E
		Poly q = mul(x, u, t).cut(t / 2);	   // 6E
		mul(q, g, t).fill0L(t);				   // 6E
		for (int i = t / 2; i &lt; std::min(t, deg()); i++)
			q[i] -= T[i];
		mul(q, u, t); // 4E
		for (int i = t / 2; i &lt; t; i++)
			x[i] = -q[i];
		return x.cut(m);
	}
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 17E
		if (m == 1)
			return {1};
		assert(T[0].v == 0);
		Poly f = {1, T[1]}, g = {1}, nf, ng = g;
		pre_all(deg());
		for (int t = 4; t &lt; m * 2; t *= 2) {
			nf = Poly(f).ntt(t);		// 2E
			ng = g.invD(nf, ng, t / 2); // 3E
			Poly q = cut(t / 2);
			for (int i = 0; i &lt; q.deg(); i++)
				q[i] *= i;
			mul(q, nf, t / 2); // 2E
			for (int i = 0; i &lt; t / 2; i++)
				q[i] -= i * f[i];
			mul(q, ng, t); // 6E
			for (int i = t / 2; i &lt; std::min(t, deg()); i++)
				q[i] = T[i] + q[i - t / 2] * iv[i];
			mul(q.fill0L(t), nf, t); // 4E
			f.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				f[i] = q[i];
		}
		return f.cut(m);
	}
	Poly sqrt(int m) const { // 11E
		Poly x = {1}, g = x.inv(1), ng = g;
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly f = Poly(x).ntt(t / 2); // 2E
			if (t &gt;= 4)
				ng = g.invD(f, ng, t / 2); // 3E
			mul(f, f, t / 2).redeg(t);	   // 1E
			for (int i = t / 2; i &lt; std::min(t, deg()); i++)
				f[i] = T[i - t / 2] + T[i] - f[i - t / 2];
			mul(f.fill0L(t), ng, t); // 6E
			x.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				x[i] = f[i] * ((P + 1) / 2);
		}
		return x.cut(deg());
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};
</code></pre>
<pre><code>poly/ntt-newton-fast.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     200 |      - |  5000000.0
                   MUL 6E |       1 |     0.001 |     500 |  2.500 |  2000000.0
                  INV 10E |       1 |     0.000 |     300 |  1.500 |  3333333.3
                  LOG 13E |       1 |     0.002 |    2300 | 11.500 |   434782.6
                  EXP 17E |       1 |     0.000 |     300 |  1.500 |  3333333.3
                 SQRT 11E |       1 |     0.001 |     600 |  3.000 |  1666666.7
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                   MUL 6E |       2 |     0.000 |     200 |  4.000 |  5000000.0
                  INV 10E |       2 |     0.001 |     500 | 10.000 |  2000000.0
                  LOG 13E |       2 |     0.001 |     700 | 14.000 |  1428571.4
                  EXP 17E |       2 |     0.000 |     200 |  4.000 |  5000000.0
                 SQRT 11E |       2 |     0.002 |    1050 | 21.000 |   952381.0
                 NTT 1E * |      64 |     0.001 |      12 |      - | 80000000.0
                   MUL 6E |      64 |     0.005 |      79 |  6.375 | 12549019.6
                  INV 10E |      64 |     0.008 |     118 |  9.500 |  8421052.6
                  LOG 13E |      64 |     0.015 |     239 | 19.125 |  4183006.5
                  EXP 17E |      64 |     0.022 |     340 | 27.250 |  2935779.8
                 SQRT 11E |      64 |     0.012 |     181 | 14.500 |  5517241.4
                 NTT 1E * |     512 |     0.006 |      11 |      - | 85333333.3
                   MUL 6E |     512 |     0.049 |      95 |  8.133 | 10491803.3
                  INV 10E |     512 |     0.072 |     141 | 12.083 |  7062069.0
                  LOG 13E |     512 |     0.092 |     179 | 15.350 |  5559174.8
                  EXP 17E |     512 |     0.142 |     277 | 23.700 |  3600537.3
                 SQRT 11E |     512 |     0.088 |     171 | 14.650 |  5824800.9
                 NTT 1E * |    4096 |     0.071 |      17 |      - | 57446599.6
                   MUL 6E |    4096 |     0.454 |     110 |  6.360 |  9031933.7
                  INV 10E |    4096 |     0.775 |     189 | 10.865 |  5287180.7
                  LOG 13E |    4096 |     0.957 |     233 | 13.416 |  4281818.1
                  EXP 17E |    4096 |     1.450 |     353 | 20.334 |  2825211.4
                 SQRT 11E |    4096 |     0.880 |     214 | 12.339 |  4655593.0
                 NTT 1E * |   16384 |     0.307 |      18 |      - | 53420280.4
                   MUL 6E |   16384 |     2.090 |     127 |  6.814 |  7839965.9
                  INV 10E |   16384 |     3.279 |     200 | 10.691 |  4996616.4
                  LOG 13E |   16384 |     4.785 |     292 | 15.600 |  3424372.7
                  EXP 17E |   16384 |     5.788 |     353 | 18.873 |  2830481.7
                 SQRT 11E |   16384 |     3.962 |     241 | 12.918 |  4135263.3
                 NTT 1E * |   32768 |     0.742 |      22 |      - | 44155536.2
                   MUL 6E |   32768 |     5.394 |     164 |  7.269 |  6074864.2
                  INV 10E |   32768 |     7.470 |     227 | 10.066 |  4386426.4
                  LOG 13E |   32768 |    10.136 |     309 | 13.658 |  3232943.5
                  EXP 17E |   32768 |    12.379 |     377 | 16.681 |  2647113.4
                 SQRT 11E |   32768 |     8.120 |     247 | 10.941 |  4035656.8
                 NTT 1E * |   65536 |     1.274 |      19 |      - | 51436971.7
                   MUL 6E |   65536 |    10.750 |     164 |  8.437 |  6096509.3
                  INV 10E |   65536 |    15.769 |     240 | 12.377 |  4155886.6
                  LOG 13E |   65536 |    21.223 |     323 | 16.658 |  3087904.8
                  EXP 17E |   65536 |    27.218 |     415 | 21.362 |  2407839.0
                 SQRT 11E |   65536 |    17.101 |     260 | 13.422 |  3832269.9
                 NTT 1E * |  131072 |     3.148 |      24 |      - | 41639134.3
                   MUL 6E |  131072 |    22.193 |     169 |  7.050 |  5905947.9
                  INV 10E |  131072 |    35.242 |     268 | 11.196 |  3719178.5
                  LOG 13E |  131072 |    45.676 |     348 | 14.511 |  2869577.4
                  EXP 17E |  131072 |    59.116 |     451 | 18.780 |  2217194.6
                 SQRT 11E |  131072 |    38.964 |     297 | 12.378 |  3363958.9
                 NTT 1E * |  262144 |     6.719 |      25 |      - | 39017437.6
                   MUL 6E |  262144 |    48.755 |     185 |  7.257 |  5376737.1
                  INV 10E |  262144 |    75.785 |     289 | 11.280 |  3459034.5
                  LOG 13E |  262144 |    95.146 |     362 | 14.161 |  2755184.0
                  EXP 17E |  262144 |   126.947 |     484 | 18.895 |  2064982.7
                 SQRT 11E |  262144 |    84.285 |     321 | 12.545 |  3110205.5
                 NTT 1E * |  524288 |    14.547 |      27 |      - | 36041377.0
                   MUL 6E |  524288 |   104.382 |     199 |  7.176 |  5022793.4
                  INV 10E |  524288 |   158.342 |     302 | 10.885 |  3311110.2
                  LOG 13E |  524288 |   217.265 |     414 | 14.936 |  2413128.7
                  EXP 17E |  524288 |   267.745 |     510 | 18.406 |  1958159.1
                 SQRT 11E |  524288 |   175.002 |     333 | 12.030 |  2995894.7
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代分块卡常"><a class="header" href="#ntt-牛顿迭代分块卡常">NTT 牛顿迭代（分块卡常）</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = qpow(3, (P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	Poly operator*(Z k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(deg());
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly inv(int m) const;
	Poly div(int m, Poly g) const;
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const;
	Poly sqrt(int m) const;
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};

Poly Poly::inv(int u) const { // 10E
	if (u == 1) {
		return {front().inv()};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);
	nf[0] = cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = cut(m, k * m).ntt(m * 2);			  // 2E
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2); // 2E
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2); // 2E
		mul(psi, ng[0], m * 2);		   // 4E
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::sqrt(int u) const { // 8E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = sqrt(m), h = x.inv(m).ntt(m * 2);
	vector&lt;Poly&gt; ng(R);

	for (int k = 1; x.deg() &lt; u; k++) {
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			if (j &gt;= 1) {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] + ng[k - 1 - j][i]);
				for (int i = m; i &lt; m * 2; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] - ng[k - 1 - j][i]);
			} else {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * ng[k - 1 - j][i];
				for (int i = m; i &lt; m * 2; i++)
					psi[i] += ng[j][i] * ng[k - 1 - j][i];
			}
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; std::min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i] * iv[2];
	}
	return x.cut(u);
}

Poly Poly::div(int u, Poly f) const { // 10E
	if (u == 1) {
		return {front() * f[0].inv()};
	}
	f.redeg(u);
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = div(m, f), h = f.inv(m).ntt(m * 2);

	vector&lt;Poly&gt; nf(R), ng(R);

	nf[0] = f.cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = f.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; std::min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::exp(int u) const { // 14E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = exp(m), y = x.inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);

	Poly df = *this;
	for (int i = 0; i &lt; df.deg(); i++)
		df[i] *= i;
	y.ntt(m * 2);
	nf[0] = df.cut(m).ntt(m * 2);

	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = df.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, m * (k - 1)).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);

		mul(psi, y, m * 2).fill0H(m * 2);
		for (int i = 0; i &lt; m * 2; i++)
			psi[i] *= iv[m * k + i];
		mul(psi, ng[0], m * 2).fill0H(m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}
</code></pre>
<pre><code>poly/ntt-newton-blockwise-fast.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |       0 |      - |        inf
                   MUL 6E |       1 |     0.001 |     600 |    inf |  1666666.7
                  INV 10E |       1 |     0.000 |     400 |    inf |  2500000.0
                  LOG 10E |       1 |     0.001 |    1000 |    inf |  1000000.0
                  EXP 14E |       1 |     0.001 |     800 |    inf |  1250000.0
                  SQRT 8E |       1 |     0.000 |     300 |    inf |  3333333.3
                 NTT 1E * |       2 |     0.000 |       0 |      - |        inf
                   MUL 6E |       2 |     0.001 |     400 |    inf |  2500000.0
                  INV 10E |       2 |     0.002 |    1050 |    inf |   952381.0
                  LOG 10E |       2 |     0.004 |    1850 |    inf |   540540.5
                  EXP 14E |       2 |     0.002 |    1000 |    inf |  1000000.0
                  SQRT 8E |       2 |     0.001 |     650 |    inf |  1538461.5
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                   MUL 6E |      64 |     0.005 |      82 |  7.571 | 12075471.7
                  INV 10E |      64 |     0.015 |     237 | 21.714 |  4210526.3
                  LOG 10E |      64 |     0.021 |     331 | 30.286 |  3018867.9
                  EXP 14E |      64 |     0.019 |     303 | 27.714 |  3298969.1
                  SQRT 8E |      64 |     0.019 |     296 | 27.143 |  3368421.1
                 NTT 1E * |     512 |     0.006 |      11 |      - | 83934426.2
                   MUL 6E |     512 |     0.049 |      96 |  8.098 | 10364372.5
                  INV 10E |     512 |     0.099 |     192 | 16.148 |  5197916.8
                  LOG 10E |     512 |     0.114 |     221 | 18.623 |  4507002.6
                  EXP 14E |     512 |     0.134 |     261 | 21.935 |  3826578.3
                  SQRT 8E |     512 |     0.088 |     171 | 14.394 |  5831368.7
                 NTT 1E * |    4096 |     0.060 |      14 |      - | 67927031.5
                   MUL 6E |    4096 |     0.480 |     117 |  7.952 |  8542178.0
                  INV 10E |    4096 |     0.738 |     180 | 12.231 |  5553868.2
                  LOG 10E |    4096 |     0.950 |     231 | 15.753 |  4312010.1
                  EXP 14E |    4096 |     1.219 |     297 | 20.221 |  3359285.2
                  SQRT 8E |    4096 |     0.843 |     205 | 13.980 |  4858814.4
                 NTT 1E * |   16384 |     0.288 |      17 |      - | 56908451.2
                   MUL 6E |   16384 |     2.508 |     153 |  8.712 |  6532398.4
                  INV 10E |   16384 |     4.102 |     250 | 14.249 |  3993933.0
                  LOG 10E |   16384 |     4.237 |     258 | 14.717 |  3866773.8
                  EXP 14E |   16384 |     5.509 |     336 | 19.134 |  2974134.3
                  SQRT 8E |   16384 |     3.279 |     200 | 11.390 |  4996313.1
                 NTT 1E * |   32768 |     0.649 |      19 |      - | 50489751.2
                   MUL 6E |   32768 |     5.226 |     159 |  8.053 |  6269912.8
                  INV 10E |   32768 |     8.695 |     265 | 13.398 |  3768451.8
                  LOG 10E |   32768 |     9.312 |     284 | 14.348 |  3518994.4
                  EXP 14E |   32768 |    11.883 |     362 | 18.310 |  2757491.1
                  SQRT 8E |   32768 |     7.133 |     217 | 10.991 |  4593640.6
                 NTT 1E * |   65536 |     1.501 |      22 |      - | 43649665.1
                   MUL 6E |   65536 |    11.027 |     168 |  7.345 |  5942981.8
                  INV 10E |   65536 |    17.230 |     262 | 11.476 |  3803687.8
                  LOG 10E |   65536 |    18.750 |     286 | 12.488 |  3495215.5
                  EXP 14E |   65536 |    27.430 |     418 | 18.270 |  2389204.5
                  SQRT 8E |   65536 |    15.143 |     231 | 10.086 |  4327727.1
                 NTT 1E * |  131072 |     3.447 |      26 |      - | 38020327.7
                   MUL 6E |  131072 |    22.368 |     170 |  6.488 |  5859924.4
                  INV 10E |  131072 |    36.784 |     280 | 10.670 |  3563278.3
                  LOG 10E |  131072 |    40.343 |     307 | 11.702 |  3248938.5
                  EXP 14E |  131072 |    56.608 |     431 | 16.420 |  2315423.7
                  SQRT 8E |  131072 |    33.904 |     258 |  9.835 |  3865918.9
                 NTT 1E * |  262144 |     7.336 |      27 |      - | 35735663.7
                   MUL 6E |  262144 |    51.543 |     196 |  7.026 |  5085919.9
                  INV 10E |  262144 |    84.531 |     322 | 11.523 |  3101148.3
                  LOG 10E |  262144 |    89.798 |     342 | 12.241 |  2919263.3
                  EXP 14E |  262144 |   118.272 |     451 | 16.123 |  2216451.1
                  SQRT 8E |  262144 |    72.488 |     276 |  9.882 |  3616402.8
                 NTT 1E * |  524288 |    14.545 |      27 |      - | 36045230.1
                   MUL 6E |  524288 |   104.842 |     199 |  7.208 |  5000725.9
                  INV 10E |  524288 |   177.024 |     337 | 12.171 |  2961681.2
                  LOG 10E |  524288 |   191.689 |     365 | 13.179 |  2735093.2
                  EXP 14E |  524288 |   256.580 |     489 | 17.640 |  2043367.2
                  SQRT 8E |  524288 |   150.765 |     287 | 10.365 |  3477508.0
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式平移"><a class="header" href="#ntt-多项式平移">NTT 多项式平移</a></h1>
<p>给定多项式 $f(x)$，求多项式 $f(x + c)$。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

Poly taylor_shift(const Poly &amp;f, Z c) {
	int n = f.deg();
	Poly A(n), B(n);
	Z ci = 1;
	for (int i = 0; i &lt; n; i++) {
		A[i] = f[i] * fac[i];
		B[i] = ci * ifac[i];
		ci *= c;
	}
	std::reverse(A.begin(), A.end());
	A = A * B;
	for (int i = 0; i &lt; n; i++) {
		B[i] = A[n - i - 1] * ifac[i];
	}
	return B;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式多点求值--快速插值"><a class="header" href="#ntt-多项式多点求值--快速插值">NTT 多项式多点求值 &amp; 快速插值</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly operator*(int k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

// @description 多项式多点求值

struct PolyEI {
	int raw_n, n;
	V&lt;Poly&gt; p;
	PolyEI(Poly a) : raw_n(a.deg()), n(get_lim(raw_n)), p(n * 2) {
		a.redeg(n);
		for (int i = 0; i &lt; n; i++)
			p[i + n] = {1, -a[i]};
		for (int i = n - 1; i; i--) {
			int ls = i * 2, rs = i * 2 + 1;
			int len = get_lim(p[ls].deg());
			p[ls].ntt(len), p[rs].ntt(len), p[i].redeg(len);
			for (int j = 0; j &lt; len; j++)
				p[i][j] = p[ls][j] * p[rs][j];
			p[i].intt(len);
			p[i].push_back(p[i][0] - 1), p[i][0] = 1;
		}
	}
	Poly eval(const Poly &amp;f) { // PolyEI(x).eval(f)
		int m = f.deg();
		if (m == 1)
			return Poly(raw_n, f[0]);
		Poly q = f.rev().div(m, p[1]).redeg(m);
		if (m &gt; n) {
			std::rotate(q.begin(), q.begin() + m - n, q.end());
			q.redeg(n);
		} else {
			q.redeg(n);
			std::rotate(q.begin(), q.begin() + m, q.end());
		}
		for (int k = n, o = 1; k &gt; 1; k /= 2)
			for (int i = 0; i &lt; n; i += k, o++) {
				if (i &gt;= raw_n)
					continue;
				Poly foo(k), bar(k);
				auto qi = q.begin() + i;
				ntt(qi, k);
				for (int j = 0; j &lt; k; j++) {
					foo[j] = qi[j] * p[o * 2 + 1][j];
					bar[j] = qi[j] * p[o * 2][j];
				}
				foo.intt(k), bar.intt(k);
				std::copy(foo.begin() + k / 2, foo.end(), qi);
				std::copy(bar.begin() + k / 2, bar.end(), qi + k / 2);
			}
		return q.cut(raw_n);
	}
	Poly inter(const Poly &amp;y) { // PolyEI(x).inter(y)
		Poly q = Poly(p[1]).redeg(raw_n + 1);
		q = eval(q.rev().deriv(raw_n + 1)).redeg(n);
		for (int i = 0; i &lt; raw_n; i++)
			q[i] = y[i] / q[i];
		for (int k = 1, h = n / 2; k &lt; n; k *= 2, h /= 2)
			for (int i = 0, o = h; i &lt; n; i += k * 2, o++) {
				if (i &gt;= raw_n)
					continue;
				auto qi = q.begin() + i;
				Poly foo(qi, qi + k), bar(qi + k, qi + k * 2);
				foo.ntt(k * 2), bar.ntt(k * 2);
				for (int j = 0; j &lt; k * 2; j++) {
					qi[j] = foo[j] * p[o * 2 + 1][j] + bar[j] * p[o * 2][j];
				}
				intt(qi, k * 2);
			}
		return q.cut(raw_n).rev();
	}
};
</code></pre>
<pre><code>poly/ntt-eval.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                     EVAL |       1 |     0.001 |    1000 | 10.000 |  1000000.0
                    INTER |       1 |     0.001 |    1200 | 12.000 |   833333.3
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                     EVAL |       2 |     0.002 |     750 | 15.000 |  1333333.3
                    INTER |       2 |     0.003 |    1650 | 33.000 |   606060.6
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                     EVAL |      64 |     0.050 |     787 | 72.001 |  1269816.1
                    INTER |      64 |     0.056 |     875 | 80.000 |  1142857.1
                 NTT 1E * |     512 |     0.006 |      12 |      - | 78769230.8
                     EVAL |     512 |     0.581 |    1135 | 89.447 |   880625.4
                    INTER |     512 |     0.578 |    1128 | 88.862 |   886422.0
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59620675.1
                     EVAL |    4096 |     6.159 |    1503 | 89.656 |   664994.0
                    INTER |    4096 |     6.511 |    1589 | 94.768 |   629122.4
                 NTT 1E * |   16384 |     0.319 |      19 |      - | 51440968.8
                     EVAL |   16384 |    32.503 |    1983 |102.049 |   504081.5
                    INTER |   16384 |    31.604 |    1928 | 99.228 |   518414.1
                 NTT 1E * |   32768 |     0.719 |      21 |      - | 45599523.5
                     EVAL |   32768 |    68.747 |    2098 | 95.668 |   476644.1
                    INTER |   32768 |    70.247 |    2143 | 97.755 |   466466.9
                 NTT 1E * |   65536 |     1.589 |      24 |      - | 41240590.7
                     EVAL |   65536 |   155.320 |    2370 | 97.740 |   421940.5
                    INTER |   65536 |   158.982 |    2425 |100.045 |   412221.7
                 NTT 1E * |  131072 |     3.196 |      24 |      - | 41012329.2
                     EVAL |  131072 |   328.893 |    2509 |102.910 |   398524.3
                    INTER |  131072 |   340.855 |    2600 |106.653 |   384538.9
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-chirp-z-变换"><a class="header" href="#ntt-chirp-z-变换">NTT Chirp Z 变换</a></h1>
<p>给定 $f(x)$ 和常数 $c$，计算 $f(c^0), f(c^1), \cdots, f(c^m)$。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

Poly chirpz(const Poly &amp;f, int m, Z c) {
	int n = f.deg(), N = get_lim(n + m - 1);
	Poly A = f, pw(n + m, 1), ipw(n + m, 1);
	Z ci = c, ivc = c.inv(), ici = ivc;
	for (int i = 2; i &lt; n + m; i++) {
		pw[i] = pw[i - 1] * ci;
		ipw[i] = ipw[i - 1] * ici;
		ci *= c, ici *= ivc;
	}
	for (int i = 0; i &lt; n; i++)
		A[i] *= ipw[i];
	std::reverse(A.begin(), A.end());
	Poly::mul(A, pw, N);
	Poly x(m);
	for (int i = 0; i &lt; m; i++) {
		x[i] = A[i + n - 1] * ipw[i];
	}
	return x;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-在线卷积"><a class="header" href="#ntt-在线卷积">NTT 在线卷积</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-半在线卷积"><a class="header" href="#ntt-半在线卷积">NTT 半在线卷积</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

struct PolySemi {
	int now = 0;
	enum : int { M = 32 };
	const Poly &amp;F;
	Poly G, conv;
	std::map&lt;int, Poly&gt; nf;
	PolySemi(const Poly &amp;f) : F(f), G(M), conv(M) {}
	void set(Z v) {
		G[now] = v;
		conv[now] += G[now] * F[0];
		now++;
	}
	Z next() { // return  (F * G)[now] - F[0] G[now]
		int len = now &amp; -now, l = now - len;
		if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else {
			Poly a = G.cut(len, l).ntt(len * 2), &amp;b = nf[len];
			if (l == 0) {
				b = F.cut(len * 2).ntt(len * 2);
				conv.redeg(now * 2);
				G.redeg(now * 2);
			}
			for (int i = 0; i &lt; len * 2; i++)
				a[i] *= b[i];
			a.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += a[i];
		}
		return conv[now];
	}
};

Poly semi_inv(Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = -F[0].inv();
	X.set(-iv0);
	for (int i = 1; i &lt; m; i++) {
		X.set(iv0 * X.next());
	}
	return X.G.redeg(m);
}

Poly semi_div(Poly H, Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = F[0].inv();
	X.set(iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly semi_exp(Poly F, int m) {
	for (int i = 0; i &lt; F.size(); i++)
		F[i] *= i;
	PolySemi X(F);
	X.set(1);
	for (int i = 1; i &lt; m; i++)
		X.set(iv[i] * X.next());
	return X.G.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-semi.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.001 |     500 |  5.000 |  2000000.0
                      DIV |       1 |     0.001 |     500 |  5.000 |  2000000.0
                      EXP |       1 |     0.000 |     100 |  1.000 | 10000000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.001 |     250 |  5.000 |  4000000.0
                      DIV |       2 |     0.001 |     400 |  8.000 |  2500000.0
                      EXP |       2 |     0.001 |     250 |  5.000 |  4000000.0
                 NTT 1E * |      64 |     0.001 |       9 |      - |106666666.7
                      INV |      64 |     0.008 |     125 | 13.333 |  8000000.0
                      DIV |      64 |     0.007 |     117 | 12.500 |  8533333.3
                      EXP |      64 |     0.008 |     123 | 13.167 |  8101265.8
                 NTT 1E * |     512 |     0.006 |      12 |      - | 81269841.3
                      INV |     512 |     0.094 |     183 | 14.873 |  5464189.3
                      DIV |     512 |     0.097 |     189 | 15.413 |  5272914.5
                      EXP |     512 |     0.095 |     184 | 15.016 |  5412262.2
                 NTT 1E * |    4096 |     0.058 |      14 |      - | 70376797.6
                      INV |    4096 |     1.317 |     321 | 22.634 |  3109373.9
                      DIV |    4096 |     1.295 |     316 | 22.251 |  3162917.3
                      EXP |    4096 |     1.285 |     313 | 22.084 |  3186787.3
                 NTT 1E * |   16384 |     0.319 |      19 |      - | 51408687.1
                      INV |   16384 |     7.464 |     455 | 23.421 |  2194969.7
                      DIV |   16384 |     6.721 |     410 | 21.087 |  2437900.8
                      EXP |   16384 |     7.023 |     428 | 22.038 |  2332761.0
                 NTT 1E * |   32768 |     0.615 |      18 |      - | 53263632.9
                      INV |   32768 |    15.412 |     470 | 25.053 |  2126072.8
                      DIV |   32768 |    14.901 |     454 | 24.222 |  2199020.6
                      EXP |   32768 |    16.627 |     507 | 27.027 |  1970771.9
                 NTT 1E * |   65536 |     1.333 |      20 |      - | 49182480.8
                      INV |   65536 |    34.056 |     519 | 25.558 |  1924381.4
                      DIV |   65536 |    38.064 |     580 | 28.566 |  1721722.6
                      EXP |   65536 |    34.752 |     530 | 26.080 |  1885798.6
                 NTT 1E * |  131072 |     3.071 |      23 |      - | 42674779.3
                      INV |  131072 |    80.288 |     612 | 26.140 |  1632527.4
                      DIV |  131072 |    83.423 |     636 | 27.161 |  1571180.1
                      EXP |  131072 |    79.614 |     607 | 25.921 |  1646343.1
                 NTT 1E * |  262144 |     7.005 |      26 |      - | 37422749.1
                      INV |  262144 |   176.279 |     672 | 25.165 |  1487099.3
                      DIV |  262144 |   184.682 |     704 | 26.365 |  1419436.1
                      EXP |  262144 |   185.354 |     707 | 26.460 |  1414291.5
                 NTT 1E * |  524288 |    14.412 |      27 |      - | 36377939.9
                      INV |  524288 |   402.913 |     768 | 27.956 |  1301244.7
                      DIV |  524288 |   398.286 |     759 | 27.635 |  1316360.8
                      EXP |  524288 |   393.112 |     749 | 27.276 |  1333686.8
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt半在线卷积卡常"><a class="header" href="#ntt半在线卷积卡常">NTT・半在线卷积・卡常</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

using pii = std::pair&lt;int, int&gt;;

struct PolySemi {
	int now = 0;
	enum : int { M = 32, B = 16 };
	const Poly &amp;F;
	Poly G, conv;
	std::map&lt;pii, Poly&gt; nf, nr;
	V&lt;int&gt; U;
	PolySemi(const Poly &amp;f) : F(f), G(M), conv(M), U(32, -1) {}
	Poly &amp;getNf(pii p) {
		auto &amp;u = nf[p];
		if (u.empty())
			u = F.cut(p.first, p.second).ntt(p.first);
		return u;
	}
	Poly &amp;getNr(pii p) {
		auto &amp;u = nr[p];
		if (u.empty())
			u = G.cut(p.first, p.second).ntt(p.first * 2);
		return u;
	}
	void set(Z v) {
		G[now] = v;
		conv[now] += G[now] * F[0];
		now++;
	}
	Z next() { // return sum{i in [0, now)} F[i] G[now - i]
		int len = now &amp; -now;
		if (len == now) {
			conv.resize(now * 2);
			G.redeg(now * 2);
		}
		if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else {
			int u = std::__lg(len / M) / std::__lg(B);
			int t = ++U[u] % (B - 1);
			len = (1 &lt;&lt; (u * std::__lg(B))) * M;
			int l = now - len;
			Poly s(len * 2);
			for (int i = 0; i &lt;= t; i++) {
				Poly &amp;a = getNr({len, l - i * len});
				Poly &amp;b = getNf({len * 2, len * i});
				for (int j = 0; j &lt; len * 2; j++)
					s[j] += a[j] * b[j];
			}
			s.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += s[i];
		}
		return conv[now];
	}
};

Poly semi_inv(Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = -F[0].inv();
	X.set(-iv0);
	for (int i = 1; i &lt; m; i++) {
		X.set(iv0 * X.next());
	}
	return X.G.redeg(m);
}

Poly semi_div(Poly H, Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = F[0].inv();
	X.set(iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly semi_exp(Poly F, int m) {
	for (int i = 0; i &lt; F.size(); i++)
		F[i] *= i;
	PolySemi X(F);
	X.set(1);
	for (int i = 1; i &lt; m; i++)
		X.set(iv[i] * X.next());
	return X.G.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-semi.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.001 |     900 |  9.000 |  1111111.1
                      DIV |       1 |     0.001 |     600 |  6.000 |  1666666.7
                      EXP |       1 |     0.001 |     500 |  5.000 |  2000000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.001 |     500 | 10.000 |  2000000.0
                      DIV |       2 |     0.001 |     700 | 14.000 |  1428571.4
                      EXP |       2 |     0.001 |     600 | 12.000 |  1666666.7
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                      INV |      64 |     0.009 |     135 | 12.429 |  7356321.8
                      DIV |      64 |     0.009 |     135 | 12.429 |  7356321.8
                      EXP |      64 |     0.008 |     121 | 11.143 |  8205128.2
                 NTT 1E * |     512 |     0.006 |      12 |      - | 78769230.8
                      INV |     512 |     0.097 |     189 | 14.923 |  5278350.5
                      DIV |     512 |     0.086 |     167 | 13.231 |  5953557.6
                      EXP |     512 |     0.089 |     174 | 13.708 |  5746352.4
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59795620.4
                      INV |    4096 |     1.192 |     290 | 17.396 |  3437400.9
                      DIV |    4096 |     1.049 |     256 | 15.320 |  3903160.5
                      EXP |    4096 |     1.039 |     253 | 15.171 |  3941501.0
                 NTT 1E * |   16384 |     0.288 |      17 |      - | 56889086.4
                      INV |   16384 |     5.456 |     333 | 18.945 |  3002829.1
                      DIV |   16384 |     6.474 |     395 | 22.480 |  2530626.9
                      EXP |   16384 |     5.831 |     355 | 20.247 |  2809767.7
                 NTT 1E * |   32768 |     0.685 |      20 |      - | 47864516.3
                      INV |   32768 |    12.212 |     372 | 17.839 |  2683180.4
                      DIV |   32768 |    14.145 |     431 | 20.661 |  2316616.0
                      EXP |   32768 |    13.018 |     397 | 19.015 |  2517212.9
                 NTT 1E * |   65536 |     1.639 |      25 |      - | 39980575.8
                      INV |   65536 |    27.163 |     414 | 16.571 |  2412699.1
                      DIV |   65536 |    28.665 |     437 | 17.487 |  2286301.3
                      EXP |   65536 |    32.782 |     500 | 19.999 |  1999141.3
                 NTT 1E * |  131072 |     3.245 |      24 |      - | 40390830.1
                      INV |  131072 |    60.853 |     464 | 18.752 |  2153923.7
                      DIV |  131072 |    61.154 |     466 | 18.845 |  2143304.5
                      EXP |  131072 |    60.957 |     465 | 18.785 |  2150220.6
                 NTT 1E * |  262144 |     6.717 |      25 |      - | 39025000.2
                      INV |  262144 |   144.283 |     550 | 21.479 |  1816867.7
                      DIV |  262144 |   142.530 |     543 | 21.218 |  1839216.1
                      EXP |  262144 |   138.003 |     526 | 20.544 |  1899557.1
                 NTT 1E * |  524288 |    14.341 |      27 |      - | 36558504.6
                      INV |  524288 |   322.740 |     615 | 22.505 |  1624491.8
                      DIV |  524288 |   313.658 |     598 | 21.871 |  1671528.6
                      EXP |  524288 |   309.840 |     590 | 21.605 |  1692124.8
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt全在线卷积"><a class="header" href="#ntt全在线卷积">NTT・全在线卷积</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

using pii = std::pair&lt;int, int&gt;;

struct PolyRelax {
	int now = 0;
	enum : int { M0 = 1024, M = 32 };
	Poly F, G, conv;
	std::map&lt;int, Poly&gt; nf, ng;

	PolyRelax() : F(M0), G(M0), conv(M0) {}

	Poly &amp;getNf(int len) {
		auto &amp;u = nf[len];
		if (u.empty())
			u = F.cut(len).ntt(len);
		return u;
	}

	Poly &amp;getNg(int len) {
		auto &amp;u = ng[len];
		if (u.empty())
			u = G.cut(len).ntt(len);
		return u;
	}

	void set(Z v1, Z v2) {
		F[now] = v1, G[now] = v2;
		conv[now] += G[now] * F[0];
		if (now != 0)
			conv[now] += F[now] * G[0];
		now++;
	}

	Z next() { // return (F * G)[now] - F[0] G[now] - F[now] G[0]
		int len = now &amp; -now, l = now - len;
		if (now &lt; M0) {
			for (int j = (now &amp; -M0) + 1; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else if (len == now) {
			conv.redeg(len * 2);
			F.redeg(len * 2);
			G.redeg(len * 2);
			Poly a = getNg(len), &amp;b = getNf(len);
			for (int i = 0; i &lt; len; i++)
				a[i] *= b[i];
			a.intt(len);
			for (int i = len; i &lt; len * 2; i++)
				conv[i] += a[i - len] - conv[i - len];
		} else if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j) {
				conv[now] += G[j] * F[now - j] + F[j] * G[now - j];
			}
		} else {
			Poly a = G.cut(len, l), &amp;b = getNf(len * 2);
			Poly c = F.cut(len, l), &amp;d = getNg(len * 2);
			a.ntt(len * 2), c.ntt(len * 2);
			for (int i = 0; i &lt; len * 2; ++i)
				a[i] = a[i] * b[i] + c[i] * d[i];
			a.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += a[i];
		}
		return conv[now];
	}
};

Poly relax_inv(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = -F[0].inv();
	X.set(F[0], -iv0);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv0 * (X.next() - F[i] * iv0));
	return X.G.redeg(m);
}

Poly relax_div(Poly H, Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = F[0].inv();
	X.set(F[0], iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly relax_exp(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	for (int i = 0; i &lt; F.deg(); i++)
		F[i] *= i;
	X.set(F[0], 1);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv[i] * (X.next() + F[i]));
	return X.G.redeg(m);
}

Poly relax_sqrt(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = 1; // F[0].sqrt()
	X.set(iv0, iv0);
	iv0 = (iv0 * 2).inv();
	for (int i = 1; i &lt; m; i++) {
		Z t = (F[i] - X.next()) * iv0;
		X.set(t, t);
	}
	return X.F.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-relax.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.003 |    2700 | 27.000 |   370370.4
                      DIV |       1 |     0.002 |    2400 | 24.000 |   416666.7
                      EXP |       1 |     0.002 |    2300 | 23.000 |   434782.6
                     SQRT |       1 |     0.002 |    2100 | 21.000 |   476190.5
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.003 |    1350 | 27.000 |   740740.7
                      DIV |       2 |     0.002 |    1050 | 21.000 |   952381.0
                      EXP |       2 |     0.003 |    1250 | 25.000 |   800000.0
                     SQRT |       2 |     0.002 |    1150 | 23.000 |   869565.2
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                      INV |      64 |     0.007 |     114 | 10.429 |  8767123.3
                      DIV |      64 |     0.008 |     123 | 11.286 |  8101265.8
                      EXP |      64 |     0.008 |     121 | 11.143 |  8205128.2
                     SQRT |      64 |     0.007 |     115 | 10.571 |  8648648.6
                 NTT 1E * |     512 |     0.006 |      11 |      - | 86779661.0
                      INV |     512 |     0.389 |     760 | 66.000 |  1314836.6
                      DIV |     512 |     0.264 |     515 | 44.746 |  1939386.6
                      EXP |     512 |     0.328 |     639 | 55.509 |  1563349.2
                     SQRT |     512 |     0.311 |     606 | 52.627 |  1648948.0
                 NTT 1E * |    4096 |     0.065 |      15 |      - | 62918586.8
                      INV |    4096 |     2.395 |     584 | 36.788 |  1710291.8
                      DIV |    4096 |     2.848 |     695 | 43.741 |  1438447.2
                      EXP |    4096 |     3.590 |     876 | 55.142 |  1141036.1
                     SQRT |    4096 |     2.472 |     603 | 37.968 |  1657153.0
                 NTT 1E * |   16384 |     0.288 |      17 |      - | 56908253.5
                      INV |   16384 |     8.958 |     546 | 31.116 |  1828908.6
                      DIV |   16384 |     9.529 |     581 | 33.098 |  1719409.8
                      EXP |   16384 |     8.520 |     520 | 29.594 |  1922952.8
                     SQRT |   16384 |     9.246 |     564 | 32.116 |  1771965.1
                 NTT 1E * |   32768 |     0.754 |      23 |      - | 43441371.1
                      INV |   32768 |    20.684 |     631 | 27.422 |  1584203.4
                      DIV |   32768 |    18.556 |     566 | 24.600 |  1765920.2
                      EXP |   32768 |    19.851 |     605 | 26.317 |  1650683.6
                     SQRT |   32768 |    19.470 |     594 | 25.812 |  1683010.9
                 NTT 1E * |   65536 |     1.694 |      25 |      - | 38689209.4
                      INV |   65536 |    45.038 |     687 | 26.588 |  1455135.1
                      DIV |   65536 |    42.054 |     641 | 24.826 |  1558394.8
                      EXP |   65536 |    42.334 |     645 | 24.992 |  1548061.0
                     SQRT |   65536 |    42.350 |     646 | 25.001 |  1547498.8
                 NTT 1E * |  131072 |     3.031 |      23 |      - | 43239377.3
                      INV |  131072 |   104.905 |     800 | 34.607 |  1249432.0
                      DIV |  131072 |    98.422 |     750 | 32.468 |  1331734.2
                      EXP |  131072 |    95.139 |     725 | 31.385 |  1377692.2
                     SQRT |  131072 |    97.290 |     742 | 32.095 |  1347224.0
                 NTT 1E * |  262144 |     6.618 |      25 |      - | 39611812.0
                      INV |  262144 |   223.007 |     850 | 33.698 |  1175498.8
                      DIV |  262144 |   234.679 |     895 | 35.462 |  1117032.8
                      EXP |  262144 |   222.326 |     848 | 33.595 |  1179094.8
                     SQRT |  262144 |   221.451 |     844 | 33.463 |  1183757.4
                 NTT 1E * |  524288 |    14.629 |      27 |      - | 35838266.5
                      INV |  524288 |   493.548 |     941 | 33.737 |  1062284.1
                      DIV |  524288 |   490.712 |     935 | 33.543 |  1068423.2
                      EXP |  524288 |   491.871 |     938 | 33.622 |  1065904.5
                     SQRT |  524288 |   503.600 |     960 | 34.424 |  1041079.6
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并查集"><a class="header" href="#并查集">并查集</a></h1>
<pre><code class="language-cpp">// @description 朴素并查集

struct DSU {
	V&lt;int&gt; fa;
	DSU(int n) : fa(n) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		fa[x] = y;
	}
};
</code></pre>
<h2 id="测试例题-20"><a class="header" href="#测试例题-20">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/unionfind">yosupo Unionfind</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="带权并查集"><a class="header" href="#带权并查集">带权并查集</a></h1>
<pre><code class="language-cpp">// @description 带权并查集

struct DSU {
	V&lt;int&gt; fa, sz;
	DSU(int n) : fa(n), sz(n, 1) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	int size(int x) {
		return sz[find(x)];
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		if (x == y)
			return;
		if (sz[x] &gt; sz[y])
			std::swap(x, y);
		sz[y] += sz[x], fa[x] = y;
		sz[x] = 0;
	}
};
</code></pre>
<h2 id="测试例题-21"><a class="header" href="#测试例题-21">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1536">P1536 村村通</a>（也不是不能用）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="st"><a class="header" href="#st">ST</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description Sparse Table

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	void init(auto first, auto last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = max(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) const {
		int s = std::__lg(r - l + 1);
		return max(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};
</code></pre>
<h2 id="测试例题-22"><a class="header" href="#测试例题-22">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3865">P3865 ST 表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="滑动窗口"><a class="header" href="#滑动窗口">滑动窗口</a></h1>
<pre><code class="language-cpp">// @description 滑动窗口

template &lt;class T&gt;
auto sliding(const V&lt;T&gt; &amp;v, int k) {
	int l = 0, r = -1, n = v.size();
	V&lt;int&gt; q(n), ret(n);
	for (int i = 0; i &lt; n; i++) {
		while (l &lt;= r &amp;&amp; i - k &gt;= q[l])
			l++;
		while (l &lt;= r &amp;&amp; v[i] &lt; v[q[r]])
			r--;
		q[++r] = i;
		ret[i] = q[l];
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-23"><a class="header" href="#测试例题-23">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树状数组"><a class="header" href="#树状数组">树状数组</a></h1>
<pre><code class="language-cpp">// @description 树状数组

template &lt;class T&gt;
struct fwtree {
	int n;
	V&lt;T&gt; v;
	// 1 ~ N - 1
	fwtree(int a = 0) : n(a), v(n) {}
	void add(int i, T x) {
		for (; i &lt; n; i += i &amp; -i) {
			v[i] += x;
		}
	}
	void build(auto first, auto last) {
		std::copy(first, last, v.begin());
		for (int i = 1; i &lt; n; i++) {
			int j = i + (i &amp; -i);
			if (j &lt; n) {
				v[j] += v[i];
			}
		}
	}
	T sum(int i) const {
		assert(i &lt; n);
		T sum = T();
		for (; i &gt; 0; i -= i &amp; -i)
			sum += v[i];
		return sum;
	}
	T sum(int l, int r) const {
		assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt; n);
		return sum(r) - sum(l - 1);
	}
};
</code></pre>
<h2 id="测试例题-24"><a class="header" href="#测试例题-24">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/point_add_range_sum">yosupo Point Add Range Sum</a></li>
<li><a href="https://loj.ac/p/130">LOJ130 树状数组 1 ：单点修改，区间查询</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="堆"><a class="header" href="#堆">堆</a></h1>
<pre><code class="language-cpp">// @description 小根堆

template &lt;class T&gt;
struct Heap {
	V&lt;T&gt; v;
	Heap() : v(1) {}
	bool update(int p) {
		bool f = v[p] &lt; v[p / 2];
		if (f) {
			std::swap(v[p], v[p / 2]);
		}
		return !f;
	}
	T top() {
		return v[1];
	}
	void put(T x) {
		v.push_back(x);
		int p = v.size() - 1;
		while (p &gt; 1) {
			if (update(p))
				return;
			p /= 2;
		}
	}
	void pop() {
		v[1] = v.back();
		v.pop_back();
		int sz = v.size(), p = 2;
		while (p &lt; sz) {
			if (p + 1 &lt; sz &amp;&amp; v[p + 1] &lt; v[p])
				p++;
			if (update(p))
				return;
			p *= 2;
		}
	}
};
</code></pre>
<h2 id="测试例题-25"><a class="header" href="#测试例题-25">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3378">P3378 堆</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线段树"><a class="header" href="#线段树">线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树

template &lt;class Val&gt;
struct SegmentTree {
	const int N;
	V&lt;Val&gt; val;
	// 0 ~ N - 1
	SegmentTree(int n) : N(2 &lt;&lt; std::__lg(n)), val(N * 2) {
		assert(n &gt; 0);
	}
	void build(auto first, auto last) {
		std::copy(first, last, val.begin() + N);
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
	void modify(int i, Val x) {
		modify(i, x, 1, 0, N);
	}
	Val query(int l, int r) {
		return query(l, r + 1, 1, 0, N);
	}
#define lson p * 2
#define rson p * 2 + 1
  private:
	void pull(int p) {
		val[p] = val[lson] + val[rson];
	}
	void modify(int i, Val x, int p, int L, int R) {
		if (R - L == 1) {
			val[p] += x;
		} else {
			int M = (L + R) / 2;
			if (i &lt; M)
				modify(i, x, lson, L, M);
			if (i &gt;= M)
				modify(i, x, rson, M, R);
			pull(p);
		}
	}
	Val query(int l, int r, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			return val[p];
		} else {
			int M = (L + R) / 2;
			Val ret = Val();
			if (l &lt; M)
				ret = ret + query(l, r, lson, L, M);
			if (r &gt; M)
				ret = ret + query(l, r, rson, M, R);
			return ret;
		}
	}
#undef lson
#undef rson
};
</code></pre>
<h2 id="测试例题-26"><a class="header" href="#测试例题-26">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="懒标记线段树"><a class="header" href="#懒标记线段树">懒标记线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树(懒标记)

template &lt;class Val, class Tag&gt;
struct LazySegmentTree {
	const int N;
	V&lt;Val&gt; val;
	V&lt;Tag&gt; tag;
	// 0 ~ N - 1
	LazySegmentTree(int n) : N(2 &lt;&lt; std::__lg(n)), val(N * 2), tag(N * 2) {
		assert(n &gt; 0);
	}
	void build(auto first, auto last) {
		std::copy(first, last, val.begin() + N);
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
	void modify(int l, int r, Tag t) {
		modify(l, r, t, 1, 0, N);
	}
	Val query(int l, int r) {
		return query(l, r, 1, 0, N);
	}
#define lson p * 2
#define rson p * 2 + 1
  private:
	void pull(int p) {
		val[p] = val[lson] + val[rson];
	}
	void push(int p) {
		Tag &amp;tp = tag[p];
		if (tp.flag) {
			val[lson].apply(tp), tag[lson].apply(tp);
			val[rson].apply(tp), tag[rson].apply(tp);
			tp.flag = false;
		}
	}
	void modify(int l, int r, Tag t, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			val[p].apply(t);
			tag[p].apply(t);
		} else {
			int M = (L + R) / 2;
			push(p);
			if (l &lt; M)
				modify(l, r, t, lson, L, M);
			if (r &gt; M)
				modify(l, r, t, rson, M, R);
			pull(p);
		}
	}
	Val query(int l, int r, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			return val[p];
		} else {
			int M = (L + R) / 2;
			Val ret = Val();
			push(p);
			if (l &lt; M)
				ret = ret + query(l, r, lson, L, M);
			if (r &gt; M)
				ret = ret + query(l, r, rson, M, R);
			return ret;
		}
	}
#undef lson
#undef rson
};
</code></pre>
<h2 id="测试例题-27"><a class="header" href="#测试例题-27">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3372">P3372 线段树 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算几何"><a class="header" href="#计算几何">计算几何</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="点"><a class="header" href="#点">点</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-多边形"><a class="header" href="#f-多边形">F 多边形</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}

using VP = V&lt;P&gt;;

template &lt;class RET&gt;
RET ring_act(const auto &amp;v, auto &amp;&amp;func) {
	RET ret{};
	for (int i = 0; i &lt; v.size() - 1; i++)
		ret += func(v[i], v[i + 1]);
	if (v.size() &gt;= 2)
		ret += func(v.back(), v.front());
	return ret;
}

D area(const VP &amp;v) {
	return ring_act&lt;D&gt;(v, crs) / 2;
}

// 必须排序且去重！
VP convex_down(const VP &amp;ps) {
	assert(ps.size() &gt;= 2);
	VP dw;
	for (P d : ps) {
		for (int n = dw.size(); n &gt; 1; n--, dw.pop_back()) {
			if (ccw(dw[n - 2], dw[n - 1], d) == 1)
				break;
		}
		dw.push_back(d);
	}
	return dw;
}

VP convex(VP ps) {
	std::sort(ps.begin(), ps.end());
	ps.erase(std::unique(ps.begin(), ps.end()), ps.end());
	if (ps.size() &lt;= 1)
		return ps;
	VP dw = convex_down(ps);
	std::reverse(ps.begin(), ps.end());
	VP up = convex_down(ps);
	dw.insert(dw.begin(), up.begin() + 1, up.end() - 1);
	return dw;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-冲突判定"><a class="header" href="#f-冲突判定">F 冲突判定</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}

P proj(const L &amp;l, const P &amp;p) {
	P v = l.vec();
	return l.s + v * dot(v, p - l.s) / v.norm();
}

bool insSL(const L &amp;s, const L &amp;l) {
	int a = ccw(l, s.s), b = ccw(l, s.t);
	return (a % 2 == 0 || b % 2 == 0 || a != b);
}

bool insSS(const L &amp;s, const L &amp;t) {
	int a = ccw(s, t.s), b = ccw(s, t.t);
	int c = ccw(t, s.s), d = ccw(t, s.t);
	return a * b &lt;= 0 &amp;&amp; c * d &lt;= 0;
}

D distLP(const L &amp;l, const P &amp;p) {
	return std::abs(crs(l.vec(), p - l.s)) / l.abs();
}

D distSP(const L &amp;s, const P &amp;p) {
	P q = proj(s, p);
	if (ccw(s, q) == 0)
		return (p - q).abs();
	else
		return std::min((s.s - p).abs(), (s.t - p).abs());
}

D distSS(const L &amp;s, const L &amp;t) {
	if (insSS(s, t))
		return 0;
	return std::min({
		distSP(s, t.s),
		distSP(s, t.t),
		distSP(t, s.s),
		distSP(t, s.t),
	});
}

int crossLL(const L &amp;l, const L &amp;m, P &amp;r) {
	P lv = l.vec(), mv = m.vec();
	D cr1 = crs(lv, mv), cr2 = crs(lv, l.t - m.s);
	if (sgn_crs(lv, mv) == 0) {
		r = l.s;
		if (sgn_crs(lv, l.t - m.s))
			return 0;
		return -1;
	}
	r = m.s + mv * cr2 / cr1;
	return 1;
}

int crossSS(L l, L m, P &amp;r) {
	int u = crossLL(l, m, r);
	if (u == 0)
		return 0;
	if (u == -1) {
		r = std::max(std::min(l.s, l.t), std::min(m.s, m.t));
		P q = std::min(std::max(l.s, l.t), std::max(m.s, m.t));
		return (q &lt; r) ? 0 : (q == r ? 1 : -1);
	}
	if (ccw(l, r) == 0 &amp;&amp; ccw(m, r) == 0)
		return 1;
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-点--线段"><a class="header" href="#i-点--线段">I 点 &amp; 线段</a></h1>
<pre><code class="language-cpp">// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	ll x{}, y{};
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const ll &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const ll &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return P{-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, ll, *);
	OPERATOR(P, ll, /);
	ll norm() const {
		return x * x + y * y;
	}
	double abs() const {
		return std::sqrt(norm());
	}
#undef T
};

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return std::tie(l.x, l.y) &lt; std::tie(r.x, r.y);
}

inline bool operator==(const P &amp;l, const P &amp;r) {
	return l.x == r.x &amp;&amp; l.y == r.y;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	ll A, B, C;
	void reduce() {
		ll g = std::gcd(std::abs(A), std::abs(B));
		g = std::gcd(g, std::abs(C));
		A /= g, B /= g, C /= g;
		if (A &lt; 0 || (A == 0 &amp;&amp; B &lt; 0)) {
			A = -A, B = -B, C = -C;
		}
	}
	ll eval(const P &amp;p) const {
		return A * p.x + B * p.y + C;
	}
	bool on(const P &amp;p) const {
		return eval(p) == 0;
	}
	static std::optional&lt;L&gt; from(P a, P d) {
		if (d == P{0, 0})
			return std::nullopt;
		L r = {d.y, -d.x, d.x * a.y - d.y * a.x};
		r.reduce();
		return r;
	}
	static std::optional&lt;L&gt; p2(P a, P b) {
		return from(a, b - a);
	}
	static std::optional&lt;L&gt; mid(P a, P b) {
		auto [dx, dy] = b - a;
		return from((a + b) / 2, {dy, -dx});
	}
};

bool operator&lt;(const L &amp;l, const L &amp;r) {
	return std::tie(l.A, l.B, l.C) &lt; std::tie(r.A, r.B, r.C);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const L &amp;l) {
	return os &lt;&lt; &quot;L(&quot; &lt;&lt; l.A &lt;&lt; &quot;, &quot; &lt;&lt; l.B &lt;&lt; &quot;, &quot; &lt;&lt; l.C &lt;&lt; &quot;)&quot;;
}

struct S {
	P s, t;
	S(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	double abs() const {
		return vec().abs();
	}
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
