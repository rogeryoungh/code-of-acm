<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Roger Young 的板子</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<style>
  main p>code {
    color: #f14668 !important;
    background: unset !important;
  }

  main pre>code {
    tab-size: 2;
  }

  main p a,
  main ul a {
    color: #0099ff !important;
  }

  .katex-display {
    overflow: auto hidden;
  }
</style>

<link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.css">
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.js"></script>
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/contrib/auto-render.min.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true },
        { left: "\\begin{equation}", right: "\\end{equation}", display: true },
      ],
      macros: {
        "\\RR": "\\mathbb{R}",
        "\\NN": "\\mathbb{N}",
        "\\QQ": "\\mathbb{Q}",
        "\\ZZ": "\\mathbb{Z}",
        "\\CC": "\\mathbb{C}",
        "\\ee": "\\mathrm{e}",
        "\\dd": "\\mathrm{d}",
        "\\eps": "\\varepsilon",
      },
      globalGroup: true,
      throwOnError: false
    });
  });
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/mdbook-admonish.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="basic/index.html"><strong aria-hidden="true">1.</strong> 基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/vec2.html"><strong aria-hidden="true">1.1.</strong> 二维数组</a></li><li class="chapter-item expanded "><a href="basic/fastio.html"><strong aria-hidden="true">1.2.</strong> 快读</a></li><li class="chapter-item expanded "><a href="basic/qpow/qpow.html"><strong aria-hidden="true">1.3.</strong> 快速幂</a></li><li class="chapter-item expanded "><a href="basic/lower-upper.html"><strong aria-hidden="true">1.4.</strong> 二分</a></li><li class="chapter-item expanded "><a href="basic/modint/modint.html"><strong aria-hidden="true">1.5.</strong> Modint</a></li><li class="chapter-item expanded "><a href="basic/modint/runtime.html"><strong aria-hidden="true">1.6.</strong> Runtime Montgomery Modint</a></li><li class="chapter-item expanded "><a href="basic/v2pti.html"><strong aria-hidden="true">1.7.</strong> V&lt;T, count&gt;</a></li><li class="chapter-item expanded "><a href="basic/bit.html"><strong aria-hidden="true">1.8.</strong> Bit</a></li></ol></li><li class="chapter-item expanded "><a href="math/index.html"><strong aria-hidden="true">2.</strong> 数学</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="math/matrix/index.html"><strong aria-hidden="true">2.1.</strong> 矩阵</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/matrix/matrix.html"><strong aria-hidden="true">2.1.1.</strong> 矩阵</a></li><li class="chapter-item "><a href="math/matrix/qmatrix.html"><strong aria-hidden="true">2.1.2.</strong> 矩阵快速幂</a></li><li class="chapter-item "><a href="math/matrix/gauss-f64.html"><strong aria-hidden="true">2.1.3.</strong> 高斯消元・f64</a></li><li class="chapter-item "><a href="math/matrix/gauss-modint.html"><strong aria-hidden="true">2.1.4.</strong> 高斯消元・modint</a></li></ol></li><li class="chapter-item expanded "><a href="math/exgcd.html"><strong aria-hidden="true">2.2.</strong> 扩展欧几里得・EXGCD</a></li><li class="chapter-item expanded "><a href="math/sieve/euler.html"><strong aria-hidden="true">2.3.</strong> 筛法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/sieve/euler.html"><strong aria-hidden="true">2.3.1.</strong> Euler 筛・朴素</a></li><li class="chapter-item "><a href="math/sieve/euler-lpf.html"><strong aria-hidden="true">2.3.2.</strong> Euler 筛・LPF</a></li><li class="chapter-item "><a href="math/sieve/eratosthenes.html"><strong aria-hidden="true">2.3.3.</strong> Eratosthenes・朴素</a></li><li class="chapter-item "><a href="math/sieve/eratosthenes-fast.html"><strong aria-hidden="true">2.3.4.</strong> Eratosthenes・卡常</a></li></ol></li><li class="chapter-item expanded "><a href="math/factor/sieve.html"><strong aria-hidden="true">2.4.</strong> 质因分解</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/factor/bruce-force.html"><strong aria-hidden="true">2.4.1.</strong> 暴力</a></li><li class="chapter-item "><a href="math/factor/sieve.html"><strong aria-hidden="true">2.4.2.</strong> 筛优化</a></li><li class="chapter-item "><a href="math/factor/lpf.html"><strong aria-hidden="true">2.4.3.</strong> LPF 优化</a></li><li class="chapter-item "><a href="math/factor/pollard-rho.html"><strong aria-hidden="true">2.4.4.</strong> Pollard Rho</a></li></ol></li><li class="chapter-item expanded "><a href="math/crt.html"><strong aria-hidden="true">2.5.</strong> 中国剩余定理・CRT</a></li><li class="chapter-item expanded "><a href="math/excrt.html"><strong aria-hidden="true">2.6.</strong> 扩展中国剩余定理</a></li><li class="chapter-item expanded "><a href="math/miller-rabbin.html"><strong aria-hidden="true">2.7.</strong> 素性测试・Miller Rabbin</a></li><li class="chapter-item expanded "><a href="math/floor-sum.html"><strong aria-hidden="true">2.8.</strong> Floor Sum・类欧</a></li><li class="chapter-item expanded "><a href="math/cipolla.html"><strong aria-hidden="true">2.9.</strong> 二次剩余・Cipolla</a></li><li class="chapter-item expanded "><a href="math/constant/index.html"><strong aria-hidden="true">2.10.</strong> 数学常数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/pre-all/pre-all.html"><strong aria-hidden="true">2.10.1.</strong> 预处理常数</a></li><li class="chapter-item "><a href="math/pre-all/pre.html"><strong aria-hidden="true">2.10.2.</strong> 预处理常数・单独</a></li><li class="chapter-item "><a href="math/constant/stirling.html"><strong aria-hidden="true">2.10.3.</strong> 斯特林数</a></li><li class="chapter-item "><a href="math/constant/euler-phi.html"><strong aria-hidden="true">2.10.4.</strong> Euler $\varphi(n)$</a></li><li class="chapter-item "><a href="math/constant/powers.html"><strong aria-hidden="true">2.10.5.</strong> 幂表</a></li><li class="chapter-item "><a href="math/constant/tetration-mod.html"><strong aria-hidden="true">2.10.6.</strong> 指数塔</a></li></ol></li><li class="chapter-item expanded "><a href="math/interpolation/index.html"><strong aria-hidden="true">2.11.</strong> 插值</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/interpolation/lagrange1.html"><strong aria-hidden="true">2.11.1.</strong> Lagrange 插值（求值）</a></li><li class="chapter-item "><a href="math/interpolation/lagrange2.html"><strong aria-hidden="true">2.11.2.</strong> Lagrange 插值（求系数）</a></li><li class="chapter-item "><a href="math/interpolation/lagrange3.html"><strong aria-hidden="true">2.11.3.</strong> Lagrange 插值（连续）</a></li></ol></li><li class="chapter-item expanded "><a href="math/fwt/fwt.html"><strong aria-hidden="true">2.12.</strong> FWT</a></li></ol></li><li class="chapter-item expanded "><a href="string/index.html"><strong aria-hidden="true">3.</strong> 字符串</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="string/kmp.html"><strong aria-hidden="true">3.1.</strong> KMP</a></li><li class="chapter-item expanded "><a href="string/z-algorithm.html"><strong aria-hidden="true">3.2.</strong> Z 函数</a></li><li class="chapter-item expanded "><a href="string/sa-doubling.html"><strong aria-hidden="true">3.3.</strong> 后缀数组</a></li><li class="chapter-item expanded "><a href="string/manacher.html"><strong aria-hidden="true">3.4.</strong> Manacher</a></li></ol></li><li class="chapter-item expanded "><a href="graph/index.html"><strong aria-hidden="true">4.</strong> 图论</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph/shortest-path/index.html"><strong aria-hidden="true">4.1.</strong> 最短路</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/shortest-path/bellman-ford-vec.html"><strong aria-hidden="true">4.1.1.</strong> Bellman Ford・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/queue-bellman-ford-vec.html"><strong aria-hidden="true">4.1.2.</strong> 队列优化 Bellman Ford・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/dijkstra-vec.html"><strong aria-hidden="true">4.1.3.</strong> Dijkstra・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/floyd-adj.html"><strong aria-hidden="true">4.1.4.</strong> Floyd・ADJ</a></li></ol></li><li class="chapter-item expanded "><a href="graph/lca/index.html"><strong aria-hidden="true">4.2.</strong> LCA</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/lca/binary-lifting.html"><strong aria-hidden="true">4.2.1.</strong> 倍增</a></li><li class="chapter-item "><a href="graph/lca/sparse-table.html"><strong aria-hidden="true">4.2.2.</strong> ST</a></li></ol></li><li class="chapter-item expanded "><a href="graph/scc/index.html"><strong aria-hidden="true">4.3.</strong> SCC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/scc/tarjan.html"><strong aria-hidden="true">4.3.1.</strong> Tarjan</a></li><li class="chapter-item "><a href="graph/scc/kosaraju.html"><strong aria-hidden="true">4.3.2.</strong> Kosaraju</a></li></ol></li><li class="chapter-item expanded "><a href="graph/kruskal.html"><strong aria-hidden="true">4.4.</strong> 最小生成树・kruskal</a></li><li class="chapter-item expanded "><a href="graph/hld.html"><strong aria-hidden="true">4.5.</strong> 树链剖分</a></li><li class="chapter-item expanded "><a href="graph/dinic.html"><strong aria-hidden="true">4.6.</strong> Dinic</a></li></ol></li><li class="chapter-item expanded "><a href="poly/index.html"><strong aria-hidden="true">5.</strong> 多项式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="poly/fft-mul.html"><strong aria-hidden="true">5.1.</strong> FFT 乘法</a></li><li class="chapter-item expanded "><a href="poly/ntt-mul-i32.html"><strong aria-hidden="true">5.2.</strong> NTT 乘法・i32</a></li><li class="chapter-item expanded "><a href="poly/ntt-mul-mod3.html"><strong aria-hidden="true">5.3.</strong> NTT 乘法・三模</a></li><li class="chapter-item expanded "><a href="poly/ntt-naive.html"><strong aria-hidden="true">5.4.</strong> NTT $O(n^2)$</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton.html"><strong aria-hidden="true">5.5.</strong> NTT 牛顿迭代</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton-fast.html"><strong aria-hidden="true">5.6.</strong> NTT 牛顿迭代・卡常</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton-blockwise-fast.html"><strong aria-hidden="true">5.7.</strong> NTT 牛顿迭代・分块卡常</a></li><li class="chapter-item expanded "><a href="poly/ntt-taylor-shift.html"><strong aria-hidden="true">5.8.</strong> NTT 平移</a></li><li class="chapter-item expanded "><a href="poly/ntt-eval.html"><strong aria-hidden="true">5.9.</strong> NTT 多点求值 & 快速插值</a></li><li class="chapter-item expanded "><a href="poly/ntt-chirpz.html"><strong aria-hidden="true">5.10.</strong> NTT Chirp Z 变换</a></li><li class="chapter-item expanded "><a href="poly/relax/index.html"><strong aria-hidden="true">5.11.</strong> NTT 在线卷积</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="poly/relax/ntt-semi.html"><strong aria-hidden="true">5.11.1.</strong> 半在线卷积</a></li><li class="chapter-item "><a href="poly/relax/ntt-semi-fast.html"><strong aria-hidden="true">5.11.2.</strong> 半在线卷积・卡常</a></li><li class="chapter-item "><a href="poly/relax/ntt-relax.html"><strong aria-hidden="true">5.11.3.</strong> 全在线卷积</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ds/index.html"><strong aria-hidden="true">6.</strong> 数据结构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ds/dsu.html"><strong aria-hidden="true">6.1.</strong> 并查集</a></li><li class="chapter-item expanded "><a href="ds/dsu-size.html"><strong aria-hidden="true">6.2.</strong> 带权并查集</a></li><li class="chapter-item expanded "><a href="ds/sparse-table.html"><strong aria-hidden="true">6.3.</strong> ST</a></li><li class="chapter-item expanded "><a href="ds/sliding.html"><strong aria-hidden="true">6.4.</strong> 滑动窗口</a></li><li class="chapter-item expanded "><a href="ds/fwtree.html"><strong aria-hidden="true">6.5.</strong> 树状数组</a></li><li class="chapter-item expanded "><a href="ds/heap.html"><strong aria-hidden="true">6.6.</strong> 堆</a></li><li class="chapter-item expanded "><a href="ds/segtree/index.html"><strong aria-hidden="true">6.7.</strong> 线段树</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ds/segtree/segment-tree.html"><strong aria-hidden="true">6.7.1.</strong> 线段树</a></li><li class="chapter-item "><a href="ds/segtree/lazy-segment-tree.html"><strong aria-hidden="true">6.7.2.</strong> 懒标记线段树</a></li><li class="chapter-item "><a href="ds/segtree/segment-tree-2.html"><strong aria-hidden="true">6.7.3.</strong> 动态开点线段树</a></li><li class="chapter-item "><a href="ds/segtree/lazy-segment-tree-2.html"><strong aria-hidden="true">6.7.4.</strong> 动态开点懒标记线段树</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="geo/index.html"><strong aria-hidden="true">7.</strong> 计算几何</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="geo/fpoint.html"><strong aria-hidden="true">7.1.</strong> F 点 & 线段</a></li><li class="chapter-item expanded "><a href="geo/polygon.html"><strong aria-hidden="true">7.2.</strong> F 多边形</a></li><li class="chapter-item expanded "><a href="geo/intersect.html"><strong aria-hidden="true">7.3.</strong> F 冲突判定</a></li><li class="chapter-item expanded "><a href="geo/ipoint.html"><strong aria-hidden="true">7.4.</strong> I 点 & 线段</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Roger Young 的板子</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rogeryoungh/code-of-acm/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>我的初始文件。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using ll = long long;

int ____ = std::cin.tie(nullptr)-&gt;sync_with_stdio(false);

// END OF HEADER | Author: Roger Young

int main() {
	int T;
	std::cin &gt;&gt; T;
	while (T--) {
		std::cout &lt;&lt; &quot;X&quot; &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二维数组"><a class="header" href="#二维数组">二维数组</a></h1>
<p>一个简单的动态二维数组，基于 <code>vector</code>。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	std::vector&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快读"><a class="header" href="#快读">快读</a></h1>
<p>这个快读目前不能自动输出，有待以后改进。</p>
<pre><code class="language-cpp">struct Buf {
	FILE *f;
	std::vector&lt;char&gt; buf;
	char *beg, *end, *p;
	Buf(FILE *f_, int size) : f(f_), buf(size), beg(buf.data()), end(beg + size - 1), p(beg) {}
	char top() const {
		return *p;
	}
	char pop() {
		char r = *p++;
		if (p == end)
			reread();
		return r;
	}
	void reread() {
		p = std::move(p, end, beg);
		int r = std::fread(p, 1, end - p, f);
		p[r] = 0, p = beg;
	}
	void write(const char *s, int len) {
		std::fwrite(s, 1, len, f);
	}
	void flush() {
		write(beg, p - beg);
		p = beg;
	}
	void push(char s) {
		*p++ = s;
		if (p == end)
			flush();
	}
	void push(const char *s, int len) {
		if (len &lt; buf.size()) {
			if (end - p &lt;= len)
				flush();
			p = std::copy_n(s, len, p);
		} else {
			flush();
			write(s, len);
		}
	}
	void puts(const char *s) {
		while (*s != 0)
			push(*s++);
	}
};

struct FastI : Buf {
	FastI(FILE *f, int size = 1 &lt;&lt; 18) : Buf(f, size) {
		p = end, reread();
	}
	void skipSpace() {
		while (std::isspace(top()))
			pop();
	}
	FastI &amp;operator&gt;&gt;(char &amp;x) {
		skipSpace();
		x = pop();
		return *this;
	}
	FastI &amp;operator&gt;&gt;(std::string &amp;x) {
		x.resize(0);
		skipSpace();
		while (std::isgraph(top()))
			x.push_back(pop());
		return *this;
	}
	template &lt;std::integral T&gt;
	FastI &amp;operator&gt;&gt;(T &amp;x) {
		bool neg = false;
		x = 0;
		skipSpace();
		if constexpr (std::is_signed_v&lt;T&gt;)
			if (top() == '-')
				neg = true, pop();
		while (std::isdigit(top()))
			x = x * 10 + (pop() &amp; 0xf);
		if constexpr (std::is_signed_v&lt;T&gt;)
			x = neg ? -x : x;
		return *this;
	}
};

struct FastO : Buf {
	FastO(FILE *f, int size = 1 &lt;&lt; 18) : Buf(f, size) {}
	~FastO() {
		Buf::flush();
	}
	template &lt;std::integral T&gt;
	FastO &amp;operator&lt;&lt;(T x) {
		static std::array&lt;char, 48&gt; u{};
		char *r = u.data() + 40, *s = r;
		bool neg = false;
		if constexpr (std::is_signed_v&lt;T&gt;)
			if (x &lt; 0)
				neg = true, x = -x;
		do
			*--s = x % 10 + '0', x /= 10;
		while (x &gt; 0);
		if constexpr (std::is_signed_v&lt;T&gt;)
			if (neg)
				*--s = '-';
		return push(s, r - s), *this;
	}
	FastO &amp;operator&lt;&lt;(char x) {
		return push(x), *this;
	}
	FastO &amp;operator&lt;&lt;(const char *x) {
		return puts(x), *this;
	}
	FastO &amp;operator&lt;&lt;(const std::string &amp;x) {
		return push(x.c_str(), x.size()), *this;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速幂"><a class="header" href="#快速幂">快速幂</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题"><a class="header" href="#测试例题">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 快速幂</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二分"><a class="header" href="#二分">二分</a></h1>
<p>函数 <code>lower</code> 寻找区间 $[l, r)$ 中 <code>true -&gt; false</code> 的最后一个 <code>true</code>。</p>
<p>函数 <code>upper</code> 寻找区间 $[l, r)$ 中 <code>false -&gt; true</code> 的第一个 <code>true</code>。</p>
<p>若无答案，则返回 $r$。</p>
<pre><code class="language-cpp">// @description 二分

ll lower(ll l, ll r, auto check) { // last true
	if (l &gt;= r or not check(l))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m) ? l : r) = m;
	}
	return l;
}

ll upper(ll l, ll r, auto check) { // first true
	if (l &gt;= r or not check(r - 1))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m - 1) ? r : l) = m;
	}
	return l;
}
</code></pre>
<h2 id="测试例题-1"><a class="header" href="#测试例题-1">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1873">P1873 EKO / 砍树</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modint-基础类"><a class="header" href="#modint-基础类">Modint 基础类</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-montgomery-modint"><a class="header" href="#runtime-montgomery-modint">Runtime Montgomery Modint</a></h1>
<p>感谢 hly1204 送的 runtime modint。</p>
<pre><code class="language-cpp">template &lt;int&gt;
class RuntimeMontgomeryModInt {
  public:
	using i32 = std::int32_t;
	using u32 = std::uint32_t;
	using u64 = std::uint64_t;
	using m32 = RuntimeMontgomeryModInt;

	using value_type = u32;

	static u32 get_mod() {
		return mod;
	}

	static bool set_mod(u32 m) {
		if (m % 2 == 0 || m == 1 || (m &amp; (3U &lt;&lt; 30)) != 0)
			return false;
		mod = m, mod2 = mod &lt;&lt; 1;
		u32 two = 2, iv = mod * (two - mod * mod);
		iv *= two - mod * iv;
		iv *= two - mod * iv;
		r = iv * (mod * iv - two);
		r2 = -u64(mod) % mod;
		return true;
	}

	RuntimeMontgomeryModInt() = default;
	~RuntimeMontgomeryModInt() = default;

	template &lt;typename T&gt;
	RuntimeMontgomeryModInt(T v) : v_(reduce(u64(v % i32(mod) + i32(mod)) * r2)) {}

	RuntimeMontgomeryModInt(const m32 &amp;) = default;

	u32 get() const {
		return norm(reduce(v_));
	}

	template &lt;typename T&gt;
	explicit operator T() const {
		return T(get());
	}

	m32 operator-() const {
		m32 res;
		res.v_ = (mod2 &amp; -(v_ != 0)) - v_;
		return res;
	}

	m32 inv() const {
		i32 x1 = 1, x3 = 0, a = get(), b = mod;
		while (b != 0) {
			i32 q = a / b, x1_old = x1, a_old = a;
			x1 = x3, x3 = x1_old - x3 * q, a = b, b = a_old - b * q;
		}
		return m32(x1);
	}

	m32 &amp;operator=(const m32 &amp;) = default;

	m32 &amp;operator+=(const m32 &amp;rhs) {
		v_ += rhs.v_ - mod2;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator-=(const m32 &amp;rhs) {
		v_ -= rhs.v_;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator*=(const m32 &amp;rhs) {
		v_ = reduce(u64(v_) * rhs.v_);
		return *this;
	}
	m32 &amp;operator/=(const m32 &amp;rhs) {
		return operator*=(rhs.inv());
	}
	friend m32 operator+(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) += rhs;
	}
	friend m32 operator-(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) -= rhs;
	}
	friend m32 operator*(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) *= rhs;
	}
	friend m32 operator/(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) /= rhs;
	}
	friend bool operator==(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) == norm(rhs.v_);
	}
	friend bool operator!=(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) != norm(rhs.v_);
	}

	friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, m32 &amp;rhs) {
		i32 x;
		is &gt;&gt; x;
		rhs = m32(x);
		return is;
	}
	friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const m32 &amp;rhs) {
		return os &lt;&lt; rhs.get();
	}

	m32 pow(u64 y) const {
		for (m32 res(1), x(*this);; x *= x) {
			if (y &amp; 1)
				res *= x;
			if ((y /= 2) == 0)
				return res;
		}
	}

  private:
	static u32 reduce(u64 x) {
		return (x + u64(u32(x) * r) * mod) &gt;&gt; 32;
	}
	static u32 norm(u32 x) {
		return x - (mod &amp; -((mod - 1 - x) &gt;&gt; 31));
	}

	u32 v_;

	static inline u32 r, r2, mod, mod2;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vt-count"><a class="header" href="#vt-count">V&lt;T, count&gt;</a></h1>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const std::vector&lt;T&gt; &amp;v) {
	std::vector&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit"><a class="header" href="#bit">Bit</a></h1>
<pre><code class="language-cpp">inline int popcnt(std::uint64_t x) {
	return __builtin_popcountll(x);
}

inline int bsr(std::uint32_t x) {
	return 31 - __builtin_clz(x);
}

inline int bsr(std::uint64_t x) {
	return 63 - __builtin_clzll(x);
}

inline int bsf(std::uint64_t x) {
	return __builtin_ctzll(x);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学"><a class="header" href="#数学">数学</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵"><a class="header" href="#矩阵">矩阵</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵-1"><a class="header" href="#矩阵-1">矩阵</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	std::vector&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description 矩阵乘法

template &lt;class T&gt;
VV&lt;T&gt; operator*(const VV&lt;T&gt; &amp;lhs, const VV&lt;T&gt; &amp;rhs) {
	assert(lhs.y == rhs.x);
	VV&lt;T&gt; u(lhs.x, rhs.y);
	for (int i = 0; i &lt; lhs.x; i++) {
		for (int k = 0; k &lt; rhs.x; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.y; j++)
				u[i][j] += rhs[k][j] * t;
		}
	}
	return u;
}

template &lt;class T&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;is, VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.y == 0];
	return os;
}
</code></pre>
<h2 id="测试例题-2"><a class="header" href="#测试例题-2">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵快速幂"><a class="header" href="#矩阵快速幂">矩阵快速幂</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	std::vector&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description 矩阵乘法

template &lt;class T&gt;
VV&lt;T&gt; operator*(const VV&lt;T&gt; &amp;lhs, const VV&lt;T&gt; &amp;rhs) {
	assert(lhs.y == rhs.x);
	VV&lt;T&gt; u(lhs.x, rhs.y);
	for (int i = 0; i &lt; lhs.x; i++) {
		for (int k = 0; k &lt; rhs.x; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.y; j++)
				u[i][j] += rhs[k][j] * t;
		}
	}
	return u;
}

template &lt;class T&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;is, VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.y == 0];
	return os;
}

// @description 矩阵快速幂

template &lt;class T&gt;
auto make_matrix_E(int n) {
	VV&lt;T&gt; ret(n, n);
	for (int i = 0; i &lt; n; i++)
		ret[i][i] = 1;
	return ret;
}

template &lt;class T&gt;
auto matrix_pow(VV&lt;T&gt; a, ll w) {
	auto ret = make_matrix_E&lt;T&gt;(a.x);
	for (; w &gt; 0; w /= 2) {
		if (w % 2 == 1)
			ret = a * ret;
		a = a * a;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-3"><a class="header" href="#测试例题-3">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高斯消元f64"><a class="header" href="#高斯消元f64">高斯消元・f64</a></h1>
<p>求解 $n$ 元方程组</p>
<p>$$
\begin{cases}
A_{1,1} x_1 + \cdots + A_{1,n} x_n &amp;= A_{1, n+1} \\
\cdots &amp;= \cdots \\
A_{n,1} x_1 + \cdots + A_{n,n} x_n &amp;= A_{n, n+1} \\
\end{cases}
$$</p>
<p>输入以 $0$-index 的矩阵 $A$ 表示。</p>
<pre><code class="language-cpp">using f64 = double;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	std::vector&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

const f64 eps = 1E-6;

std::optional&lt;VV&lt;f64&gt;&gt; gauss(VV&lt;f64&gt; v) {
	for (int i = 0; i &lt; v.x; i++) {
		int mi = i;
		for (int j = i + 1; j &lt; v.x; j++)
			if (std::abs(v[j][i]) &gt; std::abs(v[mi][i]))
				mi = j;
		for (int j = 0; j &lt; v.y; j++)
			std::swap(v[i][j], v[mi][j]);
		if (std::abs(v[i][i]) &lt; eps)
			return std::nullopt;
		auto ivi = 1 / v[i][i];
		for (int k = v.y - 1; k &gt;= i; k--)
			v[i][k] *= ivi;
		for (int j = 0; j &lt; v.x; j++) {
			if (j != i) {
				auto tmp = v[j][i];
				for (int k = 0; k &lt; v.y; k++)
					v[j][k] -= v[i][k] * tmp;
			}
		}
	}
	return v;
}
</code></pre>
<h1 id="测试例题-4"><a class="header" href="#测试例题-4">测试例题</a></h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3389">P3389 高斯消元法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高斯消元f64-1"><a class="header" href="#高斯消元f64-1">高斯消元・f64</a></h1>
<p>求解 $n$ 元方程组</p>
<p>$$
\begin{cases}
A_{1,1} x_1 + \cdots + A_{1,n} x_n &amp;= A_{1, n+1} \\
\cdots &amp;= \cdots \\
A_{n,1} x_1 + \cdots + A_{n,n} x_n &amp;= A_{n, n+1} \\
\end{cases}
$$</p>
<p>输入以 $0$-index 的矩阵 $A$ 表示。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	std::vector&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

std::optional&lt;VV&lt;Z&gt;&gt; gauss(VV&lt;Z&gt; v) {
	for (int i = 0; i &lt; v.x; i++) {
		int mi = i;
		for (int j = i + 1; j &lt; v.x; j++) {
			if (v[j][i].v != 0) {
				mi = j;
			}
		}
		for (int j = 0; j &lt; v.y; j++)
			std::swap(v[i][j], v[mi][j]);
		if (v[i][i].v == 0)
			return std::nullopt;
		auto ivi = 1 / v[i][i];
		for (int k = v.y - 1; k &gt;= i; k--)
			v[i][k] *= ivi;
		for (int j = 0; j &lt; v.x; j++) {
			if (j != i) {
				auto tmp = v[j][i];
				for (int k = 0; k &lt; v.y; k++)
					v[j][k] -= v[i][k] * tmp;
			}
		}
	}
	return v;
}
</code></pre>
<h1 id="测试例题-5"><a class="header" href="#测试例题-5">测试例题</a></h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3389">P3389 高斯消元法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展欧几里得exgcd"><a class="header" href="#扩展欧几里得exgcd">扩展欧几里得・EXGCD</a></h1>
<p>求出方程</p>
<p>$$
ax + by = \gcd(a, b)
$$</p>
<p>的一个解 $(x, y)$，并且求出 $\gcd(a, b)$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛"><a class="header" href="#euler-筛">Euler 筛</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 线性筛

std::vector&lt;bool&gt; isp;
std::vector&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n + 1, true);
	for (int i = 2; i &lt;= n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; n / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-6"><a class="header" href="#测试例题-6">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛-1"><a class="header" href="#euler-筛-1">Euler 筛</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 线性筛

std::vector&lt;bool&gt; isp;
std::vector&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n + 1, true);
	for (int i = 2; i &lt;= n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; n / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-7"><a class="header" href="#测试例题-7">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛lpf"><a class="header" href="#euler-筛lpf">Euler 筛・LPF</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数，并且筛出最小质因子（least prime factor）。</p>
<pre><code class="language-cpp">// @description 线性筛(LPF)

std::vector&lt;int&gt; lpf, primes;
void Euler(int n) {
	lpf.resize(n + 1);
	for (int i = 2; i &lt;= n; i++) {
		if (!lpf[i])
			lpf[i] = i, primes.push_back(i);
		for (auto pj : primes) {
			if (pj &gt; n / i)
				break;
			lpf[i * pj] = pj;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-8"><a class="header" href="#测试例题-8">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eratosthenes朴素"><a class="header" href="#eratosthenes朴素">Eratosthenes（朴素）</a></h1>
<p>在 $O(n \log \log n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 埃氏筛

std::vector&lt;bool&gt; isp;
std::vector&lt;int&gt; primes;
void Eratosthenes(int n) {
	isp.resize(n + 1, true);
	for (int i = 2; i &lt;= n; i++) {
		if (isp[i]) {
			primes.push_back(i);
			for (ll j = ll(i) * i; j &lt;= n; j += i)
				isp[j] = false;
		}
	}
}
</code></pre>
<h2 id="测试例题-9"><a class="header" href="#测试例题-9">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="筛法eratosthenes卡常"><a class="header" href="#筛法eratosthenes卡常">筛法・Eratosthenes・卡常</a></h1>
<pre><code class="language-cpp">// @description 埃氏筛(卡常)

std::vector&lt;bool&gt; isp;
std::vector&lt;int&gt; primes; // 个数不精确！
void Eratosthenes(int n) {
	isp.resize(n + 6, true);
	auto f = [&amp;](int i) {
		if (isp[i]) {
			primes.push_back(i);
			for (ll j = ll(i) * i; j &lt;= n; j += i)
				isp[j] = false;
		}
	};
	f(2), f(3);
	for (int i = 5; i &lt;= n; i += 6) {
		f(i), f(i + 2);
	}
}
</code></pre>
<h2 id="测试例题-10"><a class="header" href="#测试例题-10">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解筛优化"><a class="header" href="#质因分解筛优化">质因分解・筛优化</a></h1>
<p>需要筛出 $O(\sqrt{N})$ 内的质数，后可以在 $O\left(\sqrt{\frac{N}{\log N}}\right)$ 内求出 $N$ 的所有质因子。</p>
<p>常数相对于不筛有玄学改进。</p>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const std::vector&lt;T&gt; &amp;v) {
	std::vector&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}

// @description 线性筛

std::vector&lt;bool&gt; isp;
std::vector&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n + 1, true);
	for (int i = 2; i &lt;= n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; n / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	std::vector&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解暴力"><a class="header" href="#质因分解暴力">质因分解・暴力</a></h1>
<p>可以在 $O(\sqrt{n})$ 的时间复杂度内求出 $n$ 的所有质因子。</p>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const std::vector&lt;T&gt; &amp;v) {
	std::vector&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}

// @description 因式分解

auto factor(ll n) {
	std::vector&lt;ll&gt; ret;
	for (int i = 2; 1ll * i * i &lt;= n; i++) {
		for (; n % i == 0; n /= i)
			ret.push_back(i);
	}
	if (n &gt; 1)
		ret.push_back(n);
	return ret;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解筛优化-1"><a class="header" href="#质因分解筛优化-1">质因分解・筛优化</a></h1>
<p>需要筛出 $O(\sqrt{N})$ 内的质数，后可以在 $O\left(\sqrt{\frac{N}{\log N}}\right)$ 内求出 $N$ 的所有质因子。</p>
<p>常数相对于不筛有玄学改进。</p>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const std::vector&lt;T&gt; &amp;v) {
	std::vector&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}

// @description 线性筛

std::vector&lt;bool&gt; isp;
std::vector&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n + 1, true);
	for (int i = 2; i &lt;= n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; n / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	std::vector&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解lpf-优化"><a class="header" href="#质因分解lpf-优化">质因分解・LPF 优化</a></h1>
<p>需要 $O(N)$ 预处理，后可以在 $O(\log{n})$ 内求出 $n(n \leqslant N)$ 的所有质因子。</p>
<p>仅在 $N$ 较小时有用。</p>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const std::vector&lt;T&gt; &amp;v) {
	std::vector&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}

// @description 线性筛(LPF)

std::vector&lt;int&gt; lpf, primes;
void Euler(int n) {
	lpf.resize(n + 1);
	for (int i = 2; i &lt;= n; i++) {
		if (!lpf[i])
			lpf[i] = i, primes.push_back(i);
		for (auto pj : primes) {
			if (pj &gt; n / i)
				break;
			lpf[i * pj] = pj;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	std::vector&lt;ll&gt; ret;
	for (; n &gt; 1; n /= lpf[n])
		ret.push_back(lpf[n]);
	return ret;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解pollard-rho"><a class="header" href="#质因分解pollard-rho">质因分解・Pollard Rho</a></h1>
<p>Pollard Rho 算法可以在 $O(n^{0.25})$ 的期望复杂度内计算出 $n$ 的一个因子，可以用于 $10^{18}$ 内的因式分解。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = 1 % m;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(a) * ret % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}

// @description Pollard Rho

ll pollard_rho(ll N) {
	if (N % 2 == 0)
		return 2;
	if (miller_rabbin(N))
		return N;
	while (true) {
		auto f = [N, c = rand() % (N - 1) + 1](ll x) {
			return (i128(x) * x + c) % N;
		};
		ll x = 0, y = 0, p = 1, q = 1;
		do {
			int w = 128;
			do {
				p = q, x = f(x), y = f(f(y));
				q = i128(p) * std::abs(x - y) % N;
			} while (w-- &amp;&amp; q != 0);
			ll d = std::__gcd(p, N);
			if (d &gt; 1 &amp;&amp; d != N)
				return d;
		} while (x != y);
	}
}

auto factor(ll x) {
	std::vector&lt;ll&gt; v;
	if (x == 1)
		return v;
	std::function&lt;void(ll)&gt; dfs = [&amp;](ll u) {
		ll fac = pollard_rho(u);
		if (fac == u)
			v.push_back(u);
		else
			dfs(fac), dfs(u / fac);
	};
	dfs(x);
	sort(v.begin(), v.end());
	return v;
}
</code></pre>
<h2 id="备注"><a class="header" href="#备注">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline ll mul_mod(ll a, ll b, ll m) {
	ll c = a * b - ll(f80(a) / m * b + 0.5) * m;
	return c &lt; 0 ? c + m : (c &gt;= m ? c - m : c);
}
</code></pre>
<h2 id="测试例题-11"><a class="header" href="#测试例题-11">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4718">P4718 Pollard-Rho算法</a></li>
<li><a href="https://judge.yosupo.jp/problem/factorize">yosupo Factorize</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中国剩余定理"><a class="header" href="#中国剩余定理">中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>保证 $\{m_i\}$ 互质。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 中国剩余定理

template &lt;class PAIR&gt;
ll crt(const std::vector&lt;PAIR&gt; &amp;am) {
	ll prod = 1, ret = 0;
	for (auto [a, m] : am)
		prod *= m;
	for (auto [a, m] : am) {
		ll u = prod / m, v = inv_gcd(u, m);
		ret = (ret + a * u * v) % prod;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-12"><a class="header" href="#测试例题-12">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1495">P1495 中国剩余定理（CRT）/ 曹冲养猪</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展中国剩余定理"><a class="header" href="#扩展中国剩余定理">扩展中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>不保证 $\{m_i\}$ 互质，但保证 $\operatorname{lcm}(m_i) &lt; 10^{18}$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 扩展中国剩余定理

using i128 = __int128_t;

template&lt;class PAIR&gt;
ll excrt(const std::vector&lt;PAIR&gt; &amp;am) {
	auto [ans, M] = am[0];
	for (auto [a, m] : am) {
		if (M % m == 0 &amp;&amp; ans % m == a)
			continue;
		ll B = (a - ans % m + m) % m;
		auto [x, y, g] = exgcd(M, m);
		if (B % g != 0)
			return -1;
		x = i128(x) * (B / g) % (m / g);
		ans += M * x, M *= m /g;
		ans = (ans + M) % M;
	}
	return ans;
}
</code></pre>
<h2 id="测试例题-13"><a class="header" href="#测试例题-13">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4777">P4777 扩展中国剩余定理（EXCRT）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="素性测试miller-rabbin"><a class="header" href="#素性测试miller-rabbin">素性测试（Miller Rabbin）</a></h1>
<p>快速判断 $10^{18}$ 内的数字是否为素数。</p>
<p>若选取 $k$ 个素数为基底，那么复杂度大概是 $O(k \log n)$，错误率为 $4^{-k}$。</p>
<p>下方代码的基底在 $2^{64}$ 内没有例外。更多基底有关的可以查看 <a href="https://miller-rabin.appspot.com">SPRP Base</a>。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = 1 % m;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(a) * ret % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}
</code></pre>
<h2 id="备注-1"><a class="header" href="#备注-1">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline ll mul_mod(ll a, ll b, ll m) {
	ll c = a * b - ll(f80(a) / m * b + 0.5) * m;
	return c &lt; 0 ? c + m : (c &gt;= m ? c - m : c);
}
</code></pre>
<h2 id="测试例题-14"><a class="header" href="#测试例题-14">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/143">LOJ143 质数判定</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor-sum"><a class="header" href="#floor-sum">Floor Sum</a></h1>
<p>在 $O(\log n)$ 的时间内计算</p>
<p>$$
\sum_{x=0}^n \left\lfloor \frac{ax + b}{c} \right\rfloor
$$</p>
<pre><code class="language-cpp">// @description 类欧几里得算法

ll floor_sum(ll a, ll b, ll c, ll n) {
	ll m = (a * n + b) / c, S1 = n * (n + 1) / 2;
	if (a == 0) {
		return b / c * (n + 1);
	} else if (a &gt;= c || b &gt;= c) {
		ll f = S1 * (a / c) + b / c * (n + 1);
		return f + floor_sum(a % c, b % c, c, n);
	} else {
		return m * n - floor_sum(c, c - b - 1, a, m - 1);
	}
}
</code></pre>
<h2 id="测试例题-15"><a class="header" href="#测试例题-15">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5171">P5171 Earthquake</a></li>
<li><a href="https://judge.yosupo.jp/problem/sum_of_floor_of_linear">yosupo Sum of Floor of Linear</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二次剩余cipolla"><a class="header" href="#二次剩余cipolla">二次剩余（Cipolla）</a></h1>
<p>Cipolla 算法可以在 $O(\log P)$ 的时间内求出</p>
<p>$$
x^2 \equiv N \pmod P
$$</p>
<p>即模平方根。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 二次剩余(cipolla)

int legendre(int a, int p) {
	return qpow(a, (p - 1) / 2, p);
}

std::optional&lt;int&gt; cipolla(int n, int p) {
	if (n == 0)
		return 0;
	if (legendre(n, p) != 1)
		return std::nullopt;
	if (p == 2)
		return 1;
	for (int a = 0; a &lt; p; a++) {
		int i = (a * a - n + p) % p;
		using FP2 = std::pair&lt;ll, ll&gt;;
		auto mul = [p, i](const FP2 &amp;l, const FP2 &amp;r) {
			auto [la, lb] = l;
			auto [ra, rb] = r;
			return FP2{(la * ra + lb * rb % p * i) % p, (lb * ra + la * rb) % p};
		};
		if (legendre(i, p) == p - 1) {
			FP2 x = {1, 1}, u = {a, 1};
			for (int b = (p + 1) / 2; b; b /= 2) {
				if (b % 2 == 1)
					x = mul(x, u);
				u = mul(u, u);
			}
			return std::min(x.first, p - x.first);
		}
	}
	return std::nullopt;
}
</code></pre>
<h2 id="测试例题-16"><a class="header" href="#测试例题-16">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5491">P5491 二次剩余</a></li>
<li><a href="https://judge.yosupo.jp/problem/sqrt_mod">yosupo Sqrt Mod</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学常数"><a class="header" href="#数学常数">数学常数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数"><a class="header" href="#预处理常数">预处理常数</a></h1>
<h2 id="math-p"><a class="header" href="#math-p">MATH-P</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;int&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt; l)
		return;
	iv = fac = ifac = std::vector&lt;int&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n] = qpow(fac[n]), iv[n] = qpow(n);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
		iv[i] = 1ll * ifac[i] * fac[i - 1] % P;
	}
	pre_all(u);
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
</code></pre>
<h2 id="math-modint"><a class="header" href="#math-modint">MATH-MODINT</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数-1"><a class="header" href="#预处理常数-1">预处理常数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

std::vector&lt;int&gt; iv{1, 1}, fac{1}, ifac{1};

// @description 预处理逆元

void pre_inv(int n) {
	iv.resize(n + 1);
	for (int i = 2; i &lt;= n; i++) {
		iv[i] = 1ll * iv[P % i] * (P - P / i) % P;
	}
}

// @description 预处理阶乘

void pre_fac(int n) {
	fac.resize(n + 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
}

// @description 预处理阶乘逆元

void pre_ifac(int n) {
	ifac.resize(n + 1);
	ifac[n] = qpow(fac[n]);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	}
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="斯特林数"><a class="header" href="#斯特林数">斯特林数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly ln(int m) const {
		assert(T[0].v == 1);
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 48E
		assert(T[0].v == 0);
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = x * (cut(t) - x.ln(t) + Poly{1}), x.redeg(t);
		}
		return x.redeg(m);
	}
	Poly sqrt(int m) const { // 36E
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = (x + cut(t).div(t, x)) * ((P + 1) / 2);
		}
		return x.redeg(m);
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
	friend auto operator%(const Poly &amp;f, const Poly &amp;g) {
		Poly Q = f / g;
		return make_pair(Q, (f - Q * g).redeg(g.deg() - 1));
	}
#undef T
};

Poly taylor_shift(const Poly &amp;f, Z c) {
	int n = f.deg();
	Poly A(n), B(n);
	Z ci = 1;
	for (int i = 0; i &lt; n; i++) {
		A[i] = f[i] * fac[i];
		B[i] = ci * ifac[i];
		ci *= c;
	}
	std::reverse(A.begin(), A.end());
	A = A * B;
	for (int i = 0; i &lt; n; i++) {
		B[i] = A[n - i - 1] * ifac[i];
	}
	return B;
}

Poly pow_safe(const Poly &amp;g, int m, int k1, int k2) { // k % P, k % (P - 1)
	int pos = 0;
	while (pos &lt; g.deg() &amp;&amp; g[pos].v == 0) {
		++pos;
	}
	if (pos == g.deg() || pos &gt; (m - 1) / k1) {
		return Poly(m, 0);
	}
	Z x = g[pos];
	Poly f = Poly(g.begin() + pos, g.end()) * x.inv();
	f = f.pow(m - pos * k1, k1) * x.pow(k2);
	f.insert(f.begin(), pos * k1, 0);
	assert(f.deg() == m);
	return f;
}

Poly stirling1st_row(int n) {
	if (n == 0)
		return {0};
	Poly f = stirling1st_row(n / 2);
	Poly r = f * taylor_shift(f, n / 2);
	if (n % 2 == 1) {
		r *= Poly{n - 1, 1};
	}
	return r;
}

Poly stirling1st_col(int n, int k) {
	n++;
	Poly r = {1, P - 1};
	r = pow_safe(r.ln(n), n, k, k);
	Z xk = Z(P - 1).pow(k) * ifac[k];
	for (int i = 0; i &lt; n; i++) {
		r[i] *= fac[i] * xk;
	}
	return r;
}

Poly stirling2st_row(int n) {
	n++;
	Poly A(n), B(n);
	for (int i = 0; i &lt; n; i++) {
		A[i] = i % 2 == 1 ? -ifac[i] : ifac[i];
		B[i] = Z(i).pow(n - 1) * ifac[i];
	}
	return (A * B).redeg(n);
}

Poly stirling2st_col(int n, int k) {
	if (n &lt; k)
		return Poly(n + 1);
	std::function&lt;Poly(int)&gt; sol = [&amp;](int u) -&gt; Poly {
		if (u == 0)
			return {1};
		Poly f = sol(u / 2);
		f *= taylor_shift(f, P - u / 2);
		if (u % 2 == 1)
			f *= Poly{-u, 1};
		return f;
	};
	Poly f = sol(k).rev().inv(n - k + 1);
	f.insert(f.begin(), k, 0);
	return f;
}
</code></pre>
<h2 id="测试例题-17"><a class="header" href="#测试例题-17">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5395">P5395 第二类斯特林数·行</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5396">P5396 第二类斯特林数·列</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5409">P5409 第一类斯特林数·列</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5409">P5409 第一类斯特林数·列</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-varphin-函数"><a class="header" href="#euler-varphin-函数">Euler $\varphi(n)$ 函数</a></h1>
<p>需要用筛预处理 $O(\sqrt{N})$ 内的质数，每次求值复杂度 $O(\sqrt{N})$。</p>
<pre><code class="language-cpp">// @description 线性筛

std::vector&lt;bool&gt; isp;
std::vector&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n + 1, true);
	for (int i = 2; i &lt;= n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; n / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

ll euler_phi(ll x) {
	ll ans = 1;
	for (int p : primes) {
		if (1ll * p * p &gt; x)
			break;
		if (x % p == 0)
			x /= p, ans *= p - 1;
		while (x % p == 0)
			x /= p, ans *= p;
	}
	if (x &gt; 1)
		ans *= x - 1;
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="幂表"><a class="header" href="#幂表">幂表</a></h1>
<p>在 $O(n)$ 的时间内，求 $0^k, 1^k, \cdots, n^k$。</p>
<p>除了卡常以外没什么用。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

auto powers(int n, int k, int mod) {
	std::vector&lt;bool&gt; isp(n + 1, true);
	std::vector&lt;int&gt; pw(n + 1, 1);
	for (int p = 2; p &lt;= n; ++p)
		if (isp[p]) {
			for (ll j = ll(p) * p; j &lt;= n; j += p)
				isp[j] = false;
			int q = qpow(p, k, mod);
			for (int i = 1; i &lt;= n / p; ++i)
				pw[i * p] = ll(q) * pw[i] % mod;
		}
	pw[0] = qpow(0, k, mod);
	return pw;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指数塔"><a class="header" href="#指数塔">指数塔</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 线性筛

std::vector&lt;bool&gt; isp;
std::vector&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n + 1, true);
	for (int i = 2; i &lt;= n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; n / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

int euler_phi(ll x) {
	ll ans = 1;
	for (int p : primes) {
		if (1ll * p * p &gt; x)
			break;
		if (x % p == 0)
			x /= p, ans *= p - 1;
		while (x % p == 0)
			x /= p, ans *= p;
	}
	if (x &gt; 1)
		ans *= x - 1;
	return ans;
}

int tetration_mod(int a, int b, int m) {
	if (m == 1)
		return 0;
	if (a == 0)
		return (b + 1) % 2;
	if (b == 0)
		return 1;
	if (b == 1)
		return a % m;
	if (a == 2 &amp;&amp; b &lt;= 4) {
		static const std::array ans = {1, 2, 4, 16, 65536};
		return ans[b] % m;
	}
	int phi = euler_phi(m);
	int d = tetration_mod(a, b - 1, phi) + phi;
	return qpow(a % m, d, m);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插值"><a class="header" href="#插值">插值</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值"><a class="header" href="#lagrange-插值">Lagrange 插值</a></h1>
<h2 id="math-p-1"><a class="header" href="#math-p-1">MATH-P</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 拉格朗日插值

int lagrange(const std::vector&lt;int&gt; &amp;x, const std::vector&lt;int&gt; &amp;y, int k) {
	int sum = 0, n = x.size();
	for (int i = 0; i &lt; n; i++) {
		int s1 = 1, s2 = 1;
		for (int j = 0; j &lt; n; j++) {
			if (j == i)
				continue;
			s1 = 1ll * s1 * (k - x[j] + P) % P;
			s2 = 1ll * s2 * (x[i] - x[j] + P) % P;
		}
		sum += 1ll * s1 * qpow(s2) % P * y[i] % P;
	}
	return sum % P;
}
</code></pre>
<h2 id="math-modint-1"><a class="header" href="#math-modint-1">MATH-MODINT</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

Z lagrange(const std::vector&lt;Z&gt; &amp;x, const std::vector&lt;Z&gt; &amp;y, Z k) {
	int n = x.size();
	Z sum = 0;
	for (int i = 0; i &lt; n; i++) {
		Z s1 = 1, s2 = 1;
		for (int j = 0; j &lt; n; j++)
			if (j != i)
				s1 *= k - x[j], s2 *= x[i] - x[j];
		sum += s1 / s2 * y[i];
	}
	return sum;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值-1"><a class="header" href="#lagrange-插值-1">Lagrange 插值</a></h1>
<h2 id="math-p-2"><a class="header" href="#math-p-2">MATH-P</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 拉格朗日插值

auto lagrange(const std::vector&lt;int&gt; &amp;x, const std::vector&lt;int&gt; &amp;y) {
	int n = x.size();
	std::vector&lt;int&gt; d(n), u(n + 1), t(n);
	u[0] = 1;
	for (int i = 0; i &lt; n; i++) {
		for (int j = i + 1; j &gt;= 1; j--)
			u[j] = (u[j - 1] + 1ll * (P - u[j]) * x[i]) % P;
		u[0] = 1ll * u[0] * (P - x[i]) % P;
	}
	for (int i = 0; i &lt; n; i++) {
		int s2 = 1;
		for (int j = n; j &gt;= 1; j--) {
			t[j - 1] = j == n ? u[n] : (u[j] + 1ll * x[i] * t[j]) % P;
			if (j - 1 != i)
				s2 = 1ll * s2 * (x[i] - x[j - 1] + P) % P;
		}
		s2 = qpow(s2);
		for (int j = 0; j &lt; n; j++)
			d[j] = (d[j] + 1ll * t[j] * s2 % P * y[i]) % P;
	}
	return d;
}
</code></pre>
<h2 id="math-modint-2"><a class="header" href="#math-modint-2">MATH-MODINT</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

auto lagrange(const std::vector&lt;Z&gt; &amp;x, const std::vector&lt;Z&gt; &amp;y) {
	int n = x.size();
	std::vector&lt;Z&gt; d(n), u(n + 1), t(n);
	u[0] = 1;
	for (int i = 0; i &lt; n; i++) {
		for (int j = i + 1; j &gt;= 1; j--)
			u[j] = u[j - 1] - u[j] * x[i];
		u[0] *= -x[i];
	}
	for (int i = 0; i &lt; n; i++) {
		Z s2 = 1;
		for (int j = n; j &gt;= 1; j--) {
			t[j - 1] = j == n ? u[n] : u[j] + x[i] * t[j];
			if (j - 1 != i)
				s2 = s2 * (x[i] - x[j - 1]);
		}
		s2 = s2.inv();
		for (int j = 0; j &lt; n; j++)
			d[j] += t[j] * s2 * y[i];
	}
	return d;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值-2"><a class="header" href="#lagrange-插值-2">Lagrange 插值</a></h1>
<h2 id="math-p-3"><a class="header" href="#math-p-3">MATH-P</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 拉格朗日插值

int lagrange(const std::vector&lt;int&gt; &amp;y, int x) {
	int n = y.size();
	if (0 &lt;= x &amp;&amp; x &lt; n)
		return y[x];
	std::vector&lt;int&gt; pl(n + 2, 1), pr(n + 2, 1), fac(n + 2, 1);
	for (int i = 0; i &lt; n; i++)
		pl[i + 1] = 1ll * pl[i] * (x - i) % P;
	for (int i = n - 1; i &gt;= 0; i--)
		pr[i] = 1ll * pr[i + 1] * (x - i) % P;
	for (int i = 1; i &lt; n; i++)
		fac[i] = 1ll * fac[i - 1] * i % P;
	int ans = 0;
	for (int i = 0; i &lt; n; i++) {
		int s1 = 1ll * pl[i] * pr[i + 1] % P;
		int t = (n - i) % 2 == 0 ? P - 1 : 1;
		int s2 = 1ll * fac[i] * fac[n - i - 1] % P * t % P;
		ans = (ans + 1ll * s1 % P * qpow(s2) % P * y[i]) % P;
	}
	return ans;
}
</code></pre>
<h2 id="math-modint-3"><a class="header" href="#math-modint-3">MATH-MODINT</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

Z lagrange(const std::vector&lt;Z&gt; &amp;y, int x) {
	int n = y.size();
	if (0 &lt;= x &amp;&amp; x &lt; n)
		return y[x];
	std::vector&lt;Z&gt; pl(n + 2, 1), pr(n + 2, 1), fac(n + 2, 1);
	for (int i = 0; i &lt; n; i++)
		pl[i + 1] = pl[i] * (x - i);
	for (int i = n - 1; i &gt;= 0; i--)
		pr[i] = pr[i + 1] * (x - i);
	for (int i = 1; i &lt; n; i++)
		fac[i] = fac[i - 1] * i;
	Z ans = 0;
	for (int i = 0; i &lt; n; i++) {
		Z s1 = pl[i] * pr[i + 1];
		Z t = (n - i) % 2 == 0 ? -1 : 1;
		Z s2 = fac[i] * fac[n - i - 1] * t;
		ans += s1 / s2 * y[i];
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fwt"><a class="header" href="#fwt">FWT</a></h1>
<pre><code class="language-cpp">inline int popcnt(std::uint64_t x) {
	return __builtin_popcountll(x);
}

inline int bsr(std::uint32_t x) {
	return 31 - __builtin_clz(x);
}

inline int bsr(std::uint64_t x) {
	return 63 - __builtin_clzll(x);
}

inline int bsf(std::uint64_t x) {
	return __builtin_ctzll(x);
}

const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

template &lt;bool inv&gt;
void OR(auto f, int n) {
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++)
				if (inv)
					f[i + j + k] = mo(f[i + j + k] - f[i + j] + P);
				else
					f[i + j + k] = mo(f[i + j + k] + f[i + j]);
}

template &lt;bool inv&gt;
void AND(auto f, int n) {
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++)
				if (inv)
					f[i + j] = mo(f[i + j] - f[i + j + k] + P);
				else
					f[i + j] = mo(f[i + j] + f[i + j + k]);
}

template &lt;bool inv&gt;
void XOR(auto f, int n) {
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++) {
				int u = f[i + j], v = f[i + j + k];
				f[i + j] = mo(u + v);
				f[i + j + k] = mo(u - v + P);
			}
	if (inv) {
		const int ivn = P - (P - 1) / n;
		for (int i = 0; i &lt; n; i++)
			f[i] = 1ll * f[i] * ivn % P;
	}
}

auto subset_conv(const std::vector&lt;int&gt; &amp;f, const std::vector&lt;int&gt; &amp;g) {
	int N = f.size(), n = std::__lg(f.size());
	std::vector&lt;std::vector&lt;int&gt;&gt; nf, ng, nr;
	nf = ng = nr = std::vector&lt;std::vector&lt;int&gt;&gt;(n + 1, std::vector&lt;int&gt;(N));
	for (int i = 0; i &lt; N; i++)
		nf[popcnt(i)][i] = f[i], ng[popcnt(i)][i] = g[i];
	for (int i = 0; i &lt;= n; i++)
		OR&lt;0&gt;(nf[i].begin(), N), OR&lt;0&gt;(ng[i].begin(), N);
	for (int i = 0; i &lt;= n; i++)
		for (int j = 0; j &lt;= n - i; j++)
			for (int k = 0; k &lt; N; k++)
				nr[i + j][k] = (nr[i + j][k] + 1ll * nf[i][k] * ng[j][k]) % P;
	for (int i = 0; i &lt;= n; i++)
		OR&lt;1&gt;(nr[i].begin(), N);
	std::vector&lt;int&gt; r(N);
	for (int i = 0; i &lt; N; i++)
		r[i] = nr[popcnt(i)][i];
	return r;
}
</code></pre>
<pre><code class="language-cpp">inline int popcnt(std::uint64_t x) {
	return __builtin_popcountll(x);
}

inline int bsr(std::uint32_t x) {
	return 31 - __builtin_clz(x);
}

inline int bsr(std::uint64_t x) {
	return 63 - __builtin_clzll(x);
}

inline int bsf(std::uint64_t x) {
	return __builtin_ctzll(x);
}

const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

template &lt;bool inv&gt;
void OR(auto f, int n) {
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++)
				if (inv)
					f[i + j + k] -= f[i + j];
				else
					f[i + j + k] += f[i + j];
}

template &lt;bool inv&gt;
void AND(auto f, int n) {
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++)
				if (inv)
					f[i + j] -= f[i + j + k];
				else
					f[i + j] += f[i + j + k];
}

template &lt;bool inv&gt;
void XOR(auto f, int n) {
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++) {
				Z u = f[i + j], v = f[i + j + k];
				f[i + j] = u + v;
				f[i + j + k] = u - v;
			}
	if (inv) {
		const Z ivn = P - (P - 1) / n;
		for (int i = 0; i &lt; n; i++)
			f[i] *= ivn;
	}
}

auto subset_conv(const std::vector&lt;Z&gt; &amp;f, const std::vector&lt;Z&gt; &amp;g) {
	int N = f.size(), n = std::__lg(f.size());
	std::vector&lt;std::vector&lt;Z&gt;&gt; nf, ng, nr;
	nf = ng = nr = std::vector&lt;std::vector&lt;Z&gt;&gt;(n + 1, std::vector&lt;Z&gt;(N));
	for (int i = 0; i &lt; N; i++)
		nf[popcnt(i)][i] = f[i], ng[popcnt(i)][i] = g[i];
	for (int i = 0; i &lt;= n; i++)
		OR&lt;0&gt;(nf[i].begin(), N), OR&lt;0&gt;(ng[i], N);
	for (int i = 0; i &lt;= n; i++)
		for (int j = 0; j &lt;= n - i; j++)
			for (int k = 0; k &lt; N; k++)
				nr[i + j][k] += nf[i][k] * ng[j][k];
	for (int i = 0; i &lt;= n; i++)
		OR&lt;1&gt;(nr[i], N);
	std::vector&lt;Z&gt; r(N);
	for (int i = 0; i &lt; N; i++)
		r[i] = nr[popcnt(i)][i];
	return r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<pre><code class="language-cpp">auto pre_kmp(const std::string &amp;s) {
	int n = s.length();
	std::vector&lt;int&gt; pi(n + 1);
	for (int i = 1; i &lt; n; i++) {
		int j = pi[i];
		while (j &gt; 0 &amp;&amp; s[i] != s[j])
			j = pi[j];
		pi[i + 1] = j + (s[i] == s[j]);
	}
	return pi;
}

auto kmp(const std::string &amp;s, const std::string &amp;t) {
	auto pi = pre_kmp(s);
	int n = t.length();
	std::vector&lt;int&gt; p(n + 1);
	for (int i = 0; i &lt; n; i++) {
		int j = p[i];
		while (j &gt; 0 &amp;&amp; t[i] != s[j])
			j = pi[j];
		p[i + 1] = j + (t[i] == s[j]);
	}
	return std::make_pair(pi, p);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="z-函数"><a class="header" href="#z-函数">Z 函数</a></h1>
<pre><code class="language-cpp">auto pre_z_algo(const std::string &amp;s) {
	int n = s.length();
	std::vector&lt;int&gt; z(n + 1);
	z[1] = n;
	for (int i = 1, l = -1, r = 0; i &lt; n; i++) {
		int &amp;k = z[i + 1], u = r - i;
		if (u &gt; 0)
			k = std::min(u, z[i - l + 1]);
		while (i + k &lt; n &amp;&amp; s[k] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return z;
}

auto z_algo(const std::string &amp;s, const std::string &amp;t) {
	auto z = pre_z_algo(s);
	int n = t.length();
	std::vector&lt;int&gt; z2(n + 1);
	for (int i = 0, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = z2[i + 1], u = r - i;
		if (u &gt; 0)
			k = std::min(u, z[i - l + 1]);
		while (i + k &lt; n &amp;&amp; s[k] == t[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return std::make_pair(z, z2);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后缀数组"><a class="header" href="#后缀数组">后缀数组</a></h1>
<pre><code class="language-cpp">auto sa_doubleing(auto first, auto last, int m = 128) {
	int n = last - first;
	std::vector&lt;int&gt; cnt(std::max(n, m)), sa(n), rk(n + 1, -1), id(n + 1, -1);
	std::copy(first, last, rk.begin());
	for (int i = 0; i &lt; n; i++)
		cnt[rk[i]]++;
	for (int i = 1; i &lt; m; i++)
		cnt[i] += cnt[i - 1];
	for (int i = n - 1; i &gt;= 0; i--)
		sa[--cnt[rk[i]]] = i;
	for (int k = 1; k &lt; n; k *= 2) {
		int p = 0;
		for (int i = n - k; i &lt; n; i++)
			id[p++] = i;
		for (int i = 0; i &lt; n; i++)
			if (sa[i] &gt;= k)
				id[p++] = sa[i] - k;
		std::fill(cnt.begin(), cnt.end(), 0);
		for (int i = 0; i &lt; n; i++)
			cnt[rk[i]]++;
		for (int i = 1; i &lt; m; i++)
			cnt[i] += cnt[i - 1];
		for (int i = n - 1; i &gt;= 0; i--)
			sa[--cnt[rk[id[i]]]] = id[i];
		std::fill(id.begin(), id.end(), -1);
		std::swap(rk, id);
		rk[sa[0]] = 0, p = 0;
		for (int i = 1; i &lt; n; i++) {
			bool f = id[sa[i]] == id[sa[i - 1]] &amp;&amp; id[sa[i] + k] == id[sa[i - 1] + k];
			rk[sa[i]] = f ? p : ++p;
		}
		if (p == n - 1)
			break;
		m = p + 1;
	}
	return sa;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<pre><code class="language-cpp">// @description Manacher

template &lt;int o&gt;
auto manacher(const std::string &amp;s) {
	int n = s.size();
	std::vector&lt;int&gt; m(n);
	m[0] = o == 0;
	for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = m[i], u = r - i;
		if (u &gt; 0)
			k = std::min(u, m[2 * l - i]);
		while (0 &lt;= i - k - o &amp;&amp; i + k &lt; n &amp;&amp; s[i - k - o] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return m;
}

std::vector&lt;int&gt; manacher_odd(const std::string &amp;s) {
	return manacher&lt;0&gt;(s);
}

std::vector&lt;int&gt; manacher_even(const std::string &amp;s) {
	return manacher&lt;1&gt;(s);
}
</code></pre>
<h2 id="测试例题-18"><a class="header" href="#测试例题-18">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3805">P3805 manacher 算法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图论"><a class="header" href="#图论">图论</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路"><a class="header" href="#最短路">最短路</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路bellman-fordvec"><a class="header" href="#最短路bellman-fordvec">最短路・Bellman Ford・VEC</a></h1>
<p>对于 $n$ 个点 $m$ 条边的图，可以在 $O(nm)$ 的时间内求出来源点 $s$ 到所有点的最短路，并且求出路径。</p>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = std::vector&lt;std::vector&lt;Edge&lt;D&gt;&gt;&gt;;

// @description Bellman Ford 最短路

template &lt;class D&gt;
auto bellman_ford(const Edges&lt;D&gt; &amp;E, int s) {
	int n = E.size();
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	dis[s] = 0, from[s] = s;
	bool flag = true;
	for (int k = 0; k &lt; n &amp;&amp; flag; k++) {
		flag = false;
		for (int u = 0; u &lt; n; u++) {
			for (auto [v, w] : E[u]) {
				int d2 = dis[u] + w;
				if (dis[v] &gt; d2)
					dis[v] = d2, from[v] = u, flag = true;
			}
		}
	}
	return std::make_pair(dis, from);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路队列优化-bellman-fordvec"><a class="header" href="#最短路队列优化-bellman-fordvec">最短路・队列优化 Bellman Ford・VEC</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = std::vector&lt;std::vector&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 队列优化 Bellman Ford 最短路

template &lt;class D&gt;
auto queue_bellman_ford(const Edges&lt;D&gt; &amp;G, int s) {
	int n = G.size();
	std::queue&lt;int&gt; q;
	std::vector&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	std::vector&lt;int&gt; from(n, -1);
	dis[s] = 0, from[s] = s;
	q.push(s);
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (auto [v, w] : G[u]) {
			int d2 = dis[u] + w;
			if (dis[v] &gt; d2)
				dis[v] = d2, from[v] = u, q.push(v);
		}
	}
	return std::make_pair(dis, from);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路dijkstra"><a class="header" href="#最短路dijkstra">最短路・Dijkstra</a></h1>
<p>对于 $n$ 个点 $m$ 条边的图，可以在 $O(n \log m)$ 的时间内求出来源点 $s$ 到所有点的最短路，并且求出路径。</p>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = std::vector&lt;std::vector&lt;Edge&lt;D&gt;&gt;&gt;;

// @description Dijkstra 最短路

template &lt;class D&gt;
auto dijkstra(const Edges&lt;D&gt; &amp;E, int s) {
	int n = E.size();
	std::vector&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	std::vector&lt;int&gt; from(n, -1);
	std::vector&lt;bool&gt; vis(n);
	dis[s] = 0, from[s] = s;
	using pdi = std::pair&lt;D, int&gt;;
	std::priority_queue&lt;pdi, std::vector&lt;pdi&gt;, std::greater&lt;pdi&gt;&gt; pq;
	pq.emplace(0, s);
	while (!pq.empty()) {
		auto [w, u] = pq.top();
		pq.pop();
		if (vis[u])
			continue;
		vis[u] = true;
		for (auto [v, wi] : E[u]) {
			D d2 = w + wi;
			if (dis[v] &gt; d2)
				dis[v] = d2, from[v] = u, pq.emplace(d2, v);
		}
	}
	return make_pair(dis, from);
}

auto get_path(const std::vector&lt;int&gt; &amp;from, int x, int y) {
	std::vector&lt;int&gt; r;
	for (; x != y; y = from[y])
		r.push_back(y);
	r.push_back(y);
	std::reverse(r.begin(), r.end());
	return r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路floydadj"><a class="header" href="#最短路floydadj">最短路・Floyd・ADJ</a></h1>
<p>对于 $n$ 个点的图，可以在 $O(n^3)$ 的时间内求出任意两点的最短路，并记录其中一条路径。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	std::vector&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

template &lt;class D&gt;
using Edges = VV&lt;D&gt;; // 默认 x == y

template &lt;class D&gt;
auto get_edges(int n) {
	VV&lt;D&gt; f(n, n, std::numeric_limits&lt;D&gt;::max() / 2);
	for (int i = 0; i &lt; n; i++)
		f[i][i] = 0;
	return f;
}

// @description Floyd 最短路

template &lt;class D&gt;
auto floyd(const Edges&lt;D&gt; &amp;E) {
	int n = E.x;
	auto f = E;
	VV&lt;int&gt; pass(n, n, -1);
	for (int k = 0; k &lt; n; k++) {
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				D d2 = f[i][k] + f[k][j];
				if (f[i][j] &gt; d2)
					f[i][j] = d2, pass[i][j] = k;
			}
		}
	}
	return make_pair(f, pass);
}

auto get_path(const VV&lt;int&gt; &amp;pass, int x, int y) {
	std::vector&lt;int&gt; path = {x};
	std::function&lt;void(int, int)&gt; dfs = [&amp;](int a, int b) {
		if (pass[a][b] != -1) {
			int p = pass[a][b];
			dfs(a, p), path.push_back(p), dfs(p, b);
		}
	};
	if (x != y)
		dfs(x, y), path.push_back(y);
	return path;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca"><a class="header" href="#lca">LCA</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca倍增"><a class="header" href="#lca倍增">LCA・倍增</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = std::vector&lt;std::vector&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	std::vector&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(倍增)

struct LCA {
	const int n, lgn;
	VV&lt;int&gt; f;
	std::vector&lt;int&gt; dep;
	LCA(int n_) : n(n_), lgn(1 + std::__lg(n)), f(n, lgn), dep(n) {}
	int query(int x, int y) {
		if (dep[x] &gt; dep[y])
			std::swap(x, y);
		while (dep[x] &lt; dep[y])
			y = f[y][std::__lg(dep[y] - dep[x])];
		for (int i = lgn - 1; i &gt;= 0; i--) {
			if (f[x][i] != f[y][i]) {
				x = f[x][i], y = f[y][i];
			}
		}
		return x == y ? x : f[x][0];
	}
};

template &lt;class D&gt;
struct LCAImpl : LCA {
	const Edges&lt;D&gt; &amp;E;
	LCAImpl(const Edges&lt;D&gt; &amp;E_, int s = 1) : LCA(E_.size()), E(E_) {
		dfs(s, 0);
		for (int i = 1; i &lt; lgn; i++) {
			for (int j = 0; j &lt; n; j++) {
				f[j][i] = f[f[j][i - 1]][i - 1];
			}
		}
	}
	void dfs(int u, int fa) {
		f[u][0] = fa;
		dep[u] = dep[fa] + 1;
		for (auto e : E[u]) {
			if (e.to != fa) {
				dfs(e.to, u);
			}
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lcast"><a class="header" href="#lcast">LCA（ST）</a></h1>
<pre><code class="language-cpp">using pii = std::pair&lt;int, int&gt;;

template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = std::vector&lt;std::vector&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	std::vector&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(Sparse Table)

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	void init(auto first, auto last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = min(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) const {
		int s = std::__lg(r - l + 1);
		return min(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};

struct LCA {
	const int n;
	std::vector&lt;int&gt; dfn;
	SparseTable&lt;pii&gt; st;
	LCA(int n_) : n(n_), dfn(n), st(n) {}
	int query(int x, int y) const {
		if (x == y)
			return x;
		x = dfn[x], y = dfn[y];
		if (x &gt; y)
			std::swap(x, y);
		return st.query(x + 1, y).second;
	}
};

template &lt;class D&gt;
struct LCAImpl : LCA {
	const Edges&lt;D&gt; &amp;E;
	std::vector&lt;pii&gt; rnk;
	int cnt = 0;
	LCAImpl(const Edges&lt;D&gt; &amp;E_, int s = 1) : LCA(E_.size()), E(E_), rnk(n) {
		dfs(s, 0);
		st.init(rnk.begin(), rnk.end());
	}
	void dfs(int u, int fa) {
		dfn[u] = ++cnt;
		rnk[cnt] = {dfn[fa], fa};
		for (auto e : E[u]) {
			if (e.to != fa) {
				dfs(e.to, u);
			}
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scc"><a class="header" href="#scc">SCC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tarjan"><a class="header" href="#tarjan">Tarjan</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = std::vector&lt;std::vector&lt;Edge&lt;D&gt;&gt;&gt;;

struct SCC {
	std::vector&lt;int&gt; id;
	std::vector&lt;std::vector&lt;int&gt;&gt; group;
	SCC(int n) : id(n) {}
};

template &lt;class D&gt;
struct SCCImpl : SCC {
	const Edges&lt;D&gt; &amp;E;
	const int n;
	std::vector&lt;int&gt; low, dfn, stk;
	std::vector&lt;bool&gt; flag;
	int cnt = 0, c2 = 0;
	void tarjan(int u) {
		low[u] = dfn[u] = ++cnt;
		stk.push_back(u), flag[u] = true;
		for (auto e : E[u]) {
			if (dfn[e.to] == 0) {
				tarjan(e.to);
				low[u] = std::min(low[u], low[e.to]);
			} else if (flag[e.to]) {
				low[u] = std::min(low[u], dfn[e.to]);
			}
		}
		if (dfn[u] == low[u]) {
			c2++;
			while (true) {
				int v = stk.back();
				stk.pop_back();
				id[v] = c2;
				flag[v] = false;
				if (u == v)
					break;
			}
		}
	}
	SCCImpl(const Edges&lt;D&gt; &amp;E_) : SCC(E_.size()), E(E_), n(E.size()), low(n), dfn(n), flag(n) {
		for (int i = 1; i &lt; n; i++) {
			if (dfn[i] == 0)
				tarjan(i);
		}
		group.resize(c2 + 1);
		for (int i = 1; i &lt; n; i++) {
			id[i] = c2 + 1 - id[i]; // 拓扑序
			group[id[i]].push_back(i);
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kosaraju"><a class="header" href="#kosaraju">Kosaraju</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = std::vector&lt;std::vector&lt;Edge&lt;D&gt;&gt;&gt;;

struct SCC {
	std::vector&lt;int&gt; id;
	std::vector&lt;std::vector&lt;int&gt;&gt; group;
	SCC(int n) : id(n) {}
};

template &lt;class D&gt;
struct SCCImpl : SCC {
	const Edges&lt;D&gt; &amp;E, &amp;IE;
	const int n;
	std::vector&lt;bool&gt; vis;
	std::vector&lt;int&gt; stk;
	int cnt = 0;
	void dfs1(int u) {
		vis[u] = true;
		for (auto e : E[u])
			if (!vis[e.to])
				dfs1(e.to);
		stk.push_back(u);
	}
	void dfs2(int u) {
		id[u] = cnt;
		for (auto e : IE[u])
			if (id[e.to] == 0)
				dfs2(e.to);
	}
	SCCImpl(const Edges&lt;D&gt; &amp;E_, const Edges&lt;D&gt; &amp;IE_)
		: SCC(E_.size()), E(E_), IE(IE_), n(E.size()), vis(n) {
		for (int i = 1; i &lt; n; i++)
			if (!vis[i])
				dfs1(i);
		std::reverse(stk.begin(), stk.end());
		for (int u : stk) {
			if (id[u] == 0) {
				++cnt;
				dfs2(u);
			}
		}
		group.resize(cnt + 1);
		for (int i = 1; i &lt; n; i++) {
			group[id[i]].push_back(i);
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最小生成树kruskal"><a class="header" href="#最小生成树kruskal">最小生成树（kruskal）</a></h1>
<pre><code class="language-cpp">// @description 朴素并查集

struct DSU {
	std::vector&lt;int&gt; fa;
	DSU(int n) : fa(n) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		fa[x] = y;
	}
};

ll kruskal(int n) {
	std::sort(G.begin(), G.end(), [](Edge a, Edge b) {
		return get&lt;2&gt;(a) &lt; get&lt;2&gt;(b);
	});
	ll ans = 0, cnt = 0;
	DSU dsu(n + 1);
	for (auto [u, v, w] : G) {
		if (dsu.find(u) == dsu.find(v)) {
			continue;
		}
		ans += w, cnt++;
		dsu.merge(u, v);
		if (cnt == n - 1) {
			return ans;
		}
	}
	return -1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树链剖分"><a class="header" href="#树链剖分">树链剖分</a></h1>
<pre><code class="language-cpp">const int N = 1E5 + 5;
std::vector&lt;std::vector&lt;int&gt;&gt; G(N);

// @problem https://www.luogu.com.cn/problem/P3379

// @description 树链剖分 LCA

struct HLD {
	std::vector&lt;int&gt; sz, dep, fa, son, top, dfn;
	int cnt = 0;
	HLD(int n, int r = 1) : sz(n), dep(n), fa(n), son(n), top(n), dfn(n) {
		dfs1(r), dfs2(r, r);
	}
	void dfs1(int u, int f = 0) {
		dep[u] = dep[f] + 1;
		fa[u] = f, sz[u] = 1, top[u] = u;
		for (int v : G[u]) {
			if (v != f) {
				dfs1(v, u);
				sz[u] += sz[v];
				if (sz[v] &gt; sz[son[u]]) {
					son[u] = v;
				}
			}
		}
	}
	void dfs2(int u, int tp, int f = 0) {
		top[u] = tp, dfn[u] = ++cnt;
		if (son[u] != 0) {
			dfs2(son[u], tp, u);
			for (int v : G[u]) {
				if (v != f &amp;&amp; v != son[u]) {
					dfs2(v, v, u);
				}
			}
		}
	}
	int qpath(int x, int y) {
		while (top[x] != top[y]) {
			if (dep[top[x]] &gt; dep[top[y]]) {
				std::swap(x, y);
			}
			y = fa[top[y]];
		}
		return dep[x] &lt; dep[y] ? x : y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dinic"><a class="header" href="#dinic">Dinic</a></h1>
<p>感谢 gkjj 送的 Dinic。</p>
<pre><code class="language-cpp">struct Dinic {
	const int inf = 1e9;
	struct edge {
		int to, cap, rev;
	};
	std::vector&lt;std::vector&lt;edge&gt;&gt; G;
	std::vector&lt;int&gt; lev, cur;
	Dinic(int n) : G(n), lev(n), cur(n) {}

	inline void add(int x, int y, int c) {
		G[x].push_back({y, c, (int)G[y].size()});
		G[y].push_back({x, 0, (int)G[x].size() - 1});
	}

	void bfs(int s) {
		std::queue&lt;int&gt; qu;
		std::fill(lev.begin(), lev.end(), -1);
		for (lev[s] = 0, qu.push(s); qu.size();) {
			int x = qu.front();
			qu.pop();
			for (auto [to, cap, rev] : G[x])
				if (cap &gt; 0 &amp;&amp; lev[to] &lt; 0)
					lev[to] = lev[x] + 1, qu.push(to);
		}
	}

	int dfs(int x, int t, int f) {
		if (x == t)
			return f;
		for (int &amp;i = cur[x], d; i &lt; G[x].size(); i++) {
			auto &amp;[to, cap, rev] = G[x][i];
			if (cap &gt; 0 &amp;&amp; lev[x] &lt; lev[to])
				if ((d = dfs(to, t, std::min(f, cap))) &gt; 0) {
					cap -= d;
					G[to][rev].cap += d;
					return d;
				}
		}
		return 0;
	}

	ll maxflow(int s, int t) {
		for (ll flow = 0, f;;) {
			bfs(s);
			if (lev[t] &lt; 0)
				return flow;
			std::fill(cur.begin(), cur.end(), 0);
			while ((f = dfs(s, t, inf)) &gt; 0)
				flow += f;
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式"><a class="header" href="#多项式">多项式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fft-乘法"><a class="header" href="#fft-乘法">FFT 乘法</a></h1>
<p>FFT 乘法及拆系数 $5$ 次乘法，可以做 <code>int</code> 范围内的卷积。可能存在误差。</p>
<pre><code class="language-cpp">using f64 = double;

using img = std::complex&lt;f64&gt;;
using Poly = std::vector&lt;int&gt;;

std::vector&lt;img&gt; w{{1, 0}, {1, 0}};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

const f64 PI = acos(-1.0);

void pre_w(int u) {
	int l = w.size(), l2 = l * 2;
	if (u &lt;= l)
		return;
	w.resize(l2);
	img p = img(cos(PI / l), sin(PI / l));
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(u);
}

static int ntt_size = 0;

void fft(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j] + f[i + j + l];
				f[i + j + l] = w[j + l] * (f[i + j] - f[i + j + l]);
				f[i + j] = x;
			}
}

void ifft(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j], y = f[i + j + l] * w[j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	for (int i = 0; i &lt; n; i++)
		f[i] /= n;
	std::reverse(f + 1, f + n);
}

Poly mul(const Poly &amp;a, const Poly &amp;b) {
	int n = a.size(), m = b.size(), N = get_lim(n + m - 1);
	std::vector&lt;img&gt; f(N);
	for (int i = 0; i &lt; n; i++)
		f[i] += img(a[i], 0);
	for (int i = 0; i &lt; m; i++)
		f[i] += img(0, b[i]);
	fft(f.begin(), N);
	for (int i = 0; i &lt; N; i++)
		f[i] *= f[i];
	ifft(f.begin(), N);
	Poly ans(n + m - 1);
	for (int i = 0; i &lt; n + m - 1; i++)
		ans[i] = int(f[i].imag() / 2 + 0.5);
	return ans;
}

Poly mul5(const Poly &amp;a, const Poly &amp;b, int p) {
	enum : int { B = 1 &lt;&lt; 15 };
	int n = a.size(), m = b.size(), N = get_lim(n + m - 1);
	std::vector&lt;img&gt; a0(N), a1(N), Q(N);
	for (int i = 0; i &lt; n; i++)
		a0[i] = a[i] % B, a1[i] = a[i] / B;
	for (int i = 0; i &lt; m; i++)
		Q[i] = img(b[i] % B, b[i] / B);
	fft(a0.begin(), N), fft(a1.begin(), N), fft(Q.begin(), N);
	for (int i = 0; i &lt; N; i++)
		a0[i] *= Q[i], a1[i] *= Q[i];
	ifft(a0.begin(), N), ifft(a1.begin(), N);
	Poly ans(n + m - 1);
	for (int i = 0; i &lt; m + n - 1; i++) {
		ll a1b1 = a1[i].imag() + .5;
		ll a1b0 = a1[i].real() + .5;
		ll a0b1 = a0[i].imag() + .5;
		ll a0b0 = a0[i].real() + .5;
		ans[i] = ((a1b1 * B % p + a0b1 + a1b0) * B + a0b0) % p;
	}
	return ans;
}
</code></pre>
<pre><code>poly/fft-mul.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                    MUL * |       1 |     0.000 |     100 |      - | 10000000.0
         MUL5 MOD 1E9 + 7 |       1 |     0.001 |     700 |  7.000 |  1428571.4
                    MUL * |       2 |     0.000 |     200 |      - |  5000000.0
         MUL5 MOD 1E9 + 7 |       2 |     0.001 |     650 |  3.250 |  1538461.5
                    MUL * |      64 |     0.005 |      71 |      - | 13913043.5
         MUL5 MOD 1E9 + 7 |      64 |     0.012 |     185 |  2.587 |  5378151.3
                    MUL * |     512 |     0.039 |      76 |      - | 13128205.1
         MUL5 MOD 1E9 + 7 |     512 |     0.099 |     192 |  2.528 |  5192697.8
                    MUL * |    4096 |     0.364 |      88 |      - | 11240426.0
         MUL5 MOD 1E9 + 7 |    4096 |     1.041 |     254 |  2.856 |  3936202.0
                    MUL * |   16384 |     1.711 |     104 |      - |  9575155.1
         MUL5 MOD 1E9 + 7 |   16384 |     4.170 |     254 |  2.437 |  3929122.3
                    MUL * |   32768 |     3.814 |     116 |      - |  8591304.5
         MUL5 MOD 1E9 + 7 |   32768 |    10.284 |     313 |  2.696 |  3186286.8
                    MUL * |   65536 |     7.331 |     111 |      - |  8940085.1
         MUL5 MOD 1E9 + 7 |   65536 |    18.947 |     289 |  2.585 |  3458921.4
                    MUL * |  131072 |    15.852 |     120 |      - |  8268350.5
         MUL5 MOD 1E9 + 7 |  131072 |    40.463 |     308 |  2.552 |  3239330.2
                    MUL * |  262144 |    33.431 |     127 |      - |  7841390.4
         MUL5 MOD 1E9 + 7 |  262144 |    87.737 |     334 |  2.624 |  2987850.5
                    MUL * |  524288 |    71.549 |     136 |      - |  7327646.9
         MUL5 MOD 1E9 + 7 |  524288 |   193.567 |     369 |  2.705 |  2708561.5
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-乘法i32"><a class="header" href="#ntt-乘法i32">NTT 乘法・i32</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 多项式乘法

struct Poly : std::vector&lt;int&gt; {
	using vector::vector;
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n);
};
Poly w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	int p = qpow(3, (P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = 1ll * w[i] * p % P;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j], y = f[i + j + l];
				f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
				f[i + j] = mo(x + y);
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j];
				int y = 1ll * w[j + l] * f[i + j + l] % P;
				f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * ivn % P;
	std::reverse(f + 1, f + n);
}

Poly &amp;Poly::mul(Poly &amp;f, Poly &amp;g, int n) {
	f.resize(n), g.resize(n);
	ntt(f.begin(), n), ntt(g.begin(), n);
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * g[i] % P;
	return intt(f.begin(), n), f;
}

Poly operator*(Poly f, Poly g) {
	int m = f.size() + g.size() - 1;
	Poly::mul(f, g, get_lim(m));
	return f.resize(m), f;
}

Poly operator+(Poly f, Poly g) {
	int n = std::max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++)
		f[i] = mo(f[i] + g[i]);
	return f;
}

Poly operator-(Poly f, Poly g) {
	int n = std::max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++)
		f[i] = mo(f[i] - g[i] + P);
	return f;
}
</code></pre>
<pre><code>poly/ntt-mul-i32.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
          MUL MOD 1E9+7 * |       1 |     0.001 |     600 |      - |  1666666.7
          MUL MOD 1E9+7 * |       2 |     0.001 |     300 |      - |  3333333.3
          MUL MOD 1E9+7 * |      64 |     0.006 |      87 |      - | 11428571.4
          MUL MOD 1E9+7 * |     512 |     0.046 |      89 |      - | 11130434.8
          MUL MOD 1E9+7 * |    4096 |     0.452 |     110 |      - |  9053954.6
          MUL MOD 1E9+7 * |   16384 |     2.078 |     126 |      - |  7882630.4
          MUL MOD 1E9+7 * |   32768 |     4.381 |     133 |      - |  7479251.6
          MUL MOD 1E9+7 * |   65536 |     9.336 |     142 |      - |  7019879.3
          MUL MOD 1E9+7 * |  131072 |    20.979 |     160 |      - |  6247849.3
          MUL MOD 1E9+7 * |  262144 |    43.718 |     166 |      - |  5996252.5
          MUL MOD 1E9+7 * |  524288 |    92.519 |     176 |      - |  5666843.2
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-乘法三模"><a class="header" href="#ntt-乘法三模">NTT 乘法・三模</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 多项式乘法(int mod)

using Poly = std::vector&lt;int&gt;;

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

template &lt;int P&gt;
struct NTT {
	inline static Poly w{1, 1};

	inline static int ntt_size = 0;

	static inline int mo(int u) {
		return u &gt;= P ? u - P : u;
	}

	static void pre_w(int n) {
		int l = w.size(), l2 = l * 2;
		if (n &lt;= l)
			return;
		w.resize(l2);
		int p = qpow(3, (P - 1) / l2, P);
		for (int i = l; i &lt; l2; i += 2) {
			w[i] = w[i / 2];
			w[i + 1] = 1ll * w[i] * p % P;
		}
		pre_w(n);
	}

	static void ntt(auto f, int n) {
		pre_w(n), ntt_size += n;
		for (int l = n / 2; l; l /= 2)
			for (int i = 0; i &lt; n; i += l * 2)
				for (int j = 0; j &lt; l; j++) {
					int x = f[i + j], y = f[i + j + l];
					f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
					f[i + j] = mo(x + y);
				}
	}

	static void intt(auto f, int n) {
		pre_w(n), ntt_size += n;
		for (int l = 1; l &lt; n; l *= 2)
			for (int i = 0; i &lt; n; i += l * 2)
				for (int j = 0; j &lt; l; j++) {
					int x = f[i + j];
					int y = 1ll * w[j + l] * f[i + j + l] % P;
					f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
				}
		const int ivn = P - (P - 1) / n;
		for (int i = 0; i &lt; n; i++)
			f[i] = 1ll * f[i] * ivn % P;
		std::reverse(f + 1, f + n);
	};
};

template &lt;int P&gt;
Poly mul(Poly &amp;f, Poly g, int n) {
	for (int i = 0; i &lt; n; i++)
		f[i] %= P, g[i] %= P;
	NTT&lt;P&gt;::ntt(f.begin(), n), NTT&lt;P&gt;::ntt(g.begin(), n);
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * g[i] % P;
	return NTT&lt;P&gt;::intt(f.begin(), n), f;
}

Poly mul3(Poly f, Poly g, int p) {
	constexpr std::array&lt;int, 3&gt; M = {985661441, 998244353, 1004535809};
	int m = f.size() + g.size() - 1, N = get_lim(m);
	f.resize(N), g.resize(N);

	std::array&lt;Poly, 3&gt; a = {f, f, f};
	mul&lt;M[0]&gt;(a[0], g, N);
	mul&lt;M[1]&gt;(a[1], g, N);
	mul&lt;M[2]&gt;(a[2], g, N);

	Poly ans(m);

	const ll M12 = ll(M[0]) * M[1] % p;
	const ll inv_1 = qpow(M[0], M[1] - 2, M[1]);
	const ll inv_2 = qpow(ll(M[0]) * M[1] % M[2], M[2] - 2, M[2]);

	for (int i = 0; i &lt; m; i++) {
		ll x = (a[1][i] - a[0][i] + M[1]) * inv_1 % M[1] * M[0] + a[0][i];
		ans[i] = ((a[2][i] - x % M[2] + M[2]) * inv_2 % M[2] * M12 + x) % p;
	}
	return ans;
}
</code></pre>
<pre><code>poly/ntt-mul-mod3.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
          MUL MOD 1E9+7 * |       1 |     0.002 |    1700 |      - |   588235.3
          MUL MOD 1E9+7 * |       2 |     0.002 |    1200 |      - |   833333.3
          MUL MOD 1E9+7 * |      64 |     0.018 |     279 |      - |  3575419.0
          MUL MOD 1E9+7 * |     512 |     0.158 |     308 |      - |  3242558.6
          MUL MOD 1E9+7 * |    4096 |     1.529 |     373 |      - |  2678882.1
          MUL MOD 1E9+7 * |   16384 |     6.923 |     422 |      - |  2366440.0
          MUL MOD 1E9+7 * |   32768 |    14.527 |     443 |      - |  2255653.0
          MUL MOD 1E9+7 * |   65536 |    30.800 |     469 |      - |  2127784.6
          MUL MOD 1E9+7 * |  131072 |    64.859 |     494 |      - |  2020888.2
          MUL MOD 1E9+7 * |  262144 |   139.495 |     532 |      - |  1879234.6
          MUL MOD 1E9+7 * |  524288 |   303.615 |     579 |      - |  1726820.7
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntton2"><a class="header" href="#ntton2">NTT・$O(n^2)$</a></h1>
<p>NTT 的 $O(n^2)$ 板子，我也不知道有啥用，大概用来快速验证吧。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;int&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt; l)
		return;
	iv = fac = ifac = std::vector&lt;int&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n] = qpow(fac[n]), iv[n] = qpow(n);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
		iv[i] = 1ll * ifac[i] * fac[i - 1] % P;
	}
	pre_all(u);
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

struct Poly : std::vector&lt;int&gt; { // O(n2) 板子，我也不知道有啥用
	using vector::vector;
	int deg() const {
		return size();
	}
};

Poly deriv(const Poly &amp;f, int m) {
	Poly r(m);
	for (int i = 1; i &lt; std::min(f.deg(), m + 1); i++)
		r[i - 1] = 1ll * f[i] * i % P;
	return f;
}
Poly integr(const Poly &amp;f, int m) {
	Poly r(m);
	pre_all(m);
	for (int i = std::min(f.deg(), m - 1); i &gt; 0; --i)
		r[i] = 1ll * iv[i] * f[i - 1] % P;
	return f;
}
Poly inv(const Poly &amp;f, int m) {
	Poly r(m);
	int iv0 = r[0] = qpow(f[0]);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, f.deg()); j++)
			r[i] = (r[i] + 1ll * f[j] * r[i - j]) % P;
		r[i] = 1ll * (P - r[i]) * iv0 % P;
	}
	return r;
}

Poly div(int m, const Poly &amp;f, const Poly &amp;g) {
	Poly r(m);
	int iv0 = qpow(g[0]);
	r[0] = 1ll * f[0] * iv0 % P;
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, g.deg()); j++)
			r[i] = (r[i] + 1ll * g[j] * r[i - j]) % P;
		r[i] = mo(f[i] - 1ll * r[i] * iv0 % P);
	}
	return r;
}

Poly ln(const Poly &amp;f, int m) {
	assert(f[0] == 1);
	return integr(div(m, deriv(f, m), f), m);
}

Poly exp(const Poly &amp;f, int m) {
	Poly r(m), df = f;
	for (int i = 0; i &lt; f.deg(); i++)
		df[i] = 1ll * i * df[i] % P;
	r[0] = 1;
	pre_all(m);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, f.deg()); j++)
			r[i] = (r[i] + 1ll * df[j] * r[i - j]) % P;
		r[i] = 1ll * r[i] * iv[i] % P;
	}
	return r;
}

Poly sqrt(const Poly &amp;f, int m) {
	Poly r(m);
	r[0] = 1; // sqrt(f[0])
	int iv0 = qpow(2ll * r[0] % P);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt;= i - 1; j++)
			r[i] = (r[i] + 1ll * r[j] * r[i - j]) % P;
		r[i] = 1ll * (f[i] - r[i] + P) * iv0 % P;
	}
	return r;
}

Poly operator*(const Poly &amp;f, const Poly &amp;g) {
	Poly r(f.size() + g.size() - 1);
	for (int i = 0; i &lt; f.size(); i++) {
		for (int j = 0; j &lt; g.size(); j++) {
			r[i + j] = (r[i + j] + 1ll * f[i] * g[j]) % P;
		}
	}
	return r;
}

Poly operator+(const Poly &amp;f, const Poly &amp;g) {
	Poly r(std::max(f.size(), g.size()));
	std::copy(f.begin(), f.end(), r.begin());
	for (int i = 0; i &lt; g.size(); i++)
		r[i] = mo(r[i] + g[i]);
	return r;
}

Poly operator-(const Poly &amp;f, const Poly &amp;g) {
	Poly r(std::max(f.size(), g.size()));
	std::copy(f.begin(), f.end(), r.begin());
	for (int i = 0; i &lt; g.size(); i++)
		r[i] = mo(r[i] - g[i] + P);
	return r;
}
</code></pre>
<pre><code>poly/ntt-naive.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                    MUL * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.000 |     300 |  3.000 |  3333333.3
                      EXP |       1 |     0.000 |     300 |  3.000 |  3333333.3
                     SQRT |       1 |     0.000 |     200 |  2.000 |  5000000.0
                    MUL * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.000 |     150 |  3.000 |  6666666.7
                      EXP |       2 |     0.000 |     200 |  4.000 |  5000000.0
                     SQRT |       2 |     0.000 |     200 |  4.000 |  5000000.0
                    MUL * |      64 |     0.007 |     109 |      - |  9142857.1
                      INV |      64 |     0.011 |     171 |  1.571 |  5818181.8
                      EXP |      64 |     0.011 |     168 |  1.543 |  5926474.7
                     SQRT |      64 |     0.011 |     171 |  1.571 |  5818181.8
                    MUL * |     512 |     0.434 |     847 |      - |  1180542.3
                      INV |     512 |     0.660 |    1289 |  1.523 |   775288.9
                      EXP |     512 |     0.661 |    1291 |  1.525 |   774352.0
                     SQRT |     512 |     0.687 |    1341 |  1.584 |   745163.0
                    MUL * |    4096 |    27.740 |    6772 |      - |   147655.6
                      INV |    4096 |    42.110 |   10280 |  1.518 |    97268.4
                      EXP |    4096 |    42.095 |   10277 |  1.517 |    97304.0
                     SQRT |    4096 |    44.029 |   10749 |  1.587 |    93030.5
                    MUL * |   16384 |   448.268 |   27360 |      - |    36549.6
                      INV |   16384 |   673.331 |   41096 |  1.502 |    24332.8
                      EXP |   16384 |   673.468 |   41105 |  1.502 |    24327.8
                     SQRT |   16384 |   704.433 |   42995 |  1.571 |    23258.4
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代"><a class="header" href="#ntt-牛顿迭代">NTT 牛顿迭代</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly ln(int m) const {
		assert(T[0].v == 1);
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 48E
		assert(T[0].v == 0);
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = x * (cut(t) - x.ln(t) + Poly{1}), x.redeg(t);
		}
		return x.redeg(m);
	}
	Poly sqrt(int m) const { // 36E
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = (x + cut(t).div(t, x)) * ((P + 1) / 2);
		}
		return x.redeg(m);
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
	friend auto operator%(const Poly &amp;f, const Poly &amp;g) {
		Poly Q = f / g;
		return make_pair(Q, (f - Q * g).redeg(g.deg() - 1));
	}
#undef T
};
</code></pre>
<pre><code>poly/ntt-newton.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     200 |      - |  5000000.0
                   MUL 6E |       1 |     0.001 |     900 |  4.500 |  1111111.1
                  INV 12E |       1 |     0.000 |     300 |  1.500 |  3333333.3
                  LOG 18E |       1 |     0.002 |    1800 |  9.000 |   555555.6
                  EXP 48E |       1 |     0.000 |     100 |  0.500 | 10000000.0
                 SQRT 36E |       1 |     0.000 |     100 |  0.500 | 10000000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                   MUL 6E |       2 |     0.001 |     650 | 13.000 |  1538461.5
                  INV 12E |       2 |     0.001 |     250 |  5.000 |  4000000.0
                  LOG 18E |       2 |     0.002 |     800 | 16.000 |  1250000.0
                  EXP 48E |       2 |     0.004 |    2100 | 42.000 |   476190.5
                 SQRT 36E |       2 |     0.004 |    1850 | 37.000 |   540540.5
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                   MUL 6E |      64 |     0.005 |      84 |  7.714 | 11851851.9
                  INV 12E |      64 |     0.010 |     154 | 14.143 |  6464646.5
                  LOG 18E |      64 |     0.015 |     234 | 21.429 |  4266666.7
                  EXP 48E |      64 |     0.046 |     720 | 65.856 |  1388316.4
                 SQRT 36E |      64 |     0.032 |     492 | 45.000 |  2031746.0
                 NTT 1E * |     512 |     0.006 |      12 |      - | 80000000.0
                   MUL 6E |     512 |     0.048 |      93 |  7.516 | 10644490.6
                  INV 12E |     512 |     0.092 |     179 | 14.328 |  5583424.2
                  LOG 18E |     512 |     0.147 |     286 | 22.922 |  3490115.9
                  EXP 48E |     512 |     0.368 |     717 | 57.437 |  1392822.1
                 SQRT 36E |     512 |     0.270 |     527 | 42.172 |  1897005.9
                 NTT 1E * |    4096 |     0.065 |      15 |      - | 63210852.0
                   MUL 6E |    4096 |     0.466 |     113 |  7.185 |  8797288.6
                  INV 12E |    4096 |     0.913 |     222 | 14.093 |  4485341.1
                  LOG 18E |    4096 |     1.390 |     339 | 21.448 |  2947195.1
                  EXP 48E |    4096 |     3.503 |     855 | 54.065 |  1169153.3
                 SQRT 36E |    4096 |     2.625 |     640 | 40.505 |  1560564.1
                 NTT 1E * |   16384 |     0.301 |      18 |      - | 54486380.1
                   MUL 6E |   16384 |     2.133 |     130 |  7.092 |  7682302.3
                  INV 12E |   16384 |     4.130 |     252 | 13.733 |  3967466.0
                  LOG 18E |   16384 |     6.341 |     387 | 21.086 |  2583949.2
                  EXP 48E |   16384 |    15.956 |     973 | 53.065 |  1026794.5
                 SQRT 36E |   16384 |    11.925 |     727 | 39.656 |  1373958.8
                 NTT 1E * |   32768 |     0.641 |      19 |      - | 51112310.4
                   MUL 6E |   32768 |     4.539 |     138 |  7.080 |  7219072.9
                  INV 12E |   32768 |     8.761 |     267 | 13.665 |  3740393.3
                  LOG 18E |   32768 |    13.532 |     412 | 21.108 |  2421436.7
                  EXP 48E |   32768 |    33.997 |    1037 | 53.029 |   963863.8
                 SQRT 36E |   32768 |    25.406 |     775 | 39.630 |  1289752.3
                 NTT 1E * |   65536 |     1.367 |      20 |      - | 47927593.8
                   MUL 6E |   65536 |     9.587 |     146 |  7.011 |  6835871.6
                  INV 12E |   65536 |    18.600 |     283 | 13.603 |  3523413.0
                  LOG 18E |   65536 |    28.585 |     436 | 20.905 |  2292661.4
                  EXP 48E |   65536 |    71.995 |    1098 | 52.651 |   910289.3
                 SQRT 36E |   65536 |    53.839 |     821 | 39.374 |  1217251.0
                 NTT 1E * |  131072 |     2.902 |      22 |      - | 45164660.5
                   MUL 6E |  131072 |    20.263 |     154 |  6.982 |  6468397.3
                  INV 12E |  131072 |    39.211 |     299 | 13.511 |  3342710.9
                  LOG 18E |  131072 |    60.117 |     458 | 20.715 |  2180291.6
                  EXP 48E |  131072 |   152.859 |    1166 | 52.672 |   857472.4
                 SQRT 36E |  131072 |   113.866 |     868 | 39.236 |  1151102.6
                 NTT 1E * |  262144 |     6.167 |      23 |      - | 42508346.6
                   MUL 6E |  262144 |    44.207 |     168 |  7.169 |  5929857.0
                  INV 12E |  262144 |    82.809 |     315 | 13.428 |  3165632.3
                  LOG 18E |  262144 |   129.667 |     494 | 21.026 |  2021664.2
                  EXP 48E |  262144 |   325.106 |    1240 | 52.718 |   806333.0
                 SQRT 36E |  262144 |   244.422 |     932 | 39.635 |  1072505.7
                 NTT 1E * |  524288 |    13.023 |      24 |      - | 40257188.1
                   MUL 6E |  524288 |    94.030 |     179 |  7.220 |  5575732.7
                  INV 12E |  524288 |   177.943 |     339 | 13.663 |  2946383.4
                  LOG 18E |  524288 |   281.052 |     536 | 21.580 |  1865450.4
                  EXP 48E |  524288 |   698.557 |    1332 | 53.638 |   750530.5
                 SQRT 36E |  524288 |   520.214 |     992 | 39.944 |  1007832.3
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代卡常"><a class="header" href="#ntt-牛顿迭代卡常">NTT 牛顿迭代・卡常</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(deg());
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly &amp;invD(Poly f2, Poly nx, int t) {
		mul(f2, nx, t).fill0L(t); // 6E
		mul(f2, nx, t);			  // 4E
		redeg(t);
		for (int i = t / 2; i &lt; t; i++) {
			T[i] = -f2[i];
		}
		return T;
	}
	Poly inv(int m) const { // 10E
		Poly x = {qpow(T[0].v)};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x.invD(cut(t), x.cut(m), t);
		}
		return x.redeg(m);
	}
	Poly div(int m, Poly g) const { // 13E
		if (deg() == 0)
			return {};
		int t = get_lim(m);
		Poly x = cut(t / 2), u = g.inv(t / 2); // 10E
		Poly q = mul(x, u, t).cut(t / 2);	   // 6E
		mul(q, g, t).fill0L(t);				   // 6E
		for (int i = t / 2; i &lt; std::min(t, deg()); i++)
			q[i] -= T[i];
		mul(q, u, t); // 4E
		for (int i = t / 2; i &lt; t; i++)
			x[i] = -q[i];
		return x.cut(m);
	}
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 17E
		if (m == 1)
			return {1};
		assert(T[0].v == 0);
		Poly f = {1, T[1]}, g = {1}, nf, ng = g;
		pre_all(deg());
		for (int t = 4; t &lt; m * 2; t *= 2) {
			nf = Poly(f).ntt(t);		// 2E
			ng = g.invD(nf, ng, t / 2); // 3E
			Poly q = cut(t / 2);
			for (int i = 0; i &lt; q.deg(); i++)
				q[i] *= i;
			mul(q, nf, t / 2); // 2E
			for (int i = 0; i &lt; t / 2; i++)
				q[i] -= i * f[i];
			mul(q, ng, t); // 6E
			for (int i = t / 2; i &lt; std::min(t, deg()); i++)
				q[i] = T[i] + q[i - t / 2] * iv[i];
			mul(q.fill0L(t), nf, t); // 4E
			f.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				f[i] = q[i];
		}
		return f.cut(m);
	}
	Poly sqrt(int m) const { // 11E
		Poly x = {1}, g = x.inv(1), ng = g;
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly f = Poly(x).ntt(t / 2); // 2E
			if (t &gt;= 4)
				ng = g.invD(f, ng, t / 2); // 3E
			mul(f, f, t / 2).redeg(t);	   // 1E
			for (int i = t / 2; i &lt; std::min(t, deg()); i++)
				f[i] = T[i - t / 2] + T[i] - f[i - t / 2];
			mul(f.fill0L(t), ng, t); // 6E
			x.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				x[i] = f[i] * ((P + 1) / 2);
		}
		return x.cut(deg());
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};
</code></pre>
<pre><code>poly/ntt-newton-fast.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                   MUL 6E |       1 |     0.001 |    1000 | 10.000 |  1000000.0
                  INV 10E |       1 |     0.001 |     700 |  7.000 |  1428571.4
                  LOG 13E |       1 |     0.002 |    2400 | 24.000 |   416666.7
                  EXP 17E |       1 |     0.000 |     200 |  2.000 |  5000000.0
                 SQRT 11E |       1 |     0.001 |     500 |  5.000 |  2000000.0
                 NTT 1E * |       2 |     0.000 |     150 |      - |  6666666.7
                   MUL 6E |       2 |     0.002 |     750 |  5.000 |  1333333.3
                  INV 10E |       2 |     0.001 |     500 |  3.333 |  2000000.0
                  LOG 13E |       2 |     0.003 |    1550 | 10.333 |   645161.3
                  EXP 17E |       2 |     0.001 |     350 |  2.333 |  2857142.9
                 SQRT 11E |       2 |     0.002 |    1150 |  7.667 |   869565.2
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                   MUL 6E |      64 |     0.006 |      90 |  8.286 | 11034482.8
                  INV 10E |      64 |     0.008 |     131 | 12.000 |  7619047.6
                  LOG 13E |      64 |     0.014 |     220 | 20.143 |  4539007.1
                  EXP 17E |      64 |     0.015 |     239 | 21.857 |  4183006.5
                 SQRT 11E |      64 |     0.010 |     162 | 14.857 |  6153846.2
                 NTT 1E * |     512 |     0.006 |      12 |      - | 81269841.3
                   MUL 6E |     512 |     0.050 |      97 |  7.905 | 10281124.5
                  INV 10E |     512 |     0.074 |     144 | 11.730 |  6928281.5
                  LOG 13E |     512 |     0.096 |     188 | 15.302 |  5311203.3
                  EXP 17E |     512 |     0.127 |     248 | 20.174 |  4028355.8
                 SQRT 11E |     512 |     0.078 |     153 | 12.444 |  6530695.5
                 NTT 1E * |    4096 |     0.065 |      15 |      - | 63405572.8
                   MUL 6E |    4096 |     0.463 |     112 |  7.163 |  8852407.3
                  INV 10E |    4096 |     0.712 |     173 | 11.029 |  5748780.0
                  LOG 13E |    4096 |     0.929 |     226 | 14.381 |  4409051.5
                  EXP 17E |    4096 |     1.195 |     291 | 18.495 |  3428197.4
                 SQRT 11E |    4096 |     0.766 |     186 | 11.851 |  5350066.2
                 NTT 1E * |   16384 |     0.300 |      18 |      - | 54668183.7
                   MUL 6E |   16384 |     2.119 |     129 |  7.071 |  7730872.8
                  INV 10E |   16384 |     3.201 |     195 | 10.680 |  5118734.7
                  LOG 13E |   16384 |     4.244 |     259 | 14.161 |  3860428.0
                  EXP 17E |   16384 |     5.487 |     334 | 18.308 |  2985974.4
                 SQRT 11E |   16384 |     3.504 |     213 | 11.693 |  4675278.7
                 NTT 1E * |   32768 |     0.643 |      19 |      - | 50992920.9
                   MUL 6E |   32768 |     4.515 |     137 |  7.026 |  7257926.6
                  INV 10E |   32768 |     6.802 |     207 | 10.585 |  4817418.0
                  LOG 13E |   32768 |     9.083 |     277 | 14.135 |  3607667.1
                  EXP 17E |   32768 |    11.628 |     354 | 18.095 |  2818056.7
                 SQRT 11E |   32768 |     7.479 |     228 | 11.639 |  4381344.9
                 NTT 1E * |   65536 |     1.372 |      20 |      - | 47780833.4
                   MUL 6E |   65536 |     9.595 |     146 |  6.995 |  6830383.5
                  INV 10E |   65536 |    14.456 |     220 | 10.539 |  4533586.3
                  LOG 13E |   65536 |    19.309 |     294 | 14.078 |  3394055.6
                  EXP 17E |   65536 |    24.699 |     376 | 18.007 |  2653425.6
                 SQRT 11E |   65536 |    15.965 |     243 | 11.639 |  4105068.4
                 NTT 1E * |  131072 |     2.915 |      22 |      - | 44963231.0
                   MUL 6E |  131072 |    20.251 |     154 |  6.947 |  6472323.8
                  INV 10E |  131072 |    30.686 |     234 | 10.527 |  4271406.1
                  LOG 13E |  131072 |    41.018 |     312 | 14.071 |  3195475.3
                  EXP 17E |  131072 |    52.552 |     400 | 18.027 |  2494154.8
                 SQRT 11E |  131072 |    33.824 |     258 | 11.603 |  3875116.4
                 NTT 1E * |  262144 |     6.181 |      23 |      - | 42410677.1
                   MUL 6E |  262144 |    43.270 |     165 |  7.000 |  6058304.4
                  INV 10E |  262144 |    66.903 |     255 | 10.824 |  3918261.9
                  LOG 13E |  262144 |    87.424 |     333 | 14.144 |  2998526.1
                  EXP 17E |  262144 |   112.841 |     430 | 18.256 |  2323126.8
                 SQRT 11E |  262144 |    73.449 |     280 | 11.883 |  3569037.5
                 NTT 1E * |  524288 |    13.097 |      24 |      - | 40030027.4
                   MUL 6E |  524288 |    94.164 |     179 |  7.190 |  5567843.5
                  INV 10E |  524288 |   138.368 |     263 | 10.565 |  3789085.3
                  LOG 13E |  524288 |   189.446 |     361 | 14.464 |  2767476.5
                  EXP 17E |  524288 |   239.430 |     456 | 18.281 |  2189733.9
                 SQRT 11E |  524288 |   153.057 |     291 | 11.686 |  3425447.4
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代分块卡常"><a class="header" href="#ntt-牛顿迭代分块卡常">NTT 牛顿迭代（分块卡常）</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = qpow(3, (P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	Poly operator*(Z k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(deg());
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly inv(int m) const;
	Poly div(int m, Poly g) const;
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const;
	Poly sqrt(int m) const;
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};

Poly Poly::inv(int u) const { // 10E
	if (u == 1) {
		return {front().inv()};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);
	nf[0] = cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = cut(m, k * m).ntt(m * 2);			  // 2E
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2); // 2E
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2); // 2E
		mul(psi, ng[0], m * 2);		   // 4E
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::sqrt(int u) const { // 8E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = sqrt(m), h = x.inv(m).ntt(m * 2);
	vector&lt;Poly&gt; ng(R);

	for (int k = 1; x.deg() &lt; u; k++) {
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			if (j &gt;= 1) {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] + ng[k - 1 - j][i]);
				for (int i = m; i &lt; m * 2; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] - ng[k - 1 - j][i]);
			} else {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * ng[k - 1 - j][i];
				for (int i = m; i &lt; m * 2; i++)
					psi[i] += ng[j][i] * ng[k - 1 - j][i];
			}
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; std::min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i] * iv[2];
	}
	return x.cut(u);
}

Poly Poly::div(int u, Poly f) const { // 10E
	if (u == 1) {
		return {front() * f[0].inv()};
	}
	f.redeg(u);
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = div(m, f), h = f.inv(m).ntt(m * 2);

	vector&lt;Poly&gt; nf(R), ng(R);

	nf[0] = f.cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = f.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; std::min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::exp(int u) const { // 14E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = exp(m), y = x.inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);

	Poly df = *this;
	for (int i = 0; i &lt; df.deg(); i++)
		df[i] *= i;
	y.ntt(m * 2);
	nf[0] = df.cut(m).ntt(m * 2);

	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = df.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, m * (k - 1)).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);

		mul(psi, y, m * 2).fill0H(m * 2);
		for (int i = 0; i &lt; m * 2; i++)
			psi[i] *= iv[m * k + i];
		mul(psi, ng[0], m * 2).fill0H(m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}
</code></pre>
<pre><code>poly/ntt-newton-blockwise-fast.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |       0 |      - |        inf
                   MUL 6E |       1 |     0.001 |     800 |    inf |  1250000.0
                  INV 10E |       1 |     0.000 |     400 |    inf |  2500000.0
                  LOG 10E |       1 |     0.002 |    1500 |    inf |   666666.7
                  EXP 14E |       1 |     0.000 |     300 |    inf |  3333333.3
                  SQRT 8E |       1 |     0.000 |     100 |    inf | 10000000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                   MUL 6E |       2 |     0.002 |     800 | 16.000 |  1250000.0
                  INV 10E |       2 |     0.001 |     500 | 10.000 |  2000000.0
                  LOG 10E |       2 |     0.005 |    2550 | 51.000 |   392156.9
                  EXP 14E |       2 |     0.001 |     700 | 14.000 |  1428571.4
                  SQRT 8E |       2 |     0.002 |     950 | 19.000 |  1052631.6
                 NTT 1E * |      64 |     0.001 |       9 |      - |106666666.7
                   MUL 6E |      64 |     0.006 |      90 |  9.667 | 11034482.8
                  INV 10E |      64 |     0.015 |     237 | 25.333 |  4210526.3
                  LOG 10E |      64 |     0.022 |     337 | 36.000 |  2962963.0
                  EXP 14E |      64 |     0.029 |     459 | 49.000 |  2176870.7
                  SQRT 8E |      64 |     0.014 |     212 | 22.667 |  4705882.4
                 NTT 1E * |     512 |     0.006 |      12 |      - | 80000000.0
                   MUL 6E |     512 |     0.049 |      96 |  7.688 | 10406504.1
                  INV 10E |     512 |     0.090 |     175 | 14.062 |  5688952.1
                  LOG 10E |     512 |     0.109 |     212 | 16.984 |  4710211.6
                  EXP 14E |     512 |     0.134 |     261 | 20.938 |  3820895.5
                  SQRT 8E |     512 |     0.093 |     181 | 14.515 |  5511361.8
                 NTT 1E * |    4096 |     0.065 |      15 |      - | 63307573.4
                   MUL 6E |    4096 |     0.467 |     114 |  7.223 |  8765284.7
                  INV 10E |    4096 |     0.770 |     187 | 11.901 |  5319494.3
                  LOG 10E |    4096 |     0.861 |     210 | 13.309 |  4756717.6
                  EXP 14E |    4096 |     1.142 |     278 | 17.644 |  3587956.2
                  SQRT 8E |    4096 |     0.715 |     174 | 11.054 |  5727085.4
                 NTT 1E * |   16384 |     0.300 |      18 |      - | 54595316.9
                   MUL 6E |   16384 |     2.142 |     130 |  7.139 |  7647873.0
                  INV 10E |   16384 |     3.417 |     208 | 11.387 |  4794579.9
                  LOG 10E |   16384 |     3.790 |     231 | 12.630 |  4322509.2
                  EXP 14E |   16384 |     5.018 |     306 | 16.721 |  3265053.6
                  SQRT 8E |   16384 |     3.129 |     190 | 10.428 |  5235687.4
                 NTT 1E * |   32768 |     0.642 |      19 |      - | 51040657.4
                   MUL 6E |   32768 |     4.629 |     141 |  7.210 |  7078867.5
                  INV 10E |   32768 |     7.226 |     220 | 11.256 |  4534684.2
                  LOG 10E |   32768 |     8.043 |     245 | 12.528 |  4074061.2
                  EXP 14E |   32768 |    10.604 |     323 | 16.517 |  3090278.8
                  SQRT 8E |   32768 |     6.607 |     201 | 10.291 |  4959750.5
                 NTT 1E * |   65536 |     1.367 |      20 |      - | 47927593.8
                   MUL 6E |   65536 |     9.654 |     147 |  7.060 |  6788709.3
                  INV 10E |   65536 |    15.358 |     234 | 11.231 |  4267316.2
                  LOG 10E |   65536 |    16.902 |     257 | 12.360 |  3877512.4
                  EXP 14E |   65536 |    22.486 |     343 | 16.445 |  2914466.9
                  SQRT 8E |   65536 |    13.812 |     210 | 10.101 |  4745008.6
                 NTT 1E * |  131072 |     2.908 |      22 |      - | 45079211.6
                   MUL 6E |  131072 |    21.165 |     161 |  7.279 |  6192822.6
                  INV 10E |  131072 |    32.529 |     248 | 11.188 |  4029374.4
                  LOG 10E |  131072 |    35.707 |     272 | 12.281 |  3670773.9
                  EXP 14E |  131072 |    49.615 |     378 | 17.064 |  2641777.6
                  SQRT 8E |  131072 |    29.359 |     223 | 10.097 |  4464437.8
                 NTT 1E * |  262144 |     6.175 |      23 |      - | 42452572.8
                   MUL 6E |  262144 |    45.689 |     174 |  7.399 |  5737612.9
                  INV 10E |  262144 |    69.845 |     266 | 11.311 |  3753202.0
                  LOG 10E |  262144 |    77.473 |     295 | 12.546 |  3383668.6
                  EXP 14E |  262144 |   103.691 |     395 | 16.792 |  2528130.6
                  SQRT 8E |  262144 |    61.416 |     234 |  9.946 |  4268302.8
                 NTT 1E * |  524288 |    13.033 |      24 |      - | 40228445.7
                   MUL 6E |  524288 |    93.648 |     178 |  7.186 |  5598492.4
                  INV 10E |  524288 |   150.134 |     286 | 11.520 |  3492126.1
                  LOG 10E |  524288 |   163.019 |     310 | 12.508 |  3216114.0
                  EXP 14E |  524288 |   219.532 |     418 | 16.845 |  2388207.0
                  SQRT 8E |  524288 |   131.899 |     251 | 10.121 |  3974918.0
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式平移"><a class="header" href="#ntt-多项式平移">NTT 多项式平移</a></h1>
<p>给定多项式 $f(x)$，求多项式 $f(x + c)$。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

Poly taylor_shift(const Poly &amp;f, Z c) {
	int n = f.deg();
	Poly A(n), B(n);
	Z ci = 1;
	for (int i = 0; i &lt; n; i++) {
		A[i] = f[i] * fac[i];
		B[i] = ci * ifac[i];
		ci *= c;
	}
	std::reverse(A.begin(), A.end());
	A = A * B;
	for (int i = 0; i &lt; n; i++) {
		B[i] = A[n - i - 1] * ifac[i];
	}
	return B;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式多点求值--快速插值"><a class="header" href="#ntt-多项式多点求值--快速插值">NTT 多项式多点求值 &amp; 快速插值</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly operator*(int k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

// @description 多项式多点求值

struct PolyEI {
	int raw_n, n;
	std::vector&lt;Poly&gt; p;
	PolyEI(Poly a) : raw_n(a.deg()), n(get_lim(raw_n)), p(n * 2) {
		a.redeg(n);
		for (int i = 0; i &lt; n; i++)
			p[i + n] = {1, -a[i]};
		for (int i = n - 1; i; i--) {
			int ls = i * 2, rs = i * 2 + 1;
			int len = get_lim(p[ls].deg());
			p[ls].ntt(len), p[rs].ntt(len), p[i].redeg(len);
			for (int j = 0; j &lt; len; j++)
				p[i][j] = p[ls][j] * p[rs][j];
			p[i].intt(len);
			p[i].push_back(p[i][0] - 1), p[i][0] = 1;
		}
	}
	Poly eval(const Poly &amp;f) { // PolyEI(x).eval(f)
		int m = f.deg();
		if (m == 1)
			return Poly(raw_n, f[0]);
		Poly q = f.rev().div(m, p[1]).redeg(m);
		if (m &gt; n) {
			std::rotate(q.begin(), q.begin() + m - n, q.end());
			q.redeg(n);
		} else {
			q.redeg(n);
			std::rotate(q.begin(), q.begin() + m, q.end());
		}
		for (int k = n, o = 1; k &gt; 1; k /= 2)
			for (int i = 0; i &lt; n; i += k, o++) {
				if (i &gt;= raw_n)
					continue;
				Poly foo(k), bar(k);
				auto qi = q.begin() + i;
				ntt(qi, k);
				for (int j = 0; j &lt; k; j++) {
					foo[j] = qi[j] * p[o * 2 + 1][j];
					bar[j] = qi[j] * p[o * 2][j];
				}
				foo.intt(k), bar.intt(k);
				std::copy(foo.begin() + k / 2, foo.end(), qi);
				std::copy(bar.begin() + k / 2, bar.end(), qi + k / 2);
			}
		return q.cut(raw_n);
	}
	Poly inter(const Poly &amp;y) { // PolyEI(x).inter(y)
		Poly q = Poly(p[1]).redeg(raw_n + 1);
		q = eval(q.rev().deriv(raw_n + 1)).redeg(n);
		for (int i = 0; i &lt; raw_n; i++)
			q[i] = y[i] / q[i];
		for (int k = 1, h = n / 2; k &lt; n; k *= 2, h /= 2)
			for (int i = 0, o = h; i &lt; n; i += k * 2, o++) {
				if (i &gt;= raw_n)
					continue;
				auto qi = q.begin() + i;
				Poly foo(qi, qi + k), bar(qi + k, qi + k * 2);
				foo.ntt(k * 2), bar.ntt(k * 2);
				for (int j = 0; j &lt; k * 2; j++) {
					qi[j] = foo[j] * p[o * 2 + 1][j] + bar[j] * p[o * 2][j];
				}
				intt(qi, k * 2);
			}
		return q.cut(raw_n).rev();
	}
};
</code></pre>
<pre><code>poly/ntt-eval.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |       0 |      - |        inf
                     EVAL |       1 |     0.001 |     800 |    inf |  1250000.0
                    INTER |       1 |     0.001 |     600 |    inf |  1666666.7
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                     EVAL |       2 |     0.003 |    1500 | 30.000 |   666666.7
                    INTER |       2 |     0.003 |    1450 | 29.000 |   689655.2
                 NTT 1E * |      64 |     0.001 |      12 |      - | 80000000.0
                     EVAL |      64 |     0.048 |     742 | 59.375 |  1347368.4
                    INTER |      64 |     0.049 |     767 | 61.375 |  1303462.3
                 NTT 1E * |     512 |     0.006 |      12 |      - | 81269841.3
                     EVAL |     512 |     0.529 |    1033 | 84.000 |   967499.9
                    INTER |     512 |     0.506 |     987 | 80.285 |  1012261.8
                 NTT 1E * |    4096 |     0.065 |      15 |      - | 63210852.0
                     EVAL |    4096 |     5.578 |    1361 | 86.075 |   734368.1
                    INTER |    4096 |     5.601 |    1367 | 86.432 |   731339.4
                 NTT 1E * |   16384 |     0.307 |      18 |      - | 53316151.4
                     EVAL |   16384 |    27.064 |    1651 | 88.069 |   605390.6
                    INTER |   16384 |    27.099 |    1653 | 88.184 |   604599.7
                 NTT 1E * |   32768 |     0.642 |      19 |      - | 51040657.4
                     EVAL |   32768 |    59.744 |    1823 | 93.060 |   548473.2
                    INTER |   32768 |    59.576 |    1818 | 92.797 |   550023.6
                 NTT 1E * |   65536 |     1.367 |      20 |      - | 47931099.0
                     EVAL |   65536 |   130.589 |    1992 | 95.509 |   501848.5
                    INTER |   65536 |   130.216 |    1986 | 95.236 |   503288.3
                 NTT 1E * |  131072 |     2.908 |      22 |      - | 45074591.9
                     EVAL |  131072 |   283.476 |    2162 | 97.485 |   462374.0
                    INTER |  131072 |   286.674 |    2187 | 98.585 |   457215.8
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-chirp-z-变换"><a class="header" href="#ntt-chirp-z-变换">NTT Chirp Z 变换</a></h1>
<p>给定 $f(x)$ 和常数 $c$，计算 $f(c^0), f(c^1), \cdots, f(c^m)$。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

Poly chirpz(const Poly &amp;f, int m, Z c) {
	int n = f.deg(), N = get_lim(n + m - 1);
	Poly A = f, pw(n + m, 1), ipw(n + m, 1);
	Z ci = c, ivc = c.inv(), ici = ivc;
	for (int i = 2; i &lt; n + m; i++) {
		pw[i] = pw[i - 1] * ci;
		ipw[i] = ipw[i - 1] * ici;
		ci *= c, ici *= ivc;
	}
	for (int i = 0; i &lt; n; i++)
		A[i] *= ipw[i];
	std::reverse(A.begin(), A.end());
	Poly::mul(A, pw, N);
	Poly x(m);
	for (int i = 0; i &lt; m; i++) {
		x[i] = A[i + n - 1] * ipw[i];
	}
	return x;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-在线卷积"><a class="header" href="#ntt-在线卷积">NTT 在线卷积</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-半在线卷积"><a class="header" href="#ntt-半在线卷积">NTT 半在线卷积</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

struct PolySemi {
	int now = 0;
	enum : int { M = 32 };
	const Poly &amp;F;
	Poly G, conv;
	std::map&lt;int, Poly&gt; nf;
	PolySemi(const Poly &amp;f) : F(f), G(M), conv(M) {}
	void set(Z v) {
		G[now] = v;
		conv[now] += G[now] * F[0];
		now++;
	}
	Z next() { // return  (F * G)[now] - F[0] G[now]
		int len = now &amp; -now, l = now - len;
		if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else {
			Poly a = G.cut(len, l).ntt(len * 2), &amp;b = nf[len];
			if (l == 0) {
				b = F.cut(len * 2).ntt(len * 2);
				conv.redeg(now * 2);
				G.redeg(now * 2);
			}
			for (int i = 0; i &lt; len * 2; i++)
				a[i] *= b[i];
			a.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += a[i];
		}
		return conv[now];
	}
};

Poly semi_inv(Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = -F[0].inv();
	X.set(-iv0);
	for (int i = 1; i &lt; m; i++) {
		X.set(iv0 * X.next());
	}
	return X.G.redeg(m);
}

Poly semi_div(Poly H, Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = F[0].inv();
	X.set(iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly semi_exp(Poly F, int m) {
	for (int i = 0; i &lt; F.size(); i++)
		F[i] *= i;
	PolySemi X(F);
	X.set(1);
	for (int i = 1; i &lt; m; i++)
		X.set(iv[i] * X.next());
	return X.G.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-semi.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |       0 |      - |        inf
                      INV |       1 |     0.000 |     400 |    inf |  2500000.0
                      DIV |       1 |     0.001 |     800 |    inf |  1250000.0
                      EXP |       1 |     0.001 |     800 |    inf |  1250000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.001 |     650 | 13.000 |  1538461.5
                      DIV |       2 |     0.001 |     300 |  6.000 |  3333333.3
                      EXP |       2 |     0.001 |     500 | 10.000 |  2000000.0
                 NTT 1E * |      64 |     0.001 |       9 |      - |106666666.7
                      INV |      64 |     0.006 |      95 | 10.167 | 10491803.3
                      DIV |      64 |     0.007 |     110 | 11.833 |  9014084.5
                      EXP |      64 |     0.006 |      93 | 10.000 | 10666666.7
                 NTT 1E * |     512 |     0.006 |      12 |      - | 82580645.2
                      INV |     512 |     0.096 |     186 | 15.435 |  5350108.2
                      DIV |     512 |     0.093 |     181 | 15.000 |  5505376.3
                      EXP |     512 |     0.094 |     183 | 15.129 |  5458422.2
                 NTT 1E * |    4096 |     0.065 |      15 |      - | 63503876.0
                      INV |    4096 |     1.204 |     293 | 18.665 |  3402287.2
                      DIV |    4096 |     1.198 |     292 | 18.569 |  3419896.7
                      EXP |    4096 |     1.202 |     293 | 18.634 |  3407948.8
                 NTT 1E * |   16384 |     0.300 |      18 |      - | 54613515.4
                      INV |   16384 |     6.197 |     378 | 20.656 |  2643952.9
                      DIV |   16384 |     6.206 |     378 | 20.685 |  2640203.6
                      EXP |   16384 |     6.233 |     380 | 20.776 |  2628681.7
                 NTT 1E * |   32768 |     0.645 |      19 |      - | 50763827.7
                      INV |   32768 |    13.978 |     426 | 21.655 |  2344261.8
                      DIV |   32768 |    14.014 |     427 | 21.711 |  2338156.4
                      EXP |   32768 |    14.062 |     429 | 21.784 |  2330324.7
                 NTT 1E * |   65536 |     1.367 |      20 |      - | 47945125.3
                      INV |   65536 |    31.261 |     477 | 22.870 |  2096393.1
                      DIV |   65536 |    31.824 |     485 | 23.282 |  2059319.1
                      EXP |   65536 |    31.512 |     480 | 23.053 |  2079747.9
                 NTT 1E * |  131072 |     3.069 |      23 |      - | 42704324.9
                      INV |  131072 |    71.031 |     541 | 23.142 |  1845289.2
                      DIV |  131072 |    70.482 |     537 | 22.963 |  1859665.2
                      EXP |  131072 |    71.465 |     545 | 23.284 |  1834067.5
                 NTT 1E * |  262144 |     6.181 |      23 |      - | 42408632.5
                      INV |  262144 |   156.620 |     597 | 25.337 |  1673759.6
                      DIV |  262144 |   157.802 |     601 | 25.529 |  1661222.5
                      EXP |  262144 |   156.995 |     598 | 25.398 |  1669762.7
                 NTT 1E * |  524288 |    13.788 |      26 |      - | 38025608.4
                      INV |  524288 |   346.274 |     660 | 25.115 |  1514082.3
                      DIV |  524288 |   346.371 |     660 | 25.122 |  1513658.8
                      EXP |  524288 |   346.409 |     660 | 25.124 |  1513492.7
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt半在线卷积卡常"><a class="header" href="#ntt半在线卷积卡常">NTT・半在线卷积・卡常</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

using pii = std::pair&lt;int, int&gt;;

struct PolySemi {
	int now = 0;
	enum : int { M = 32, B = 16 };
	const Poly &amp;F;
	Poly G, conv;
	std::map&lt;pii, Poly&gt; nf, nr;
	std::vector&lt;int&gt; U;
	PolySemi(const Poly &amp;f) : F(f), G(M), conv(M), U(32, -1) {}
	Poly &amp;getNf(pii p) {
		auto &amp;u = nf[p];
		if (u.empty())
			u = F.cut(p.first, p.second).ntt(p.first);
		return u;
	}
	Poly &amp;getNr(pii p) {
		auto &amp;u = nr[p];
		if (u.empty())
			u = G.cut(p.first, p.second).ntt(p.first * 2);
		return u;
	}
	void set(Z v) {
		G[now] = v;
		conv[now] += G[now] * F[0];
		now++;
	}
	Z next() { // return sum{i in [0, now)} F[i] G[now - i]
		int len = now &amp; -now;
		if (len == now) {
			conv.resize(now * 2);
			G.redeg(now * 2);
		}
		if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else {
			int u = std::__lg(len / M) / std::__lg(B);
			int t = ++U[u] % (B - 1);
			len = (1 &lt;&lt; (u * std::__lg(B))) * M;
			int l = now - len;
			Poly s(len * 2);
			for (int i = 0; i &lt;= t; i++) {
				Poly &amp;a = getNr({len, l - i * len});
				Poly &amp;b = getNf({len * 2, len * i});
				for (int j = 0; j &lt; len * 2; j++)
					s[j] += a[j] * b[j];
			}
			s.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += s[i];
		}
		return conv[now];
	}
};

Poly semi_inv(Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = -F[0].inv();
	X.set(-iv0);
	for (int i = 1; i &lt; m; i++) {
		X.set(iv0 * X.next());
	}
	return X.G.redeg(m);
}

Poly semi_div(Poly H, Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = F[0].inv();
	X.set(iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly semi_exp(Poly F, int m) {
	for (int i = 0; i &lt; F.size(); i++)
		F[i] *= i;
	PolySemi X(F);
	X.set(1);
	for (int i = 1; i &lt; m; i++)
		X.set(iv[i] * X.next());
	return X.G.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-semi.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.001 |     800 |  8.000 |  1250000.0
                      DIV |       1 |     0.001 |     900 |  9.000 |  1111111.1
                      EXP |       1 |     0.000 |     400 |  4.000 |  2500000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.001 |     650 | 13.000 |  1538461.5
                      DIV |       2 |     0.001 |     400 |  8.000 |  2500000.0
                      EXP |       2 |     0.001 |     600 | 12.000 |  1666666.7
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                      INV |      64 |     0.009 |     137 | 12.571 |  7272727.3
                      DIV |      64 |     0.008 |     126 | 11.571 |  7901234.6
                      EXP |      64 |     0.010 |     156 | 14.286 |  6400000.0
                 NTT 1E * |     512 |     0.006 |      12 |      - | 81269841.3
                      INV |     512 |     0.086 |     168 | 13.730 |  5919075.1
                      DIV |     512 |     0.084 |     164 | 13.365 |  6080760.1
                      EXP |     512 |     0.089 |     174 | 14.174 |  5733546.8
                 NTT 1E * |    4096 |     0.065 |      15 |      - | 63307573.4
                      INV |    4096 |     0.998 |     243 | 15.422 |  4105043.4
                      DIV |    4096 |     0.994 |     242 | 15.359 |  4121980.8
                      EXP |    4096 |     0.993 |     242 | 15.348 |  4124886.6
                 NTT 1E * |   16384 |     0.300 |      18 |      - | 54522644.0
                      INV |   16384 |     5.149 |     314 | 17.135 |  3181862.1
                      DIV |   16384 |     5.105 |     311 | 16.988 |  3209412.0
                      EXP |   16384 |     5.079 |     309 | 16.901 |  3226094.8
                 NTT 1E * |   32768 |     0.642 |      19 |      - | 51024761.8
                      INV |   32768 |    11.009 |     335 | 17.142 |  2976536.3
                      DIV |   32768 |    11.182 |     341 | 17.412 |  2930353.7
                      EXP |   32768 |    11.150 |     340 | 17.362 |  2938921.3
                 NTT 1E * |   65536 |     1.377 |      21 |      - | 47586545.4
                      INV |   65536 |    23.442 |     357 | 17.021 |  2795697.5
                      DIV |   65536 |    23.629 |     360 | 17.157 |  2773525.3
                      EXP |   65536 |    23.812 |     363 | 17.290 |  2752256.6
                 NTT 1E * |  131072 |     2.904 |      22 |      - | 45139773.8
                      INV |  131072 |    49.715 |     379 | 17.121 |  2636469.9
                      DIV |  131072 |    50.414 |     384 | 17.362 |  2599904.5
                      EXP |  131072 |    50.576 |     385 | 17.418 |  2591587.0
                 NTT 1E * |  262144 |     6.169 |      23 |      - | 42495949.7
                      INV |  262144 |   116.401 |     444 | 18.870 |  2252083.2
                      DIV |  262144 |   120.635 |     460 | 19.556 |  2173033.2
                      EXP |  262144 |   120.516 |     459 | 19.537 |  2175188.0
                 NTT 1E * |  524288 |    13.035 |      24 |      - | 40222902.7
                      INV |  524288 |   257.710 |     491 | 19.771 |  2034410.2
                      DIV |  524288 |   261.460 |     498 | 20.059 |  2005232.4
                      EXP |  524288 |   252.972 |     482 | 19.408 |  2072509.9
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt全在线卷积"><a class="header" href="#ntt全在线卷积">NTT・全在线卷积</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

std::vector&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = std::vector&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

std::vector&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : std::vector&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

using pii = std::pair&lt;int, int&gt;;

struct PolyRelax {
	int now = 0;
	enum : int { M0 = 1024, M = 32 };
	Poly F, G, conv;
	std::map&lt;int, Poly&gt; nf, ng;

	PolyRelax() : F(M0), G(M0), conv(M0) {}

	Poly &amp;getNf(int len) {
		auto &amp;u = nf[len];
		if (u.empty())
			u = F.cut(len).ntt(len);
		return u;
	}

	Poly &amp;getNg(int len) {
		auto &amp;u = ng[len];
		if (u.empty())
			u = G.cut(len).ntt(len);
		return u;
	}

	void set(Z v1, Z v2) {
		F[now] = v1, G[now] = v2;
		conv[now] += G[now] * F[0];
		if (now != 0)
			conv[now] += F[now] * G[0];
		now++;
	}

	Z next() { // return (F * G)[now] - F[0] G[now] - F[now] G[0]
		int len = now &amp; -now, l = now - len;
		if (now &lt; M0) {
			for (int j = (now &amp; -M0) + 1; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else if (len == now) {
			conv.redeg(len * 2);
			F.redeg(len * 2);
			G.redeg(len * 2);
			Poly a = getNg(len), &amp;b = getNf(len);
			for (int i = 0; i &lt; len; i++)
				a[i] *= b[i];
			a.intt(len);
			for (int i = len; i &lt; len * 2; i++)
				conv[i] += a[i - len] - conv[i - len];
		} else if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j) {
				conv[now] += G[j] * F[now - j] + F[j] * G[now - j];
			}
		} else {
			Poly a = G.cut(len, l), &amp;b = getNf(len * 2);
			Poly c = F.cut(len, l), &amp;d = getNg(len * 2);
			a.ntt(len * 2), c.ntt(len * 2);
			for (int i = 0; i &lt; len * 2; ++i)
				a[i] = a[i] * b[i] + c[i] * d[i];
			a.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += a[i];
		}
		return conv[now];
	}
};

Poly relax_inv(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = -F[0].inv();
	X.set(F[0], -iv0);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv0 * (X.next() - F[i] * iv0));
	return X.G.redeg(m);
}

Poly relax_div(Poly H, Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = F[0].inv();
	X.set(F[0], iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly relax_exp(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	for (int i = 0; i &lt; F.deg(); i++)
		F[i] *= i;
	X.set(F[0], 1);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv[i] * (X.next() + F[i]));
	return X.G.redeg(m);
}

Poly relax_sqrt(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = 1; // F[0].sqrt()
	X.set(iv0, iv0);
	iv0 = (iv0 * 2).inv();
	for (int i = 1; i &lt; m; i++) {
		Z t = (F[i] - X.next()) * iv0;
		X.set(t, t);
	}
	return X.F.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-relax.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.001 |    1100 | 11.000 |   909090.9
                      DIV |       1 |     0.002 |    2200 | 22.000 |   454545.5
                      EXP |       1 |     0.001 |    1000 | 10.000 |  1000000.0
                     SQRT |       1 |     0.001 |    1400 | 14.000 |   714285.7
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.001 |     550 | 11.000 |  1818181.8
                      DIV |       2 |     0.003 |    1500 | 30.000 |   666666.7
                      EXP |       2 |     0.003 |    1400 | 28.000 |   714285.7
                     SQRT |       2 |     0.002 |     900 | 18.000 |  1111111.1
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                      INV |      64 |     0.006 |      98 |  9.000 | 10158730.2
                      DIV |      64 |     0.007 |     112 | 10.286 |  8888888.9
                      EXP |      64 |     0.007 |     103 |  9.429 |  9696969.7
                     SQRT |      64 |     0.008 |     118 | 10.857 |  8421052.6
                 NTT 1E * |     512 |     0.006 |      12 |      - | 81269841.3
                      INV |     512 |     0.296 |     578 | 47.047 |  1727401.2
                      DIV |     512 |     0.301 |     588 | 47.809 |  1699872.8
                      EXP |     512 |     0.298 |     582 | 47.301 |  1718126.6
                     SQRT |     512 |     0.297 |     579 | 47.095 |  1725654.6
                 NTT 1E * |    4096 |     0.065 |      15 |      - | 63307573.4
                      INV |    4096 |     2.221 |     542 | 34.323 |  1844469.3
                      DIV |    4096 |     2.325 |     567 | 35.930 |  1761952.3
                      EXP |    4096 |     2.345 |     572 | 36.250 |  1746402.4
                     SQRT |    4096 |     2.220 |     542 | 34.314 |  1844966.9
                 NTT 1E * |   16384 |     0.300 |      18 |      - | 54577130.5
                      INV |   16384 |     8.222 |     501 | 27.389 |  1992683.8
                      DIV |   16384 |     8.236 |     502 | 27.434 |  1989369.1
                      EXP |   16384 |     8.366 |     510 | 27.868 |  1958408.7
                     SQRT |   16384 |     8.367 |     510 | 27.873 |  1958057.6
                 NTT 1E * |   32768 |     0.649 |      19 |      - | 50474585.6
                      INV |   32768 |    17.835 |     544 | 27.472 |  1837332.5
                      DIV |   32768 |    17.791 |     542 | 27.404 |  1841866.3
                      EXP |   32768 |    17.935 |     547 | 27.626 |  1827077.8
                     SQRT |   32768 |    17.868 |     545 | 27.523 |  1833918.7
                 NTT 1E * |   65536 |     1.369 |      20 |      - | 47871578.9
                      INV |   65536 |    39.453 |     602 | 28.819 |  1661095.1
                      DIV |   65536 |    39.008 |     595 | 28.494 |  1680070.3
                      EXP |   65536 |    39.390 |     601 | 28.773 |  1663777.2
                     SQRT |   65536 |    39.207 |     598 | 28.639 |  1671555.7
                 NTT 1E * |  131072 |     2.913 |      22 |      - | 44995660.8
                      INV |  131072 |    87.126 |     664 | 29.910 |  1504391.5
                      DIV |  131072 |    88.282 |     673 | 30.306 |  1484704.3
                      EXP |  131072 |    87.053 |     664 | 29.884 |  1505653.0
                     SQRT |  131072 |    88.031 |     671 | 30.220 |  1488922.4
                 NTT 1E * |  262144 |     6.167 |      23 |      - | 42506968.0
                      INV |  262144 |   196.059 |     747 | 31.791 |  1337067.9
                      DIV |  262144 |   196.224 |     748 | 31.818 |  1335942.9
                      EXP |  262144 |   195.079 |     744 | 31.632 |  1343786.2
                     SQRT |  262144 |   195.605 |     746 | 31.718 |  1340169.9
                 NTT 1E * |  524288 |    13.775 |      26 |      - | 38061768.8
                      INV |  524288 |   432.537 |     824 | 31.401 |  1212121.8
                      DIV |  524288 |   433.130 |     826 | 31.444 |  1210462.6
                      EXP |  524288 |   433.457 |     826 | 31.468 |  1209549.1
                     SQRT |  524288 |   431.840 |     823 | 31.350 |  1214079.6
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并查集"><a class="header" href="#并查集">并查集</a></h1>
<pre><code class="language-cpp">// @description 朴素并查集

struct DSU {
	std::vector&lt;int&gt; fa;
	DSU(int n) : fa(n) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		fa[x] = y;
	}
};
</code></pre>
<h2 id="测试例题-19"><a class="header" href="#测试例题-19">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/unionfind">yosupo Unionfind</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="带权并查集"><a class="header" href="#带权并查集">带权并查集</a></h1>
<pre><code class="language-cpp">// @description 带权并查集

struct DSU {
	std::vector&lt;int&gt; fa, sz;
	DSU(int n) : fa(n), sz(n, 1) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	int size(int x) {
		return sz[find(x)];
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		if (x == y)
			return;
		if (sz[x] &gt; sz[y])
			std::swap(x, y);
		sz[y] += sz[x], fa[x] = y;
		sz[x] = 0;
	}
};
</code></pre>
<h2 id="测试例题-20"><a class="header" href="#测试例题-20">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1536">P1536 村村通</a>（也不是不能用）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="st"><a class="header" href="#st">ST</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	std::vector&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description Sparse Table

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	void init(auto first, auto last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = max(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) const {
		int s = std::__lg(r - l + 1);
		return max(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};
</code></pre>
<h2 id="测试例题-21"><a class="header" href="#测试例题-21">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3865">P3865 ST 表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="滑动窗口"><a class="header" href="#滑动窗口">滑动窗口</a></h1>
<pre><code class="language-cpp">// @description 滑动窗口

template &lt;class T&gt;
auto sliding(const std::vector&lt;T&gt; &amp;v, int k) {
	int l = 0, r = -1, n = v.size();
	std::vector&lt;int&gt; q(n), ret(n);
	for (int i = 0; i &lt; n; i++) {
		while (l &lt;= r &amp;&amp; i - k &gt;= q[l])
			l++;
		while (l &lt;= r &amp;&amp; v[i] &lt; v[q[r]])
			r--;
		q[++r] = i;
		ret[i] = q[l];
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-22"><a class="header" href="#测试例题-22">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树状数组"><a class="header" href="#树状数组">树状数组</a></h1>
<pre><code class="language-cpp">// @description 树状数组

template &lt;class T&gt;
struct fwtree {
	int n;
	std::vector&lt;T&gt; v;
	// 1 ~ N - 1
	fwtree(int a = 0) : n(a), v(n) {}
	void add(int i, T x) {
		for (; i &lt; n; i += i &amp; -i) {
			v[i] += x;
		}
	}
	void build(auto first, auto last) {
		std::copy(first, last, v.begin());
		for (int i = 1; i &lt; n; i++) {
			int j = i + (i &amp; -i);
			if (j &lt; n) {
				v[j] += v[i];
			}
		}
	}
	T sum(int i) const {
		assert(i &lt; n);
		T sum = T();
		for (; i &gt; 0; i -= i &amp; -i)
			sum += v[i];
		return sum;
	}
	T sum(int l, int r) const {
		assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt; n);
		return sum(r) - sum(l - 1);
	}
};
</code></pre>
<h2 id="测试例题-23"><a class="header" href="#测试例题-23">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/point_add_range_sum">yosupo Point Add Range Sum</a></li>
<li><a href="https://loj.ac/p/130">LOJ130 树状数组 1 ：单点修改，区间查询</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="堆"><a class="header" href="#堆">堆</a></h1>
<pre><code class="language-cpp">// @description 小根堆

template &lt;class T&gt;
struct Heap {
	std::vector&lt;T&gt; v;
	Heap() : v(1) {}
	bool update(int p) {
		bool f = v[p] &lt; v[p / 2];
		if (f) {
			std::swap(v[p], v[p / 2]);
		}
		return !f;
	}
	T top() {
		return v[1];
	}
	void put(T x) {
		v.push_back(x);
		int p = v.size() - 1;
		while (p &gt; 1) {
			if (update(p))
				return;
			p /= 2;
		}
	}
	void pop() {
		v[1] = v.back();
		v.pop_back();
		int sz = v.size(), p = 2;
		while (p &lt; sz) {
			if (p + 1 &lt; sz &amp;&amp; v[p + 1] &lt; v[p])
				p++;
			if (update(p))
				return;
			p *= 2;
		}
	}
};
</code></pre>
<h2 id="测试例题-24"><a class="header" href="#测试例题-24">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3378">P3378 堆</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线段树"><a class="header" href="#线段树">线段树</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线段树-1"><a class="header" href="#线段树-1">线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树

template &lt;class Val, auto merge = std::plus()&gt;
struct SegTree {
	const int N;
	std::vector&lt;Val&gt; tr;
	SegTree(std::uint32_t n) : N(std::bit_ceil(n)), tr(N * 2) {}
	auto leaf() {
		return std::span(tr.begin() + N, tr.end());
	}
	void pull(int p) {
		tr[p] = merge(tr[p * 2], tr[p * 2 + 1]);
	}
	void build() {
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
	void modify(int i, auto &amp;&amp;op) {
		i += N, op(tr[i]);
		for (i /= 2; i &gt; 0; i /= 2)
			pull(i);
	}
	Val query(int l, int r) {
		Val vl{}, vr{};
		int pl = l + N, pr = r + N;
		while (pr - pl &gt;= 1) {
			if (pl % 2 == 1)
				vl = merge(vl, tr[pl]);
			if (pr % 2 == 1)
				vr = merge(tr[pr - 1], vr);
			pl = (pl + 1) / 2, pr /= 2;
		}
		return merge(vl, vr);
	}
};
</code></pre>
<h2 id="测试例题-25"><a class="header" href="#测试例题-25">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="懒标记线段树"><a class="header" href="#懒标记线段树">懒标记线段树</a></h1>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<ul>
<li><code>SegTree(n)</code>：令 $N = 2^{\lceil \log_2 (n) \rceil}$，创建一个 $[0, N)$ 的线段树。</li>
<li><code>build(first, last)</code>：传入迭代器，$O(n)$ 的建树。</li>
<li><code>modify(l, r, tag)</code>：对区间 $[l, r)$ 作用 $tag$。</li>
<li><code>query(l, r)</code>：查询区间 $[l, r)$ 的值。</li>
</ul>
<h2 id="代码"><a class="header" href="#代码">代码</a></h2>
<pre><code class="language-cpp">// @description 线段树(懒标记)

template &lt;class Val, class Tag, auto merge = std::plus()&gt;
struct SegTree {
	const int N;
	struct Seg {
		Val val;
		std::optional&lt;Tag&gt; tag;
		void apply(const Tag &amp;t) {
			t.to(val);
			if (tag.has_value())
				t.to(tag.value());
			else
				tag = t;
		}
	};
	std::vector&lt;Seg&gt; tr;
	SegTree(std::uint32_t n) : N(std::bit_ceil(n)), tr(N * 2) {}
	auto leaf() {
		return std::span(tr.begin() + N, tr.end());
	}
	void build() {
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
#define lson p * 2
#define rson p * 2 + 1
	template &lt;bool with_pull&gt;
	void traverse(int l, int r, auto &amp;&amp;op) {
		auto dfs = [&amp;](auto &amp;&amp;self, int p, int L, int R) -&gt; void {
			if (l &lt;= L &amp;&amp; R &lt;= r) {
				op(tr[p]);
			} else {
				int M = (L + R) / 2;
				auto &amp;t = tr[p].tag;
				if (t.has_value()) {
					tr[lson].apply(t.value());
					tr[rson].apply(t.value());
					t.reset();
				}
				if (l &lt; M)
					self(self, lson, L, M);
				if (r &gt; M)
					self(self, rson, M, R);
				if constexpr (with_pull)
					pull(p);
			}
		};
		dfs(dfs, 1, 0, N);
	}
	void pull(int p) {
		tr[p].val = merge(tr[lson].val, tr[rson].val);
	}
	void modify(int l, int r, const Tag &amp;t) {
		traverse&lt;true&gt;(l, r, [&amp;](Seg &amp;cur) {
			cur.apply(t);
		});
	}
	Val query(int l, int r) {
		Val ret{};
		traverse&lt;false&gt;(l, r, [&amp;](const Seg &amp;cur) {
			ret = merge(ret, cur.val);
		});
		return ret;
	}
};
</code></pre>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<p>例如在 <a href="https://www.luogu.com.cn/problem/P3373">P3373 线段树 2</a> 中。</p>
<pre><code class="language-cpp">struct Val {
	int sum = 0, len = 0;
};
struct Tag {
	int k = 1, m = 0;
	void to(Tag &amp;t) const {
		t.m = (1ll * t.m * k + m) % P;
		t.k = (1ll * t.k * k) % P;
	}
	void to(Val &amp;v) const {
		v.sum = (1ll * k * v.sum + 1ll * m * v.len) % P;
	}
};
Val merge(const Val &amp;l, const Val &amp;r) {
	return {(l.sum + r.sum) % P, l.len + r.len};
}
</code></pre>
<h2 id="测试例题-26"><a class="header" href="#测试例题-26">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3372">P3372 线段树 1</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3373">P3373 线段树 2</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线段树-2"><a class="header" href="#线段树-2">线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树

template &lt;class Val, auto E, auto merge = std::plus()&gt;
struct SegTree {
	struct Seg {
		Val val{};
		Seg(const Val v = {}) : val(v) {}
		Seg *ls = nullptr, *rs = nullptr;
	};
	static Seg *clone(Seg *p, ll len) {
		static std::queue&lt;Seg&gt; pool;
		return &amp;pool.emplace(!p ? E(len) : *p);
	}
	const ll L0, R0;
	SegTree(ll l, ll r) : L0(l), R0(r) {}
	Seg *root() {
		return clone(nullptr, R0 - L0);
	}
	Val val(Seg *p, ll len) {
		return !p ? E(len) : p-&gt;val;
	}
	template &lt;bool create = false&gt;
	Seg *modify(Seg *rt, ll k, auto &amp;&amp;op) {
		auto dfs = [&amp;](auto &amp;&amp;self, Seg *p, ll L, ll R) -&gt; Seg * {
			if (create || !p)
				p = clone(p, R - L);
			if (R - L == 1) {
				op(p-&gt;val);
			} else {
				ll M = (L + R) / 2;
				if (k &lt; M)
					p-&gt;ls = self(self, p-&gt;ls, L, M);
				else
					p-&gt;rs = self(self, p-&gt;rs, M, R);
				p-&gt;val = merge(val(p-&gt;ls, M - L), val(p-&gt;rs, R - M));
			}
			return p;
		};
		return dfs(dfs, rt, L0, R0);
	}
	Val query(Seg *rt, ll l, ll r) {
		Val ret{};
		auto dfs = [&amp;](auto &amp;&amp;self, Seg *p, ll L, ll R) -&gt; void {
			if (l &lt;= L &amp;&amp; R &lt;= r) {
				ret = merge(ret, val(p, R - L));
			} else {
				ll M = (L + R) / 2;
				if (l &lt; M)
					self(self, !p ? p : p-&gt;ls, L, M);
				if (r &gt; M)
					self(self, !p ? p : p-&gt;rs, M, R);
			}
		};
		dfs(dfs, rt, L0, R0);
		return ret;
	}
};
</code></pre>
<h2 id="测试例题-27"><a class="header" href="#测试例题-27">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="懒标记线段树-1"><a class="header" href="#懒标记线段树-1">懒标记线段树</a></h1>
<h2 id="代码-1"><a class="header" href="#代码-1">代码</a></h2>
<pre><code class="language-cpp">// @description 线段树(懒标记)

template &lt;class Val, class Tag, auto E, auto merge = std::plus()&gt;
struct SegTree {
	struct Seg {
		Val val{};
		std::optional&lt;Tag&gt; tag{};
		Seg *ls = nullptr, *rs = nullptr;
		Seg(const Val &amp;v) : val(v) {}
		void apply(const Tag &amp;t) {
			t.to(val);
			if (tag.has_value())
				t.to(tag.value());
			else
				tag = t;
		}
	};
	const ll L0, R0;
	Seg *rt = nullptr;
	SegTree(ll l, ll r) : L0(l), R0(r) {}
	static Seg *alloc(ll len) {
		static std::queue&lt;Seg&gt; pool;
		return &amp;pool.emplace(E(len));
	}
	Val val(Seg *p, ll len) {
		return !p ? E(len) : p-&gt;val;
	}
	template &lt;bool with_pull&gt;
	Seg *traverse(Seg *s, ll l, ll r, auto &amp;&amp;op) {
		auto dfs = [&amp;](auto &amp;&amp;self, Seg *p, ll L, ll R) -&gt; Seg * {
			if (!p) {
				p = alloc(R - L);
			}
			if (l &lt;= L &amp;&amp; R &lt;= r) {
				op(p);
			} else {
				int M = (L + R) / 2;
				auto &amp;tt = p-&gt;tag;
				if (tt.has_value()) {
					if (!p-&gt;ls)
						p-&gt;ls = alloc(M - L);
					if (!p-&gt;rs)
						p-&gt;rs = alloc(R - M);
					p-&gt;ls-&gt;apply(tt.value());
					p-&gt;rs-&gt;apply(tt.value());
					tt.reset();
				}
				if (l &lt; M)
					p-&gt;ls = self(self, p-&gt;ls, L, M);
				if (r &gt; M)
					p-&gt;rs = self(self, p-&gt;rs, M, R);
				if constexpr (with_pull)
					p-&gt;val = merge(val(p-&gt;ls, M - L), val(p-&gt;rs, R - M));
			}
			return p;
		};
		return dfs(dfs, s, L0, R0);
	}
	void modify(ll l, ll r, const Tag &amp;t) {
		rt = traverse&lt;true&gt;(rt, l, r, [&amp;](Seg *p) {
			p-&gt;apply(t);
		});
	}
	Val query(ll l, ll r) {
		Val ret{};
		rt = traverse&lt;false&gt;(rt, l, r, [&amp;](Seg *p) {
			ret = merge(ret, p-&gt;val);
		});
		return ret;
	}
};
</code></pre>
<h2 id="例子-1"><a class="header" href="#例子-1">例子</a></h2>
<p>例如在 <a href="https://www.luogu.com.cn/problem/P3373">P3373 线段树 2</a> 中。</p>
<pre><code class="language-cpp">struct Val {
	int sum = 0, len = 0;
};
struct Tag {
	int k = 1, m = 0;
	void to(Tag &amp;t) const {
		t.m = (1ll * t.m * k + m) % P;
		t.k = (1ll * t.k * k) % P;
	}
	void to(Val &amp;v) const {
		v.sum = (1ll * k * v.sum + 1ll * m * v.len) % P;
	}
};
Val merge(const Val &amp;l, const Val &amp;r) {
	return {(l.sum + r.sum) % P, l.len + r.len};
}
Val E(int len) {
	return {0, len};
}
</code></pre>
<h2 id="测试例题-28"><a class="header" href="#测试例题-28">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3372">P3372 线段树 1</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3373">P3373 线段树 2</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算几何"><a class="header" href="#计算几何">计算几何</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="点"><a class="header" href="#点">点</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-多边形"><a class="header" href="#f-多边形">F 多边形</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}

using VP = std::vector&lt;P&gt;;

template &lt;class RET&gt;
RET ring_act(const auto &amp;v, auto &amp;&amp;func) {
	RET ret{};
	for (int i = 0; i &lt; v.size() - 1; i++)
		ret += func(v[i], v[i + 1]);
	if (v.size() &gt;= 2)
		ret += func(v.back(), v.front());
	return ret;
}

D area(const VP &amp;v) {
	return ring_act&lt;D&gt;(v, crs) / 2;
}

// 必须排序且去重！
VP convex_down(const VP &amp;ps) {
	assert(ps.size() &gt;= 2);
	VP dw;
	for (P d : ps) {
		for (int n = dw.size(); n &gt; 1; n--, dw.pop_back()) {
			if (ccw(dw[n - 2], dw[n - 1], d) == 1)
				break;
		}
		dw.push_back(d);
	}
	return dw;
}

VP convex(VP ps) {
	std::sort(ps.begin(), ps.end());
	ps.erase(std::unique(ps.begin(), ps.end()), ps.end());
	if (ps.size() &lt;= 1)
		return ps;
	VP dw = convex_down(ps);
	std::reverse(ps.begin(), ps.end());
	VP up = convex_down(ps);
	dw.insert(dw.begin(), up.begin() + 1, up.end() - 1);
	return dw;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-冲突判定"><a class="header" href="#f-冲突判定">F 冲突判定</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}

P proj(const L &amp;l, const P &amp;p) {
	P v = l.vec();
	return l.s + v * dot(v, p - l.s) / v.norm();
}

bool insSL(const L &amp;s, const L &amp;l) {
	int a = ccw(l, s.s), b = ccw(l, s.t);
	return (a % 2 == 0 || b % 2 == 0 || a != b);
}

bool insSS(const L &amp;s, const L &amp;t) {
	int a = ccw(s, t.s), b = ccw(s, t.t);
	int c = ccw(t, s.s), d = ccw(t, s.t);
	return a * b &lt;= 0 &amp;&amp; c * d &lt;= 0;
}

D distLP(const L &amp;l, const P &amp;p) {
	return std::abs(crs(l.vec(), p - l.s)) / l.abs();
}

D distSP(const L &amp;s, const P &amp;p) {
	P q = proj(s, p);
	if (ccw(s, q) == 0)
		return (p - q).abs();
	else
		return std::min((s.s - p).abs(), (s.t - p).abs());
}

D distSS(const L &amp;s, const L &amp;t) {
	if (insSS(s, t))
		return 0;
	return std::min({
		distSP(s, t.s),
		distSP(s, t.t),
		distSP(t, s.s),
		distSP(t, s.t),
	});
}

int crossLL(const L &amp;l, const L &amp;m, P &amp;r) {
	P lv = l.vec(), mv = m.vec();
	D cr1 = crs(lv, mv), cr2 = crs(lv, l.t - m.s);
	if (sgn_crs(lv, mv) == 0) {
		r = l.s;
		if (sgn_crs(lv, l.t - m.s))
			return 0;
		return -1;
	}
	r = m.s + mv * cr2 / cr1;
	return 1;
}

int crossSS(L l, L m, P &amp;r) {
	int u = crossLL(l, m, r);
	if (u == 0)
		return 0;
	if (u == -1) {
		r = std::max(std::min(l.s, l.t), std::min(m.s, m.t));
		P q = std::min(std::max(l.s, l.t), std::max(m.s, m.t));
		return (q &lt; r) ? 0 : (q == r ? 1 : -1);
	}
	if (ccw(l, r) == 0 &amp;&amp; ccw(m, r) == 0)
		return 1;
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-点--线段"><a class="header" href="#i-点--线段">I 点 &amp; 线段</a></h1>
<pre><code class="language-cpp">// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	ll x{}, y{};
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const ll &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const ll &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return P{-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, ll, *);
	OPERATOR(P, ll, /);
	ll norm() const {
		return x * x + y * y;
	}
	double abs() const {
		return std::sqrt(norm());
	}
#undef T
};

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return std::tie(l.x, l.y) &lt; std::tie(r.x, r.y);
}

inline bool operator==(const P &amp;l, const P &amp;r) {
	return l.x == r.x &amp;&amp; l.y == r.y;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	ll A, B, C;
	void reduce() {
		ll g = std::gcd(std::abs(A), std::abs(B));
		g = std::gcd(g, std::abs(C));
		A /= g, B /= g, C /= g;
		if (A &lt; 0 || (A == 0 &amp;&amp; B &lt; 0)) {
			A = -A, B = -B, C = -C;
		}
	}
	ll eval(const P &amp;p) const {
		return A * p.x + B * p.y + C;
	}
	bool on(const P &amp;p) const {
		return eval(p) == 0;
	}
	static std::optional&lt;L&gt; from(P a, P d) {
		if (d == P{0, 0})
			return std::nullopt;
		L r = {d.y, -d.x, d.x * a.y - d.y * a.x};
		r.reduce();
		return r;
	}
	static std::optional&lt;L&gt; p2(P a, P b) {
		return from(a, b - a);
	}
	static std::optional&lt;L&gt; mid(P a, P b) {
		auto [dx, dy] = b - a;
		return from((a + b) / 2, {dy, -dx});
	}
};

bool operator&lt;(const L &amp;l, const L &amp;r) {
	return std::tie(l.A, l.B, l.C) &lt; std::tie(r.A, r.B, r.C);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const L &amp;l) {
	return os &lt;&lt; &quot;L(&quot; &lt;&lt; l.A &lt;&lt; &quot;, &quot; &lt;&lt; l.B &lt;&lt; &quot;, &quot; &lt;&lt; l.C &lt;&lt; &quot;)&quot;;
}

struct S {
	P s, t;
	S(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	double abs() const {
		return vec().abs();
	}
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
