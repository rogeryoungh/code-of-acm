<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Roger Young 的板子</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<style>
  main p>code {
    color: #f14668 !important;
    background: unset !important;
  }

  main pre>code {
    tab-size: 2;
  }

  main p a,
  main ul a {
    color: #0099ff !important;
  }

  .katex-display {
    overflow: auto hidden;
  }
</style>

<link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.css">
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/katex.min.js"></script>
<script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.13.16/contrib/auto-render.min.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true },
        { left: "\\begin{equation}", right: "\\end{equation}", display: true },
      ],
      macros: {
        "\\RR": "\\mathbb{R}",
        "\\NN": "\\mathbb{N}",
        "\\QQ": "\\mathbb{Q}",
        "\\ZZ": "\\mathbb{Z}",
        "\\CC": "\\mathbb{C}",
        "\\ee": "\\mathrm{e}",
        "\\dd": "\\mathrm{d}",
        "\\eps": "\\varepsilon",
      },
      globalGroup: true,
      throwOnError: false
    });
  });
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/mdbook-admonish.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="basic/index.html"><strong aria-hidden="true">1.</strong> 基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/vec2.html"><strong aria-hidden="true">1.1.</strong> 二维数组</a></li><li class="chapter-item expanded "><a href="basic/fastio.html"><strong aria-hidden="true">1.2.</strong> 快读</a></li><li class="chapter-item expanded "><a href="basic/qpow/qpow.html"><strong aria-hidden="true">1.3.</strong> 快速幂</a></li><li class="chapter-item expanded "><a href="basic/lower-upper.html"><strong aria-hidden="true">1.4.</strong> 二分</a></li><li class="chapter-item expanded "><a href="basic/modint/modint.html"><strong aria-hidden="true">1.5.</strong> Modint</a></li><li class="chapter-item expanded "><a href="basic/modint/runtime.html"><strong aria-hidden="true">1.6.</strong> Runtime Montgomery Modint</a></li><li class="chapter-item expanded "><a href="basic/v2pti.html"><strong aria-hidden="true">1.7.</strong> V&lt;T, count&gt;</a></li><li class="chapter-item expanded "><a href="basic/bit.html"><strong aria-hidden="true">1.8.</strong> Bit</a></li></ol></li><li class="chapter-item expanded "><a href="math/index.html"><strong aria-hidden="true">2.</strong> 数学</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="math/matrix/index.html"><strong aria-hidden="true">2.1.</strong> 矩阵</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/matrix/matrix.html"><strong aria-hidden="true">2.1.1.</strong> 矩阵</a></li><li class="chapter-item "><a href="math/matrix/qmatrix.html"><strong aria-hidden="true">2.1.2.</strong> 矩阵快速幂</a></li><li class="chapter-item "><a href="math/matrix/gauss-f64.html"><strong aria-hidden="true">2.1.3.</strong> 高斯消元・f64</a></li><li class="chapter-item "><a href="math/matrix/gauss-modint.html"><strong aria-hidden="true">2.1.4.</strong> 高斯消元・modint</a></li></ol></li><li class="chapter-item expanded "><a href="math/exgcd.html"><strong aria-hidden="true">2.2.</strong> 扩展欧几里得・EXGCD</a></li><li class="chapter-item expanded "><a href="math/sieve/euler.html"><strong aria-hidden="true">2.3.</strong> 筛法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/sieve/euler.html"><strong aria-hidden="true">2.3.1.</strong> Euler 筛・朴素</a></li><li class="chapter-item "><a href="math/sieve/euler-lpf.html"><strong aria-hidden="true">2.3.2.</strong> Euler 筛・LPF</a></li><li class="chapter-item "><a href="math/sieve/eratosthenes.html"><strong aria-hidden="true">2.3.3.</strong> Eratosthenes・朴素</a></li><li class="chapter-item "><a href="math/sieve/eratosthenes-fast.html"><strong aria-hidden="true">2.3.4.</strong> Eratosthenes・卡常</a></li></ol></li><li class="chapter-item expanded "><a href="math/factor/sieve.html"><strong aria-hidden="true">2.4.</strong> 质因分解</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/factor/bruce-force.html"><strong aria-hidden="true">2.4.1.</strong> 暴力</a></li><li class="chapter-item "><a href="math/factor/sieve.html"><strong aria-hidden="true">2.4.2.</strong> 筛优化</a></li><li class="chapter-item "><a href="math/factor/lpf.html"><strong aria-hidden="true">2.4.3.</strong> LPF 优化</a></li><li class="chapter-item "><a href="math/factor/pollard-rho.html"><strong aria-hidden="true">2.4.4.</strong> Pollard Rho</a></li></ol></li><li class="chapter-item expanded "><a href="math/crt.html"><strong aria-hidden="true">2.5.</strong> 中国剩余定理・CRT</a></li><li class="chapter-item expanded "><a href="math/excrt.html"><strong aria-hidden="true">2.6.</strong> 扩展中国剩余定理</a></li><li class="chapter-item expanded "><a href="math/miller-rabbin.html"><strong aria-hidden="true">2.7.</strong> 素性测试・Miller Rabbin</a></li><li class="chapter-item expanded "><a href="math/floor-sum.html"><strong aria-hidden="true">2.8.</strong> Floor Sum・类欧</a></li><li class="chapter-item expanded "><a href="math/cipolla.html"><strong aria-hidden="true">2.9.</strong> 二次剩余・Cipolla</a></li><li class="chapter-item expanded "><a href="math/constant/index.html"><strong aria-hidden="true">2.10.</strong> 数学常数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/pre-all/pre-all.html"><strong aria-hidden="true">2.10.1.</strong> 预处理常数</a></li><li class="chapter-item "><a href="math/pre-all/pre.html"><strong aria-hidden="true">2.10.2.</strong> 预处理常数・单独</a></li><li class="chapter-item "><a href="math/constant/stirling.html"><strong aria-hidden="true">2.10.3.</strong> 斯特林数</a></li><li class="chapter-item "><a href="math/constant/euler-phi.html"><strong aria-hidden="true">2.10.4.</strong> Euler $\varphi(n)$</a></li><li class="chapter-item "><a href="math/constant/powers.html"><strong aria-hidden="true">2.10.5.</strong> 幂表</a></li><li class="chapter-item "><a href="math/constant/tetration-mod.html"><strong aria-hidden="true">2.10.6.</strong> 指数塔</a></li></ol></li><li class="chapter-item expanded "><a href="math/interpolation/index.html"><strong aria-hidden="true">2.11.</strong> 插值</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="math/interpolation/lagrange1.html"><strong aria-hidden="true">2.11.1.</strong> Lagrange 插值（求值）</a></li><li class="chapter-item "><a href="math/interpolation/lagrange2.html"><strong aria-hidden="true">2.11.2.</strong> Lagrange 插值（求系数）</a></li><li class="chapter-item "><a href="math/interpolation/lagrange3.html"><strong aria-hidden="true">2.11.3.</strong> Lagrange 插值（连续）</a></li></ol></li><li class="chapter-item expanded "><a href="math/fwt/fwt.html"><strong aria-hidden="true">2.12.</strong> FWT</a></li></ol></li><li class="chapter-item expanded "><a href="string/index.html"><strong aria-hidden="true">3.</strong> 字符串</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="string/kmp.html"><strong aria-hidden="true">3.1.</strong> KMP</a></li><li class="chapter-item expanded "><a href="string/z-algorithm.html"><strong aria-hidden="true">3.2.</strong> Z 函数</a></li><li class="chapter-item expanded "><a href="string/sa-doubling.html"><strong aria-hidden="true">3.3.</strong> 后缀数组</a></li><li class="chapter-item expanded "><a href="string/manacher.html"><strong aria-hidden="true">3.4.</strong> Manacher</a></li></ol></li><li class="chapter-item expanded "><a href="graph/index.html"><strong aria-hidden="true">4.</strong> 图论</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph/shortest-path/index.html"><strong aria-hidden="true">4.1.</strong> 最短路</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/shortest-path/bellman-ford-vec.html"><strong aria-hidden="true">4.1.1.</strong> Bellman Ford・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/queue-bellman-ford-vec.html"><strong aria-hidden="true">4.1.2.</strong> 队列优化 Bellman Ford・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/dijkstra-vec.html"><strong aria-hidden="true">4.1.3.</strong> Dijkstra・VEC</a></li><li class="chapter-item "><a href="graph/shortest-path/floyd-adj.html"><strong aria-hidden="true">4.1.4.</strong> Floyd・ADJ</a></li></ol></li><li class="chapter-item expanded "><a href="graph/lca/index.html"><strong aria-hidden="true">4.2.</strong> LCA</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/lca/binary-lifting.html"><strong aria-hidden="true">4.2.1.</strong> 倍增</a></li><li class="chapter-item "><a href="graph/lca/sparse-table.html"><strong aria-hidden="true">4.2.2.</strong> ST</a></li></ol></li><li class="chapter-item expanded "><a href="graph/scc/index.html"><strong aria-hidden="true">4.3.</strong> SCC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graph/scc/tarjan.html"><strong aria-hidden="true">4.3.1.</strong> Tarjan</a></li><li class="chapter-item "><a href="graph/scc/kosaraju.html"><strong aria-hidden="true">4.3.2.</strong> Kosaraju</a></li></ol></li><li class="chapter-item expanded "><a href="graph/kruskal.html"><strong aria-hidden="true">4.4.</strong> 最小生成树・kruskal</a></li><li class="chapter-item expanded "><a href="graph/hld.html"><strong aria-hidden="true">4.5.</strong> 树链剖分</a></li><li class="chapter-item expanded "><a href="graph/dinic.html"><strong aria-hidden="true">4.6.</strong> Dinic</a></li></ol></li><li class="chapter-item expanded "><a href="poly/index.html"><strong aria-hidden="true">5.</strong> 多项式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="poly/fft-mul.html"><strong aria-hidden="true">5.1.</strong> FFT 乘法</a></li><li class="chapter-item expanded "><a href="poly/ntt-mul-i32.html"><strong aria-hidden="true">5.2.</strong> NTT 乘法・i32</a></li><li class="chapter-item expanded "><a href="poly/ntt-mul-mod3.html"><strong aria-hidden="true">5.3.</strong> NTT 乘法・三模</a></li><li class="chapter-item expanded "><a href="poly/ntt-naive.html"><strong aria-hidden="true">5.4.</strong> NTT $O(n^2)$</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton.html"><strong aria-hidden="true">5.5.</strong> NTT 牛顿迭代</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton-fast.html"><strong aria-hidden="true">5.6.</strong> NTT 牛顿迭代・卡常</a></li><li class="chapter-item expanded "><a href="poly/ntt-newton-blockwise-fast.html"><strong aria-hidden="true">5.7.</strong> NTT 牛顿迭代・分块卡常</a></li><li class="chapter-item expanded "><a href="poly/ntt-taylor-shift.html"><strong aria-hidden="true">5.8.</strong> NTT 平移</a></li><li class="chapter-item expanded "><a href="poly/ntt-eval.html"><strong aria-hidden="true">5.9.</strong> NTT 多点求值 & 快速插值</a></li><li class="chapter-item expanded "><a href="poly/ntt-chirpz.html"><strong aria-hidden="true">5.10.</strong> NTT Chirp Z 变换</a></li><li class="chapter-item expanded "><a href="poly/relax/index.html"><strong aria-hidden="true">5.11.</strong> NTT 在线卷积</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="poly/relax/ntt-semi.html"><strong aria-hidden="true">5.11.1.</strong> 半在线卷积</a></li><li class="chapter-item "><a href="poly/relax/ntt-semi-fast.html"><strong aria-hidden="true">5.11.2.</strong> 半在线卷积・卡常</a></li><li class="chapter-item "><a href="poly/relax/ntt-relax.html"><strong aria-hidden="true">5.11.3.</strong> 全在线卷积</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ds/index.html"><strong aria-hidden="true">6.</strong> 数据结构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ds/dsu.html"><strong aria-hidden="true">6.1.</strong> 并查集</a></li><li class="chapter-item expanded "><a href="ds/dsu-size.html"><strong aria-hidden="true">6.2.</strong> 带权并查集</a></li><li class="chapter-item expanded "><a href="ds/sparse-table.html"><strong aria-hidden="true">6.3.</strong> ST</a></li><li class="chapter-item expanded "><a href="ds/sliding.html"><strong aria-hidden="true">6.4.</strong> 滑动窗口</a></li><li class="chapter-item expanded "><a href="ds/fwtree.html"><strong aria-hidden="true">6.5.</strong> 树状数组</a></li><li class="chapter-item expanded "><a href="ds/heap.html"><strong aria-hidden="true">6.6.</strong> 堆</a></li><li class="chapter-item expanded "><a href="ds/segment-tree.html"><strong aria-hidden="true">6.7.</strong> 线段树</a></li><li class="chapter-item expanded "><a href="ds/lazy-segment-tree.html"><strong aria-hidden="true">6.8.</strong> 懒标记线段树</a></li></ol></li><li class="chapter-item expanded "><a href="geo/index.html"><strong aria-hidden="true">7.</strong> 计算几何</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="geo/fpoint.html"><strong aria-hidden="true">7.1.</strong> F 点 & 线段</a></li><li class="chapter-item expanded "><a href="geo/polygon.html"><strong aria-hidden="true">7.2.</strong> F 多边形</a></li><li class="chapter-item expanded "><a href="geo/intersect.html"><strong aria-hidden="true">7.3.</strong> F 冲突判定</a></li><li class="chapter-item expanded "><a href="geo/ipoint.html"><strong aria-hidden="true">7.4.</strong> I 点 & 线段</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Roger Young 的板子</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rogeryoungh/code-of-acm/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>我的初始文件。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

template &lt;class T&gt;
using V = std::vector&lt;T&gt;;
using ll = long long;

int ____ = std::cin.tie(nullptr)-&gt;sync_with_stdio(false);

// END OF HEADER | Author: Roger Young

int main() {
	int T;
	std::cin &gt;&gt; T;
	while (T--) {
		std::cout &lt;&lt; &quot;X&quot; &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二维数组"><a class="header" href="#二维数组">二维数组</a></h1>
<p>一个简单的动态二维数组，基于 <code>vector</code>。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快读"><a class="header" href="#快读">快读</a></h1>
<p>这个快读目前不能自动输出，有待以后改进。</p>
<pre><code class="language-cpp">struct BasicBuffer {
	std::vector&lt;char&gt; s;
	BasicBuffer() : s(1 &lt;&lt; 18) {}
	char *p = s.data(), *beg = p, *end = p + s.size();
	inline char getc() {
		if (p == end)
			readAll();
		return *p++;
	}
	inline void putc(char c) {
		if (p == end)
			writeAll();
		*p++ = c;
	}
	inline void puts(const char *x) {
		while (*x != 0)
			putc(*x++);
	}
	void readAll() {
		std::fread(beg, 1, end - beg, stdin);
		p = s.data();
	}
	void writeAll() {
		std::fwrite(beg, 1, p - beg, stdout);
		p = s.data();
	}
};

struct FastI : BasicBuffer {
	FastI() {
		readAll();
	}
	ll read() {
		ll x = 0;
		char c = getc();
		bool sgn = true;
		while (!std::isdigit(c))
			sgn = sgn &amp;&amp; c != '-', c = getc();
		while (std::isdigit(c))
			x = x * 10 + c - '0', c = getc();
		return sgn ? x : -x;
	}
	template &lt;class T&gt;
	FastI &amp;operator&gt;&gt;(T &amp;x) {
		return x = read(), *this;
	}
	FastI &amp;operator&gt;&gt;(char &amp;x) {
		return x = getc(), *this;
	}
};

struct FastO : BasicBuffer {
	std::array&lt;char, 32&gt; u{};
	~FastO() {
		writeAll();
	}
	void output(ll x) {
		char *i = u.data() + 20;
		if (x &lt; 0)
			putc('-'), x = -x;
		do
			*--i = x % 10 + '0', x /= 10;
		while (x &gt; 0);
		puts(i);
	}
	template &lt;class T&gt;
	FastO &amp;operator&lt;&lt;(const T &amp;x) {
		return output(x), *this;
	}
	FastO &amp;operator&lt;&lt;(char x) {
		return putc(x), *this;
	}
	FastO &amp;operator&lt;&lt;(const char *x) {
		return puts(x), *this;
	}
	FastO &amp;operator&lt;&lt;(const std::string &amp;x) {
		return puts(x.c_str()), *this;
	}
};

FastI fin;
FastO fout;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速幂"><a class="header" href="#快速幂">快速幂</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题"><a class="header" href="#测试例题">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 快速幂</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二分"><a class="header" href="#二分">二分</a></h1>
<p>函数 <code>lower</code> 寻找区间 $[l, r)$ 中 <code>true -&gt; false</code> 的最后一个 <code>true</code>。</p>
<p>函数 <code>upper</code> 寻找区间 $[l, r)$ 中 <code>false -&gt; true</code> 的第一个 <code>true</code>。</p>
<p>若无答案，则返回 $r$。</p>
<pre><code class="language-cpp">// @description 二分

ll lower(ll l, ll r, auto check) { // last true
	if (l &gt;= r or not check(l))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m) ? l : r) = m;
	}
	return l;
}

ll upper(ll l, ll r, auto check) { // first true
	if (l &gt;= r or not check(r - 1))
		return r;
	while (r - l &gt; 1) {
		ll m = l + (r - l) / 2;
		(check(m - 1) ? r : l) = m;
	}
	return l;
}
</code></pre>
<h2 id="测试例题-1"><a class="header" href="#测试例题-1">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1873">P1873 EKO / 砍树</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modint-基础类"><a class="header" href="#modint-基础类">Modint 基础类</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-montgomery-modint"><a class="header" href="#runtime-montgomery-modint">Runtime Montgomery Modint</a></h1>
<p>感谢 hly1204 送的 runtime modint。</p>
<pre><code class="language-cpp">template &lt;int&gt;
class RuntimeMontgomeryModInt {
  public:
	using i32 = std::int32_t;
	using u32 = std::uint32_t;
	using u64 = std::uint64_t;
	using m32 = RuntimeMontgomeryModInt;

	using value_type = u32;

	static u32 get_mod() {
		return mod;
	}

	static bool set_mod(u32 m) {
		if (m % 2 == 0 || m == 1 || (m &amp; (3U &lt;&lt; 30)) != 0)
			return false;
		mod = m, mod2 = mod &lt;&lt; 1;
		u32 two = 2, iv = mod * (two - mod * mod);
		iv *= two - mod * iv;
		iv *= two - mod * iv;
		r = iv * (mod * iv - two);
		r2 = -u64(mod) % mod;
		return true;
	}

	RuntimeMontgomeryModInt() = default;
	~RuntimeMontgomeryModInt() = default;

	template &lt;typename T&gt;
	RuntimeMontgomeryModInt(T v) : v_(reduce(u64(v % i32(mod) + i32(mod)) * r2)) {}

	RuntimeMontgomeryModInt(const m32 &amp;) = default;

	u32 get() const {
		return norm(reduce(v_));
	}

	template &lt;typename T&gt;
	explicit operator T() const {
		return T(get());
	}

	m32 operator-() const {
		m32 res;
		res.v_ = (mod2 &amp; -(v_ != 0)) - v_;
		return res;
	}

	m32 inv() const {
		i32 x1 = 1, x3 = 0, a = get(), b = mod;
		while (b != 0) {
			i32 q = a / b, x1_old = x1, a_old = a;
			x1 = x3, x3 = x1_old - x3 * q, a = b, b = a_old - b * q;
		}
		return m32(x1);
	}

	m32 &amp;operator=(const m32 &amp;) = default;

	m32 &amp;operator+=(const m32 &amp;rhs) {
		v_ += rhs.v_ - mod2;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator-=(const m32 &amp;rhs) {
		v_ -= rhs.v_;
		v_ += mod2 &amp; -(v_ &gt;&gt; 31);
		return *this;
	}
	m32 &amp;operator*=(const m32 &amp;rhs) {
		v_ = reduce(u64(v_) * rhs.v_);
		return *this;
	}
	m32 &amp;operator/=(const m32 &amp;rhs) {
		return operator*=(rhs.inv());
	}
	friend m32 operator+(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) += rhs;
	}
	friend m32 operator-(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) -= rhs;
	}
	friend m32 operator*(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) *= rhs;
	}
	friend m32 operator/(const m32 &amp;lhs, const m32 &amp;rhs) {
		return m32(lhs) /= rhs;
	}
	friend bool operator==(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) == norm(rhs.v_);
	}
	friend bool operator!=(const m32 &amp;lhs, const m32 &amp;rhs) {
		return norm(lhs.v_) != norm(rhs.v_);
	}

	friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, m32 &amp;rhs) {
		i32 x;
		is &gt;&gt; x;
		rhs = m32(x);
		return is;
	}
	friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const m32 &amp;rhs) {
		return os &lt;&lt; rhs.get();
	}

	m32 pow(u64 y) const {
		for (m32 res(1), x(*this);; x *= x) {
			if (y &amp; 1)
				res *= x;
			if ((y /= 2) == 0)
				return res;
		}
	}

  private:
	static u32 reduce(u64 x) {
		return (x + u64(u32(x) * r) * mod) &gt;&gt; 32;
	}
	static u32 norm(u32 x) {
		return x - (mod &amp; -((mod - 1 - x) &gt;&gt; 31));
	}

	u32 v_;

	static inline u32 r, r2, mod, mod2;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vt-count"><a class="header" href="#vt-count">V&lt;T, count&gt;</a></h1>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const V&lt;T&gt; &amp;v) {
	V&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit"><a class="header" href="#bit">Bit</a></h1>
<pre><code class="language-cpp">inline int popcnt(std::uint64_t x) {
	return __builtin_popcountll(x);
}

inline int bsr(std::uint32_t x) {
	return 31 - __builtin_clz(x);
}

inline int bsr(std::uint64_t x) {
	return 63 - __builtin_clzll(x);
}

inline int bsf(std::uint64_t x) {
	return __builtin_ctzll(x);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学"><a class="header" href="#数学">数学</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵"><a class="header" href="#矩阵">矩阵</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵-1"><a class="header" href="#矩阵-1">矩阵</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description 矩阵乘法

template &lt;class T&gt;
VV&lt;T&gt; operator*(const VV&lt;T&gt; &amp;lhs, const VV&lt;T&gt; &amp;rhs) {
	assert(lhs.y == rhs.x);
	VV&lt;T&gt; u(lhs.x, rhs.y);
	for (int i = 0; i &lt; lhs.x; i++) {
		for (int k = 0; k &lt; rhs.x; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.y; j++)
				u[i][j] += rhs[k][j] * t;
		}
	}
	return u;
}

template &lt;class T&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;is, VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.y == 0];
	return os;
}
</code></pre>
<h2 id="测试例题-2"><a class="header" href="#测试例题-2">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="矩阵快速幂"><a class="header" href="#矩阵快速幂">矩阵快速幂</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description 矩阵乘法

template &lt;class T&gt;
VV&lt;T&gt; operator*(const VV&lt;T&gt; &amp;lhs, const VV&lt;T&gt; &amp;rhs) {
	assert(lhs.y == rhs.x);
	VV&lt;T&gt; u(lhs.x, rhs.y);
	for (int i = 0; i &lt; lhs.x; i++) {
		for (int k = 0; k &lt; rhs.x; k++) {
			T t = lhs[i][k];
			for (int j = 0; j &lt; rhs.y; j++)
				u[i][j] += rhs[k][j] * t;
		}
	}
	return u;
}

template &lt;class T&gt;
std::istream &amp;operator&gt;&gt;(std::istream &amp;is, VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		is &gt;&gt; m.m[i];
	return is;
}

template &lt;class T&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const VV&lt;T&gt; &amp;m) {
	for (int i = 0; i &lt; m.x * m.y; i++)
		os &lt;&lt; m.m[i] &lt;&lt; &quot; \n&quot;[(i + 1) % m.y == 0];
	return os;
}

// @description 矩阵快速幂

template &lt;class T&gt;
auto make_matrix_E(int n) {
	VV&lt;T&gt; ret(n, n);
	for (int i = 0; i &lt; n; i++)
		ret[i][i] = 1;
	return ret;
}

template &lt;class T&gt;
auto matrix_pow(VV&lt;T&gt; a, ll w) {
	auto ret = make_matrix_E&lt;T&gt;(a.x);
	for (; w &gt; 0; w /= 2) {
		if (w % 2 == 1)
			ret = a * ret;
		a = a * a;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-3"><a class="header" href="#测试例题-3">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/100">LOJ100 矩阵乘法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高斯消元f64"><a class="header" href="#高斯消元f64">高斯消元・f64</a></h1>
<p>求解 $n$ 元方程组</p>
<p>$$
\begin{cases}
A_{1,1} x_1 + \cdots + A_{1,n} x_n &amp;= A_{1, n+1} \\
\cdots &amp;= \cdots \\
A_{n,1} x_1 + \cdots + A_{n,n} x_n &amp;= A_{n, n+1} \\
\end{cases}
$$</p>
<p>输入以 $0$-index 的矩阵 $A$ 表示。</p>
<pre><code class="language-cpp">using f64 = double;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

const f64 eps = 1E-6;

std::optional&lt;VV&lt;f64&gt;&gt; gauss(VV&lt;f64&gt; v) {
	for (int i = 0; i &lt; v.x; i++) {
		int mi = i;
		for (int j = i + 1; j &lt; v.x; j++)
			if (std::abs(v[j][i]) &gt; std::abs(v[mi][i]))
				mi = j;
		for (int j = 0; j &lt; v.y; j++)
			std::swap(v[i][j], v[mi][j]);
		if (std::abs(v[i][i]) &lt; eps)
			return std::nullopt;
		auto ivi = 1 / v[i][i];
		for (int k = v.y - 1; k &gt;= i; k--)
			v[i][k] *= ivi;
		for (int j = 0; j &lt; v.x; j++) {
			if (j != i) {
				auto tmp = v[j][i];
				for (int k = 0; k &lt; v.y; k++)
					v[j][k] -= v[i][k] * tmp;
			}
		}
	}
	return v;
}
</code></pre>
<h1 id="测试例题-4"><a class="header" href="#测试例题-4">测试例题</a></h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3389">P3389 高斯消元法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高斯消元f64-1"><a class="header" href="#高斯消元f64-1">高斯消元・f64</a></h1>
<p>求解 $n$ 元方程组</p>
<p>$$
\begin{cases}
A_{1,1} x_1 + \cdots + A_{1,n} x_n &amp;= A_{1, n+1} \\
\cdots &amp;= \cdots \\
A_{n,1} x_1 + \cdots + A_{n,n} x_n &amp;= A_{n, n+1} \\
\end{cases}
$$</p>
<p>输入以 $0$-index 的矩阵 $A$ 表示。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

std::optional&lt;VV&lt;Z&gt;&gt; gauss(VV&lt;Z&gt; v) {
	for (int i = 0; i &lt; v.x; i++) {
		int mi = i;
		for (int j = i + 1; j &lt; v.x; j++) {
			if (v[j][i].v != 0) {
				mi = j;
			}
		}
		for (int j = 0; j &lt; v.y; j++)
			std::swap(v[i][j], v[mi][j]);
		if (v[i][i].v == 0)
			return std::nullopt;
		auto ivi = 1 / v[i][i];
		for (int k = v.y - 1; k &gt;= i; k--)
			v[i][k] *= ivi;
		for (int j = 0; j &lt; v.x; j++) {
			if (j != i) {
				auto tmp = v[j][i];
				for (int k = 0; k &lt; v.y; k++)
					v[j][k] -= v[i][k] * tmp;
			}
		}
	}
	return v;
}
</code></pre>
<h1 id="测试例题-5"><a class="header" href="#测试例题-5">测试例题</a></h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3389">P3389 高斯消元法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展欧几里得exgcd"><a class="header" href="#扩展欧几里得exgcd">扩展欧几里得・EXGCD</a></h1>
<p>求出方程</p>
<p>$$
ax + by = \gcd(a, b)
$$</p>
<p>的一个解 $(x, y)$，并且求出 $\gcd(a, b)$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛"><a class="header" href="#euler-筛">Euler 筛</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-6"><a class="header" href="#测试例题-6">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛-1"><a class="header" href="#euler-筛-1">Euler 筛</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-7"><a class="header" href="#测试例题-7">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-筛lpf"><a class="header" href="#euler-筛lpf">Euler 筛・LPF</a></h1>
<p>在 $O(n)$ 的时间内筛出 $n$ 以内的所有质数，并且筛出最小质因子（least prime factor）。</p>
<pre><code class="language-cpp">// @description 线性筛(LPF)

V&lt;int&gt; lpf, primes;
void Euler(int n) {
	lpf.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (!lpf[i])
			lpf[i] = i, primes.push_back(i);
		for (auto pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			lpf[i * pj] = pj;
			if (i % pj == 0)
				break;
		}
	}
}
</code></pre>
<h2 id="测试例题-8"><a class="header" href="#测试例题-8">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eratosthenes朴素"><a class="header" href="#eratosthenes朴素">Eratosthenes（朴素）</a></h1>
<p>在 $O(n \log \log n)$ 的时间内筛出 $n$ 以内的所有质数。</p>
<pre><code class="language-cpp">// @description 埃氏筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Eratosthenes(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i]) {
			primes.push_back(i);
			for (ll j = ll(i) * i; j &lt; n; j += i)
				isp[j] = false;
		}
	}
}
</code></pre>
<h2 id="测试例题-9"><a class="header" href="#测试例题-9">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="筛法eratosthenes卡常"><a class="header" href="#筛法eratosthenes卡常">筛法・Eratosthenes・卡常</a></h1>
<pre><code class="language-cpp">// @description 埃氏筛(卡常)

V&lt;bool&gt; isp;
V&lt;int&gt; primes; // 个数不精确！
void Eratosthenes(int n) {
	isp.resize(n + 6, true);
	auto f = [&amp;](int i) {
		if (isp[i]) {
			primes.push_back(i);
			for (ll j = ll(i) * i; j &lt; n; j += i)
				isp[j] = false;
		}
	};
	f(2), f(3);
	for (int i = 5; i &lt; n; i += 6) {
		f(i), f(i + 2);
	}
}
</code></pre>
<h2 id="测试例题-10"><a class="header" href="#测试例题-10">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解筛优化"><a class="header" href="#质因分解筛优化">质因分解・筛优化</a></h1>
<p>需要筛出 $O(\sqrt{N})$ 内的质数，后可以在 $O\left(\sqrt{\frac{N}{\log N}}\right)$ 内求出 $N$ 的所有质因子。</p>
<p>常数相对于不筛有玄学改进。</p>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const V&lt;T&gt; &amp;v) {
	V&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}

// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解暴力"><a class="header" href="#质因分解暴力">质因分解・暴力</a></h1>
<p>可以在 $O(\sqrt{n})$ 的时间复杂度内求出 $n$ 的所有质因子。</p>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const V&lt;T&gt; &amp;v) {
	V&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}

// @description 因式分解

auto factor(ll n) {
	V&lt;ll&gt; ret;
	for (int i = 2; 1ll * i * i &lt;= n; i++) {
		for (; n % i == 0; n /= i)
			ret.push_back(i);
	}
	if (n &gt; 1)
		ret.push_back(n);
	return ret;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解筛优化-1"><a class="header" href="#质因分解筛优化-1">质因分解・筛优化</a></h1>
<p>需要筛出 $O(\sqrt{N})$ 内的质数，后可以在 $O\left(\sqrt{\frac{N}{\log N}}\right)$ 内求出 $N$ 的所有质因子。</p>
<p>常数相对于不筛有玄学改进。</p>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const V&lt;T&gt; &amp;v) {
	V&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}

// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ans;
	for (int i : primes) {
		if (1ll * i * i &gt; n)
			break;
		for (; n % i == 0; n /= i)
			ans.push_back(i);
	}
	if (n &gt; 1)
		ans.push_back(n);
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解lpf-优化"><a class="header" href="#质因分解lpf-优化">质因分解・LPF 优化</a></h1>
<p>需要 $O(N)$ 预处理，后可以在 $O(\log{n})$ 内求出 $n(n \leqslant N)$ 的所有质因子。</p>
<p>仅在 $N$ 较小时有用。</p>
<pre><code class="language-cpp">// @description V&lt;T&gt; -&gt; V&lt;pair&lt;T, count&gt;&gt;

template &lt;class T&gt;
auto v2pti(const V&lt;T&gt; &amp;v) {
	V&lt;std::pair&lt;T, int&gt;&gt; r;
	if (v.empty())
		return r;
	r.emplace_back(v[0], 1);
	for (int i = 1; i &lt; v.size(); i++) {
		if (v[i] == v[i - 1])
			r.back().second++;
		else
		 	r.emplace_back(v[i], 1);
	}
	return r;
}

// @description 线性筛(LPF)

V&lt;int&gt; lpf, primes;
void Euler(int n) {
	lpf.resize(n);
	for (int i = 2; i &lt; n; i++) {
		if (!lpf[i])
			lpf[i] = i, primes.push_back(i);
		for (auto pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			lpf[i * pj] = pj;
			if (i % pj == 0)
				break;
		}
	}
}

// @description 质因子分解

auto factor(ll n) {
	V&lt;ll&gt; ret;
	for (; n &gt; 1; n /= lpf[n])
		ret.push_back(lpf[n]);
	return ret;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="质因分解pollard-rho"><a class="header" href="#质因分解pollard-rho">质因分解・Pollard Rho</a></h1>
<p>Pollard Rho 算法可以在 $O(n^{0.25})$ 的期望复杂度内计算出 $n$ 的一个因子，可以用于 $10^{18}$ 内的因式分解。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = 1 % m;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(a) * ret % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}

// @description Pollard Rho

ll pollard_rho(ll N) {
	if (N % 2 == 0)
		return 2;
	if (miller_rabbin(N))
		return N;
	while (true) {
		auto f = [N, c = rand() % (N - 1) + 1](ll x) {
			return (i128(x) * x + c) % N;
		};
		ll x = 0, y = 0, p = 1, q = 1;
		do {
			int w = 128;
			do {
				p = q, x = f(x), y = f(f(y));
				q = i128(p) * std::abs(x - y) % N;
			} while (w-- &amp;&amp; q != 0);
			ll d = std::__gcd(p, N);
			if (d &gt; 1 &amp;&amp; d != N)
				return d;
		} while (x != y);
	}
}

auto factor(ll x) {
	V&lt;ll&gt; v;
	if (x == 1)
		return v;
	std::function&lt;void(ll)&gt; dfs = [&amp;](ll u) {
		ll fac = pollard_rho(u);
		if (fac == u)
			v.push_back(u);
		else
			dfs(fac), dfs(u / fac);
	};
	dfs(x);
	sort(v.begin(), v.end());
	return v;
}
</code></pre>
<h2 id="备注"><a class="header" href="#备注">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline ll mul_mod(ll a, ll b, ll m) {
	ll c = a * b - ll(f80(a) / m * b + 0.5) * m;
	return c &lt; 0 ? c + m : (c &gt;= m ? c - m : c);
}
</code></pre>
<h2 id="测试例题-11"><a class="header" href="#测试例题-11">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4718">P4718 Pollard-Rho算法</a></li>
<li><a href="https://judge.yosupo.jp/problem/factorize">yosupo Factorize</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中国剩余定理"><a class="header" href="#中国剩余定理">中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>保证 $\{m_i\}$ 互质。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 中国剩余定理

template &lt;class PAIR&gt;
ll crt(const V&lt;PAIR&gt; &amp;am) {
	ll prod = 1, ret = 0;
	for (auto [a, m] : am)
		prod *= m;
	for (auto [a, m] : am) {
		ll u = prod / m, v = inv_gcd(u, m);
		ret = (ret + a * u * v) % prod;
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-12"><a class="header" href="#测试例题-12">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1495">P1495 中国剩余定理（CRT）/ 曹冲养猪</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展中国剩余定理"><a class="header" href="#扩展中国剩余定理">扩展中国剩余定理</a></h1>
<p>求解关于 $x$ 的同余方程</p>
<p>$$
\begin{cases}
x \equiv a_1 &amp;\pmod {m_1} \\
x \equiv a_2 &amp;\pmod {m_2} \\
&amp;\vdots \\
x \equiv a_n &amp;\pmod {m_n}
\end{cases}
$$</p>
<p>不保证 $\{m_i\}$ 互质，但保证 $\operatorname{lcm}(m_i) &lt; 10^{18}$。</p>
<pre><code class="language-cpp">// @description 扩展欧几里得

std::tuple&lt;ll, ll, ll&gt; exgcd(ll a, ll b) {
	if (b == 0) {
		if (a &gt; 0)
			return {1, 0, a};
		else
			return {-1, 0, -a};
	} else {
		auto [y, x, g] = exgcd(b, a % b);
		return {x, y - a / b * x, g};
	}
}

ll inv_gcd(ll a, ll p) {
	return (std::get&lt;0&gt;(exgcd(a, p)) % p + p) % p;
}

// @description 扩展中国剩余定理

using i128 = __int128_t;

template&lt;class PAIR&gt;
ll excrt(const V&lt;PAIR&gt; &amp;am) {
	auto [ans, M] = am[0];
	for (auto [a, m] : am) {
		if (M % m == 0 &amp;&amp; ans % m == a)
			continue;
		ll B = (a - ans % m + m) % m;
		auto [x, y, g] = exgcd(M, m);
		if (B % g != 0)
			return -1;
		x = i128(x) * (B / g) % (m / g);
		ans += M * x, M *= m /g;
		ans = (ans + M) % M;
	}
	return ans;
}
</code></pre>
<h2 id="测试例题-13"><a class="header" href="#测试例题-13">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4777">P4777 扩展中国剩余定理（EXCRT）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="素性测试miller-rabbin"><a class="header" href="#素性测试miller-rabbin">素性测试（Miller Rabbin）</a></h1>
<p>快速判断 $10^{18}$ 内的数字是否为素数。</p>
<p>若选取 $k$ 个素数为基底，那么复杂度大概是 $O(k \log n)$，错误率为 $4^{-k}$。</p>
<p>下方代码的基底在 $2^{64}$ 内没有例外。更多基底有关的可以查看 <a href="https://miller-rabin.appspot.com">SPRP Base</a>。</p>
<pre><code class="language-cpp">using i128 = __int128_t;

// @description 快速幂(i128)

ll qpow128(ll a, ll b, ll m) {
	ll ret = 1 % m;
	for (; b; b /= 2) {
		if (b % 2 == 1)
			ret = i128(a) * ret % m;
		a = i128(a) * a % m;
	}
	return ret;
}

// @description 素性测试(Miller Rabbin)

bool miller_rabbin(ll n) {
	if (n &lt;= 3)
		return n &gt;= 2;
	if (n % 2 == 0)
		return false;
	ll a = n - 1;
	a /= a &amp; -a;
	for (int p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
		if (n &lt;= p)
			return true;
		ll t = a, v = qpow128(p, t, n);
		while (t != n - 1 &amp;&amp; v != 1 &amp;&amp; v != n - 1)
			v = i128(v) * v % n, t *= 2;
		if (v != n - 1 &amp;&amp; t % 2 == 0)
			return false;
	}
	return true;
}
</code></pre>
<h2 id="备注-1"><a class="header" href="#备注-1">备注</a></h2>
<p>如果需要卡常，那么 <code>i64 * i64 % i64</code> 实际上可以用浮点数卡一下。</p>
<pre><code class="language-cpp">inline ll mul_mod(ll a, ll b, ll m) {
	ll c = a * b - ll(f80(a) / m * b + 0.5) * m;
	return c &lt; 0 ? c + m : (c &gt;= m ? c - m : c);
}
</code></pre>
<h2 id="测试例题-14"><a class="header" href="#测试例题-14">测试例题</a></h2>
<ul>
<li><a href="https://loj.ac/p/143">LOJ143 质数判定</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor-sum"><a class="header" href="#floor-sum">Floor Sum</a></h1>
<p>在 $O(\log n)$ 的时间内计算</p>
<p>$$
\sum_{x=0}^n \left\lfloor \frac{ax + b}{c} \right\rfloor
$$</p>
<pre><code class="language-cpp">// @description 类欧几里得算法

ll floor_sum(ll a, ll b, ll c, ll n) {
	ll m = (a * n + b) / c, S1 = n * (n + 1) / 2;
	if (a == 0) {
		return b / c * (n + 1);
	} else if (a &gt;= c || b &gt;= c) {
		ll f = S1 * (a / c) + b / c * (n + 1);
		return f + floor_sum(a % c, b % c, c, n);
	} else {
		return m * n - floor_sum(c, c - b - 1, a, m - 1);
	}
}
</code></pre>
<h2 id="测试例题-15"><a class="header" href="#测试例题-15">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5171">P5171 Earthquake</a></li>
<li><a href="https://judge.yosupo.jp/problem/sum_of_floor_of_linear">yosupo Sum of Floor of Linear</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二次剩余cipolla"><a class="header" href="#二次剩余cipolla">二次剩余（Cipolla）</a></h1>
<p>Cipolla 算法可以在 $O(\log P)$ 的时间内求出</p>
<p>$$
x^2 \equiv N \pmod P
$$</p>
<p>即模平方根。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 二次剩余(cipolla)

int legendre(int a, int p) {
	return qpow(a, (p - 1) / 2, p);
}

std::optional&lt;int&gt; cipolla(int n, int p) {
	if (n == 0)
		return 0;
	if (legendre(n, p) != 1)
		return std::nullopt;
	if (p == 2)
		return 1;
	for (int a = 0; a &lt; p; a++) {
		int i = (a * a - n + p) % p;
		using FP2 = std::pair&lt;ll, ll&gt;;
		auto mul = [p, i](const FP2 &amp;l, const FP2 &amp;r) {
			auto [la, lb] = l;
			auto [ra, rb] = r;
			return FP2{(la * ra + lb * rb % p * i) % p, (lb * ra + la * rb) % p};
		};
		if (legendre(i, p) == p - 1) {
			FP2 x = {1, 1}, u = {a, 1};
			for (int b = (p + 1) / 2; b; b /= 2) {
				if (b % 2 == 1)
					x = mul(x, u);
				u = mul(u, u);
			}
			return std::min(x.first, p - x.first);
		}
	}
	return std::nullopt;
}
</code></pre>
<h2 id="测试例题-16"><a class="header" href="#测试例题-16">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5491">P5491 二次剩余</a></li>
<li><a href="https://judge.yosupo.jp/problem/sqrt_mod">yosupo Sqrt Mod</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学常数"><a class="header" href="#数学常数">数学常数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数"><a class="header" href="#预处理常数">预处理常数</a></h1>
<h2 id="math-p"><a class="header" href="#math-p">MATH-P</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;int&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt; l)
		return;
	iv = fac = ifac = V&lt;int&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n] = qpow(fac[n]), iv[n] = qpow(n);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
		iv[i] = 1ll * ifac[i] * fac[i - 1] % P;
	}
	pre_all(u);
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
</code></pre>
<h2 id="math-modint"><a class="header" href="#math-modint">MATH-MODINT</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预处理常数-1"><a class="header" href="#预处理常数-1">预处理常数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

V&lt;int&gt; iv{1, 1}, fac{1}, ifac{1};

// @description 预处理逆元

void pre_inv(int n) {
	iv.resize(n + 1);
	for (int i = 2; i &lt;= n; i++) {
		iv[i] = 1ll * iv[P % i] * (P - P / i) % P;
	}
}

// @description 预处理阶乘

void pre_fac(int n) {
	fac.resize(n + 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
}

// @description 预处理阶乘逆元

void pre_ifac(int n) {
	ifac.resize(n + 1);
	ifac[n] = qpow(fac[n]);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	}
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="斯特林数"><a class="header" href="#斯特林数">斯特林数</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly ln(int m) const {
		assert(T[0].v == 1);
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 48E
		assert(T[0].v == 0);
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = x * (cut(t) - x.ln(t) + Poly{1}), x.redeg(t);
		}
		return x.redeg(m);
	}
	Poly sqrt(int m) const { // 36E
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = (x + cut(t).div(t, x)) * ((P + 1) / 2);
		}
		return x.redeg(m);
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
	friend auto operator%(const Poly &amp;f, const Poly &amp;g) {
		Poly Q = f / g;
		return make_pair(Q, (f - Q * g).redeg(g.deg() - 1));
	}
#undef T
};

Poly taylor_shift(const Poly &amp;f, Z c) {
	int n = f.deg();
	Poly A(n), B(n);
	Z ci = 1;
	for (int i = 0; i &lt; n; i++) {
		A[i] = f[i] * fac[i];
		B[i] = ci * ifac[i];
		ci *= c;
	}
	std::reverse(A.begin(), A.end());
	A = A * B;
	for (int i = 0; i &lt; n; i++) {
		B[i] = A[n - i - 1] * ifac[i];
	}
	return B;
}

Poly pow_safe(const Poly &amp;g, int m, int k1, int k2) { // k % P, k % (P - 1)
	int pos = 0;
	while (pos &lt; g.deg() &amp;&amp; g[pos].v == 0) {
		++pos;
	}
	if (pos == g.deg() || pos &gt; (m - 1) / k1) {
		return Poly(m, 0);
	}
	Z x = g[pos];
	Poly f = Poly(g.begin() + pos, g.end()) * x.inv();
	f = f.pow(m - pos * k1, k1) * x.pow(k2);
	f.insert(f.begin(), pos * k1, 0);
	assert(f.deg() == m);
	return f;
}

Poly stirling1st_row(int n) {
	if (n == 0)
		return {0};
	Poly f = stirling1st_row(n / 2);
	Poly r = f * taylor_shift(f, n / 2);
	if (n % 2 == 1) {
		r *= Poly{n - 1, 1};
	}
	return r;
}

Poly stirling1st_col(int n, int k) {
	n++;
	Poly r = {1, P - 1};
	r = pow_safe(r.ln(n), n, k, k);
	Z xk = Z(P - 1).pow(k) * ifac[k];
	for (int i = 0; i &lt; n; i++) {
		r[i] *= fac[i] * xk;
	}
	return r;
}

Poly stirling2st_row(int n) {
	n++;
	Poly A(n), B(n);
	for (int i = 0; i &lt; n; i++) {
		A[i] = i % 2 == 1 ? -ifac[i] : ifac[i];
		B[i] = Z(i).pow(n - 1) * ifac[i];
	}
	return (A * B).redeg(n);
}

Poly stirling2st_col(int n, int k) {
	if (n &lt; k)
		return Poly(n + 1);
	std::function&lt;Poly(int)&gt; sol = [&amp;](int u) -&gt; Poly {
		if (u == 0)
			return {1};
		Poly f = sol(u / 2);
		f *= taylor_shift(f, P - u / 2);
		if (u % 2 == 1)
			f *= Poly{-u, 1};
		return f;
	};
	Poly f = sol(k).rev().inv(n - k + 1);
	f.insert(f.begin(), k, 0);
	return f;
}
</code></pre>
<h2 id="测试例题-17"><a class="header" href="#测试例题-17">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5395">P5395 第二类斯特林数·行</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5396">P5396 第二类斯特林数·列</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5409">P5409 第一类斯特林数·列</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5409">P5409 第一类斯特林数·列</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-varphin-函数"><a class="header" href="#euler-varphin-函数">Euler $\varphi(n)$ 函数</a></h1>
<p>需要用筛预处理 $O(\sqrt{N})$ 内的质数，每次求值复杂度 $O(\sqrt{N})$。</p>
<pre><code class="language-cpp">// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

ll euler_phi(ll x) {
	ll ans = 1;
	for (int p : primes) {
		if (1ll * p * p &gt; x)
			break;
		if (x % p == 0)
			x /= p, ans *= p - 1;
		while (x % p == 0)
			x /= p, ans *= p;
	}
	if (x &gt; 1)
		ans *= x - 1;
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="幂表"><a class="header" href="#幂表">幂表</a></h1>
<p>在 $O(n)$ 的时间内，求 $0^k, 1^k, \cdots, n^k$。</p>
<p>除了卡常以外没什么用。</p>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

auto powers(int n, int k, int mod) {
	V&lt;bool&gt; isp(n + 1, true);
	V&lt;int&gt; pw(n + 1, 1);
	for (int p = 2; p &lt;= n; ++p)
		if (isp[p]) {
			for (ll j = ll(p) * p; j &lt;= n; j += p)
				isp[j] = false;
			int q = qpow(p, k, mod);
			for (int i = 1; i &lt;= n / p; ++i)
				pw[i * p] = ll(q) * pw[i] % mod;
		}
	pw[0] = qpow(0, k, mod);
	return pw;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指数塔"><a class="header" href="#指数塔">指数塔</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 线性筛

V&lt;bool&gt; isp;
V&lt;int&gt; primes;
void Euler(int n) {
	isp.resize(n, true);
	for (int i = 2; i &lt; n; i++) {
		if (isp[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj &gt; (n - 1) / i)
				break;
			isp[i * pj] = false;
			if (i % pj == 0)
				break;
		}
	}
}

int euler_phi(ll x) {
	ll ans = 1;
	for (int p : primes) {
		if (1ll * p * p &gt; x)
			break;
		if (x % p == 0)
			x /= p, ans *= p - 1;
		while (x % p == 0)
			x /= p, ans *= p;
	}
	if (x &gt; 1)
		ans *= x - 1;
	return ans;
}

int tetration_mod(int a, int b, int m) {
	if (m == 1)
		return 0;
	if (a == 0)
		return (b + 1) % 2;
	if (b == 0)
		return 1;
	if (b == 1)
		return a % m;
	if (a == 2 &amp;&amp; b &lt;= 4) {
		static const std::array ans = {1, 2, 4, 16, 65536};
		return ans[b] % m;
	}
	int phi = euler_phi(m);
	int d = tetration_mod(a, b - 1, phi) + phi;
	return qpow(a % m, d, m);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插值"><a class="header" href="#插值">插值</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值"><a class="header" href="#lagrange-插值">Lagrange 插值</a></h1>
<h2 id="math-p-1"><a class="header" href="#math-p-1">MATH-P</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 拉格朗日插值

int lagrange(const V&lt;int&gt; &amp;x, const V&lt;int&gt; &amp;y, int k) {
	int sum = 0, n = x.size();
	for (int i = 0; i &lt; n; i++) {
		int s1 = 1, s2 = 1;
		for (int j = 0; j &lt; n; j++) {
			if (j == i)
				continue;
			s1 = 1ll * s1 * (k - x[j] + P) % P;
			s2 = 1ll * s2 * (x[i] - x[j] + P) % P;
		}
		sum += 1ll * s1 * qpow(s2) % P * y[i] % P;
	}
	return sum % P;
}
</code></pre>
<h2 id="math-modint-1"><a class="header" href="#math-modint-1">MATH-MODINT</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

Z lagrange(const V&lt;Z&gt; &amp;x, const V&lt;Z&gt; &amp;y, Z k) {
	int n = x.size();
	Z sum = 0;
	for (int i = 0; i &lt; n; i++) {
		Z s1 = 1, s2 = 1;
		for (int j = 0; j &lt; n; j++)
			if (j != i)
				s1 *= k - x[j], s2 *= x[i] - x[j];
		sum += s1 / s2 * y[i];
	}
	return sum;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值-1"><a class="header" href="#lagrange-插值-1">Lagrange 插值</a></h1>
<h2 id="math-p-2"><a class="header" href="#math-p-2">MATH-P</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 拉格朗日插值

auto lagrange(const V&lt;int&gt; &amp;x, const V&lt;int&gt; &amp;y) {
	int n = x.size();
	V&lt;int&gt; d(n), u(n + 1), t(n);
	u[0] = 1;
	for (int i = 0; i &lt; n; i++) {
		for (int j = i + 1; j &gt;= 1; j--)
			u[j] = (u[j - 1] + 1ll * (P - u[j]) * x[i]) % P;
		u[0] = 1ll * u[0] * (P - x[i]) % P;
	}
	for (int i = 0; i &lt; n; i++) {
		int s2 = 1;
		for (int j = n; j &gt;= 1; j--) {
			t[j - 1] = j == n ? u[n] : (u[j] + 1ll * x[i] * t[j]) % P;
			if (j - 1 != i)
				s2 = 1ll * s2 * (x[i] - x[j - 1] + P) % P;
		}
		s2 = qpow(s2);
		for (int j = 0; j &lt; n; j++)
			d[j] = (d[j] + 1ll * t[j] * s2 % P * y[i]) % P;
	}
	return d;
}
</code></pre>
<h2 id="math-modint-2"><a class="header" href="#math-modint-2">MATH-MODINT</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

auto lagrange(const V&lt;Z&gt; &amp;x, const V&lt;Z&gt; &amp;y) {
	int n = x.size();
	V&lt;Z&gt; d(n), u(n + 1), t(n);
	u[0] = 1;
	for (int i = 0; i &lt; n; i++) {
		for (int j = i + 1; j &gt;= 1; j--)
			u[j] = u[j - 1] - u[j] * x[i];
		u[0] *= -x[i];
	}
	for (int i = 0; i &lt; n; i++) {
		Z s2 = 1;
		for (int j = n; j &gt;= 1; j--) {
			t[j - 1] = j == n ? u[n] : u[j] + x[i] * t[j];
			if (j - 1 != i)
				s2 = s2 * (x[i] - x[j - 1]);
		}
		s2 = s2.inv();
		for (int j = 0; j &lt; n; j++)
			d[j] += t[j] * s2 * y[i];
	}
	return d;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-插值-2"><a class="header" href="#lagrange-插值-2">Lagrange 插值</a></h1>
<h2 id="math-p-3"><a class="header" href="#math-p-3">MATH-P</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 拉格朗日插值

int lagrange(const V&lt;int&gt; &amp;y, int x) {
	int n = y.size();
	if (0 &lt;= x &amp;&amp; x &lt; n)
		return y[x];
	V&lt;int&gt; pl(n + 2, 1), pr(n + 2, 1), fac(n + 2, 1);
	for (int i = 0; i &lt; n; i++)
		pl[i + 1] = 1ll * pl[i] * (x - i) % P;
	for (int i = n - 1; i &gt;= 0; i--)
		pr[i] = 1ll * pr[i + 1] * (x - i) % P;
	for (int i = 1; i &lt; n; i++)
		fac[i] = 1ll * fac[i - 1] * i % P;
	int ans = 0;
	for (int i = 0; i &lt; n; i++) {
		int s1 = 1ll * pl[i] * pr[i + 1] % P;
		int t = (n - i) % 2 == 0 ? P - 1 : 1;
		int s2 = 1ll * fac[i] * fac[n - i - 1] % P * t % P;
		ans = (ans + 1ll * s1 % P * qpow(s2) % P * y[i]) % P;
	}
	return ans;
}
</code></pre>
<h2 id="math-modint-3"><a class="header" href="#math-modint-3">MATH-MODINT</a></h2>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 拉格朗日插值

Z lagrange(const V&lt;Z&gt; &amp;y, int x) {
	int n = y.size();
	if (0 &lt;= x &amp;&amp; x &lt; n)
		return y[x];
	V&lt;Z&gt; pl(n + 2, 1), pr(n + 2, 1), fac(n + 2, 1);
	for (int i = 0; i &lt; n; i++)
		pl[i + 1] = pl[i] * (x - i);
	for (int i = n - 1; i &gt;= 0; i--)
		pr[i] = pr[i + 1] * (x - i);
	for (int i = 1; i &lt; n; i++)
		fac[i] = fac[i - 1] * i;
	Z ans = 0;
	for (int i = 0; i &lt; n; i++) {
		Z s1 = pl[i] * pr[i + 1];
		Z t = (n - i) % 2 == 0 ? -1 : 1;
		Z s2 = fac[i] * fac[n - i - 1] * t;
		ans += s1 / s2 * y[i];
	}
	return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fwt"><a class="header" href="#fwt">FWT</a></h1>
<pre><code class="language-cpp">inline int popcnt(std::uint64_t x) {
	return __builtin_popcountll(x);
}

inline int bsr(std::uint32_t x) {
	return 31 - __builtin_clz(x);
}

inline int bsr(std::uint64_t x) {
	return 63 - __builtin_clzll(x);
}

inline int bsf(std::uint64_t x) {
	return __builtin_ctzll(x);
}

const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

void OR(V&lt;int&gt; &amp;f, bool inv) {
	int n = f.size(), x = inv ? 1 : P - 1;
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++)
				f[i + j + k] = (f[i + j + k] + 1ll * f[i + j] * x) % P;
}

void AND(V&lt;int&gt; &amp;f, bool inv) {
	int n = f.size(), x = inv ? 1 : P - 1;
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++)
				f[i + j] = (f[i + j] + 1ll * f[i + j + k] * x) % P;
}

void XOR(V&lt;int&gt; &amp;f, bool inv) {
	int n = f.size(), x = inv ? 1 : qpow(2);
	for (int k = 1; k &lt; n; k &lt;&lt;= 1)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++) {
				int u = f[i + j], v = f[i + j + k];
				f[i + j] = 1ll * (u + v) * x % P;
				f[i + j + k] = 1ll * (u - v + P) * x % P;
			}
}

auto subset_conv(const V&lt;int&gt; &amp;f, const V&lt;int&gt; &amp;g) {
	int N = f.size(), n = std::__lg(f.size());
	V&lt;V&lt;int&gt;&gt; nf, ng, nr;
	nf = ng = nr = V&lt;V&lt;int&gt;&gt;(n + 1, V&lt;int&gt;(N));
	for (int i = 0; i &lt; N; i++)
		nf[popcnt(i)][i] = f[i], ng[popcnt(i)][i] = g[i];
	for (int i = 0; i &lt;= n; i++)
		OR(nf[i], true), OR(ng[i], true);
	for (int i = 0; i &lt; N; i++)
		for (int j = 0; j &lt;= n; j++)
			for (int k = 0; k &lt;= n - j; k++)
				nr[j + k][i] = (nr[j + k][i] + 1ll * nf[j][i] * ng[k][i]) % P;
	for (int i = 0; i &lt;= n; i++)
		OR(nr[i], false);
	V&lt;int&gt; r(N);
	for (int i = 0; i &lt; N; i++)
		r[i] = nr[popcnt(i)][i];
	return r;
}
</code></pre>
<pre><code class="language-cpp">inline int popcnt(std::uint64_t x) {
	return __builtin_popcountll(x);
}

inline int bsr(std::uint32_t x) {
	return 31 - __builtin_clz(x);
}

inline int bsr(std::uint64_t x) {
	return 63 - __builtin_clzll(x);
}

inline int bsf(std::uint64_t x) {
	return __builtin_ctzll(x);
}

const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

void OR(V&lt;Z&gt; &amp;f, bool inv) {
	int n = f.size(), x = inv ? 1 : -1;
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++)
				f[i + j + k] += f[i + j] * x;
}

void AND(V&lt;Z&gt; &amp;f, bool inv) {
	int n = f.size(), x = inv ? 1 : -1;
	for (int k = 1; k &lt; n; k *= 2)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++)
				f[i + j] += f[i + j + k] * x;
}

void XOR(V&lt;Z&gt; &amp;f, bool inv) {
	int n = f.size(), x = inv ? 1 : qpow(2);
	for (int k = 1; k &lt; n; k &lt;&lt;= 1)
		for (int i = 0; i &lt; n; i += k * 2)
			for (int j = 0; j &lt; k; j++) {
				Z u = f[i + j], v = f[i + j + k];
				f[i + j] = (u + v) * x;
				f[i + j + k] = (u - v) * x;
			}
}

auto subset_conv(const V&lt;Z&gt; &amp;f, const V&lt;Z&gt; &amp;g) {
	int N = f.size(), n = std::__lg(f.size());
	V&lt;V&lt;Z&gt;&gt; nf, ng, nr;
	nf = ng = nr = V&lt;V&lt;Z&gt;&gt;(n + 1, V&lt;Z&gt;(N));
	for (int i = 0; i &lt; N; i++)
		nf[popcnt(i)][i] = f[i], ng[popcnt(i)][i] = g[i];
	for (int i = 0; i &lt;= n; i++)
		OR(nf[i], true), OR(ng[i], true);
	for (int i = 0; i &lt; N; i++)
		for (int j = 0; j &lt;= n; j++)
			for (int k = 0; k &lt;= n - j; k++)
				nr[j + k][i] += nf[j][i] * ng[k][i];
	for (int i = 0; i &lt;= n; i++)
		OR(nr[i], false);
	V&lt;Z&gt; r(N);
	for (int i = 0; i &lt; N; i++)
		r[i] = nr[popcnt(i)][i];
	return r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<pre><code class="language-cpp">auto pre_kmp(const std::string &amp;s) {
	int n = s.length();
	V&lt;int&gt; pi(n + 1);
	for (int i = 1; i &lt; n; i++) {
		int j = pi[i];
		while (j &gt; 0 &amp;&amp; s[i] != s[j])
			j = pi[j];
		pi[i + 1] = j + (s[i] == s[j]);
	}
	return pi;
}

auto kmp(const std::string &amp;s, const std::string &amp;t) {
	auto pi = pre_kmp(s);
	int n = t.length();
	V&lt;int&gt; p(n + 1);
	for (int i = 0; i &lt; n; i++) {
		int j = p[i];
		while (j &gt; 0 &amp;&amp; t[i] != s[j])
			j = pi[j];
		p[i + 1] = j + (t[i] == s[j]);
	}
	return std::make_pair(pi, p);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="z-函数"><a class="header" href="#z-函数">Z 函数</a></h1>
<pre><code class="language-cpp">auto pre_z_algo(const std::string &amp;s) {
	int n = s.length();
	V&lt;int&gt; z(n + 1);
	z[1] = n;
	for (int i = 1, l = -1, r = 0; i &lt; n; i++) {
		int &amp;k = z[i + 1], u = r - i;
		if (u &gt; 0)
			k = std::min(u, z[i - l + 1]);
		while (i + k &lt; n &amp;&amp; s[k] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return z;
}

auto z_algo(const std::string &amp;s, const std::string &amp;t) {
	auto z = pre_z_algo(s);
	int n = t.length();
	V&lt;int&gt; z2(n + 1);
	for (int i = 0, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = z2[i + 1], u = r - i;
		if (u &gt; 0)
			k = std::min(u, z[i - l + 1]);
		while (i + k &lt; n &amp;&amp; s[k] == t[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return std::make_pair(z, z2);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后缀数组"><a class="header" href="#后缀数组">后缀数组</a></h1>
<pre><code class="language-cpp">auto sa_doubleing(auto first, auto last, int m = 128) {
	int n = last - first;
	V&lt;int&gt; cnt(std::max(n, m)), sa(n), rk(n + 1, -1), id(n + 1, -1);
	std::copy(first, last, rk.begin());
	for (int i = 0; i &lt; n; i++)
		cnt[rk[i]]++;
	for (int i = 1; i &lt; m; i++)
		cnt[i] += cnt[i - 1];
	for (int i = n - 1; i &gt;= 0; i--)
		sa[--cnt[rk[i]]] = i;
	for (int k = 1; k &lt; n; k *= 2) {
		int p = 0;
		for (int i = n - k; i &lt; n; i++)
			id[p++] = i;
		for (int i = 0; i &lt; n; i++)
			if (sa[i] &gt;= k)
				id[p++] = sa[i] - k;
		std::fill(cnt.begin(), cnt.end(), 0);
		for (int i = 0; i &lt; n; i++)
			cnt[rk[i]]++;
		for (int i = 1; i &lt; m; i++)
			cnt[i] += cnt[i - 1];
		for (int i = n - 1; i &gt;= 0; i--)
			sa[--cnt[rk[id[i]]]] = id[i];
		std::fill(id.begin(), id.end(), -1);
		std::swap(rk, id);
		rk[sa[0]] = 0, p = 0;
		for (int i = 1; i &lt; n; i++) {
			bool f = id[sa[i]] == id[sa[i - 1]] &amp;&amp; id[sa[i] + k] == id[sa[i - 1] + k];
			rk[sa[i]] = f ? p : ++p;
		}
		if (p == n - 1)
			break;
		m = p + 1;
	}
	return sa;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<pre><code class="language-cpp">// @description Manacher

template &lt;int o&gt;
auto manacher(const std::string &amp;s) {
	int n = s.size();
	V&lt;int&gt; m(n);
	m[0] = o == 0;
	for (int i = 1, l = 0, r = 0; i &lt; n; i++) {
		int &amp;k = m[i], u = r - i;
		if (u &gt; 0)
			k = std::min(u, m[2 * l - i]);
		while (0 &lt;= i - k - o &amp;&amp; i + k &lt; n &amp;&amp; s[i - k - o] == s[i + k])
			k++;
		if (i + k &gt; r)
			l = i, r = i + k;
	}
	return m;
}

V&lt;int&gt; manacher_odd(const std::string &amp;s) {
	return manacher&lt;0&gt;(s);
}

V&lt;int&gt; manacher_even(const std::string &amp;s) {
	return manacher&lt;1&gt;(s);
}
</code></pre>
<h2 id="测试例题-18"><a class="header" href="#测试例题-18">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3805">P3805 manacher 算法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图论"><a class="header" href="#图论">图论</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路"><a class="header" href="#最短路">最短路</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路bellman-fordvec"><a class="header" href="#最短路bellman-fordvec">最短路・Bellman Ford・VEC</a></h1>
<p>对于 $n$ 个点 $m$ 条边的图，可以在 $O(nm)$ 的时间内求出来源点 $s$ 到所有点的最短路，并且求出路径。</p>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description Bellman Ford 最短路

template &lt;class D&gt;
auto bellman_ford(const Edges&lt;D&gt; &amp;E, int s) {
	int n = E.size();
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	dis[s] = 0, from[s] = s;
	bool flag = true;
	for (int k = 0; k &lt; n &amp;&amp; flag; k++) {
		flag = false;
		for (int u = 0; u &lt; n; u++) {
			for (auto [v, w] : E[u]) {
				int d2 = dis[u] + w;
				if (dis[v] &gt; d2)
					dis[v] = d2, from[v] = u, flag = true;
			}
		}
	}
	return std::make_pair(dis, from);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路队列优化-bellman-fordvec"><a class="header" href="#最短路队列优化-bellman-fordvec">最短路・队列优化 Bellman Ford・VEC</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 队列优化 Bellman Ford 最短路

template &lt;class D&gt;
auto queue_bellman_ford(const Edges&lt;D&gt; &amp;G, int s) {
	int n = G.size();
	std::queue&lt;int&gt; q;
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	dis[s] = 0, from[s] = s;
	q.push(s);
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (auto [v, w] : G[u]) {
			int d2 = dis[u] + w;
			if (dis[v] &gt; d2)
				dis[v] = d2, from[v] = u, q.push(v);
		}
	}
	return std::make_pair(dis, from);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路dijkstra"><a class="header" href="#最短路dijkstra">最短路・Dijkstra</a></h1>
<p>对于 $n$ 个点 $m$ 条边的图，可以在 $O(n \log m)$ 的时间内求出来源点 $s$ 到所有点的最短路，并且求出路径。</p>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description Dijkstra 最短路

template &lt;class D&gt;
auto dijkstra(const Edges&lt;D&gt; &amp;E, int s) {
	int n = E.size();
	V&lt;D&gt; dis(n, std::numeric_limits&lt;D&gt;::max() / 2);
	V&lt;int&gt; from(n, -1);
	V&lt;bool&gt; vis(n);
	dis[s] = 0, from[s] = s;
	using pdi = std::pair&lt;D, int&gt;;
	std::priority_queue&lt;pdi, V&lt;pdi&gt;, std::greater&lt;pdi&gt;&gt; pq;
	pq.emplace(0, s);
	while (!pq.empty()) {
		auto [w, u] = pq.top();
		pq.pop();
		if (vis[u])
			continue;
		vis[u] = true;
		for (auto [v, wi] : E[u]) {
			D d2 = w + wi;
			if (dis[v] &gt; d2)
				dis[v] = d2, from[v] = u, pq.emplace(d2, v);
		}
	}
	return make_pair(dis, from);
}

auto get_path(const V&lt;int&gt; &amp;from, int x, int y) {
	V&lt;int&gt; r;
	for (; x != y; y = from[y])
		r.push_back(y);
	r.push_back(y);
	std::reverse(r.begin(), r.end());
	return r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最短路floydadj"><a class="header" href="#最短路floydadj">最短路・Floyd・ADJ</a></h1>
<p>对于 $n$ 个点的图，可以在 $O(n^3)$ 的时间内求出任意两点的最短路，并记录其中一条路径。</p>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

template &lt;class D&gt;
using Edges = VV&lt;D&gt;; // 默认 x == y

template &lt;class D&gt;
auto get_edges(int n) {
	VV&lt;D&gt; f(n, n, std::numeric_limits&lt;D&gt;::max() / 2);
	for (int i = 0; i &lt; n; i++)
		f[i][i] = 0;
	return f;
}

// @description Floyd 最短路

template &lt;class D&gt;
auto floyd(const Edges&lt;D&gt; &amp;E) {
	int n = E.x;
	auto f = E;
	VV&lt;int&gt; pass(n, n, -1);
	for (int k = 0; k &lt; n; k++) {
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; n; j++) {
				D d2 = f[i][k] + f[k][j];
				if (f[i][j] &gt; d2)
					f[i][j] = d2, pass[i][j] = k;
			}
		}
	}
	return make_pair(f, pass);
}

auto get_path(const VV&lt;int&gt; &amp;pass, int x, int y) {
	V&lt;int&gt; path = {x};
	std::function&lt;void(int, int)&gt; dfs = [&amp;](int a, int b) {
		if (pass[a][b] != -1) {
			int p = pass[a][b];
			dfs(a, p), path.push_back(p), dfs(p, b);
		}
	};
	if (x != y)
		dfs(x, y), path.push_back(y);
	return path;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca"><a class="header" href="#lca">LCA</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca倍增"><a class="header" href="#lca倍增">LCA・倍增</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(倍增)

struct LCA {
	const int n, lgn;
	VV&lt;int&gt; f;
	V&lt;int&gt; dep;
	LCA(int n_) : n(n_), lgn(1 + std::__lg(n)), f(n, lgn), dep(n) {}
	int query(int x, int y) {
		if (dep[x] &gt; dep[y])
			std::swap(x, y);
		while (dep[x] &lt; dep[y])
			y = f[y][std::__lg(dep[y] - dep[x])];
		for (int i = lgn - 1; i &gt;= 0; i--) {
			if (f[x][i] != f[y][i]) {
				x = f[x][i], y = f[y][i];
			}
		}
		return x == y ? x : f[x][0];
	}
};

template &lt;class D&gt;
struct LCAImpl : LCA {
	const Edges&lt;D&gt; &amp;E;
	LCAImpl(const Edges&lt;D&gt; &amp;E_, int s = 1) : LCA(E_.size()), E(E_) {
		dfs(s, 0);
		for (int i = 1; i &lt; lgn; i++) {
			for (int j = 0; j &lt; n; j++) {
				f[j][i] = f[f[j][i - 1]][i - 1];
			}
		}
	}
	void dfs(int u, int fa) {
		f[u][0] = fa;
		dep[u] = dep[fa] + 1;
		for (auto e : E[u]) {
			if (e.to != fa) {
				dfs(e.to, u);
			}
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lcast"><a class="header" href="#lcast">LCA（ST）</a></h1>
<pre><code class="language-cpp">using pii = std::pair&lt;int, int&gt;;

template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description LCA(Sparse Table)

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	void init(auto first, auto last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = min(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) const {
		int s = std::__lg(r - l + 1);
		return min(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};

struct LCA {
	const int n;
	V&lt;int&gt; dfn;
	SparseTable&lt;pii&gt; st;
	LCA(int n_) : n(n_), dfn(n), st(n) {}
	int query(int x, int y) const {
		if (x == y)
			return x;
		x = dfn[x], y = dfn[y];
		if (x &gt; y)
			std::swap(x, y);
		return st.query(x + 1, y).second;
	}
};

template &lt;class D&gt;
struct LCAImpl : LCA {
	const Edges&lt;D&gt; &amp;E;
	V&lt;pii&gt; rnk;
	int cnt = 0;
	LCAImpl(const Edges&lt;D&gt; &amp;E_, int s = 1) : LCA(E_.size()), E(E_), rnk(n) {
		dfs(s, 0);
		st.init(rnk.begin(), rnk.end());
	}
	void dfs(int u, int fa) {
		dfn[u] = ++cnt;
		rnk[cnt] = {dfn[fa], fa};
		for (auto e : E[u]) {
			if (e.to != fa) {
				dfs(e.to, u);
			}
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scc"><a class="header" href="#scc">SCC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tarjan"><a class="header" href="#tarjan">Tarjan</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

struct SCC {
	V&lt;int&gt; id;
	V&lt;V&lt;int&gt;&gt; group;
	SCC(int n) : id(n) {}
};

template &lt;class D&gt;
struct SCCImpl : SCC {
	const Edges&lt;D&gt; &amp;E;
	const int n;
	V&lt;int&gt; low, dfn, stk;
	V&lt;bool&gt; flag;
	int cnt = 0, c2 = 0;
	void tarjan(int u) {
		low[u] = dfn[u] = ++cnt;
		stk.push_back(u), flag[u] = true;
		for (auto e : E[u]) {
			if (dfn[e.to] == 0) {
				tarjan(e.to);
				low[u] = std::min(low[u], low[e.to]);
			} else if (flag[e.to]) {
				low[u] = std::min(low[u], dfn[e.to]);
			}
		}
		if (dfn[u] == low[u]) {
			c2++;
			while (true) {
				int v = stk.back();
				stk.pop_back();
				id[v] = c2;
				flag[v] = false;
				if (u == v)
					break;
			}
		}
	}
	SCCImpl(const Edges&lt;D&gt; &amp;E_) : SCC(E_.size()), E(E_), n(E.size()), low(n), dfn(n), flag(n) {
		for (int i = 1; i &lt; n; i++) {
			if (dfn[i] == 0)
				tarjan(i);
		}
		group.resize(c2 + 1);
		for (int i = 1; i &lt; n; i++) {
			id[i] = c2 + 1 - id[i]; // 拓扑序
			group[id[i]].push_back(i);
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kosaraju"><a class="header" href="#kosaraju">Kosaraju</a></h1>
<pre><code class="language-cpp">template &lt;class D&gt;
struct Edge {
	int to;
	D len;
};

template &lt;class D&gt;
using Edges = V&lt;V&lt;Edge&lt;D&gt;&gt;&gt;;

struct SCC {
	V&lt;int&gt; id;
	V&lt;V&lt;int&gt;&gt; group;
	SCC(int n) : id(n) {}
};

template &lt;class D&gt;
struct SCCImpl : SCC {
	const Edges&lt;D&gt; &amp;E, &amp;IE;
	const int n;
	V&lt;bool&gt; vis;
	V&lt;int&gt; stk;
	int cnt = 0;
	void dfs1(int u) {
		vis[u] = true;
		for (auto e : E[u])
			if (!vis[e.to])
				dfs1(e.to);
		stk.push_back(u);
	}
	void dfs2(int u) {
		id[u] = cnt;
		for (auto e : IE[u])
			if (id[e.to] == 0)
				dfs2(e.to);
	}
	SCCImpl(const Edges&lt;D&gt; &amp;E_, const Edges&lt;D&gt; &amp;IE_)
		: SCC(E_.size()), E(E_), IE(IE_), n(E.size()), vis(n) {
		for (int i = 1; i &lt; n; i++)
			if (!vis[i])
				dfs1(i);
		std::reverse(stk.begin(), stk.end());
		for (int u : stk) {
			if (id[u] == 0) {
				++cnt;
				dfs2(u);
			}
		}
		group.resize(cnt + 1);
		for (int i = 1; i &lt; n; i++) {
			group[id[i]].push_back(i);
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最小生成树kruskal"><a class="header" href="#最小生成树kruskal">最小生成树（kruskal）</a></h1>
<pre><code class="language-cpp">// @description 朴素并查集

struct DSU {
	V&lt;int&gt; fa;
	DSU(int n) : fa(n) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		fa[x] = y;
	}
};

ll kruskal(int n) {
	std::sort(G.begin(), G.end(), [](Edge a, Edge b) {
		return get&lt;2&gt;(a) &lt; get&lt;2&gt;(b);
	});
	ll ans = 0, cnt = 0;
	DSU dsu(n + 1);
	for (auto [u, v, w] : G) {
		if (dsu.find(u) == dsu.find(v)) {
			continue;
		}
		ans += w, cnt++;
		dsu.merge(u, v);
		if (cnt == n - 1) {
			return ans;
		}
	}
	return -1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树链剖分"><a class="header" href="#树链剖分">树链剖分</a></h1>
<pre><code class="language-cpp">const int N = 1E5 + 5;
V&lt;int&gt; G[N];

// @problem https://www.luogu.com.cn/problem/P3379

// @description 树链剖分 LCA

struct HLD {
	V&lt;int&gt; sz, dep, fa, son, top, dfn;
	int cnt = 0;
	HLD(int n, int r = 1) : sz(n), dep(n), fa(n), son(n), top(n), dfn(n) {
		dfs1(r), dfs2(r, r);
	}
	void dfs1(int u, int f = 0) {
		dep[u] = dep[f] + 1;
		fa[u] = f, sz[u] = 1, top[u] = u;
		for (int v : G[u]) {
			if (v != f) {
				dfs1(v, u);
				sz[u] += sz[v];
				if (sz[v] &gt; sz[son[u]]) {
					son[u] = v;
				}
			}
		}
	}
	void dfs2(int u, int tp, int f = 0) {
		top[u] = tp, dfn[u] = ++cnt;
		if (son[u] != 0) {
			dfs2(son[u], tp, u);
			for (int v : G[u]) {
				if (v != f &amp;&amp; v != son[u]) {
					dfs2(v, v, u);
				}
			}
		}
	}
	int qpath(int x, int y) {
		while (top[x] != top[y]) {
			if (dep[top[x]] &gt; dep[top[y]]) {
				std::swap(x, y);
			}
			y = fa[top[y]];
		}
		return dep[x] &lt; dep[y] ? x : y;
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dinic"><a class="header" href="#dinic">Dinic</a></h1>
<p>感谢 gkjj 送的 Dinic。</p>
<pre><code class="language-cpp">struct Dinic {
	const int inf = 1e9;
	struct edge {
		int to, cap, rev;
	};
	V&lt;V&lt;edge&gt;&gt; G;
	V&lt;int&gt; lev, cur;
	Dinic(int n) : G(n), lev(n), cur(n) {}

	inline void add(int x, int y, int c) {
		G[x].push_back({y, c, (int)G[y].size()});
		G[y].push_back({x, 0, (int)G[x].size() - 1});
	}

	void bfs(int s) {
		std::queue&lt;int&gt; qu;
		std::fill(lev.begin(), lev.end(), -1);
		for (lev[s] = 0, qu.push(s); qu.size();) {
			int x = qu.front();
			qu.pop();
			for (auto [to, cap, rev] : G[x])
				if (cap &gt; 0 &amp;&amp; lev[to] &lt; 0)
					lev[to] = lev[x] + 1, qu.push(to);
		}
	}

	int dfs(int x, int t, int f) {
		if (x == t)
			return f;
		for (int &amp;i = cur[x], d; i &lt; G[x].size(); i++) {
			auto &amp;[to, cap, rev] = G[x][i];
			if (cap &gt; 0 &amp;&amp; lev[x] &lt; lev[to])
				if ((d = dfs(to, t, std::min(f, cap))) &gt; 0) {
					cap -= d;
					G[to][rev].cap += d;
					return d;
				}
		}
		return 0;
	}

	ll maxflow(int s, int t) {
		for (ll flow = 0, f;;) {
			bfs(s);
			if (lev[t] &lt; 0)
				return flow;
			std::fill(cur.begin(), cur.end(), 0);
			while ((f = dfs(s, t, inf)) &gt; 0)
				flow += f;
		}
	}
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式"><a class="header" href="#多项式">多项式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fft-乘法"><a class="header" href="#fft-乘法">FFT 乘法</a></h1>
<p>FFT 乘法及拆系数 $5$ 次乘法，可以做 <code>int</code> 范围内的卷积。可能存在误差。</p>
<pre><code class="language-cpp">using f64 = double;

using img = std::complex&lt;f64&gt;;
using Poly = V&lt;int&gt;;

V&lt;img&gt; w{{1, 0}, {1, 0}};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

const f64 PI = acos(-1.0);

void pre_w(int u) {
	int l = w.size(), l2 = l * 2;
	if (u &lt;= l)
		return;
	w.resize(l2);
	img p = img(cos(PI / l), sin(PI / l));
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(u);
}

static int ntt_size = 0;

void fft(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j] + f[i + j + l];
				f[i + j + l] = w[j + l] * (f[i + j] - f[i + j + l]);
				f[i + j] = x;
			}
}

void ifft(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				img x = f[i + j], y = f[i + j + l] * w[j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	for (int i = 0; i &lt; n; i++)
		f[i] /= n;
	std::reverse(f + 1, f + n);
}

Poly mul(const Poly &amp;a, const Poly &amp;b) {
	int n = a.size(), m = b.size(), N = get_lim(n + m - 1);
	V&lt;img&gt; f(N);
	for (int i = 0; i &lt; n; i++)
		f[i] += img(a[i], 0);
	for (int i = 0; i &lt; m; i++)
		f[i] += img(0, b[i]);
	fft(f.begin(), N);
	for (int i = 0; i &lt; N; i++)
		f[i] *= f[i];
	ifft(f.begin(), N);
	Poly ans(n + m - 1);
	for (int i = 0; i &lt; n + m - 1; i++)
		ans[i] = int(f[i].imag() / 2 + 0.5);
	return ans;
}

Poly mul5(const Poly &amp;a, const Poly &amp;b, int p) {
	enum : int { B = 1 &lt;&lt; 15 };
	int n = a.size(), m = b.size(), N = get_lim(n + m - 1);
	V&lt;img&gt; a0(N), a1(N), Q(N);
	for (int i = 0; i &lt; n; i++)
		a0[i] = a[i] % B, a1[i] = a[i] / B;
	for (int i = 0; i &lt; m; i++)
		Q[i] = img(b[i] % B, b[i] / B);
	fft(a0.begin(), N), fft(a1.begin(), N), fft(Q.begin(), N);
	for (int i = 0; i &lt; N; i++)
		a0[i] *= Q[i], a1[i] *= Q[i];
	ifft(a0.begin(), N), ifft(a1.begin(), N);
	Poly ans(n + m - 1);
	for (int i = 0; i &lt; m + n - 1; i++) {
		ll a1b1 = a1[i].imag() + .5;
		ll a1b0 = a1[i].real() + .5;
		ll a0b1 = a0[i].imag() + .5;
		ll a0b0 = a0[i].real() + .5;
		ans[i] = ((a1b1 * B % p + a0b1 + a1b0) * B + a0b0) % p;
	}
	return ans;
}
</code></pre>
<pre><code>poly/fft-mul.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                    MUL * |       1 |     0.000 |     400 |      - |  2500000.0
         MUL5 MOD 1E9 + 7 |       1 |     0.001 |     800 |  2.000 |  1250000.0
                    MUL * |       2 |     0.000 |     150 |      - |  6666666.7
         MUL5 MOD 1E9 + 7 |       2 |     0.001 |     400 |  2.667 |  2500000.0
                    MUL * |      64 |     0.004 |      70 |      - | 14222222.2
         MUL5 MOD 1E9 + 7 |      64 |     0.013 |     206 |  2.934 |  4848117.6
                    MUL * |     512 |     0.041 |      79 |      - | 12518031.3
         MUL5 MOD 1E9 + 7 |     512 |     0.119 |     232 |  2.905 |  4309655.5
                    MUL * |    4096 |     0.411 |     100 |      - |  9960798.8
         MUL5 MOD 1E9 + 7 |    4096 |     1.154 |     281 |  2.806 |  3549910.2
                    MUL * |   16384 |     1.809 |     110 |      - |  9059191.1
         MUL5 MOD 1E9 + 7 |   16384 |     5.173 |     315 |  2.861 |  3166942.6
                    MUL * |   32768 |     3.831 |     116 |      - |  8554036.8
         MUL5 MOD 1E9 + 7 |   32768 |    10.701 |     326 |  2.793 |  3062172.9
                    MUL * |   65536 |     8.194 |     125 |      - |  7997629.6
         MUL5 MOD 1E9 + 7 |   65536 |    22.899 |     349 |  2.795 |  2861916.8
                    MUL * |  131072 |    17.427 |     132 |      - |  7521166.0
         MUL5 MOD 1E9 + 7 |  131072 |    48.830 |     372 |  2.802 |  2684253.7
                    MUL * |  262144 |    36.342 |     138 |      - |  7213209.8
         MUL5 MOD 1E9 + 7 |  262144 |   110.750 |     422 |  3.047 |  2366980.5
                    MUL * |  524288 |    81.684 |     155 |      - |  6418453.5
         MUL5 MOD 1E9 + 7 |  524288 |   240.655 |     459 |  2.946 |  2178591.3
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-乘法i32"><a class="header" href="#ntt-乘法i32">NTT 乘法・i32</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 多项式乘法

struct Poly : V&lt;int&gt; {
	using vector::vector;
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n);
};
Poly w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

inline int mo(int u) {
	return u &gt;= P ? u - P : u;
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	int p = qpow(3, (P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = 1ll * w[i] * p % P;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j], y = f[i + j + l];
				f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
				f[i + j] = mo(x + y);
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				int x = f[i + j];
				int y = 1ll * w[j + l] * f[i + j + l] % P;
				f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * ivn % P;
	std::reverse(f + 1, f + n);
}

Poly &amp;Poly::mul(Poly &amp;f, Poly &amp;g, int n) {
	f.resize(n), g.resize(n);
	ntt(f.begin(), n), ntt(g.begin(), n);
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * g[i] % P;
	return intt(f.begin(), n), f;
}

Poly operator*(Poly f, Poly g) {
	int m = f.size() + g.size() - 1;
	Poly::mul(f, g, get_lim(m));
	return f.resize(m), f;
}

Poly operator+(Poly f, Poly g) {
	int n = std::max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++)
		f[i] = mo(f[i] + g[i]);
	return f;
}

Poly operator-(Poly f, Poly g) {
	int n = std::max(f.size(), g.size());
	f.resize(n);
	for (int i = 0; i &lt; n; i++)
		f[i] = mo(f[i] - g[i] + P);
	return f;
}
</code></pre>
<pre><code>poly/ntt-mul-i32.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
          MUL MOD 1E9+7 * |       1 |     0.000 |     400 |      - |  2500000.0
          MUL MOD 1E9+7 * |       2 |     0.001 |     300 |      - |  3333333.3
          MUL MOD 1E9+7 * |      64 |     0.006 |      98 |      - | 10158730.2
          MUL MOD 1E9+7 * |     512 |     0.045 |      87 |      - | 11377524.9
          MUL MOD 1E9+7 * |    4096 |     0.433 |     105 |      - |  9468046.5
          MUL MOD 1E9+7 * |   16384 |     2.007 |     122 |      - |  8164819.3
          MUL MOD 1E9+7 * |   32768 |     4.173 |     127 |      - |  7851784.2
          MUL MOD 1E9+7 * |   65536 |     9.472 |     144 |      - |  6918647.2
          MUL MOD 1E9+7 * |  131072 |    19.624 |     149 |      - |  6679044.8
          MUL MOD 1E9+7 * |  262144 |    41.619 |     158 |      - |  6298662.6
          MUL MOD 1E9+7 * |  524288 |    88.440 |     168 |      - |  5928161.5
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-乘法三模"><a class="header" href="#ntt-乘法三模">NTT 乘法・三模</a></h1>
<pre><code class="language-cpp">// @description 快速幂(i32)

int qpow(int a, ll b, int m) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = ll(a) * ret % m;
		a = ll(a) * a % m;
	}
	return ret;
}

// @description 多项式乘法(int mod)

using Poly = V&lt;int&gt;;

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

template &lt;int P&gt;
struct NTT {
	inline static Poly w{1, 1};

	inline static int ntt_size = 0;

	static inline int mo(int u) {
		return u &gt;= P ? u - P : u;
	}

	static void pre_w(int n) {
		int l = w.size(), l2 = l * 2;
		if (n &lt;= l)
			return;
		w.resize(l2);
		int p = qpow(3, (P - 1) / l2, P);
		for (int i = l; i &lt; l2; i += 2) {
			w[i] = w[i / 2];
			w[i + 1] = 1ll * w[i] * p % P;
		}
		pre_w(n);
	}

	static void ntt(auto f, int n) {
		pre_w(n), ntt_size += n;
		for (int l = n / 2; l; l /= 2)
			for (int i = 0; i &lt; n; i += l * 2)
				for (int j = 0; j &lt; l; j++) {
					int x = f[i + j], y = f[i + j + l];
					f[i + j + l] = 1ll * (x - y + P) * w[j + l] % P;
					f[i + j] = mo(x + y);
				}
	}

	static void intt(auto f, int n) {
		pre_w(n), ntt_size += n;
		for (int l = 1; l &lt; n; l *= 2)
			for (int i = 0; i &lt; n; i += l * 2)
				for (int j = 0; j &lt; l; j++) {
					int x = f[i + j];
					int y = 1ll * w[j + l] * f[i + j + l] % P;
					f[i + j] = mo(x + y), f[i + j + l] = mo(x - y + P);
				}
		const int ivn = P - (P - 1) / n;
		for (int i = 0; i &lt; n; i++)
			f[i] = 1ll * f[i] * ivn % P;
		std::reverse(f + 1, f + n);
	};
};

template &lt;int P&gt;
Poly mul(Poly &amp;f, Poly g, int n) {
	for (int i = 0; i &lt; n; i++)
		f[i] %= P, g[i] %= P;
	NTT&lt;P&gt;::ntt(f.begin(), n), NTT&lt;P&gt;::ntt(g.begin(), n);
	for (int i = 0; i &lt; n; i++)
		f[i] = 1ll * f[i] * g[i] % P;
	return NTT&lt;P&gt;::intt(f.begin(), n), f;
}

Poly mul3(Poly f, Poly g, int p) {
	constexpr std::array&lt;int, 3&gt; M = {985661441, 998244353, 1004535809};
	int m = f.size() + g.size() - 1, N = get_lim(m);
	f.resize(N), g.resize(N);

	std::array&lt;Poly, 3&gt; a = {f, f, f};
	mul&lt;M[0]&gt;(a[0], g, N);
	mul&lt;M[1]&gt;(a[1], g, N);
	mul&lt;M[2]&gt;(a[2], g, N);

	Poly ans(m);

	const ll M12 = ll(M[0]) * M[1] % p;
	const ll inv_1 = qpow(M[0], M[1] - 2, M[1]);
	const ll inv_2 = qpow(ll(M[0]) * M[1] % M[2], M[2] - 2, M[2]);

	for (int i = 0; i &lt; m; i++) {
		ll x = (a[1][i] - a[0][i] + M[1]) * inv_1 % M[1] * M[0] + a[0][i];
		ans[i] = ((a[2][i] - x % M[2] + M[2]) * inv_2 % M[2] * M12 + x) % p;
	}
	return ans;
}
</code></pre>
<pre><code>poly/ntt-mul-mod3.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
          MUL MOD 1E9+7 * |       1 |     0.001 |    1400 |      - |   714285.7
          MUL MOD 1E9+7 * |       2 |     0.002 |    1150 |      - |   869565.2
          MUL MOD 1E9+7 * |      64 |     0.022 |     343 |      - |  2908958.7
          MUL MOD 1E9+7 * |     512 |     0.169 |     330 |      - |  3027704.7
          MUL MOD 1E9+7 * |    4096 |     1.608 |     392 |      - |  2546715.7
          MUL MOD 1E9+7 * |   16384 |     7.101 |     433 |      - |  2307181.9
          MUL MOD 1E9+7 * |   32768 |    14.948 |     456 |      - |  2192143.3
          MUL MOD 1E9+7 * |   65536 |    31.893 |     486 |      - |  2054870.0
          MUL MOD 1E9+7 * |  131072 |    67.125 |     512 |      - |  1952663.5
          MUL MOD 1E9+7 * |  262144 |   140.907 |     537 |      - |  1860402.5
          MUL MOD 1E9+7 * |  524288 |   306.415 |     584 |      - |  1711036.8
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntton2"><a class="header" href="#ntton2">NTT・$O(n^2)$</a></h1>
<p>NTT 的 $O(n^2)$ 板子，我也不知道有啥用，大概用来快速验证吧。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;int&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt; l)
		return;
	iv = fac = ifac = V&lt;int&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n] = qpow(fac[n]), iv[n] = qpow(n);
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
		iv[i] = 1ll * ifac[i] * fac[i - 1] % P;
	}
	pre_all(u);
}

// @description 组合数

int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

inline int mo(int x) {
	return x &gt;= P ? x - P : x;
}

struct Poly : V&lt;int&gt; { // O(n2) 板子，我也不知道有啥用
	using vector::vector;
	int deg() const {
		return size();
	}
};

Poly deriv(const Poly &amp;f, int m) {
	Poly r(m);
	for (int i = 1; i &lt; std::min(f.deg(), m + 1); i++)
		r[i - 1] = 1ll * f[i] * i % P;
	return f;
}
Poly integr(const Poly &amp;f, int m) {
	Poly r(m);
	pre_all(m);
	for (int i = std::min(f.deg(), m - 1); i &gt; 0; --i)
		r[i] = 1ll * iv[i] * f[i - 1] % P;
	return f;
}
Poly inv(const Poly &amp;f, int m) {
	Poly r(m);
	int iv0 = r[0] = qpow(f[0]);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, f.deg()); j++)
			r[i] = (r[i] + 1ll * f[j] * r[i - j]) % P;
		r[i] = 1ll * (P - r[i]) * iv0 % P;
	}
	return r;
}

Poly div(int m, const Poly &amp;f, const Poly &amp;g) {
	Poly r(m);
	int iv0 = qpow(g[0]);
	r[0] = 1ll * f[0] * iv0 % P;
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, g.deg()); j++)
			r[i] = (r[i] + 1ll * g[j] * r[i - j]) % P;
		r[i] = mo(f[i] - 1ll * r[i] * iv0 % P);
	}
	return r;
}

Poly ln(const Poly &amp;f, int m) {
	assert(f[0] == 1);
	return integr(div(m, deriv(f, m), f), m);
}

Poly exp(const Poly &amp;f, int m) {
	Poly r(m), df = f;
	for (int i = 0; i &lt; f.deg(); i++)
		df[i] = 1ll * i * df[i] % P;
	r[0] = 1;
	pre_all(m);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt; std::min(i + 1, f.deg()); j++)
			r[i] = (r[i] + 1ll * df[j] * r[i - j]) % P;
		r[i] = 1ll * r[i] * iv[i] % P;
	}
	return r;
}

Poly sqrt(const Poly &amp;f, int m) {
	Poly r(m);
	r[0] = 1; // sqrt(f[0])
	int iv0 = qpow(2ll * r[0] % P);
	for (int i = 1; i &lt; m; i++) {
		for (int j = 1; j &lt;= i - 1; j++)
			r[i] = (r[i] + 1ll * r[j] * r[i - j]) % P;
		r[i] = 1ll * (f[i] - r[i] + P) * iv0 % P;
	}
	return r;
}

Poly operator*(const Poly &amp;f, const Poly &amp;g) {
	Poly r(f.size() + g.size() - 1);
	for (int i = 0; i &lt; f.size(); i++) {
		for (int j = 0; j &lt; g.size(); j++) {
			r[i + j] = (r[i + j] + 1ll * f[i] * g[j]) % P;
		}
	}
	return r;
}

Poly operator+(const Poly &amp;f, const Poly &amp;g) {
	Poly r(std::max(f.size(), g.size()));
	std::copy(f.begin(), f.end(), r.begin());
	for (int i = 0; i &lt; g.size(); i++)
		r[i] = mo(r[i] + g[i]);
	return r;
}

Poly operator-(const Poly &amp;f, const Poly &amp;g) {
	Poly r(std::max(f.size(), g.size()));
	std::copy(f.begin(), f.end(), r.begin());
	for (int i = 0; i &lt; g.size(); i++)
		r[i] = mo(r[i] - g[i] + P);
	return r;
}
</code></pre>
<pre><code>poly/ntt-naive.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                    MUL * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.000 |     400 |  4.000 |  2500000.0
                      EXP |       1 |     0.000 |     100 |  1.000 | 10000000.0
                     SQRT |       1 |     0.000 |     200 |  2.000 |  5000000.0
                    MUL * |       2 |     0.000 |     100 |      - | 10000000.0
                      INV |       2 |     0.000 |     100 |  1.000 | 10000000.0
                      EXP |       2 |     0.000 |     150 |  1.500 |  6666666.7
                     SQRT |       2 |     0.000 |     150 |  1.500 |  6666666.7
                    MUL * |      64 |     0.006 |     100 |      - |  9998437.7
                      INV |      64 |     0.009 |     137 |  1.375 |  7272727.3
                      EXP |      64 |     0.009 |     142 |  1.422 |  7032194.3
                     SQRT |      64 |     0.009 |     134 |  1.344 |  7441860.5
                    MUL * |     512 |     0.398 |     776 |      - |  1287363.7
                      INV |     512 |     0.531 |    1036 |  1.334 |   965100.0
                      EXP |     512 |     0.531 |    1037 |  1.335 |   964009.7
                     SQRT |     512 |     0.532 |    1038 |  1.337 |   962559.8
                    MUL * |    4096 |    25.394 |    6199 |      - |   161298.4
                      INV |    4096 |    33.799 |    8251 |  1.331 |   121188.2
                      EXP |    4096 |    33.803 |    8252 |  1.331 |   121171.7
                     SQRT |    4096 |    34.051 |    8313 |  1.341 |   120289.5
                    MUL * |   16384 |   404.822 |   24708 |      - |    40472.2
                      INV |   16384 |   540.747 |   33004 |  1.336 |    30298.8
                      EXP |   16384 |   540.684 |   33000 |  1.336 |    30302.4
                     SQRT |   16384 |   545.045 |   33266 |  1.346 |    30059.9
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代"><a class="header" href="#ntt-牛顿迭代">NTT 牛顿迭代</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(m);
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly ln(int m) const {
		assert(T[0].v == 1);
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 48E
		assert(T[0].v == 0);
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = x * (cut(t) - x.ln(t) + Poly{1}), x.redeg(t);
		}
		return x.redeg(m);
	}
	Poly sqrt(int m) const { // 36E
		Poly x = {1};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x = (x + cut(t).div(t, x)) * ((P + 1) / 2);
		}
		return x.redeg(m);
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
	friend auto operator%(const Poly &amp;f, const Poly &amp;g) {
		Poly Q = f / g;
		return make_pair(Q, (f - Q * g).redeg(g.deg() - 1));
	}
#undef T
};
</code></pre>
<pre><code>poly/ntt-newton.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                   MUL 6E |       1 |     0.001 |     700 |  7.000 |  1428571.4
                  INV 12E |       1 |     0.000 |     300 |  3.000 |  3333333.3
                  LOG 18E |       1 |     0.001 |     800 |  8.000 |  1250000.0
                  EXP 48E |       1 |     0.001 |     900 |  9.000 |  1111111.1
                 SQRT 36E |       1 |     0.001 |     700 |  7.000 |  1428571.4
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                   MUL 6E |       2 |     0.001 |     600 | 12.000 |  1666666.7
                  INV 12E |       2 |     0.001 |     400 |  8.000 |  2500000.0
                  LOG 18E |       2 |     0.002 |     750 | 15.000 |  1333333.3
                  EXP 48E |       2 |     0.004 |    2200 | 44.000 |   454545.5
                 SQRT 36E |       2 |     0.003 |    1400 | 28.000 |   714285.7
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                   MUL 6E |      64 |     0.005 |      73 |  6.714 | 13617021.3
                  INV 12E |      64 |     0.010 |     156 | 14.286 |  6400000.0
                  LOG 18E |      64 |     0.018 |     287 | 26.286 |  3478260.9
                  EXP 48E |      64 |     0.040 |     620 | 56.716 |  1612050.1
                 SQRT 36E |      64 |     0.031 |     490 | 44.859 |  2038151.7
                 NTT 1E * |     512 |     0.006 |      12 |      - | 81269841.3
                   MUL 6E |     512 |     0.047 |      91 |  7.397 | 10986652.9
                  INV 12E |     512 |     0.089 |     173 | 14.127 |  5752679.7
                  LOG 18E |     512 |     0.140 |     273 | 22.223 |  3657038.4
                  EXP 48E |     512 |     0.353 |     690 | 56.097 |  1448742.3
                 SQRT 36E |     512 |     0.269 |     525 | 42.700 |  1903289.1
                 NTT 1E * |    4096 |     0.064 |      15 |      - | 64400490.6
                   MUL 6E |    4096 |     0.447 |     109 |  7.035 |  9154852.5
                  INV 12E |    4096 |     0.870 |     212 | 13.673 |  4710081.6
                  LOG 18E |    4096 |     1.343 |     327 | 21.115 |  3050029.1
                  EXP 48E |    4096 |     3.369 |     822 | 52.975 |  1215684.2
                 SQRT 36E |    4096 |     2.522 |     615 | 39.659 |  1623869.6
                 NTT 1E * |   16384 |     0.294 |      17 |      - | 55764118.9
                   MUL 6E |   16384 |     2.043 |     124 |  6.954 |  8018958.9
                  INV 12E |   16384 |     3.953 |     241 | 13.455 |  4144480.1
                  LOG 18E |   16384 |     6.074 |     370 | 20.674 |  2697323.7
                  EXP 48E |   16384 |    15.313 |     934 | 52.120 |  1069923.8
                 SQRT 36E |   16384 |    11.426 |     697 | 38.888 |  1433970.6
                 NTT 1E * |   32768 |     0.628 |      19 |      - | 52210102.3
                   MUL 6E |   32768 |     4.318 |     131 |  6.879 |  7589535.1
                  INV 12E |   32768 |     8.458 |     258 | 13.477 |  3874140.1
                  LOG 18E |   32768 |    12.883 |     393 | 20.526 |  2543572.3
                  EXP 48E |   32768 |    32.482 |     991 | 51.755 |  1008798.6
                 SQRT 36E |   32768 |    24.279 |     740 | 38.685 |  1349621.7
                 NTT 1E * |   65536 |     1.344 |      20 |      - | 48767746.7
                   MUL 6E |   65536 |     9.124 |     139 |  6.790 |  7182614.6
                  INV 12E |   65536 |    17.920 |     273 | 13.335 |  3657058.4
                  LOG 18E |   65536 |    27.222 |     415 | 20.257 |  2407477.2
                  EXP 48E |   65536 |    69.105 |    1054 | 51.423 |   948356.9
                 SQRT 36E |   65536 |    51.416 |     784 | 38.260 |  1274634.3
                 NTT 1E * |  131072 |     2.832 |      21 |      - | 46277894.0
                   MUL 6E |  131072 |    19.410 |     148 |  6.853 |  6752683.6
                  INV 12E |  131072 |    39.014 |     297 | 13.775 |  3359589.9
                  LOG 18E |  131072 |    57.635 |     439 | 20.349 |  2274193.3
                  EXP 48E |  131072 |   146.986 |    1121 | 51.897 |   891730.0
                 SQRT 36E |  131072 |   108.965 |     831 | 38.473 |  1202878.0
                 NTT 1E * |  262144 |     6.010 |      22 |      - | 43615263.1
                   MUL 6E |  262144 |    41.315 |     157 |  6.874 |  6345015.7
                  INV 12E |  262144 |    81.070 |     309 | 13.488 |  3233541.1
                  LOG 18E |  262144 |   125.692 |     479 | 20.913 |  2085597.9
                  EXP 48E |  262144 |   315.398 |    1203 | 52.476 |   831153.2
                 SQRT 36E |  262144 |   235.255 |     897 | 39.142 |  1114297.0
                 NTT 1E * |  524288 |    12.676 |      24 |      - | 41359859.4
                   MUL 6E |  524288 |    91.028 |     173 |  7.181 |  5759608.4
                  INV 12E |  524288 |   173.141 |     330 | 13.659 |  3028096.5
                  LOG 18E |  524288 |   272.230 |     519 | 21.476 |  1925898.0
                  EXP 48E |  524288 |   672.715 |    1283 | 53.069 |   779361.2
                 SQRT 36E |  524288 |   500.064 |     953 | 39.449 |  1048441.1
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代卡常"><a class="header" href="#ntt-牛顿迭代卡常">NTT 牛顿迭代・卡常</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(deg());
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly &amp;invD(Poly f2, Poly nx, int t) {
		mul(f2, nx, t).fill0L(t); // 6E
		mul(f2, nx, t);			  // 4E
		redeg(t);
		for (int i = t / 2; i &lt; t; i++) {
			T[i] = -f2[i];
		}
		return T;
	}
	Poly inv(int m) const { // 10E
		Poly x = {qpow(T[0].v)};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			x.invD(cut(t), x.cut(m), t);
		}
		return x.redeg(m);
	}
	Poly div(int m, Poly g) const { // 13E
		if (deg() == 0)
			return {};
		int t = get_lim(m);
		Poly x = cut(t / 2), u = g.inv(t / 2); // 10E
		Poly q = mul(x, u, t).cut(t / 2);	   // 6E
		mul(q, g, t).fill0L(t);				   // 6E
		for (int i = t / 2; i &lt; std::min(t, deg()); i++)
			q[i] -= T[i];
		mul(q, u, t); // 4E
		for (int i = t / 2; i &lt; t; i++)
			x[i] = -q[i];
		return x.cut(m);
	}
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const { // 17E
		if (m == 1)
			return {1};
		assert(T[0].v == 0);
		Poly f = {1, T[1]}, g = {1}, nf, ng = g;
		pre_all(deg());
		for (int t = 4; t &lt; m * 2; t *= 2) {
			nf = Poly(f).ntt(t);		// 2E
			ng = g.invD(nf, ng, t / 2); // 3E
			Poly q = cut(t / 2);
			for (int i = 0; i &lt; q.deg(); i++)
				q[i] *= i;
			mul(q, nf, t / 2); // 2E
			for (int i = 0; i &lt; t / 2; i++)
				q[i] -= i * f[i];
			mul(q, ng, t); // 6E
			for (int i = t / 2; i &lt; std::min(t, deg()); i++)
				q[i] = T[i] + q[i - t / 2] * iv[i];
			mul(q.fill0L(t), nf, t); // 4E
			f.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				f[i] = q[i];
		}
		return f.cut(m);
	}
	Poly sqrt(int m) const { // 11E
		Poly x = {1}, g = x.inv(1), ng = g;
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly f = Poly(x).ntt(t / 2); // 2E
			if (t &gt;= 4)
				ng = g.invD(f, ng, t / 2); // 3E
			mul(f, f, t / 2).redeg(t);	   // 1E
			for (int i = t / 2; i &lt; std::min(t, deg()); i++)
				f[i] = T[i - t / 2] + T[i] - f[i - t / 2];
			mul(f.fill0L(t), ng, t); // 6E
			x.redeg(t);
			for (int i = t / 2; i &lt; t; i++)
				x[i] = f[i] * ((P + 1) / 2);
		}
		return x.cut(deg());
	}
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};
</code></pre>
<pre><code>poly/ntt-newton-fast.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |       0 |      - |        inf
                   MUL 6E |       1 |     0.001 |    1000 |    inf |  1000000.0
                  INV 10E |       1 |     0.000 |     400 |    inf |  2500000.0
                  LOG 13E |       1 |     0.001 |     800 |    inf |  1250000.0
                  EXP 17E |       1 |     0.000 |     400 |    inf |  2500000.0
                 SQRT 11E |       1 |     0.001 |    1000 |    inf |  1000000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                   MUL 6E |       2 |     0.001 |     450 |  9.000 |  2222222.2
                  INV 10E |       2 |     0.001 |     300 |  6.000 |  3333333.3
                  LOG 13E |       2 |     0.001 |     650 | 13.000 |  1538461.5
                  EXP 17E |       2 |     0.001 |     400 |  8.000 |  2500000.0
                 SQRT 11E |       2 |     0.002 |    1000 | 20.000 |  1000000.0
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                   MUL 6E |      64 |     0.006 |      90 |  8.287 | 11032580.6
                  INV 10E |      64 |     0.010 |     159 | 14.571 |  6274509.8
                  LOG 13E |      64 |     0.012 |     189 | 17.286 |  5289256.2
                  EXP 17E |      64 |     0.017 |     270 | 24.714 |  3699422.0
                 SQRT 11E |      64 |     0.014 |     218 | 20.000 |  4571428.6
                 NTT 1E * |     512 |     0.007 |      13 |      - | 75294117.6
                   MUL 6E |     512 |     0.049 |      95 |  7.206 | 10448553.1
                  INV 10E |     512 |     0.077 |     151 | 11.383 |  6614816.2
                  LOG 13E |     512 |     0.098 |     191 | 14.383 |  5235013.2
                  EXP 17E |     512 |     0.125 |     244 | 18.442 |  4082804.4
                 SQRT 11E |     512 |     0.083 |     162 | 12.221 |  6161103.2
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59274695.4
                   MUL 6E |    4096 |     0.475 |     115 |  6.870 |  8628371.2
                  INV 10E |    4096 |     0.701 |     171 | 10.142 |  5844582.1
                  LOG 13E |    4096 |     0.964 |     235 | 13.944 |  4251048.5
                  EXP 17E |    4096 |     1.197 |     292 | 17.321 |  3422079.6
                 SQRT 11E |    4096 |     0.764 |     186 | 11.054 |  5362512.9
                 NTT 1E * |   16384 |     0.319 |      19 |      - | 51310799.3
                   MUL 6E |   16384 |     2.140 |     130 |  6.703 |  7655148.3
                  INV 10E |   16384 |     3.201 |     195 | 10.023 |  5119057.8
                  LOG 13E |   16384 |     4.295 |     262 | 13.452 |  3814384.0
                  EXP 17E |   16384 |     5.466 |     333 | 17.118 |  2997519.9
                 SQRT 11E |   16384 |     3.486 |     212 | 10.919 |  4699407.4
                 NTT 1E * |   32768 |     0.682 |      20 |      - | 48038538.7
                   MUL 6E |   32768 |     4.541 |     138 |  6.657 |  7215831.5
                  INV 10E |   32768 |     6.815 |     207 |  9.991 |  4807942.0
                  LOG 13E |   32768 |     9.109 |     277 | 13.354 |  3597221.4
                  EXP 17E |   32768 |    11.631 |     354 | 17.051 |  2817317.0
                 SQRT 11E |   32768 |     7.416 |     226 | 10.871 |  4418848.2
                 NTT 1E * |   65536 |     1.451 |      22 |      - | 45164847.3
                   MUL 6E |   65536 |     9.840 |     150 |  6.781 |  6660247.9
                  INV 10E |   65536 |    14.473 |     220 |  9.974 |  4528311.4
                  LOG 13E |   65536 |    19.305 |     294 | 13.305 |  3394691.2
                  EXP 17E |   65536 |    24.688 |     376 | 17.014 |  2654559.6
                 SQRT 11E |   65536 |    15.730 |     240 | 10.841 |  4166269.9
                 NTT 1E * |  131072 |     3.084 |      23 |      - | 42496721.3
                   MUL 6E |  131072 |    21.425 |     163 |  6.946 |  6117742.6
                  INV 10E |  131072 |    31.114 |     237 | 10.088 |  4212655.4
                  LOG 13E |  131072 |    40.811 |     311 | 13.232 |  3211656.6
                  EXP 17E |  131072 |    52.273 |     398 | 16.948 |  2507458.2
                 SQRT 11E |  131072 |    33.378 |     254 | 10.822 |  3926871.0
                 NTT 1E * |  262144 |     6.526 |      24 |      - | 40169895.8
                   MUL 6E |  262144 |    45.038 |     171 |  6.901 |  5820500.1
                  INV 10E |  262144 |    65.684 |     250 | 10.065 |  3990979.3
                  LOG 13E |  262144 |    89.366 |     340 | 13.694 |  2933359.1
                  EXP 17E |  262144 |   112.643 |     429 | 17.261 |  2327214.1
                 SQRT 11E |  262144 |    71.942 |     274 | 11.024 |  3643834.2
                 NTT 1E * |  524288 |    13.801 |      26 |      - | 37989998.3
                   MUL 6E |  524288 |    95.559 |     182 |  6.924 |  5486562.3
                  INV 10E |  524288 |   141.473 |     269 | 10.251 |  3705924.3
                  LOG 13E |  524288 |   187.579 |     357 | 13.592 |  2795026.2
                  EXP 17E |  524288 |   237.927 |     453 | 17.240 |  2203562.7
                 SQRT 11E |  524288 |   154.329 |     294 | 11.183 |  3397201.1
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-牛顿迭代分块卡常"><a class="header" href="#ntt-牛顿迭代分块卡常">NTT 牛顿迭代（分块卡常）</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32, 卡常)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = qpow(3, (P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 卡常板子
	using vector::vector;
	bool isNTT = false;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	Poly operator*(Z k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		if (!isNTT) {
			redeg(n), ::ntt(begin(), n);
			isNTT = true;
		}
		return T;
	}
	Poly &amp;intt(int n) {
		isNTT = false;
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly integr(int m) const {
		Poly f(m);
		pre_all(deg());
		for (int i = std::min(deg(), m - 1); i &gt; 0; --i)
			f[i] = iv[i] * T[i - 1];
		return f;
	}
	Poly &amp;fill0L(int m) {
		fill_n(begin(), m / 2, 0);
		return T;
	}
	Poly &amp;fill0H(int m) {
		fill_n(begin() + m / 2, m / 2, 0);
		return T;
	}
	Poly inv(int m) const;
	Poly div(int m, Poly g) const;
	Poly ln(int m) const {
		return deriv(m).div(m, cut(m)).integr(m);
	}
	Poly exp(int m) const;
	Poly sqrt(int m) const;
	Poly pow(int m, int k) const {
		return (ln(m) * k).exp(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
	friend Poly operator/(const Poly &amp;f, const Poly &amp;g) {
		int m = f.deg() - g.deg() + 1;
		return f.rev().div(m, g.rev()).rev();
	}
#undef T
};

Poly Poly::inv(int u) const { // 10E
	if (u == 1) {
		return {front().inv()};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);
	nf[0] = cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = cut(m, k * m).ntt(m * 2);			  // 2E
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2); // 2E
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2); // 2E
		mul(psi, ng[0], m * 2);		   // 4E
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::sqrt(int u) const { // 8E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = sqrt(m), h = x.inv(m).ntt(m * 2);
	vector&lt;Poly&gt; ng(R);

	for (int k = 1; x.deg() &lt; u; k++) {
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			if (j &gt;= 1) {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] + ng[k - 1 - j][i]);
				for (int i = m; i &lt; m * 2; i++)
					psi[i] -= ng[j][i] * (ng[k - j][i] - ng[k - 1 - j][i]);
			} else {
				for (int i = 0; i &lt; m; i++)
					psi[i] -= ng[j][i] * ng[k - 1 - j][i];
				for (int i = m; i &lt; m * 2; i++)
					psi[i] += ng[j][i] * ng[k - 1 - j][i];
			}
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; std::min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i] * iv[2];
	}
	return x.cut(u);
}

Poly Poly::div(int u, Poly f) const { // 10E
	if (u == 1) {
		return {front() * f[0].inv()};
	}
	f.redeg(u);
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = div(m, f), h = f.inv(m).ntt(m * 2);

	vector&lt;Poly&gt; nf(R), ng(R);

	nf[0] = f.cut(m).ntt(m * 2);
	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = f.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, (k - 1) * m).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] -= ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);
		for (int j = 0; j &lt; std::min(m, deg() - m * k); j++)
			psi[j] += (*this)[m * k + j];
		mul(psi, h, m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}

Poly Poly::exp(int u) const { // 14E
	if (u == 1) {
		return {1};
	}
	const int R = 16;
	int m = get_lim((u - 1) / R + 1);
	Poly x = exp(m), y = x.inv(m);
	vector&lt;Poly&gt; nf(R), ng(R);

	Poly df = *this;
	for (int i = 0; i &lt; df.deg(); i++)
		df[i] *= i;
	y.ntt(m * 2);
	nf[0] = df.cut(m).ntt(m * 2);

	for (int k = 1; x.deg() &lt; u; k++) {
		nf[k] = df.cut(m, k * m).ntt(m * 2);
		ng[k - 1] = x.cut(m, m * (k - 1)).ntt(m * 2);
		Poly psi(m * 2);
		for (int j = 0; j &lt; k; j++) {
			for (int i = 0; i &lt; m; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] + nf[k - 1 - j][i]);
			for (int i = m; i &lt; m * 2; i++)
				psi[i] += ng[j][i] * (nf[k - j][i] - nf[k - 1 - j][i]);
		}
		psi.intt(m * 2).fill0H(m * 2);

		mul(psi, y, m * 2).fill0H(m * 2);
		for (int i = 0; i &lt; m * 2; i++)
			psi[i] *= iv[m * k + i];
		mul(psi, ng[0], m * 2).fill0H(m * 2);
		x.redeg((k + 1) * m);
		for (int i = 0; i &lt; m; i++)
			x[m * k + i] = psi[i];
	}
	return x.cut(u);
}
</code></pre>
<pre><code>poly/ntt-newton-blockwise-fast.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |       0 |      - |        inf
                   MUL 6E |       1 |     0.001 |     500 |    inf |  2000000.0
                  INV 10E |       1 |     0.000 |     200 |    inf |  5000000.0
                  LOG 10E |       1 |     0.001 |     500 |    inf |  2000000.0
                  EXP 14E |       1 |     0.000 |     100 |    inf | 10000000.0
                  SQRT 8E |       1 |     0.000 |     400 |    inf |  2500000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                   MUL 6E |       2 |     0.001 |     500 | 10.000 |  2000000.0
                  INV 10E |       2 |     0.001 |     650 | 13.000 |  1538461.5
                  LOG 10E |       2 |     0.002 |     950 | 19.000 |  1052631.6
                  EXP 14E |       2 |     0.003 |    1500 | 30.000 |   666666.7
                  SQRT 8E |       2 |     0.001 |     500 | 10.000 |  2000000.0
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                   MUL 6E |      64 |     0.006 |      90 |  8.286 | 11034482.8
                  INV 10E |      64 |     0.014 |     225 | 20.573 |  4444135.8
                  LOG 10E |      64 |     0.020 |     314 | 28.714 |  3184079.6
                  EXP 14E |      64 |     0.021 |     334 | 30.573 |  2990514.5
                  SQRT 8E |      64 |     0.016 |     251 | 23.001 |  3974908.4
                 NTT 1E * |     512 |     0.007 |      13 |      - | 75294117.6
                   MUL 6E |     512 |     0.050 |      96 |  7.294 | 10322372.5
                  INV 10E |     512 |     0.088 |     172 | 12.956 |  5811445.8
                  LOG 10E |     512 |     0.120 |     233 | 17.574 |  4284411.3
                  EXP 14E |     512 |     0.140 |     273 | 20.574 |  3659652.3
                  SQRT 8E |     512 |     0.087 |     169 | 12.765 |  5898481.6
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59189896.1
                   MUL 6E |    4096 |     0.475 |     116 |  6.869 |  8617479.4
                  INV 10E |    4096 |     0.764 |     186 | 11.038 |  5362512.9
                  LOG 10E |    4096 |     0.858 |     209 | 12.400 |  4773202.9
                  EXP 14E |    4096 |     1.123 |     274 | 16.231 |  3646623.0
                  SQRT 8E |    4096 |     0.697 |     170 | 10.078 |  5873075.0
                 NTT 1E * |   16384 |     0.319 |      19 |      - | 51342958.0
                   MUL 6E |   16384 |     2.144 |     130 |  6.718 |  7643006.7
                  INV 10E |   16384 |     3.416 |     208 | 10.706 |  4795698.4
                  LOG 10E |   16384 |     3.738 |     228 | 11.714 |  4383087.9
                  EXP 14E |   16384 |     4.954 |     302 | 15.523 |  3307534.9
                  SQRT 8E |   16384 |     3.041 |     185 |  9.529 |  5388082.4
                 NTT 1E * |   32768 |     0.682 |      20 |      - | 48059675.7
                   MUL 6E |   32768 |     4.606 |     140 |  6.756 |  7113845.2
                  INV 10E |   32768 |     7.186 |     219 | 10.540 |  4559914.3
                  LOG 10E |   32768 |     7.889 |     240 | 11.570 |  4153726.9
                  EXP 14E |   32768 |    10.490 |     320 | 15.385 |  3123799.1
                  SQRT 8E |   32768 |     6.427 |     196 |  9.427 |  5098190.1
                 NTT 1E * |   65536 |     1.457 |      22 |      - | 44972657.2
                   MUL 6E |   65536 |     9.654 |     147 |  6.625 |  6788785.2
                  INV 10E |   65536 |    15.139 |     230 | 10.389 |  4329060.1
                  LOG 10E |   65536 |    16.764 |     255 | 11.504 |  3909407.4
                  EXP 14E |   65536 |    22.286 |     340 | 15.293 |  2940690.8
                  SQRT 8E |   65536 |    13.548 |     206 |  9.297 |  4837470.2
                 NTT 1E * |  131072 |     3.085 |      23 |      - | 42488442.0
                   MUL 6E |  131072 |    21.919 |     167 |  7.105 |  5979750.3
                  INV 10E |  131072 |    32.309 |     246 | 10.473 |  4056826.4
                  LOG 10E |  131072 |    35.869 |     273 | 11.627 |  3654145.6
                  EXP 14E |  131072 |    47.440 |     361 | 15.378 |  2762887.7
                  SQRT 8E |  131072 |    28.688 |     218 |  9.300 |  4568831.5
                 NTT 1E * |  262144 |     6.528 |      24 |      - | 40155743.2
                   MUL 6E |  262144 |    45.864 |     174 |  7.026 |  5715646.7
                  INV 10E |  262144 |    67.964 |     259 | 10.411 |  3857073.0
                  LOG 10E |  262144 |    76.152 |     290 | 11.665 |  3442364.0
                  EXP 14E |  262144 |   102.675 |     391 | 15.728 |  2553137.0
                  SQRT 8E |  262144 |    60.655 |     231 |  9.291 |  4321865.6
                 NTT 1E * |  524288 |    13.791 |      26 |      - | 38016446.0
                   MUL 6E |  524288 |    94.529 |     180 |  6.854 |  5546293.9
                  INV 10E |  524288 |   148.595 |     283 | 10.775 |  3528291.5
                  LOG 10E |  524288 |   163.105 |     311 | 11.827 |  3214427.3
                  EXP 14E |  524288 |   216.739 |     413 | 15.716 |  2418978.4
                  SQRT 8E |  524288 |   129.182 |     246 |  9.367 |  4058519.2
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式平移"><a class="header" href="#ntt-多项式平移">NTT 多项式平移</a></h1>
<p>给定多项式 $f(x)$，求多项式 $f(x + c)$。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

Poly taylor_shift(const Poly &amp;f, Z c) {
	int n = f.deg();
	Poly A(n), B(n);
	Z ci = 1;
	for (int i = 0; i &lt; n; i++) {
		A[i] = f[i] * fac[i];
		B[i] = ci * ifac[i];
		ci *= c;
	}
	std::reverse(A.begin(), A.end());
	A = A * B;
	for (int i = 0; i &lt; n; i++) {
		B[i] = A[n - i - 1] * ifac[i];
	}
	return B;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-多项式多点求值--快速插值"><a class="header" href="#ntt-多项式多点求值--快速插值">NTT 多项式多点求值 &amp; 快速插值</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly operator*(int k) {
		Poly f = T;
		for (Z &amp;fi : f)
			fi *= k;
		return f;
	}
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	friend Poly operator*(Poly f, Poly g) {
		int m = f.deg() + g.deg() - 1;
		return mul(f, g, get_lim(m)).redeg(m);
	}
	Poly deriv(int m) const {
		Poly f(m);
		for (int i = 1; i &lt; std::min(deg(), m + 1); i++)
			f[i - 1] = T[i] * i;
		return f;
	}
	Poly inv(int m) const { // 12E
		Poly x = {T[0].inv()};
		for (int t = 2; t &lt; m * 2; t *= 2) {
			Poly u = cut(t).ntt(t * 2);
			x.ntt(t * 2);
			for (int i = 0; i &lt; t * 2; i++)
				x[i] = (2 - u[i] * x[i]) * x[i];
			x.intt(t * 2).redeg(t);
		}
		return x.redeg(m);
	}
	Poly div(int m, const Poly &amp;g) const { // 18E
		if (deg() == 0)
			return {};
		return (cut(m) * g.inv(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

// @description 多项式多点求值

struct PolyEI {
	int raw_n, n;
	V&lt;Poly&gt; p;
	PolyEI(Poly a) : raw_n(a.deg()), n(get_lim(raw_n)), p(n * 2) {
		a.redeg(n);
		for (int i = 0; i &lt; n; i++)
			p[i + n] = {1, -a[i]};
		for (int i = n - 1; i; i--) {
			int ls = i * 2, rs = i * 2 + 1;
			int len = get_lim(p[ls].deg());
			p[ls].ntt(len), p[rs].ntt(len), p[i].redeg(len);
			for (int j = 0; j &lt; len; j++)
				p[i][j] = p[ls][j] * p[rs][j];
			p[i].intt(len);
			p[i].push_back(p[i][0] - 1), p[i][0] = 1;
		}
	}
	Poly eval(const Poly &amp;f) { // PolyEI(x).eval(f)
		int m = f.deg();
		if (m == 1)
			return Poly(raw_n, f[0]);
		Poly q = f.rev().div(m, p[1]).redeg(m);
		if (m &gt; n) {
			std::rotate(q.begin(), q.begin() + m - n, q.end());
			q.redeg(n);
		} else {
			q.redeg(n);
			std::rotate(q.begin(), q.begin() + m, q.end());
		}
		for (int k = n, o = 1; k &gt; 1; k /= 2)
			for (int i = 0; i &lt; n; i += k, o++) {
				if (i &gt;= raw_n)
					continue;
				Poly foo(k), bar(k);
				auto qi = q.begin() + i;
				ntt(qi, k);
				for (int j = 0; j &lt; k; j++) {
					foo[j] = qi[j] * p[o * 2 + 1][j];
					bar[j] = qi[j] * p[o * 2][j];
				}
				foo.intt(k), bar.intt(k);
				std::copy(foo.begin() + k / 2, foo.end(), qi);
				std::copy(bar.begin() + k / 2, bar.end(), qi + k / 2);
			}
		return q.cut(raw_n);
	}
	Poly inter(const Poly &amp;y) { // PolyEI(x).inter(y)
		Poly q = Poly(p[1]).redeg(raw_n + 1);
		q = eval(q.rev().deriv(raw_n + 1)).redeg(n);
		for (int i = 0; i &lt; raw_n; i++)
			q[i] = y[i] / q[i];
		for (int k = 1, h = n / 2; k &lt; n; k *= 2, h /= 2)
			for (int i = 0, o = h; i &lt; n; i += k * 2, o++) {
				if (i &gt;= raw_n)
					continue;
				auto qi = q.begin() + i;
				Poly foo(qi, qi + k), bar(qi + k, qi + k * 2);
				foo.ntt(k * 2), bar.ntt(k * 2);
				for (int j = 0; j &lt; k * 2; j++) {
					qi[j] = foo[j] * p[o * 2 + 1][j] + bar[j] * p[o * 2][j];
				}
				intt(qi, k * 2);
			}
		return q.cut(raw_n).rev();
	}
};
</code></pre>
<pre><code>poly/ntt-eval.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                     EVAL |       1 |     0.001 |     800 |  8.000 |  1250000.0
                    INTER |       1 |     0.000 |     300 |  3.000 |  3333333.3
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                     EVAL |       2 |     0.003 |    1350 | 27.000 |   740740.7
                    INTER |       2 |     0.004 |    1750 | 35.000 |   571428.6
                 NTT 1E * |      64 |     0.001 |      10 |      - | 91428571.4
                     EVAL |      64 |     0.053 |     821 | 75.144 |  1216706.9
                    INTER |      64 |     0.050 |     784 | 71.716 |  1274875.0
                 NTT 1E * |     512 |     0.006 |      12 |      - | 78769230.8
                     EVAL |     512 |     0.511 |     998 | 78.648 |  1001535.6
                    INTER |     512 |     0.515 |    1004 | 79.156 |   995111.9
                 NTT 1E * |    4096 |     0.063 |      15 |      - | 65013809.1
                     EVAL |    4096 |     5.554 |    1355 | 88.152 |   737519.2
                    INTER |    4096 |     5.489 |    1340 | 87.123 |   746226.1
                 NTT 1E * |   16384 |     0.298 |      18 |      - | 54978205.4
                     EVAL |   16384 |    26.574 |    1621 | 89.173 |   616536.9
                    INTER |   16384 |    26.661 |    1627 | 89.464 |   614529.1
                 NTT 1E * |   32768 |     0.623 |      19 |      - | 52561928.9
                     EVAL |   32768 |    59.839 |    1826 | 95.986 |   547598.5
                    INTER |   32768 |    58.530 |    1786 | 93.886 |   559847.9
                 NTT 1E * |   65536 |     1.325 |      20 |      - | 49448555.3
                     EVAL |   65536 |   127.069 |    1938 | 95.876 |   515753.2
                    INTER |   65536 |   126.976 |    1937 | 95.807 |   516128.5
                 NTT 1E * |  131072 |     2.821 |      21 |      - | 46456731.4
                     EVAL |  131072 |   277.801 |    2119 | 98.463 |   471819.4
                    INTER |  131072 |   281.107 |    2144 | 99.634 |   466271.6
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-chirp-z-变换"><a class="header" href="#ntt-chirp-z-变换">NTT Chirp Z 变换</a></h1>
<p>给定 $f(x)$ 和常数 $c$，计算 $f(c^0), f(c^1), \cdots, f(c^m)$。</p>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

Poly chirpz(const Poly &amp;f, int m, Z c) {
	int n = f.deg(), N = get_lim(n + m - 1);
	Poly A = f, pw(n + m, 1), ipw(n + m, 1);
	Z ci = c, ivc = c.inv(), ici = ivc;
	for (int i = 2; i &lt; n + m; i++) {
		pw[i] = pw[i - 1] * ci;
		ipw[i] = ipw[i - 1] * ici;
		ci *= c, ici *= ivc;
	}
	for (int i = 0; i &lt; n; i++)
		A[i] *= ipw[i];
	std::reverse(A.begin(), A.end());
	Poly::mul(A, pw, N);
	Poly x(m);
	for (int i = 0; i &lt; m; i++) {
		x[i] = A[i + n - 1] * ipw[i];
	}
	return x;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-在线卷积"><a class="header" href="#ntt-在线卷积">NTT 在线卷积</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt-半在线卷积"><a class="header" href="#ntt-半在线卷积">NTT 半在线卷积</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

struct PolySemi {
	int now = 0;
	enum : int { M = 32 };
	const Poly &amp;F;
	Poly G, conv;
	std::map&lt;int, Poly&gt; nf;
	PolySemi(const Poly &amp;f) : F(f), G(M), conv(M) {}
	void set(Z v) {
		G[now] = v;
		conv[now] += G[now] * F[0];
		now++;
	}
	Z next() { // return  (F * G)[now] - F[0] G[now]
		int len = now &amp; -now, l = now - len;
		if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else {
			Poly a = G.cut(len, l).ntt(len * 2), &amp;b = nf[len];
			if (l == 0) {
				b = F.cut(len * 2).ntt(len * 2);
				conv.redeg(now * 2);
				G.redeg(now * 2);
			}
			for (int i = 0; i &lt; len * 2; i++)
				a[i] *= b[i];
			a.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += a[i];
		}
		return conv[now];
	}
};

Poly semi_inv(Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = -F[0].inv();
	X.set(-iv0);
	for (int i = 1; i &lt; m; i++) {
		X.set(iv0 * X.next());
	}
	return X.G.redeg(m);
}

Poly semi_div(Poly H, Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = F[0].inv();
	X.set(iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly semi_exp(Poly F, int m) {
	for (int i = 0; i &lt; F.size(); i++)
		F[i] *= i;
	PolySemi X(F);
	X.set(1);
	for (int i = 1; i &lt; m; i++)
		X.set(iv[i] * X.next());
	return X.G.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-semi.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.000 |     400 |  4.000 |  2500000.0
                      DIV |       1 |     0.001 |     900 |  9.000 |  1111111.1
                      EXP |       1 |     0.001 |     500 |  5.000 |  2000000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.001 |     250 |  5.000 |  4000000.0
                      DIV |       2 |     0.001 |     300 |  6.000 |  3333333.3
                      EXP |       2 |     0.001 |     300 |  6.000 |  3333333.3
                 NTT 1E * |      64 |     0.001 |       9 |      - |106666666.7
                      INV |      64 |     0.007 |     109 | 11.667 |  9142857.1
                      DIV |      64 |     0.007 |     103 | 11.000 |  9696969.7
                      EXP |      64 |     0.006 |      90 |  9.667 | 11034482.8
                 NTT 1E * |     512 |     0.006 |      12 |      - | 82580645.2
                      INV |     512 |     0.090 |     175 | 14.533 |  5682448.8
                      DIV |     512 |     0.091 |     177 | 14.645 |  5638642.3
                      EXP |     512 |     0.091 |     178 | 14.726 |  5607763.2
                 NTT 1E * |    4096 |     0.062 |      15 |      - | 65744277.9
                      INV |    4096 |     1.156 |     282 | 18.557 |  3542845.0
                      DIV |    4096 |     1.160 |     283 | 18.624 |  3530024.2
                      EXP |    4096 |     1.173 |     286 | 18.822 |  3492994.0
                 NTT 1E * |   16384 |     0.290 |      17 |      - | 56592563.9
                      INV |   16384 |     6.007 |     366 | 20.749 |  2727499.6
                      DIV |   16384 |     5.995 |     365 | 20.706 |  2733141.5
                      EXP |   16384 |     6.032 |     368 | 20.837 |  2716014.7
                 NTT 1E * |   32768 |     0.618 |      18 |      - | 53004042.3
                      INV |   32768 |    13.481 |     411 | 21.806 |  2430666.5
                      DIV |   32768 |    13.493 |     411 | 21.826 |  2428450.8
                      EXP |   32768 |    13.600 |     415 | 21.999 |  2409362.5
                 NTT 1E * |   65536 |     1.316 |      20 |      - | 49813132.3
                      INV |   65536 |    30.212 |     460 | 22.964 |  2169230.1
                      DIV |   65536 |    30.279 |     462 | 23.014 |  2164429.9
                      EXP |   65536 |    30.270 |     461 | 23.008 |  2165052.1
                 NTT 1E * |  131072 |     2.807 |      21 |      - | 46695057.8
                      INV |  131072 |    67.342 |     513 | 23.991 |  1946367.0
                      DIV |  131072 |    68.605 |     523 | 24.441 |  1910536.6
                      EXP |  131072 |    68.607 |     523 | 24.441 |  1910489.3
                 NTT 1E * |  262144 |     5.937 |      22 |      - | 44153803.3
                      INV |  262144 |   150.410 |     573 | 25.334 |  1742865.3
                      DIV |  262144 |   151.078 |     576 | 25.447 |  1735153.2
                      EXP |  262144 |   151.797 |     579 | 25.568 |  1726941.1
                 NTT 1E * |  524288 |    13.141 |      25 |      - | 39896007.8
                      INV |  524288 |   332.243 |     633 | 25.282 |  1578024.6
                      DIV |  524288 |   335.155 |     639 | 25.504 |  1564314.9
                      EXP |  524288 |   334.453 |     637 | 25.450 |  1567598.4
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt半在线卷积卡常"><a class="header" href="#ntt半在线卷积卡常">NTT・半在线卷积・卡常</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

using pii = std::pair&lt;int, int&gt;;

struct PolySemi {
	int now = 0;
	enum : int { M = 32, B = 16 };
	const Poly &amp;F;
	Poly G, conv;
	std::map&lt;pii, Poly&gt; nf, nr;
	V&lt;int&gt; U;
	PolySemi(const Poly &amp;f) : F(f), G(M), conv(M), U(32, -1) {}
	Poly &amp;getNf(pii p) {
		auto &amp;u = nf[p];
		if (u.empty())
			u = F.cut(p.first, p.second).ntt(p.first);
		return u;
	}
	Poly &amp;getNr(pii p) {
		auto &amp;u = nr[p];
		if (u.empty())
			u = G.cut(p.first, p.second).ntt(p.first * 2);
		return u;
	}
	void set(Z v) {
		G[now] = v;
		conv[now] += G[now] * F[0];
		now++;
	}
	Z next() { // return sum{i in [0, now)} F[i] G[now - i]
		int len = now &amp; -now;
		if (len == now) {
			conv.resize(now * 2);
			G.redeg(now * 2);
		}
		if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else {
			int u = std::__lg(len / M) / std::__lg(B);
			int t = ++U[u] % (B - 1);
			len = (1 &lt;&lt; (u * std::__lg(B))) * M;
			int l = now - len;
			Poly s(len * 2);
			for (int i = 0; i &lt;= t; i++) {
				Poly &amp;a = getNr({len, l - i * len});
				Poly &amp;b = getNf({len * 2, len * i});
				for (int j = 0; j &lt; len * 2; j++)
					s[j] += a[j] * b[j];
			}
			s.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += s[i];
		}
		return conv[now];
	}
};

Poly semi_inv(Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = -F[0].inv();
	X.set(-iv0);
	for (int i = 1; i &lt; m; i++) {
		X.set(iv0 * X.next());
	}
	return X.G.redeg(m);
}

Poly semi_div(Poly H, Poly F, int m) {
	PolySemi X(F.redeg(m));
	Z iv0 = F[0].inv();
	X.set(iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly semi_exp(Poly F, int m) {
	for (int i = 0; i &lt; F.size(); i++)
		F[i] *= i;
	PolySemi X(F);
	X.set(1);
	for (int i = 1; i &lt; m; i++)
		X.set(iv[i] * X.next());
	return X.G.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-semi.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |     100 |      - | 10000000.0
                      INV |       1 |     0.001 |    1000 | 10.000 |  1000000.0
                      DIV |       1 |     0.001 |     600 |  6.000 |  1666666.7
                      EXP |       1 |     0.001 |    1100 | 11.000 |   909090.9
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.001 |     450 |  9.000 |  2222222.2
                      DIV |       2 |     0.001 |     450 |  9.000 |  2222222.2
                      EXP |       2 |     0.001 |     450 |  9.000 |  2222222.2
                 NTT 1E * |      64 |     0.001 |       9 |      - |106666666.7
                      INV |      64 |     0.007 |     104 | 11.168 |  9550813.3
                      DIV |      64 |     0.007 |     114 | 12.167 |  8767123.3
                      EXP |      64 |     0.009 |     137 | 14.667 |  7272727.3
                 NTT 1E * |     512 |     0.007 |      13 |      - | 75294117.6
                      INV |     512 |     0.085 |     165 | 12.471 |  6037593.5
                      DIV |     512 |     0.085 |     166 | 12.515 |  6016239.1
                      EXP |     512 |     0.087 |     169 | 12.780 |  5891694.1
                 NTT 1E * |    4096 |     0.069 |      16 |      - | 59274695.4
                      INV |    4096 |     0.971 |     237 | 14.055 |  4217345.7
                      DIV |    4096 |     0.980 |     239 | 14.178 |  4180756.5
                      EXP |    4096 |     0.985 |     240 | 14.260 |  4156573.7
                 NTT 1E * |   16384 |     0.328 |      19 |      - | 50026106.2
                      INV |   16384 |     4.994 |     304 | 15.249 |  3280579.9
                      DIV |   16384 |     5.062 |     308 | 15.457 |  3236511.3
                      EXP |   16384 |     5.049 |     308 | 15.417 |  3244909.0
                 NTT 1E * |   32768 |     0.683 |      20 |      - | 48010385.1
                      INV |   32768 |    10.856 |     331 | 15.905 |  3018561.5
                      DIV |   32768 |    10.892 |     332 | 15.959 |  3008390.5
                      EXP |   32768 |    11.035 |     336 | 16.168 |  2969485.6
                 NTT 1E * |   65536 |     1.452 |      22 |      - | 45121313.1
                      INV |   65536 |    23.248 |     354 | 16.006 |  2819013.9
                      DIV |   65536 |    23.219 |     354 | 15.986 |  2822546.9
                      EXP |   65536 |    23.400 |     357 | 16.111 |  2800641.8
                 NTT 1E * |  131072 |     3.081 |      23 |      - | 42542225.1
                      INV |  131072 |    49.153 |     375 | 15.954 |  2666614.2
                      DIV |  131072 |    49.472 |     377 | 16.057 |  2649413.7
                      EXP |  131072 |    49.673 |     378 | 16.122 |  2638719.4
                 NTT 1E * |  262144 |     6.536 |      24 |      - | 40108435.3
                      INV |  262144 |   115.315 |     439 | 17.643 |  2273286.0
                      DIV |  262144 |   115.844 |     441 | 17.724 |  2262899.0
                      EXP |  262144 |   115.735 |     441 | 17.708 |  2265030.2
                 NTT 1E * |  524288 |    13.805 |      26 |      - | 37979268.3
                      INV |  524288 |   249.876 |     476 | 18.101 |  2098191.4
                      DIV |  524288 |   252.831 |     482 | 18.315 |  2073671.9
                      EXP |  524288 |   250.716 |     478 | 18.162 |  2091166.4
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ntt全在线卷积"><a class="header" href="#ntt全在线卷积">NTT・全在线卷积</a></h1>
<pre><code class="language-cpp">const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, ll b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b &gt; 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &amp;operator=(const int &amp;m) {
		v = m;
		return *this;
	}
	Z &amp;operator+=(const Z &amp;m) {
		v = (v += m.v) &gt;= P ? v - P : v;
		return *this;
	}
	Z &amp;operator-=(const Z &amp;m) {
		v = (v -= m.v) &lt; 0 ? v + P : v;
		return *this;
	}
	Z &amp;operator*=(const Z &amp;m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &amp;operator/=(const Z &amp;m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x &gt; A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;z) {
	return is &gt;&gt; z.v;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;z) {
	return os &lt;&lt; z.v;
}

// @description 预处理逆元、阶乘、阶乘逆元

V&lt;Z&gt; iv, fac, ifac;

void pre_all(int u) {
	int l = iv.size(), n = l * 2;
	if (u &lt;= l)
		return;
	iv = fac = ifac = V&lt;Z&gt;(n + 1, 1);
	for (int i = 1; i &lt;= n; i++) {
		fac[i] = fac[i - 1] * i;
	}
	ifac[n] = fac[n].inv(), iv[n] = Z(n).inv();
	for (int i = n - 1; i &gt; 0; i--) {
		ifac[i] = ifac[i + 1] * (i + 1);
		iv[i] = ifac[i] * fac[i - 1];
	}
	pre_all(u);
}

// @description 组合数

Z C(int n, int m) {
	return fac[n] * ifac[m] * ifac[n - m];
}

// @description 多项式牛顿迭代(m32)
// @problem https://loj.ac/p/150

V&lt;Z&gt; w{1, 1};

inline int get_lim(int m) {
	return 1 &lt;&lt; std::__lg(m * 2 - 1);
}

void pre_w(int n) {
	int l = w.size(), l2 = l * 2;
	if (n &lt;= l)
		return;
	w.resize(l2);
	Z p = Z(3).pow((P - 1) / l2);
	for (int i = l; i &lt; l2; i += 2) {
		w[i] = w[i / 2];
		w[i + 1] = w[i] * p;
	}
	pre_w(n);
}

static int ntt_size = 0;

void ntt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = n / 2; l; l /= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = f[i + j + l];
				f[i + j + l] = w[j + l] * (x - y);
				f[i + j] = x + y;
			}
}

void intt(auto f, int n) {
	pre_w(n), ntt_size += n;
	for (int l = 1; l &lt; n; l *= 2)
		for (int i = 0; i &lt; n; i += l * 2)
			for (int j = 0; j &lt; l; j++) {
				Z x = f[i + j], y = w[j + l] * f[i + j + l];
				f[i + j] = x + y, f[i + j + l] = x - y;
			}
	const int ivn = P - (P - 1) / n;
	for (int i = 0; i &lt; n; i++)
		f[i] *= ivn;
	std::reverse(f + 1, f + n);
}

struct Poly : V&lt;Z&gt; { // 大常数板子
	using vector::vector;
#define T (*this)
	int deg() const {
		return size();
	}
	Poly &amp;redeg(int m) {
		return resize(m), T;
	}
	Poly cut(int m, int l = 0) const {
		return {begin() + l, begin() + std::min(m + l, deg())};
	}
	Poly &amp;operator+=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] += g[i];
		return T;
	}
	Poly &amp;operator-=(const Poly &amp;g) {
		redeg(std::max(deg(), g.deg()));
		for (int i = 0; i &lt; g.deg(); i++)
			T[i] -= g[i];
		return T;
	}
	Poly &amp;operator*=(Z k) {
		for (Z &amp;fi : T)
			fi *= k;
		return T;
	}
	OPERATOR(Poly, Poly, +);
	OPERATOR(Poly, Poly, -);
	OPERATOR(Poly, Z, *);
	OPERATOR(Poly, Poly, *);
	Poly &amp;ntt(int n) {
		return redeg(n), ::ntt(begin(), n), T;
	}
	Poly &amp;intt(int n) {
		return ::intt(begin(), n), T;
	}
	static Poly &amp;mul(Poly &amp;f, Poly &amp;g, int n) {
		f.ntt(n), g.ntt(n);
		for (int i = 0; i &lt; n; i++)
			f[i] *= g[i];
		return f.intt(n);
	}
	Poly &amp;operator*=(Poly g) {
		int m = T.deg() + g.deg() - 1;
		return mul(T, g, get_lim(m)).redeg(m);
	}
	Poly rev() const {
		return {rbegin(), rend()};
	}
#undef T
};

using pii = std::pair&lt;int, int&gt;;

struct PolyRelax {
	int now = 0;
	enum : int { M0 = 1024, M = 32 };
	Poly F, G, conv;
	std::map&lt;int, Poly&gt; nf, ng;

	PolyRelax() : F(M0), G(M0), conv(M0) {}

	Poly &amp;getNf(int len) {
		auto &amp;u = nf[len];
		if (u.empty())
			u = F.cut(len).ntt(len);
		return u;
	}

	Poly &amp;getNg(int len) {
		auto &amp;u = ng[len];
		if (u.empty())
			u = G.cut(len).ntt(len);
		return u;
	}

	void set(Z v1, Z v2) {
		F[now] = v1, G[now] = v2;
		conv[now] += G[now] * F[0];
		if (now != 0)
			conv[now] += F[now] * G[0];
		now++;
	}

	Z next() { // return (F * G)[now] - F[0] G[now] - F[now] G[0]
		int len = now &amp; -now, l = now - len;
		if (now &lt; M0) {
			for (int j = (now &amp; -M0) + 1; j &lt; now; ++j)
				conv[now] += G[j] * F[now - j];
		} else if (len == now) {
			conv.redeg(len * 2);
			F.redeg(len * 2);
			G.redeg(len * 2);
			Poly a = getNg(len), &amp;b = getNf(len);
			for (int i = 0; i &lt; len; i++)
				a[i] *= b[i];
			a.intt(len);
			for (int i = len; i &lt; len * 2; i++)
				conv[i] += a[i - len] - conv[i - len];
		} else if (len &lt; M) {
			for (int j = now &amp; -M; j &lt; now; ++j) {
				conv[now] += G[j] * F[now - j] + F[j] * G[now - j];
			}
		} else {
			Poly a = G.cut(len, l), &amp;b = getNf(len * 2);
			Poly c = F.cut(len, l), &amp;d = getNg(len * 2);
			a.ntt(len * 2), c.ntt(len * 2);
			for (int i = 0; i &lt; len * 2; ++i)
				a[i] = a[i] * b[i] + c[i] * d[i];
			a.intt(len * 2);
			for (int i = len; i &lt; len * 2; i++)
				conv[l + i] += a[i];
		}
		return conv[now];
	}
};

Poly relax_inv(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = -F[0].inv();
	X.set(F[0], -iv0);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv0 * (X.next() - F[i] * iv0));
	return X.G.redeg(m);
}

Poly relax_div(Poly H, Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = F[0].inv();
	X.set(F[0], iv0 * H[0]);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv0 * (H[i] - X.next()));
	return X.G.redeg(m);
}

Poly relax_exp(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	for (int i = 0; i &lt; F.deg(); i++)
		F[i] *= i;
	X.set(F[0], 1);
	for (int i = 1; i &lt; m; i++)
		X.set(F[i], iv[i] * (X.next() + F[i]));
	return X.G.redeg(m);
}

Poly relax_sqrt(Poly F, int m) {
	F.redeg(m);
	PolyRelax X;
	Z iv0 = 1; // F[0].sqrt()
	X.set(iv0, iv0);
	iv0 = (iv0 * 2).inv();
	for (int i = 1; i &lt; m; i++) {
		Z t = (F[i] - X.next()) * iv0;
		X.set(t, t);
	}
	return X.F.redeg(m);
}
</code></pre>
<pre><code>poly/relax/ntt-relax.hpp:
===============================================================================
   Name (baseline is *)   |   Dim   |  Total ms |  ns/op  |Baseline| Ops/second
===============================================================================
                 NTT 1E * |       1 |     0.000 |       0 |      - |        inf
                      INV |       1 |     0.001 |     700 |    inf |  1428571.4
                      DIV |       1 |     0.001 |    1200 |    inf |   833333.3
                      EXP |       1 |     0.001 |     800 |    inf |  1250000.0
                     SQRT |       1 |     0.001 |     800 |    inf |  1250000.0
                 NTT 1E * |       2 |     0.000 |      50 |      - | 20000000.0
                      INV |       2 |     0.002 |     800 | 16.000 |  1250000.0
                      DIV |       2 |     0.002 |    1100 | 22.000 |   909090.9
                      EXP |       2 |     0.003 |    1450 | 29.000 |   689655.2
                     SQRT |       2 |     0.001 |     600 | 12.000 |  1666666.7
                 NTT 1E * |      64 |     0.001 |      12 |      - | 80000000.0
                      INV |      64 |     0.006 |      95 |  7.625 | 10491803.3
                      DIV |      64 |     0.006 |      96 |  7.751 | 10320916.0
                      EXP |      64 |     0.006 |      96 |  7.751 | 10320916.0
                     SQRT |      64 |     0.007 |     104 |  8.375 |  9552238.8
                 NTT 1E * |     512 |     0.006 |      12 |      - | 81256943.3
                      INV |     512 |     0.252 |     492 | 39.995 |  2031689.6
                      DIV |     512 |     0.269 |     525 | 42.709 |  1902588.9
                      EXP |     512 |     0.270 |     526 | 42.820 |  1897645.7
                     SQRT |     512 |     0.268 |     524 | 42.598 |  1907550.8
                 NTT 1E * |    4096 |     0.063 |      15 |      - | 64706718.7
                      INV |    4096 |     2.111 |     515 | 33.354 |  1939982.7
                      DIV |    4096 |     2.183 |     533 | 34.492 |  1876006.8
                      EXP |    4096 |     2.182 |     532 | 34.466 |  1877382.5
                     SQRT |    4096 |     2.171 |     529 | 34.291 |  1886983.7
                 NTT 1E * |   16384 |     0.292 |      17 |      - | 56127080.7
                      INV |   16384 |     7.858 |     479 | 26.920 |  2084977.3
                      DIV |   16384 |     7.967 |     486 | 27.292 |  2056528.9
                      EXP |   16384 |     7.967 |     486 | 27.292 |  2056554.8
                     SQRT |   16384 |     7.962 |     485 | 27.276 |  2057742.9
                 NTT 1E * |   32768 |     0.624 |      19 |      - | 52536563.0
                      INV |   32768 |    17.008 |     519 | 27.269 |  1926603.2
                      DIV |   32768 |    17.039 |     519 | 27.319 |  1923097.9
                      EXP |   32768 |    17.195 |     524 | 27.568 |  1905694.7
                     SQRT |   32768 |    17.038 |     519 | 27.317 |  1923244.5
                 NTT 1E * |   65536 |     1.327 |      20 |      - | 49370327.9
                      INV |   65536 |    37.400 |     570 | 28.175 |  1752283.5
                      DIV |   65536 |    37.929 |     578 | 28.573 |  1727839.2
                      EXP |   65536 |    37.613 |     573 | 28.335 |  1742355.6
                     SQRT |   65536 |    37.618 |     574 | 28.339 |  1742128.6
                 NTT 1E * |  131072 |     2.817 |      21 |      - | 46529278.4
                      INV |  131072 |    84.430 |     644 | 29.972 |  1552425.7
                      DIV |  131072 |    84.527 |     644 | 30.006 |  1550658.8
                      EXP |  131072 |    83.274 |     635 | 29.562 |  1573978.6
                     SQRT |  131072 |    84.337 |     643 | 29.939 |  1554154.2
                 NTT 1E * |  262144 |     5.975 |      22 |      - | 43876659.8
                      INV |  262144 |   187.949 |     716 | 31.458 |  1394758.9
                      DIV |  262144 |   187.657 |     715 | 31.409 |  1396929.2
                      EXP |  262144 |   188.943 |     720 | 31.625 |  1387424.0
                     SQRT |  262144 |   187.847 |     716 | 31.441 |  1395517.7
                 NTT 1E * |  524288 |    13.243 |      25 |      - | 39591112.5
                      INV |  524288 |   415.140 |     791 | 31.349 |  1262919.0
                      DIV |  524288 |   415.426 |     792 | 31.370 |  1262049.5
                      EXP |  524288 |   417.068 |     795 | 31.494 |  1257080.6
                     SQRT |  524288 |   414.077 |     789 | 31.269 |  1266160.9
===============================================================================
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并查集"><a class="header" href="#并查集">并查集</a></h1>
<pre><code class="language-cpp">// @description 朴素并查集

struct DSU {
	V&lt;int&gt; fa;
	DSU(int n) : fa(n) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		fa[x] = y;
	}
};
</code></pre>
<h2 id="测试例题-19"><a class="header" href="#测试例题-19">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/unionfind">yosupo Unionfind</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="带权并查集"><a class="header" href="#带权并查集">带权并查集</a></h1>
<pre><code class="language-cpp">// @description 带权并查集

struct DSU {
	V&lt;int&gt; fa, sz;
	DSU(int n) : fa(n), sz(n, 1) {
		for (int i = 0; i &lt; n; i++)
			fa[i] = i;
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	bool same(int x, int y) {
		return find(x) == find(y);
	}
	int size(int x) {
		return sz[find(x)];
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		if (x == y)
			return;
		if (sz[x] &gt; sz[y])
			std::swap(x, y);
		sz[y] += sz[x], fa[x] = y;
		sz[x] = 0;
	}
};
</code></pre>
<h2 id="测试例题-20"><a class="header" href="#测试例题-20">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1536">P1536 村村通</a>（也不是不能用）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="st"><a class="header" href="#st">ST</a></h1>
<pre><code class="language-cpp">// @description 二维数组

template &lt;class T&gt;
struct VV {
	int x, y;
	V&lt;T&gt; m;
	VV(int a, int b, const T &amp;v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

// @description Sparse Table

template &lt;class T&gt;
struct SparseTable {
	int n, lgn;
	VV&lt;T&gt; v;
	SparseTable(int a) : n(a), lgn(1 + std::__lg(n)), v(lgn, n) {}
	void init(auto first, auto last) {
		copy(first, last, v[0]);
		for (int i = 1; i &lt; lgn; i++) {
			int ti = 1 &lt;&lt; (i - 1);
			for (int j = 0; j &lt;= n - 2 * ti; j++) {
				v[i][j] = max(v[i - 1][j], v[i - 1][j + ti]);
			}
		}
	}
	T query(int l, int r) const {
		int s = std::__lg(r - l + 1);
		return max(v[s][l], v[s][r - (1 &lt;&lt; s) + 1]);
	}
};
</code></pre>
<h2 id="测试例题-21"><a class="header" href="#测试例题-21">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3865">P3865 ST 表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="滑动窗口"><a class="header" href="#滑动窗口">滑动窗口</a></h1>
<pre><code class="language-cpp">// @description 滑动窗口

template &lt;class T&gt;
auto sliding(const V&lt;T&gt; &amp;v, int k) {
	int l = 0, r = -1, n = v.size();
	V&lt;int&gt; q(n), ret(n);
	for (int i = 0; i &lt; n; i++) {
		while (l &lt;= r &amp;&amp; i - k &gt;= q[l])
			l++;
		while (l &lt;= r &amp;&amp; v[i] &lt; v[q[r]])
			r--;
		q[++r] = i;
		ret[i] = q[l];
	}
	return ret;
}
</code></pre>
<h2 id="测试例题-22"><a class="header" href="#测试例题-22">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树状数组"><a class="header" href="#树状数组">树状数组</a></h1>
<pre><code class="language-cpp">// @description 树状数组

template &lt;class T&gt;
struct fwtree {
	int n;
	V&lt;T&gt; v;
	// 1 ~ N - 1
	fwtree(int a = 0) : n(a), v(n) {}
	void add(int i, T x) {
		for (; i &lt; n; i += i &amp; -i) {
			v[i] += x;
		}
	}
	void build(auto first, auto last) {
		std::copy(first, last, v.begin());
		for (int i = 1; i &lt; n; i++) {
			int j = i + (i &amp; -i);
			if (j &lt; n) {
				v[j] += v[i];
			}
		}
	}
	T sum(int i) const {
		assert(i &lt; n);
		T sum = T();
		for (; i &gt; 0; i -= i &amp; -i)
			sum += v[i];
		return sum;
	}
	T sum(int l, int r) const {
		assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt; n);
		return sum(r) - sum(l - 1);
	}
};
</code></pre>
<h2 id="测试例题-23"><a class="header" href="#测试例题-23">测试例题</a></h2>
<ul>
<li><a href="https://judge.yosupo.jp/problem/point_add_range_sum">yosupo Point Add Range Sum</a></li>
<li><a href="https://loj.ac/p/130">LOJ130 树状数组 1 ：单点修改，区间查询</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="堆"><a class="header" href="#堆">堆</a></h1>
<pre><code class="language-cpp">// @description 小根堆

template &lt;class T&gt;
struct Heap {
	V&lt;T&gt; v;
	Heap() : v(1) {}
	bool update(int p) {
		bool f = v[p] &lt; v[p / 2];
		if (f) {
			std::swap(v[p], v[p / 2]);
		}
		return !f;
	}
	T top() {
		return v[1];
	}
	void put(T x) {
		v.push_back(x);
		int p = v.size() - 1;
		while (p &gt; 1) {
			if (update(p))
				return;
			p /= 2;
		}
	}
	void pop() {
		v[1] = v.back();
		v.pop_back();
		int sz = v.size(), p = 2;
		while (p &lt; sz) {
			if (p + 1 &lt; sz &amp;&amp; v[p + 1] &lt; v[p])
				p++;
			if (update(p))
				return;
			p *= 2;
		}
	}
};
</code></pre>
<h2 id="测试例题-24"><a class="header" href="#测试例题-24">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3378">P3378 堆</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线段树"><a class="header" href="#线段树">线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树

template &lt;class Val&gt;
struct SegmentTree {
	const int N;
	V&lt;Val&gt; val;
	// 0 ~ N - 1
	SegmentTree(int n) : N(2 &lt;&lt; std::__lg(n)), val(N * 2) {
		assert(n &gt; 0);
	}
	void build(auto first, auto last) {
		std::copy(first, last, val.begin() + N);
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
	void modify(int i, Val x) {
		modify(i, x, 1, 0, N);
	}
	Val query(int l, int r) {
		return query(l, r + 1, 1, 0, N);
	}
#define lson p * 2
#define rson p * 2 + 1
  private:
	void pull(int p) {
		val[p] = val[lson] + val[rson];
	}
	void modify(int i, Val x, int p, int L, int R) {
		if (R - L == 1) {
			val[p] += x;
		} else {
			int M = (L + R) / 2;
			if (i &lt; M)
				modify(i, x, lson, L, M);
			if (i &gt;= M)
				modify(i, x, rson, M, R);
			pull(p);
		}
	}
	Val query(int l, int r, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			return val[p];
		} else {
			int M = (L + R) / 2;
			Val ret = Val();
			if (l &lt; M)
				ret = ret + query(l, r, lson, L, M);
			if (r &gt; M)
				ret = ret + query(l, r, rson, M, R);
			return ret;
		}
	}
#undef lson
#undef rson
};
</code></pre>
<h2 id="测试例题-25"><a class="header" href="#测试例题-25">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="懒标记线段树"><a class="header" href="#懒标记线段树">懒标记线段树</a></h1>
<pre><code class="language-cpp">// @description 线段树(懒标记)

template &lt;class Val, class Tag&gt;
struct LazySegmentTree {
	const int N;
	V&lt;Val&gt; val;
	V&lt;Tag&gt; tag;
	// 0 ~ N - 1
	LazySegmentTree(int n) : N(2 &lt;&lt; std::__lg(n)), val(N * 2), tag(N * 2) {
		assert(n &gt; 0);
	}
	void build(auto first, auto last) {
		std::copy(first, last, val.begin() + N);
		for (int i = N - 1; i &gt;= 1; i--)
			pull(i);
	}
	void modify(int l, int r, Tag t) {
		modify(l, r, t, 1, 0, N);
	}
	Val query(int l, int r) {
		return query(l, r, 1, 0, N);
	}
#define lson p * 2
#define rson p * 2 + 1
  private:
	void pull(int p) {
		val[p] = val[lson] + val[rson];
	}
	void push(int p) {
		Tag &amp;tp = tag[p];
		if (tp.flag) {
			val[lson].apply(tp), tag[lson].apply(tp);
			val[rson].apply(tp), tag[rson].apply(tp);
			tp.flag = false;
		}
	}
	void modify(int l, int r, Tag t, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			val[p].apply(t);
			tag[p].apply(t);
		} else {
			int M = (L + R) / 2;
			push(p);
			if (l &lt; M)
				modify(l, r, t, lson, L, M);
			if (r &gt; M)
				modify(l, r, t, rson, M, R);
			pull(p);
		}
	}
	Val query(int l, int r, int p, int L, int R) {
		if (l &lt;= L &amp;&amp; R &lt;= r) {
			return val[p];
		} else {
			int M = (L + R) / 2;
			Val ret = Val();
			push(p);
			if (l &lt; M)
				ret = ret + query(l, r, lson, L, M);
			if (r &gt; M)
				ret = ret + query(l, r, rson, M, R);
			return ret;
		}
	}
#undef lson
#undef rson
};
</code></pre>
<h2 id="测试例题-26"><a class="header" href="#测试例题-26">测试例题</a></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3372">P3372 线段树 1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算几何"><a class="header" href="#计算几何">计算几何</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="点"><a class="header" href="#点">点</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-多边形"><a class="header" href="#f-多边形">F 多边形</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}

using VP = V&lt;P&gt;;

template &lt;class RET&gt;
RET ring_act(const auto &amp;v, auto &amp;&amp;func) {
	RET ret{};
	for (int i = 0; i &lt; v.size() - 1; i++)
		ret += func(v[i], v[i + 1]);
	if (v.size() &gt;= 2)
		ret += func(v.back(), v.front());
	return ret;
}

D area(const VP &amp;v) {
	return ring_act&lt;D&gt;(v, crs) / 2;
}

// 必须排序且去重！
VP convex_down(const VP &amp;ps) {
	assert(ps.size() &gt;= 2);
	VP dw;
	for (P d : ps) {
		for (int n = dw.size(); n &gt; 1; n--, dw.pop_back()) {
			if (ccw(dw[n - 2], dw[n - 1], d) == 1)
				break;
		}
		dw.push_back(d);
	}
	return dw;
}

VP convex(VP ps) {
	std::sort(ps.begin(), ps.end());
	ps.erase(std::unique(ps.begin(), ps.end()), ps.end());
	if (ps.size() &lt;= 1)
		return ps;
	VP dw = convex_down(ps);
	std::reverse(ps.begin(), ps.end());
	VP up = convex_down(ps);
	dw.insert(dw.begin(), up.begin() + 1, up.end() - 1);
	return dw;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-冲突判定"><a class="header" href="#f-冲突判定">F 冲突判定</a></h1>
<pre><code class="language-cpp">using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const D &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const D &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &amp;l, const P &amp;r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return cmp(l, r) &lt; 0;
}

bool operator==(const P &amp;l, const P &amp;r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) &lt;= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr &lt; 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) &lt; 0)
		return 2;
	if (dot(-b, c - b) &lt; 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}

P proj(const L &amp;l, const P &amp;p) {
	P v = l.vec();
	return l.s + v * dot(v, p - l.s) / v.norm();
}

bool insSL(const L &amp;s, const L &amp;l) {
	int a = ccw(l, s.s), b = ccw(l, s.t);
	return (a % 2 == 0 || b % 2 == 0 || a != b);
}

bool insSS(const L &amp;s, const L &amp;t) {
	int a = ccw(s, t.s), b = ccw(s, t.t);
	int c = ccw(t, s.s), d = ccw(t, s.t);
	return a * b &lt;= 0 &amp;&amp; c * d &lt;= 0;
}

D distLP(const L &amp;l, const P &amp;p) {
	return std::abs(crs(l.vec(), p - l.s)) / l.abs();
}

D distSP(const L &amp;s, const P &amp;p) {
	P q = proj(s, p);
	if (ccw(s, q) == 0)
		return (p - q).abs();
	else
		return std::min((s.s - p).abs(), (s.t - p).abs());
}

D distSS(const L &amp;s, const L &amp;t) {
	if (insSS(s, t))
		return 0;
	return std::min({
		distSP(s, t.s),
		distSP(s, t.t),
		distSP(t, s.s),
		distSP(t, s.t),
	});
}

int crossLL(const L &amp;l, const L &amp;m, P &amp;r) {
	P lv = l.vec(), mv = m.vec();
	D cr1 = crs(lv, mv), cr2 = crs(lv, l.t - m.s);
	if (sgn_crs(lv, mv) == 0) {
		r = l.s;
		if (sgn_crs(lv, l.t - m.s))
			return 0;
		return -1;
	}
	r = m.s + mv * cr2 / cr1;
	return 1;
}

int crossSS(L l, L m, P &amp;r) {
	int u = crossLL(l, m, r);
	if (u == 0)
		return 0;
	if (u == -1) {
		r = std::max(std::min(l.s, l.t), std::min(m.s, m.t));
		P q = std::min(std::max(l.s, l.t), std::max(m.s, m.t));
		return (q &lt; r) ? 0 : (q == r ? 1 : -1);
	}
	if (ccw(l, r) == 0 &amp;&amp; ccw(m, r) == 0)
		return 1;
	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-点--线段"><a class="header" href="#i-点--线段">I 点 &amp; 线段</a></h1>
<pre><code class="language-cpp">// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &amp;l, const V &amp;r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	ll x{}, y{};
	P &amp;operator+=(const P &amp;o) {
		return x += o.x, y += o.y, T;
	}
	P &amp;operator-=(const P &amp;o) {
		return x -= o.x, y -= o.y, T;
	}
	P &amp;operator*=(const ll &amp;k) {
		return x *= k, y *= k, T;
	}
	P &amp;operator/=(const ll &amp;k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return P{-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, ll, *);
	OPERATOR(P, ll, /);
	ll norm() const {
		return x * x + y * y;
	}
	double abs() const {
		return std::sqrt(norm());
	}
#undef T
};

bool operator&lt;(const P &amp;l, const P &amp;r) {
	return std::tie(l.x, l.y) &lt; std::tie(r.x, r.y);
}

inline bool operator==(const P &amp;l, const P &amp;r) {
	return l.x == r.x &amp;&amp; l.y == r.y;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const P &amp;p) {
	return os &lt;&lt; &quot;P(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}

struct L {
	ll A, B, C;
	void reduce() {
		ll g = std::gcd(std::abs(A), std::abs(B));
		g = std::gcd(g, std::abs(C));
		A /= g, B /= g, C /= g;
		if (A &lt; 0 || (A == 0 &amp;&amp; B &lt; 0)) {
			A = -A, B = -B, C = -C;
		}
	}
	ll eval(const P &amp;p) const {
		return A * p.x + B * p.y + C;
	}
	bool on(const P &amp;p) const {
		return eval(p) == 0;
	}
	static std::optional&lt;L&gt; from(P a, P d) {
		if (d == P{0, 0})
			return std::nullopt;
		L r = {d.y, -d.x, d.x * a.y - d.y * a.x};
		r.reduce();
		return r;
	}
	static std::optional&lt;L&gt; p2(P a, P b) {
		return from(a, b - a);
	}
	static std::optional&lt;L&gt; mid(P a, P b) {
		auto [dx, dy] = b - a;
		return from((a + b) / 2, {dy, -dx});
	}
};

bool operator&lt;(const L &amp;l, const L &amp;r) {
	return std::tie(l.A, l.B, l.C) &lt; std::tie(r.A, r.B, r.C);
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const L &amp;l) {
	return os &lt;&lt; &quot;L(&quot; &lt;&lt; l.A &lt;&lt; &quot;, &quot; &lt;&lt; l.B &lt;&lt; &quot;, &quot; &lt;&lt; l.C &lt;&lt; &quot;)&quot;;
}

struct S {
	P s, t;
	S(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	double abs() const {
		return vec().abs();
	}
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
