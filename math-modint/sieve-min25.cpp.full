const int P = 998244353;

// @description 快速幂(i32, P)

int qpow(int a, int b = P - 2, int m = P) {
	int ret = 1 % m;
	for (; b > 0; b /= 2) {
		if (b % 2 == 1)
			ret = 1ll * ret * a % m;
		a = 1ll * a * a % m;
	}
	return ret;
}

// @description 取模整数

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &l, const V &r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct Z {
	int v;
	Z(ll a = 0) : v((a % P + P) % P) {}
	Z &operator=(const int &m) {
		v = m;
		return *this;
	}
	Z &operator+=(const Z &m) {
		v = (v += m.v) >= P ? v - P : v;
		return *this;
	}
	Z &operator-=(const Z &m) {
		v = (v -= m.v) < 0 ? v + P : v;
		return *this;
	}
	Z &operator*=(const Z &m) {
		v = 1ll * v * m.v % P;
		return *this;
	}
	OPERATOR(Z, Z, +);
	OPERATOR(Z, Z, -);
	OPERATOR(Z, Z, *);
	Z pow(int n) const {
		return qpow(v, n);
	}
	Z inv() const {
		return pow(P - 2);
	}
	// useless
	Z operator-() const {
		return v == 0 ? 0 : P - v;
	}
	Z &operator/=(const Z &m) {
		return *this *= m.inv();
	}
	OPERATOR(Z, Z, /);
	auto approx(int A = 1E3) {
		int x = v, y = P, a = 1, b = 0;
		while (x > A) {
			std::swap(x, y), std::swap(a, b);
			a -= x / y * b, x %= y;
		}
		return std::make_pair(x, a);
	}
};

std::istream &operator>>(std::istream &is, Z &z) {
	return is >> z.v;
}

std::ostream &operator<<(std::ostream &os, const Z &z) {
	return os << z.v;
}

std::vector<bool> not_p;
std::vector<int> primes;
void Euler(int n) {
	not_p.resize(n);
	for (int i = 2; i < n; i++) {
		if (not not_p[i])
			primes.push_back(i);
		for (int pj : primes) {
			if (pj > (n - 1) / i)
				break;
			not_p[i * pj] = true;
			if (i % pj == 0)
				break;
		}
	}
}

struct Min25 {
	ll n, sn, m = 0;
	std::vector<bool> not_p;
	std::vector<int> pri;
	std::vector<Z> sum;
	Z fp(int p, int k) {
		Z pk = Z(p).pow(k);
		return pk * (pk - 1);
	}
	int id(ll x) {
		return x <= sn ? x : m - (n / x) + 1;
	}
	Min25(ll u) : n(u), sn(sqrt(n) + 1), not_p(sn + 1), sum(sn * 2 + 5) {
		std::vector<Z> s2(sn * 2 + 5), s1(sn * 2 + 5);
		std::vector<ll> w(sn * 2 + 5);
		for (ll l = 1, r; l <= n; l = r + 1) {
			w[++m] = r = n / (n / l);
			Z mr = r % P;
			s1[m] = mr * (mr + 1) / 2 - 1;
			s2[m] = mr * (mr + 1) * (2 * mr + 1) / 6 - 1;
		}
		pri = primes, pri.insert(pri.begin(), 0);
		for (int i = 1, pi = pri[i]; pi <= sn; pi = pri[++i]) {
			for (int j = m; pi <= w[j] / pi; j--) {
				s1[j] -= pi * (s1[id(w[j] / pi)] - s1[pri[i - 1]]);
				s2[j] -= Z(pi) * pi * (s2[id(w[j] / pi)] - s2[pri[i - 1]]);
			}
		}
		for (int i = 2; i <= m; i++) {
			sum[i] = s2[i] - s1[i];
		}
	}
	Z eval() {
		return F(n, 0) + 1;
	}
	Z F(ll u, int k) {
		if (u <= pri[k])
			return 0;
		Z ret = sum[id(u)] - sum[pri[k]];
		for (int i = k + 1; i < pri.size() && 1ll * pri[i] * pri[i] <= u; i++) {
			ll pi = pri[i], pc = pi;
			for (int c = 1; pc * pi <= u; c++, pc *= pi)
				ret += fp(pi, c) * F(u / pc, i) + fp(pi, c + 1);
		}
		return ret;
	}
};