\documentclass{probook}

\usepackage{multicol}

\geometry{
  paperwidth=290mm,
  paperheight=210mm,
  margin=20mm,
  left=15mm,
  right=15mm,
}

\title{ACM 模板}
\author{\href{https://github.com/rogeryoungh}{rogeryoungh}}

\begin{document}
\newcommand\mfrac[2]{\dfrac{#1\smash[b]{\strut}}{#2\smash[t]{\strut}}}
\newcommand\ee{\mathrm{e}}
\newcommand\dd{\mathrm{d}}
\newcommand\uppi{\mathrm{\pi}}

\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\DFT}{\operatorname{DFT}_{\omega_n}}
\newcommand{\Id}{\operatorname{Id}}

\maketitle

\frontmatter

\columnseprule=2pt
\setlength{\columnsep}{30pt}
\begin{multicols}{2}

\tableofcontents

\mainmatter






\chapter{上号}

尝试使用 C++ 17 的新特性。

\section{头文件}

\lstinputlisting[style=cpp,caption=/上号/头文件.hpp]{上号/头文件.hpp}

\section{进制转换}

\lstinputlisting[style=cpp,caption=/上号/进制转换.cpp]{上号/进制转换.cpp}

\section{常见技巧}

向上取整 $p/q$ 为 \lstinline{(p-1)/q+1} 。

预计算 $\log_n$，只需 \lstinline{_fora(i, n, MN) logn[i] = logn[i/n] + 1;}。

字典序 \lstinline{strcmp(x,y) < 0}。

大根堆（优先队列）：\lstinline{priority_queue<pii, vector<pii>, greater<pii>>}。

\section{二分查找}

\paragraph*{STL 二分}

在 $[l,r)$ 查找 $\geqslant v$ 中最前的一个，找不到则返回 $r$ 。支持 cmp 函数。

\begin{lstlisting}[style=cpp]
T* lower_bound(T* l, T* r, const T& v, Comp cmp);
\end{lstlisting}

在 $[l,r)$ 查找 $> value$ 中最前的一个，找不到则返回 $r$ 。支持 cmp 函数。

\begin{lstlisting}[style=cpp]
T* upper_bound(T* l, T* r, const T& v, Comp cmp);
\end{lstlisting}

\paragraph*{手写二分}

在 \lstinline{true -> false} 的开区间 $[l, r)$ 中，找到最后一个 \lstinline{true}。

\lstinputlisting[style=cpp,caption=/上号/二分/01.cpp]{上号/二分/01.cpp}

在 \lstinline{false -> true} 的开区间 $[l, r)$ 中，找到第一个 \lstinline{true}。

\lstinputlisting[style=cpp,caption=/上号/二分/02.cpp]{上号/二分/02.cpp}

对于上凸（$\wedge$ 形）函数，可以使用三分法来查找最大值。对于下凸（$\vee$ 形）变号即可

\lstinputlisting[style=cpp,caption=/上号/三分法.cpp]{上号/三分法.cpp}

\section{二维数组}

基于 \lstinline{vector} 的二维数组。

\lstinputlisting[style=cpp,caption=/上号/二维数组.cpp]{上号/二维数组.cpp}

\section{矩阵乘法}

构建一个 $p$ 行 $q$ 列的矩阵。

\lstinputlisting[style=cpp,caption=/上号/矩阵乘法.cpp]{上号/矩阵乘法.cpp}

矩阵的输入、输出。

\begin{lstlisting}[style=cpp]
template <class T>
istream &operator>>(istream &is, VV<T> &m) {
	for (int i = 0; i < m.x * m.y; i++)
		is >> m.m[i];
	return is;
}

template <class T>
ostream &operator<<(ostream &os, const VV<T> &m) {
	for (int i = 0; i < m.x * m.y; i++)
		os << m.m[i] << " \n"[(i + 1) % m.y == 0];
	return os;
}
\end{lstlisting}

\section{快速幂}

\lstinputlisting[style=cpp,caption=/上号/快速幂.cpp]{上号/快速幂.cpp}

\lstinputlisting[style=cpp,caption=/上号/矩阵快速幂.cpp]{上号/矩阵快速幂.cpp}

\section{快速排序}

\lstinputlisting[style=cpp,caption=/上号/快速排序.cpp]{上号/快速排序.cpp}

\section{\texorpdfstring{第 $k$ 大数}{第 k 大数}}

\lstinputlisting[style=cpp,caption=/上号/第 k 大数.cpp]{上号/第k大数.cpp}

\section{归并排序求逆序对}

\lstinputlisting[style=cpp,caption=/上号/逆序对.cpp]{上号/逆序对.cpp}

\section{取模整数}

\lstinputlisting[style=cpp,caption=/上号/modint.cpp]{上号/modint.cpp}







\chapter{数学}

\section{GCD \& LCM \& EXGCD}

\paragraph{GCD \& LCM} 自 CPP17 之后，头文件 numeric 中已经实现了二进制

\lstinputlisting[style=cpp,caption=/数学/gcdlcm.cpp]{数学/gcdlcm.cpp}

对于方程 
\[ax+by=\gcd(a,b)\]
可通过 $\rm exgcd$ 求出一个整数解。

\lstinputlisting[style=cpp,caption=/数学/exgcd.cpp]{数学/exgcd.cpp}

方程 $ax+by=c$ 有解的充要条件是 $\gcd(a,b) \mid c$。

\section{乘法逆元}

方程 $ax \equiv 1 \pmod p$ 有解的充要条件是 $\gcd(a,p) = 1$。

容易想到它与方程 $ax + py = c$ 等价，于是可以利用 $\rm exgcd$ 求最小正解。

\lstinputlisting[style=cpp,caption=/数学/逆元/exgcd法.cpp]{数学/逆元/exgcd法.cpp}

仅当 $p$ 为质数时，由 Fermat 小定理知 $x \equiv a^{p-2} \pmod p$。

\lstinputlisting[style=cpp,caption=/数学/逆元/快速幂法.cpp]{数学/逆元/快速幂法.cpp}

\section{筛法}

\paragraph{Eratosthenes 筛}

复杂度 $O(n\log \log n)$。

\lstinputlisting[style=cpp,caption=/数学/筛法/Eratosthenes.cpp]{数学/筛法/Eratosthenes.cpp}

\paragraph{Euler 筛（LPF）}

复杂度 $O(n)$，每个合数只会被筛一次。

\lstinputlisting[style=cpp,caption=/数学/筛法/Euler.cpp]{数学/筛法/Euler.cpp}

\paragraph{Euler 筛 + MobiusMu + EulerPhi}

由于 Euler 筛过程中会把每一个数拆分成两个互质的因数，因此可以用来预处理积性函数和加性函数。如 Euler 筛 + $\mu(m)$ + $\varphi(m)$，复杂度 $O(n)$。

\lstinputlisting[style=cpp,caption=/数学/筛法/Sieve.cpp]{数学/筛法/Sieve.cpp}

\paragraph{杜教筛}

当卷积可以求和时可以拆杜教筛。

\lstinputlisting[style=cpp,caption=/数学/筛法/Sieve.cpp]{数学/筛法/du.cpp}

\paragraph{Min25 筛}

当函数可以拆多项式时。

\lstinputlisting[style=cpp,caption=/数学/筛法/min25.cpp]{数学/筛法/min25.cpp}

\paragraph{PN 筛}

PN 的个数只有 $O(\sqrt n)$。

\lstinputlisting[style=cpp,caption=/数学/筛法/pn.cpp]{数学/筛法/pn.cpp}

\section{素性测试 \& 质因分解}

\subsection{试除法}

\lstinputlisting[style=cpp,caption=/数学/试除法.cpp]{数学/试除法.cpp}

\subsection{Miller Rabbin}

\lstinputlisting[style=cpp,caption=/数学/MillerRabbin.cpp]{数学/MillerRabbin.cpp}

\subsection{Pollard Rho}

\lstinputlisting[style=cpp,caption=/数学/PollardRho.cpp]{数学/PollardRho.cpp}

\subsection{排列组合}

\subsection{Lucas 定理}

当 $n,m$ 很大而 $p$ 较小的时候，有
\[  
\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p 
\]

\lstinputlisting[style=cpp,caption=/数学/Lucas.cpp]{数学/Lucas.cpp}

\section{约瑟夫 Josephus 问题}

对 $n$ 个人进行标号 $0,\cdots,n-1$，顺时针站一圈。从 $0$ 号开始，每一次从当前的人继续顺时针数 $k$ 个，然后让这个人出局，如此反复。

设最后剩下的人的编号为 $J(n,k)$，有递推式
\[J(n+1,k) = (J(n,k)+k) \bmod (n+1)\]
踢出第一个人 $k$ 后，即转化为 $J(n,k)$ 的情景，还原编号只需增加相对位移 $k$。

\lstinputlisting[style=cpp,caption=/数学/Josephus.cpp]{数学/Josephus.cpp}

\section{同余}

\paragraph{中国剩余定理}
若 $n_i$ 中任意两个互质，求方程组的解
\[ x \equiv a_i \pmod {n_i} , \quad i \in \{ 1,2,\cdots,k \} \]

\lstinputlisting[style=cpp,caption=/数学/China.cpp]{数学/China.cpp}

\paragraph{扩展中国剩余定理}
若 $n_i$ 中不互质，需要 excrt
\lstinputlisting[style=cpp,caption=/数学/excrt.cpp]{数学/excrt.cpp}

\paragraph{二次剩余} 求 $x^2 \equiv n$，可以使用 Cipolla 算法。
\lstinputlisting[style=cpp,caption=/数学/Cipolla.cpp]{数学/Cipolla.cpp}


\section{整除分块}
令 $A = \{ \lfloor n/d \rfloor \mid 1 \leqslant d \leqslant n \}$，则 $|A| \leqslant 2\sqrt{n}$，即整除求和时可以做到 $\sqrt{n}$ 的速度。

\lstinputlisting[style=cpp,caption=/数学/整除分块/01.cpp]{数学/整除分块/01.cpp}

假如求和的是 $\sum\limits_{i=1}^{\min(n,m)} \left\lfloor \frac{n}{i} \right\rfloor\left\lfloor \frac{m}{i} \right\rfloor$，则可以用二维分块的技巧


\lstinputlisting[style=cpp,caption=/数学/整除分块/02.cpp]{数学/整除分块/02.cpp}

\section{博弈}

下面都是石子游戏，轮流取走物品。方便起见，称场上 $n$ 堆石子 $a_1,\cdots,a_n$ 为局势。先手必输的局势称为奇异局势

\subsection{Nim 博弈}

有 $n$ 堆分别有 $a_i$ 个物品，两人轮流取走任意一堆的任意个物品，不能不取，最后取光者获胜。奇异局势判定
\[a_1 \oplus \cdots \oplus a_n =0\]

\subsection{Wythoff 博奕}

两堆分别有 $a,b$ 各物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，不可不取，最后取光者获胜。

\lstinputlisting[style=cpp,caption=/数学/博弈/Wythoff.cpp]{数学/博弈/Wythoff.cpp}

特点：所有自然数都出现在奇异局势中，不重不漏。

\section{多项式 NTT}

多项式好难。

\subsection{核心}

\lstinputlisting[style=cpp,caption=/数学/NTT/core.cpp]{数学/NTT/core.cpp}

\subsection{形式幂级数}

\lstinputlisting[style=cpp,caption=/数学/NTT/poly.cpp]{数学/NTT/poly.cpp}

\subsection{牛顿迭代}

给定多项式 $f$，考虑求 $A(g) = 0$。假若我们已经求得 $g_0 = g \bmod x^n$，那么在 $A(g)$ 处做泰勒展开
\[ 0 \equiv A(g) \equiv A(g_0) + A'(g_0) \ast (g - g_0) \pmod{x^{2n}} \]
因此
\[ g \equiv g_0 - \frac{A(g_0)}{\frac{\partial A}{\partial g}(g_0)} \pmod{x^{2n}} \]
令 $A(g) = f \ast g$ 可以求 inv，令 $A(g) = f \ast g - h$ 可以求 div，令 $A(g) = \ln g - f$ 可以求 exp。

\lstinputlisting[style=cpp,caption=/数学/NTT/impl.cpp]{数学/NTT/impl.cpp}

\subsection{多项式平移}

\lstinputlisting[style=cpp,caption=/数学/NTT/taylor-shift.cpp]{数学/NTT/taylor-shift.cpp}

\subsection{Chirp Z 变换}

\lstinputlisting[style=cpp,caption=/数学/NTT/chirpz.cpp]{数学/NTT/chirpz.cpp}

\subsection{三模 NTT}

\lstinputlisting[style=cpp,caption=/数学/NTT/mod3.cpp]{数学/NTT/mod3.cpp}

\subsection{在线卷积}

当 $f$ 已经给出时，若要逐点的计算 $f \ast g$，可以使用半在线卷积算法。

\lstinputlisting[style=cpp,caption=/数学/NTT/semi.cpp]{数学/NTT/semi.cpp}

当 $f$ 和 $g$ 都未给出时，可以使用全在线卷积。

\lstinputlisting[style=cpp,caption=/数学/NTT/relax.cpp]{数学/NTT/relax.cpp}

\subsection{多点求值 ・ 快速插值}

\lstinputlisting[style=cpp,caption=/数学/NTT/eval.cpp]{数学/NTT/eval.cpp}

\subsection{Berlekamp–Massey}

\lstinputlisting[style=cpp,caption=/数学/NTT/bm.cpp]{数学/NTT/bm.cpp}

\subsection{FFT}

\lstinputlisting[style=cpp,caption=/数学/FFT/core.cpp]{数学/FFT/core.cpp}

\section{线性代数}

高斯消元。

\lstinputlisting[style=cpp,caption=/数学/gauss.cpp]{数学/gauss.cpp}

拉格朗日插值。

\lstinputlisting[style=cpp,caption=/数学/interpolation-lagrange.cpp]{数学/interpolation-lagrange.cpp}

线性基。

\lstinputlisting[style=cpp,caption=/数学/basis.cpp]{数学/basis.cpp}



\section{数学常数}

\subsection{幂塔}

\lstinputlisting[style=cpp,caption=/数学/常数/tetration-mod.cpp]{数学/常数/tetration-mod.cpp}

\subsection{斯特林数}

\lstinputlisting[style=cpp,caption=/数学/常数/stirling.cpp]{数学/常数/stirling.cpp}

\subsection{幂表}

\lstinputlisting[style=cpp,caption=/数学/常数/powers.cpp]{数学/常数/powers.cpp}





\chapter{图论}

\section{链式前项星}

现在更常用 \lstinline{vector<int>}，很方便快捷。

\lstinputlisting[style=cpp,caption=/图论/链式前项星.cpp]{图论/链式前项星.cpp}

\section{最短路}

\subsection{Dijkstra}

权值必须是非负，复杂度 $O(E\log E)$。

\lstinputlisting[style=cpp,caption=/图论/最短路/Dijkstra.cpp]{图论/最短路/Dijkstra.cpp}

\subsection{Bellman-Ford}

复杂度 $O(VE)$。

\lstinputlisting[style=cpp,caption=/图论/最短路/Bellman-Ford.cpp]{图论/最短路/Bellman-Ford.cpp}

\subsection{Floyd}

起始条件 $f(i,j)={\rm edge}(i,j)$，$f(i,i)=0$。

\lstinputlisting[style=cpp,caption=/图论/最短路/Floyd.cpp]{图论/最短路/Floyd.cpp}

\section{最近公共祖先 LCA}

\lstinputlisting[style=cpp,caption=图论/LCA.cpp]{图论/LCA.cpp}

\section{树链剖分}

\lstinputlisting[style=cpp,caption=图论/树链剖分.cpp]{图论/树链剖分.cpp}

\section{Tarjan}

\lstinputlisting[style=cpp,caption=图论/Tarjan.cpp]{图论/Tarjan.cpp}







\chapter{动态规划}

\section{背包}

\subsection{01 背包}

给定体积为 $v_i$，价值 $w_i$ 的 $N$ 个物品，背包容积为 $M$，每个物品只能取 $1$ 个，求最大价值。

\lstinputlisting[style=cpp,caption=/动态规划/01背包.cpp]{动态规划/01背包.cpp}

\subsection{完全背包}

给定体积为 $v_i$，价值 $w_i$ 的 $n$ 个物品，背包容积为 $v$，每个物品任意取，求最大价值。

\lstinputlisting[style=cpp,caption=/动态规划/完全背包.cpp]{动态规划/完全背包.cpp}

\subsection{多重背包}

给定体积为 $v_i$，价值 $w_i$ 的 $N$ 个物品，背包容积为 $M$，每个物品有 $c_i$ 个，求最大价值。

如各种背包组合（如洛谷 P1833 樱花），通常把完全背包转为 $99999$ 个（适当调节）多重背包，再按 01 背包来。

\lstinputlisting[style=cpp,caption=/动态规划/多重背包.cpp]{动态规划/多重背包.cpp}

\section{最长公共上升序列}

给出 $1,2,\ldots,n$ 的两个排列 $a$ 和 $b$ ，求它们的最长公共子序列。

\lstinputlisting[style=cpp,caption=/动态规划/最长公共上升序列.cpp]{动态规划/最长公共上升序列.cpp}

\section{数字计数}

试计算在区间 $1$ 到 $n$ 的所有整数中，数码 $x(0 \leqslant x \leqslant 9)$ 共出现了多少次？

\lstinputlisting[style=cpp,caption=/动态规划/数字计数/01.cpp]{动态规划/数字计数/01.cpp}

试计算在区间 $1$ 到 $n$ 的所有整数中，出现数码 $x(0 \leqslant x \leqslant 9)$ 的数字有多少？

\lstinputlisting[style=cpp,caption=/动态规划/数字计数/02.cpp]{动态规划/数字计数/02.cpp}







\chapter{数据结构}

\section{链表}

\lstinputlisting[style=cpp,caption=/数据结构/链表.cpp]{数据结构/链表.cpp}

链表的遍历。

\begin{lstlisting}[style=cpp]
for(Node *p=l->head->next; p!=l->tail; p=p->next)
	//正序遍历
for(Node *p=l->tail->prev; p!=l->head; p=p->prev)
	//逆序遍历
\end{lstlisting}

\section{滑动窗口}

\lstinputlisting[style=cpp,caption=/数据结构/滑动窗口.cpp]{数据结构/滑动窗口.cpp}

\section{并查集}

\lstinputlisting[style=cpp,caption=/数据结构/并查集.cpp]{数据结构/并查集.cpp}

\section{树状数组}

树状数组可以维护数组 $a$ 实现：1. 将某个数加上 $x$。2. 前缀和。

\lstinputlisting[style=cpp,caption=/数据结构/树状数组/01.cpp]{数据结构/树状数组/01.cpp}

\paragraph{区间加 \& 区间求和}

维护数组 $a$ 的额外差分数组 $b$，当我们对 $a$ 的前缀 $r$ 求和时有
\[ \sum_{i=1}^r \sum_{j=1}^i b_j = \sum_{i=1}^rb_i(r-i+1) = (r+1)\sum_{i=1}^rb_i - \sum_{i=1}^rb_ii \]
因此还需要两个树状数组来维护 $\sum b_i$ 和 $\sum b_ii$。

\lstinputlisting[style=cpp,caption=/数据结构/树状数组/02.cpp]{数据结构/树状数组/02.cpp}

\section{ST 表}

因为 \lstinline{std::__lg(n)}，不需要预处理 $\log_2$。令 $st(i,j)$ 表示区间 $[i,i+2^j-1]$ 的最大值，显然 $ST(i,0)=a_i$。状态转移方程
\[ ST(i,j+1) = \max(f(i,j) , f(i+2^{j},j)) \]
对于 RMQ 问题，记 $s = \lfloor\log_2(r-l+1)\rfloor$，我们总是可以用两个区间 $[l,l+2^s-1]$ 和 $[r-2^s+1,r]$ 来覆盖所查询区间。

\lstinputlisting[style=cpp,caption=/数据结构/ST表/01.cpp]{数据结构/ST表/01.cpp}

\section{线段树}

单点修改，区间查询。

\lstinputlisting[style=cpp,caption=/数据结构/线段树/01.cpp]{数据结构/线段树/01.cpp}

区间修改，区间查询。

\lstinputlisting[style=cpp,caption=/数据结构/线段树/02.cpp]{数据结构/线段树/02.cpp}







\chapter{字符串}

\section{KMP}

\paragraph{前缀函数}

对于长为 $n$ 的字符串 $s$，定义每个位置的前缀函数 $\pi(i)$，值为 $s(0,i)$ 的真后缀与 $s$ 的真前缀中相等的最长的长度。

设最长的长度为 $j_1=\pi(i)$，如何找到其次长 $j_2$？

注意到后缀 $j_1$ 位与前缀 $j_1$ 位完全相同，故 $j_2$ 为前缀 $j_1$ 中相等真前缀与真后缀中最长的，即
\[j_{n+1} = \pi(j_n-1)\]

\lstinputlisting[style=cpp,caption=/字符串/KMP/01.cpp]{字符串/KMP/01.cpp}

\paragraph{Knuth - Morris - Pratt}

给定一个文本 $t$ 和一个字符串 $s$ （模式串），尝试找到 $s$ 在 $t$ 中所有出现。

构造字符串 $s+*+t$，其中 $*$ 为不出现在两个字符串中的特殊字符，此时字符串 $t$ 的前缀恰为 $s$，$\pi(i)$ 的意义为 $s$ 在此处的出现长度。

当 $\pi(i)=|s|$ 时，$s$ 在此处完全出现。

当字符串已经合并时，直接计算 $\pi(i)$ 函数即可，字符串出现位置是 $i-2|s|$。

\lstinputlisting[style=cpp,caption=/字符串/KMP/02.cpp]{字符串/KMP/02.cpp}

\paragraph{EXKMP}

对于长为 $n$ 的字符串 $s$，定义每个位置的后缀函数 $z(i)$，值为 $s(i,n-1)$ 的真前缀与 $s$ 真前缀中相等的最长的长度。

\lstinputlisting[style=cpp,caption=/字符串/KMP/03.cpp]{字符串/KMP/03.cpp}

\section{Manacher}

\lstinputlisting[style=cpp,caption=/字符串/manacher/01.cpp]{字符串/manacher/01.cpp}

\section{后缀数组}

\lstinputlisting[style=cpp,caption=/字符串/SA.cpp]{字符串/SA.cpp}



\end{multicols}

\end{document}
