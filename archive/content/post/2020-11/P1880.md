---
author: "rogeryoungh"
title: "P1880 石子合并"
date: "2020-11-30"
katex: true
showtoc: true
tags: 
  - "洛谷"
  - "DP"
---

## 题目大意

环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。

求最终分数的最小值和最大值。

## 分析

考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为

{{< display-math >}}
dp(i,j) = \max_{i \leqslant k \leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j))
{{< /display-math >}}

其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。

然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。

细节：前缀和、循环开两倍。

```cpp
int dmax[205][205], dmin[205][205];
int f[205], s[205];

int main() {
    int n = rr();
    _fora (i, 1, n)
        f[i + n] = f[i] = rr();
    _fora (i, 1, n * 2)
        s[i] = s[i - 1] + f[i];
    _fora (len, 2, n) {
        _fora (i, 1, 2 * n - len + 1) {
            int j = i + len - 1;
            int mmax = 0, mmin = 0x3f3f3f3f;
            int ss = s[j] - s[i - 1];
            _fora (k, i, j - 1) {
                mmax = max(mmax, dmax[i][k] + dmax[k + 1][j] + ss);
                mmin = min(mmin, dmin[i][k] + dmin[k + 1][j] + ss);
            }
            dmax[i][j] = mmax;
            dmin[i][j] = mmin;
        }
    }
    int rst = 0x3f3f3f3f;
    _fora (p, 0, n - 1)
        rst = min(rst, dmin[p + 1][p + n]);
    printf("%d\n", rst);
    rst = 0;
    _fora (p, 0, n - 1)
        rst = max(rst, dmax[p + 1][p + n]);
    printf("%d\n", rst);
    return 0;
}
```