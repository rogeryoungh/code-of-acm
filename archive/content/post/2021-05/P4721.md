---
author: "rogeryoungh"
title: "P4721 分治 FFT"
date: "2021-05-24"
katex: true
showtoc: true
tags: 
  - "洛谷"
  - "多项式"
---

## 题目大意

给定 $g[1], \cdots, g[m]$，求序列 $f$。

{{< display-math >}}
f [n] = \sum_{j = 1}^n f [n - j] g [j] = \sum_{j = 1}^n f [n - j] h [j]
{{< /display-math >}}

## 分析

不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程

{{< display-math >}}
f [n] = \sum_{j = 1}^n f [n - j] g [j] = \sum_{j = 1}^n f [n - j] h [j]
{{< /display-math >}}

这个形式看似卷积，但实际上它缺了一项。对 $n > 0$ 凑卷积

{{< display-math >}}
f [n] (h [0] + 1) = \sum_{j = 0}^n f [n - j] h [j] = (f \ast h) [n]
{{< /display-math >}}

又 $f [0] = 1$，有

{{< display-math >}}
f \ast (1 + h [0]) - f \ast h = f [0] (1 + h [0]) - f [0] h [0] = f [0]
{{< /display-math >}}

解得

{{< display-math >}}
f (x) = \frac{f [0]}{1 + h [0] - h (x)} = \frac{1}{1 - g (x)}
{{< /display-math >}}

于是求逆即可

```cpp
poly_t ff, ans;

int main() {
    ll n = rr() - 1;
    for (int i = 1; i <= n; i++)
        ff[i] = -rr();
    ff[0] = 1;
    int lim = 1;
    while (lim <= n)
        lim <<= 1;
    poly::poly_inv(ff, ans, lim);
    for (int i = 0; i <= n; i++)
        printf("%lld ", ans[i]);
    return 0;
}
```
