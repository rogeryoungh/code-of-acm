---
author: "rogeryoungh"
title: "P4173 残缺的字符串"
date: "2021-07-28"
katex: true
showtoc: true
tags: 
  - "洛谷"
  - "卷积"
  - "字符串"
---

魔改 KMP 大概是不行的，卷积在这里出现的很妙。

## 卷积处理匹配

定义匹配函数

{{< display-math >}}
d(x,y) = [x = y]
{{< /display-math >}}

给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义

{{< display-math >}}
f(k) = \sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k})
{{< /display-math >}}

即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算

{{< display-math >}}
d(x,y) = (x - y)^2
{{< /display-math >}}

再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有

{{< display-math >}}
\begin{aligned}
f(k) &= \sum_{i=0}^{m-1}A_{i}^2 + \sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\
&= \sum_{i=0}^{m-1}A_{i}^2 + \sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k}
\end{aligned}
{{< /display-math >}}

前面两项能够预处理，最后一项是卷积。于是最终复杂度是 $O(n \log n)$。

## 考虑通配符

仅令通配符的字符值为 $0$，再搓个匹配函数

{{< display-math >}}
d(x,y) = xy(x-y)^2
{{< /display-math >}}

然后大力展开

{{< display-math >}}
\begin{aligned}
f(k) &= \sum_{i=0}^{m-1}A_{i}^3B_{i-m+k} + \sum_{i=0}^{m-1}A_{i}B_{i-m+k}^3 - 2\sum_{i=0}^{m-1} A_{i}^2B_{i-m+k}^2\\
&= \sum_{i=0}^{m-1}S_{m-i}^3B_{i-m+k} + \sum_{i=0}^{m-1}S_{m-i}B_{i-m+k}^3 - 2\sum_{i=0}^{m-1} S_{m-i}^2B_{i-m+k}^2
\end{aligned}
{{< /display-math >}}

注意到三个都是卷积，于是最终复杂度是 $O(n \log n)$。

> 记得优化取模。我换 NTT 之后 TLE 了好几次，最后发现是 NTT 里取模写多了。。

```cpp
#include "template/basic/qpow.hpp"
#include "template/basic/mo.hpp"
#include "template/basic/inv.hpp"

#include "template/poly-ntt/init.hpp"
#include "template/poly-ntt/ntt.hpp"

char a[maxn], b[maxn];
poly_type ts, tb, B, S, ANS;

int stk[maxn], cnt = 0;

int main() {
    ll m = rr(), n = rr();
    int lim = 1, lim_2;
    while (lim <= n + m)
        lim <<= 1;
    poly::init(lim);

    scanf("%s", a); // 模式串
    scanf("%s", b); // 文本串

    for (ll i = 1; i <= m; i++) {
        ll j = m - i, t = a[j] - 'a' + 1;
        if (a[j] == '*')
            t = 0;
        ts[i] = t;
    }

    for (ll i = 0; i <= n - 1; i++) {
        ll t = b[i] - 'a' + 1;
        if (b[i] == '*')
            t = 0;
        tb[i] = t;
    }

    for (ll i = 0; i < lim; i++) {
        S[i] = ts[i];
        B[i] = tb[i] * tb[i] * tb[i];
    }
    poly::ntt(S), poly::ntt(B);
    for (ll i = 0; i < lim; i++)
        ANS[i] = S[i] * B[i];

    for (ll i = 0; i < lim; i++) {
        S[i] = ts[i] * ts[i] * ts[i];
        B[i] = tb[i];
    }
    poly::ntt(S), poly::ntt(B);
    for (ll i = 0; i < lim; i++)
        ANS[i] = ANS[i] + S[i] * B[i];

    for (ll i = 0; i < lim; i++) {
        S[i] = ts[i] * ts[i];
        B[i] = tb[i] * tb[i];
    }
    poly::ntt(S), poly::ntt(B);
    for (ll i = 0; i < lim; i++)
        ANS[i] = mo(ANS[i] - S[i] * B[i] * 2);

    poly::intt(ANS);
    for (ll i = m; i <= n; i++) {
        if (ANS[i] == 0)
            stk[++cnt] = i - m + 1;
    }
    printf("%d\n", cnt);
    for (ll i = 1; i <= cnt; i++) {
        printf("%d ", stk[i]);
    }

    return 0;
}
```