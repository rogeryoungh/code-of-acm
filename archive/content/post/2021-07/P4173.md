---
author: "rogeryoungh"
title: "P4173 残缺的字符串"
date: "2021-07-28"
katex: true
showtoc: true
tags: 
  - "洛谷"
  - "卷积"
  - "字符串"
---

魔改 KMP 大概是不行的，卷积在这里出现的很妙。

## 卷积处理匹配

定义匹配函数

{{< display-math >}}
d(x,y) = [x = y]
{{< /display-math >}}

给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义

{{< display-math >}}
f(k) = \sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k})
{{< /display-math >}}

即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算

{{< display-math >}}
d(x,y) = (x - y)^2
{{< /display-math >}}

再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有

{{< display-math >}}
\begin{aligned}
f(k) &= \sum_{i=0}^{m-1}A_{i}^2 + \sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\
&= \sum_{i=0}^{m-1}A_{i}^2 + \sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k}
\end{aligned}
{{< /display-math >}}

前面两项能够预处理，最后一项是卷积。于是最终复杂度是 $O(n \log n)$。

## 考虑通配符

仅令通配符的字符值为 $0$，再搓个匹配函数

{{< display-math >}}
d(x,y) = xy(x-y)^2
{{< /display-math >}}

然后大力展开

{{< display-math >}}
\begin{aligned}
f(k) &= \sum_{i=0}^{m-1}A_{i}^3B_{i-m+k} + \sum_{i=0}^{m-1}A_{i}B_{i-m+k}^3 - 2\sum_{i=0}^{m-1} A_{i}^2B_{i-m+k}^2\\
&= \sum_{i=0}^{m-1}S_{m-i}^3B_{i-m+k} + \sum_{i=0}^{m-1}S_{m-i}B_{i-m+k}^3 - 2\sum_{i=0}^{m-1} S_{m-i}^2B_{i-m+k}^2
\end{aligned}
{{< /display-math >}}

注意到三个都是卷积，于是最终复杂度是 $O(n \log n)$。

> 记得优化取模。我换 NTT 之后 TLE 了好几次，最后发现是 NTT 里取模写多了。。

```cpp
#define ACM_MOD 998244353
const int mod = ACM_MOD;

using poly_t = vector<int>;

poly_t w;

#include "template/basic/qpow.hpp"
#include "template/basic/mo.hpp"
#include "template/basic/inv.hpp"

#include "template/poly-ntt/ntt_init.hpp"
#include "template/poly-ntt/ntt.hpp"

const int maxn = 1 << 21;

char a[maxn], b[maxn];

int stk[maxn], cnt = 0;

int main() {
    ll m, n;
    scanf("%lld %lld", &m, &n);
    int lim = getlim(m, n);
    w = ntt_init(lim);
    poly_t B(lim), S(lim), ANS(lim), ts(lim), tb(lim);

    scanf("%s %s", a, b);

    for (ll i = 1; i <= m; i++) {
        ll j = m - i, t = a[j] - 'a' + 1;
        if (a[j] == '*')
            t = 0;
        ts[i] = t;
    }

    for (ll i = 0; i <= n - 1; i++) {
        ll t = b[i] - 'a' + 1;
        if (b[i] == '*')
            t = 0;
        tb[i] = t;
    }

    for (ll i = 0; i < lim; i++) {
        S[i] = ts[i];
        B[i] = mul(mul(tb[i], tb[i]), tb[i]);
    }
    ntt(S), ntt(B);
    for (ll i = 0; i < lim; i++)
        ANS[i] = mul(S[i], B[i]);

    for (ll i = 0; i < lim; i++) {
        S[i] = mul(mul(ts[i], ts[i]), ts[i]);
        B[i] = tb[i];
    }
    ntt(S), ntt(B);
    for (ll i = 0; i < lim; i++)
        ANS[i] = add(ANS[i], mul(S[i], B[i]));

    for (ll i = 0; i < lim; i++) {
        S[i] = ts[i] * ts[i] % mod;
        B[i] = tb[i] * tb[i] % mod;
    }
    ntt(S), ntt(B);
    for (ll i = 0; i < lim; i++)
        ANS[i] = sub(ANS[i], mul(S[i], B[i]) * 2 % mod);

    intt(ANS);
    for (ll i = m; i <= n; i++) {
        if (ANS[i] == 0)
            stk[++cnt] = i - m + 1;
    }
    printf("%d\n", cnt);
    for (ll i = 1; i <= cnt; i++) {
        printf("%d ", stk[i]);
    }

    return 0;
}
```
