// @description 二维数组

template <class T>
struct VV {
	int x, y;
	std::vector<T> m;
	VV(int a, int b, const T &v = T()) : x(a), y(b), m(a * b, v) {}
	auto operator[](int i) {
		return m.begin() + i * y;
	}
	auto operator[](int i) const {
		return m.begin() + i * y;
	}
};

template <class D>
using Graph = VV<D>; // 默认 x == y

template <class D>
auto get_graph(int n) {
	VV<D> f(n, n, std::numeric_limits<D>::max() / 2);
	for (int i = 0; i < n; i++)
		f[i][i] = 0;
	return f;
}

// @description Floyd 最短路

template <class D>
auto floyd(const Graph<D> &G) {
	int n = G.x;
	auto f = G;
	VV<int> pass(n, n, -1);
	for (int k = 0; k < n; k++) {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				D d2 = f[i][k] + f[k][j];
				if (f[i][j] > d2)
					f[i][j] = d2, pass[i][j] = k;
			}
		}
	}
	return make_pair(f, pass);
}

auto get_path(const VV<int> &pass, int x, int y) {
	vector<int> path = {x};
	std::function<void(int, int)> dfs = [&](int a, int b) {
		if (pass[a][b] != -1) {
			int p = pass[a][b];
			dfs(a, p), path.push_back(p), dfs(p, b);
		}
	};
	if (x != y)
		dfs(x, y), path.push_back(y);
	return path;
}