[{"content":"随机到了一个神秘题目。\n题目大意 在 $n$ 个点的无向图中，有 $k$ 个点有守卫。假如你携带有 $x$ 千克的铀，那么你在移动时与这些守卫的距离必须都大于 $x$。\n多组询问，回答从点 $x$ 运输到点 $y$ 最多能运输多少铀。\n分析 这题对算法的考察较为综合，卡了我一天。\n首先需要求出每个点到最近的守卫的距离 $dis$，在 dijkstra 时设置多个起点即可。\n把每个边的权值设置为两个端点 $dis$ 的最小值，重新建图 $G_2$。\n接下来是关键的一步：得到 $G_2$ 的最大生成树 $G_3$，任何运输路径都在最大生成树上。\n最后用 LCA 维护树两点之间路径的权值 $\\min$。\nint main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; G1[x].push_back({y, z}); G1[y].push_back({x, z}); } int k; cin \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; start(k); for (auto \u0026amp;si : start) cin \u0026gt;\u0026gt; si; auto dis = dijkstra(n, start); for (int u = 1; u \u0026lt;= n; u++) { for (auto [v, w] : G1[u]) { ll tw = min(dis[u], dis[v]); G2[u].push_back({v, max\u0026lt;ll\u0026gt;(0, tw - 1)}); } } kruskal(n); int Q; cin \u0026gt;\u0026gt; Q; LCA\u0026lt;N\u0026gt; lca(n + 1, 1); while (Q--) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; cout \u0026lt;\u0026lt; lca.query(x, y) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 全部代码请看：Luogu/8x/P8240.cpp。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-05/p8240/","summary":"随机到了一个神秘题目。\n题目大意 在 $n$ 个点的无向图中，有 $k$ 个点有守卫。假如你携带有 $x$ 千克的铀，那么你在移动时与这些守卫的距离必须都大于 $x$。\n多组询问，回答从点 $x$ 运输到点 $y$ 最多能运输多少铀。\n分析 这题对算法的考察较为综合，卡了我一天。\n首先需要求出每个点到最近的守卫的距离 $dis$，在 dijkstra 时设置多个起点即可。\n把每个边的权值设置为两个端点 $dis$ 的最小值，重新建图 $G_2$。\n接下来是关键的一步：得到 $G_2$ 的最大生成树 $G_3$，任何运输路径都在最大生成树上。\n最后用 LCA 维护树两点之间路径的权值 $\\min$。\nint main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; G1[x].push_back({y, z}); G1[y].push_back({x, z}); } int k; cin \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; start(k); for (auto \u0026amp;si : start) cin \u0026gt;\u0026gt; si; auto dis = dijkstra(n, start); for (int u = 1; u \u0026lt;= n; u++) { for (auto [v, w] : G1[u]) { ll tw = min(dis[u], dis[v]); G2[u].","title":"P8240 偷铀计划"},{"content":"咕了好久。\nA. Alexey and Train 奇怪的模拟。略。\n全部代码请看：Codeforces/CF1501/CF1501B.cpp。\nB. Napoleon Cake 略。\n全部代码请看：Codeforces/CF1501/CF1501B.cpp。\nC. Going Home 给定一个数组，请给出是否存在四元组使得\n$$ a_w + a_v = a_x + a_y $$\n分析 这题很诈骗。注意到 $x+y$ 最多只有 $5 \\times 10^6$ 种情况，暴力即可。\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); for (auto \u0026amp;ai : a) { cin \u0026gt;\u0026gt; ai; } vector\u0026lt;pii\u0026gt; u(N + 1); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { int sum = a[i] + a[j]; if (u[sum] != pii{0, 0}) { auto [x, y] = u[sum]; if (x == i || x == j || y == i || y == j) continue; printf(\u0026#34;YES\\n%d %d %d %d\u0026#34;, x + 1, y + 1, i + 1, j + 1); exit(0); } u[sum] = {i, j}; } } printf(\u0026#34;NO\u0026#34;); return 0; } 全部代码请看：Codeforces/CF1501/CF1501C.cpp。\nD. Two chandeliers 给定两个序列 $\\{a_i\\}, \\{b_i\\}$，分别长 $n$ 和 $m$。令无限序列 $\\{A_i\\}, \\{b_i\\}$ 是其不断循环。\n问第 $k$ 对 $A_i \\neq B_i$ 在哪个位置。\n分析 考察其相同时刻，显然 $\\operatorname{lcm}(n, m)$ 是一个周期，而在一个周期内至多只有 $\\min(n, m)$ 次相同。\n因此可以用桶得到两个相同的位置 $x, y$，再通过 excrt（我的板子还不知道为啥假了）解方程\n$$ p \\equiv x \\pmod n, p \\equiv y \\pmod m $$\n可以反推出位置 $p$。最后考虑二分答案即可。\nint main() { ll n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; a(n), b(m); for (auto \u0026amp;ai : a) { cin \u0026gt;\u0026gt; ai; } for (auto \u0026amp;bi : b) { cin \u0026gt;\u0026gt; bi; } ll cyc = n * m / std::__gcd(n, m); vector\u0026lt;int\u0026gt; tong(2 * (n + m + 1), -1); for (int i = 0; i \u0026lt; n; i++) { tong[a[i]] = i; } vector\u0026lt;ll\u0026gt; pos; for (int i = 0; i \u0026lt; m; i++) { int num = tong[b[i]]; if (num == -1) continue; ll p = excrt({num, i}, {n, m}); if (p != -1) pos.push_back(p); } sort(pos.begin(), pos.end()); auto get = [\u0026amp;](ll p) -\u0026gt; ll { if (pos.empty()) return 0; ll rem = p % cyc; ll sum = lower(1, pos.size(), [\u0026amp;](int i) { return pos[i - 1] \u0026lt;= rem; }); return p / cyc * pos.size() + sum; }; cout \u0026lt;\u0026lt; upper(1, 1E18, [\u0026amp;](ll x) { return x - get(x - 1) \u0026gt;= k; }); return 0; } 全部代码请看：Codeforces/CF1501/CF1501D.cpp。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-04/cf1501/","summary":"咕了好久。\nA. Alexey and Train 奇怪的模拟。略。\n全部代码请看：Codeforces/CF1501/CF1501B.cpp。\nB. Napoleon Cake 略。\n全部代码请看：Codeforces/CF1501/CF1501B.cpp。\nC. Going Home 给定一个数组，请给出是否存在四元组使得\n$$ a_w + a_v = a_x + a_y $$\n分析 这题很诈骗。注意到 $x+y$ 最多只有 $5 \\times 10^6$ 种情况，暴力即可。\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); for (auto \u0026amp;ai : a) { cin \u0026gt;\u0026gt; ai; } vector\u0026lt;pii\u0026gt; u(N + 1); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { int sum = a[i] + a[j]; if (u[sum] !","title":"Codeforces Round #707"},{"content":"复习一下。\nA. 串 计算长度不超过 $n$ 且蕴含 us 作为子串的字符串有多少个。\n分析 读错题目了，还以为是容斥。对 “出现 us”、“出现 u”、“其他” 三种情况分别 DP。\nint main() { int n; cin \u0026gt;\u0026gt; n; ll ans = 0; ll dp0 = 1, dpu = 0, dps = 0; for (int i = 1; i \u0026lt;= n; i++) { ll t0 = dp0 * 25 % P; ll tu = (dpu * 25 + dp0) % P; ll ts = (dpu + dps * 26) % P; dp0 = t0, dpu = tu, dps = ts; ans = (ans + dps) % P; } cout \u0026lt;\u0026lt; ans; return 0; } 全部代码请看：Nowcoder/NC9981/A.cpp。\n实际上计算可以做到 $\\log n$。记三种情况分别为 $o_n, u_n, s_n$，可以解得\n$$ o_n = 25^n, \\quad u_n = n 25^{n-1}, \\quad s_n = 26^n - o_n-u_n $$\n因此计算得\n$$ \\sum_{i=2}^n s_i = \\frac{1}{14400}(576 \\cdot 26^{n+1} - (599+24n)25^{n+1}-1) $$\nB. 括号 构造长度不超过 $10^5$ 的括号串，使得恰好包含 $k$ 个括号对。\n分析 考虑弄 $5 \\times 10^4$ 个 (，再考虑如何把 $k$ 拆分成 $k_i$，在 $k_i$ 后加上右括号即可。\n拆分可以从 $5\\times10^4$ 开始，逐渐递减。若是从小到大，长度会超。\nint main() { ll k; cin \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; vis(N + 1); for (int i = N; i \u0026gt;= 1; i--) { if (k \u0026gt;= i) { k -= i; vis[i] = 1; } } string s; for (int i = 1; i \u0026lt;= N; i++) { s.push_back(\u0026#39;(\u0026#39;); if (vis[i]) s.push_back(\u0026#39;)\u0026#39;); } cout \u0026lt;\u0026lt; s; return 0; } 全部代码请看：Nowcoder/NC9981/B.cpp。\nC. 红和蓝 给定一棵 $n$ 个节点的树，需要用红色和蓝色把树染色：\n每个红点周围有且仅有一个红点，每个蓝点周围有且仅有一个蓝点。 分析 显然颜色是以二元对的形式分组。下证这样的分组形式唯一。\n如果该点是叶子，其必须和父节点同色，形式唯一。 如果该点不是叶子，则只有两种可能： 已经被子节点标记，形式唯一。 未被标记，依 DFS 序知子节点全是已经标记，且确定唯一的。故只能和父节点同色。 对于每个叶子，其必须和其父节点同色，从而可以赋给他们相同的编号。如果某个叶子其父节点已经被标记，则说明此树不可染色。\nconst int N = 1E5; vector\u0026lt;int\u0026gt; G[N]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } vector\u0026lt;int\u0026gt; vis(n + 1), col(n + 1); int cnt = 0; std::function\u0026lt;void(int, int)\u0026gt; dfs1 = [\u0026amp;](int x, int fa) { for (auto u : G[x]) { if (u != fa) dfs1(u, x); } if (!vis[x]) { if (vis[fa]) { cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; exit(0); } vis[fa] = vis[x] = ++cnt; } }; std::function\u0026lt;void(int, int)\u0026gt; dfs2 = [\u0026amp;](int x, int fa) { for (auto u : G[x]) { if (u == fa) continue; if (vis[u] == vis[x]) { col[u] = col[x]; } else { col[u] = !col[x]; } dfs2(u, x); } }; vis[0] = 1, col[1] = 1; dfs1(1, 0), dfs2(1, 0); for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; (col[i] ? \u0026#39;R\u0026#39; : \u0026#39;B\u0026#39;); } return 0; } 全部代码请看：Nowcoder/NC9981/C.cpp。\nD. 点一成零 给定一个 $n \\times n$ 的 01 方阵，每次修改可以把一处格子由 $0$ 改为 $1$。\n然后回答询问：每次点击可以把一个 $1$ 的连通块变为 $0$，问有几种操作能够全部为 $0$。\n分析 若方阵中有 $a$ 个连通块，每个连通块的大小是 $b_i$，那么答案是\n$$ ans = a! \\prod b_i $$\n因此我们需要维护连通块的个数，和每个连通块的大小。用带权并查集实现即可。\n同时需要维护连通块的乘积，在合并时维护乘积。\nconst int N = 500 + 10; char ss[N][N]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; ss[i]; } pre_all(n * n + 10); int cnt = 0, mul = 1; DSU dsu(n * n); auto merge = [\u0026amp;](int x1, int y1, int x2, int y2) { if (x2 \u0026lt; 0 || x2 \u0026gt;= n || y2 \u0026lt; 0 || y2 \u0026gt;= n) return; if (ss[x2][y2] == \u0026#39;0\u0026#39;) return; int p1 = x1 * n + y1, p2 = x2 * n + y2; if (dsu.find(p1) != dsu.find(p2)) { mul = 1ll * mul * Inv[dsu.size(p1)] % P * Inv[dsu.size(p2)] % P; dsu.merge(p1, p2); mul = 1ll * mul * dsu.size(p1) % P; cnt--; } }; auto change = [\u0026amp;](int i, int j) { if (ss[i][j] == \u0026#39;1\u0026#39;) return; ss[i][j] = \u0026#39;1\u0026#39;; cnt++; merge(i, j, i, j - 1); merge(i, j, i, j + 1); merge(i, j, i - 1, j); merge(i, j, i + 1, j); }; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (ss[i][j] == \u0026#39;0\u0026#39;) continue; ss[i][j] = \u0026#39;0\u0026#39;; change(i, j); } } int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; change(x, y); cout \u0026lt;\u0026lt; 1ll * mul * fac[cnt] % P \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 全部代码请看：Nowcoder/NC9981/D.cpp。\nE. 三棱锥之刻 计算几何，不讲。\nconst double PI = acos(-1.0); int main() { double a, r; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; r; double a2 = a * a, r2 = r * r; double s2 = r2 - a2 / 24; double ans = 0; if (s2 \u0026gt; 0) { double s = sqrt(s2); if (s2 \u0026lt; a2 / 12) { ans = PI * s2; } else if (s2 \u0026lt; a2 / 3) { double costh = a / s / 2 / sqrt(3); double th = acos(costh); double sinth = sqrt(1 - costh * costh); double t = s * sinth; ans = t * a / sqrt(12) + (PI / 3 - th) * s2; ans *= 3; } else { ans = a * a * sqrt(3) / 4; } } printf(\u0026#34;%.10lf\u0026#34;, ans * 4); return 0; } 全部代码请看：Nowcoder/NC9981/E.cpp。\nF. 对答案一时爽 给定 $n$ 道选择题，以及牛牛和牛妹的选择。\n问两人得分之和有可能达到的最大值和最小值。\n分析 显然最小值是 $0$。\n当两人答案相同时，可能得两分；否则得一分。\nint main() { int n; cin \u0026gt;\u0026gt; n; int sum = 0; vector\u0026lt;char\u0026gt; s1(n), s2(n); for (auto \u0026amp;si : s1) cin \u0026gt;\u0026gt; si; for (auto \u0026amp;si : s2) cin \u0026gt;\u0026gt; si; for (int i = 0; i \u0026lt; n; i++) { if (s1[i] == s2[i]) { sum += 2; } else { sum += 1; } } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 0; return 0; } 全部代码请看：Nowcoder/NC9981/F.cpp。\nH. 幂塔个位数的计算 计算 $a \\uparrow \\uparrow n$ 的个位数。\n分析 去年我是打表找规律，但是很容易误认为解只和 $a \\bmod 10$ 有关。\n更朴素的想法是欧拉降幂。\na = int(input()) n = int(input()) if(n == 1): print(a % 10) elif(n == 2): print(pow(a, a % 4 + 4, 10)) else: x = pow(a, a % 2 + 2, 4) print(pow(a, x + 4, 10)) 全部代码请看：Nowcoder/NC9981/H.py。\n还有些题解误认为 $a, n$ 都对 $100$ 取模，这里给出一个 Hack。\nINPUT: 2 1001 ============== OUTPUT: 6 I. 限制不互素对的排列 构造一个长为 $n$ 的排列，使得其中恰有 $k$ 对相邻的数，其 $\\gcd(a_i, a_{i+1}) \u0026gt; 1$。\n分析 怎么感觉这题见过。\n注意到偶数序列是两两 $\\gcd \\geqslant 2$ 的，而相邻整数一定有 $\\gcd(i, i+1) = 1$。\n令 $1$ 作为奇偶分界点，对于 $k \u0026lt; n / 2$ 我们已经有了构造方法。\n对于 $k = n / 2$，需要额外再找出一对。我找的是 $(6, 3)$。\nint main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; if (n \u0026lt; 6 \u0026amp;\u0026amp; k == n / 2) { cout \u0026lt;\u0026lt; -1; exit(0); } vector\u0026lt;int\u0026gt; vis(n + 1), ans; for (int i = 2; i \u0026lt;= n; i += 2) { if (i == 6) continue; ans.push_back(i); } ans.push_back(6); ans.push_back(3); for (int i = 0; i \u0026lt;= k; i++) { cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; vis[ans[i]] = true; } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 全部代码请看：Nowcoder/NC9981/I.cpp。\nJ. 一群小青蛙呱蹦呱蹦呱 给定一个集合 $A = {1, \\cdots, n}$，在其中划去所有质数的幂次 $p_j^k$，组成集合 $B$。问集合 $B$ 所有数的 $\\lcm$ 是多少。\n分析 注意到 $\\lcm$ 再取模，只可能是对于所有因子独立计算贡献。\nint main() { ll n; cin \u0026gt;\u0026gt; n; if (n \u0026lt;= 5) { cout \u0026lt;\u0026lt; \u0026#34;empty\u0026#34;; return 0; } Euler(n / 2); ll ans = 1; for (auto pj : primes) { ll tn = n; if (pj == 2) { tn /= 3; } else { tn /= 2; } tn /= pj; while (tn \u0026gt; 0) { tn /= pj; ans = ans * pj % P; } } cout \u0026lt;\u0026lt; ans; return 0; } 全部代码请看：Nowcoder/NC9981/J.cpp。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-04/nc9981/","summary":"复习一下。\nA. 串 计算长度不超过 $n$ 且蕴含 us 作为子串的字符串有多少个。\n分析 读错题目了，还以为是容斥。对 “出现 us”、“出现 u”、“其他” 三种情况分别 DP。\nint main() { int n; cin \u0026gt;\u0026gt; n; ll ans = 0; ll dp0 = 1, dpu = 0, dps = 0; for (int i = 1; i \u0026lt;= n; i++) { ll t0 = dp0 * 25 % P; ll tu = (dpu * 25 + dp0) % P; ll ts = (dpu + dps * 26) % P; dp0 = t0, dpu = tu, dps = ts; ans = (ans + dps) % P; } cout \u0026lt;\u0026lt; ans; return 0; } 全部代码请看：Nowcoder/NC9981/A.","title":"2021 牛客寒假算法基础集训营 1"},{"content":"A. T-shirt 前 $A$ 名一定获得衣服，在 $[A+1, B]$ 之间的人将随机挑 $C$ 个人获得衣服。\n若已知他排名于 $X$，求其获得衣服的概率。\n分析 int main() { int A, B, C, X; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; C \u0026gt;\u0026gt; X; double ans = 0; if (X \u0026lt;= A) { ans = 1; } else if (X \u0026lt;= B \u0026amp;\u0026amp; A != B) { ans = 1.0 * C / (B - A); } printf(\u0026#34;%.12lf\u0026#34;, ans); return 0; } 全部代码请看：Atcoder/ABC242/ABC242A.cpp。\nB. Minimize Ordering 给定一个字符串 $S$，请找到 $S$ 的重排 $S\u0026rsquo;$，并且使其字典序尽可能小。\n分析 int main() { string s; cin \u0026gt;\u0026gt; s; std::sort(s.begin(), s.end()); cout \u0026lt;\u0026lt; s; return 0; } 全部代码请看：Atcoder/ABC242/ABC242B.cpp。\nC. 1111gal password 相邻数字差为 $1$ 且有 $N$ 位的数字有多少个。\n分析 const int P = 998244353; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v1(10, 1), v2(10); for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; 9; j++) { v2[j] = ((v1[j - 1] + v1[j]) % P + v1[j + 1]) % P; } v2[0] = v1[1], v2[9] = v1[8]; v1 = v2; } int sum = 0; for (int i = 0; i \u0026lt; 9; i++) { sum = (sum + v1[i]) % P; } cout \u0026lt;\u0026lt; sum; return 0; } 全部代码请看：Atcoder/ABC242/ABC242C.cpp。\nD. ABC Transform 给定包含 ABC 的字符串 $S$，可以对字符串做如下变换：\nA-\u0026gt;BC，B-\u0026gt;CA，C-\u0026gt;AB。 多次询问，回答经过 $t_i$ 次变换后第 $k_i$ 个字符。\n分析 注意到一个字符经过变换后会变成两个字符，是类似二叉树的东西。\n因此我们可以沿着树向上走，而且每向上走一层，长度就少一半，故很快就到 $0$。\n似乎有更快的位运算做法，有空再回来看看吧。\nint main() { string s; int Q; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; Q; std::function\u0026lt;ll(ll, ll)\u0026gt; get = [\u0026amp;](ll pos, ll t) -\u0026gt; ll { if (t == 0) { return s[pos] - \u0026#39;A\u0026#39;; } else if (pos == 0) { return (s[0] - \u0026#39;A\u0026#39; + t) % 3; } else if (pos % 2 == 0) { return get(pos / 2, t - 1) + 1; } else { return get(pos / 2, t - 1) + 2; } }; while (Q--) { ll ti, ki; cin \u0026gt;\u0026gt; ti \u0026gt;\u0026gt; ki; cout \u0026lt;\u0026lt; char(get(ki - 1, ti) % 3 + \u0026#39;A\u0026#39;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 全部代码请看：Atcoder/ABC242/ABC242D.cpp。\nE. (∀x∀) 给定一个长为 $N$ 的字符串 $S$，计算满足下列条件的字符串数量：\n$X$ 是一个长为 $N$ 的回文串。 在字典序下有 $X \\leqslant S$。 分析 类似于数位 DP，考虑第 $i$ 位如果满足 $X_i \u0026lt; S_i$，那么中间几位可以随便放。\n最后，如果存在的话，注意特判中间一位，和其他特殊情况。\nconst int N = 1E6, P = 998244353; int main() { vector\u0026lt;int\u0026gt; pw(N); pw[0] = 1; for (int i = 1; i \u0026lt; N; i++) { pw[i] = 1ll * pw[i - 1] * 26 % P; } int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; ll sum = 0; int mid = n / 2; for (int i = 0; i \u0026lt; mid; i++) { sum += 1ll * pw[n - mid - i - 1] * (s[i] - \u0026#39;A\u0026#39;) % P; } if (n % 2 == 1) { sum += s[mid] - \u0026#39;A\u0026#39;; } string s2(s.begin() + (n - mid), s.end()); string s3(s.begin(), s.begin() + mid); std::reverse(s3.begin(), s3.end()); if (s3 \u0026lt;= s2) sum++; cout \u0026lt;\u0026lt; sum % P \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 全部代码请看：Atcoder/ABC242/ABC242E.cpp。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-03/abc242/","summary":"A. T-shirt 前 $A$ 名一定获得衣服，在 $[A+1, B]$ 之间的人将随机挑 $C$ 个人获得衣服。\n若已知他排名于 $X$，求其获得衣服的概率。\n分析 int main() { int A, B, C, X; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; C \u0026gt;\u0026gt; X; double ans = 0; if (X \u0026lt;= A) { ans = 1; } else if (X \u0026lt;= B \u0026amp;\u0026amp; A != B) { ans = 1.0 * C / (B - A); } printf(\u0026#34;%.12lf\u0026#34;, ans); return 0; } 全部代码请看：Atcoder/ABC242/ABC242A.cpp。\nB. Minimize Ordering 给定一个字符串 $S$，请找到 $S$ 的重排 $S\u0026rsquo;$，并且使其字典序尽可能小。","title":"AtCoder Beginner Contest 242(A-E)"},{"content":"数学不行，摆烂。\nA. Shampoo 三个人 F, M, T 按顺序洗澡，其中洗发液用量分别是 $A, B, C$。\n现在洗发液的量 $V$，问谁先无法洗澡？\n分析 第一次没认真读，WA 了一发。\nint main() { int V, A, B, C; cin \u0026gt;\u0026gt; V \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; C; V %= A + B + C; if (V \u0026lt; A) { cout \u0026lt;\u0026lt; \u0026#34;F\u0026#34;; } else if (V \u0026lt; A + B) { cout \u0026lt;\u0026lt; \u0026#34;M\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;T\u0026#34;; } return 0; } 全部代码请看：Atcoder/ABC243/ABC243A.cpp。\nB. Hit and Blow 给定两个长为 $N$ 的无重复的整数序列 $\\{A_i\\},\\{B_i\\}$。找到满足以下条件的数量：\n对于 $i$，使得 $A_i = B_i$。问 $i$ 有多少个。 对于 $(i,j)$，使得 $A_i = B_j$ 且 $i \\neq j$。问 $(i,j)$ 有多少个。 分析 因为 $N$ 只有 $10^3$，可以非常暴力的计算。\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n), b(n); for (auto \u0026amp;ai : a) cin \u0026gt;\u0026gt; ai; for (auto \u0026amp;bi : b) cin \u0026gt;\u0026gt; bi; int ans1 = 0; for (int i = 0; i \u0026lt; n; i++) ans1 += a[i] == b[i]; int ans2 = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (j == i) continue; ans2 += a[i] == b[j]; } } cout \u0026lt;\u0026lt; ans1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; ans2; return 0; } 全部代码请看：Atcoder/ABC243/ABC243B.cpp。\nC. Collision 2 给定 $N$ 个人的座标 $(x_i, y_i)$，并且每个人有两个行走的方向 $L,R$。问是否存在一个时间，使得两个人互相碰面？\n分析 考虑所有 $y$ 座标相同的人，只需考虑最左侧的 $R$ 和最右侧的 $L$ 是否有碰面机会。\nusing int3 = tuple\u0026lt;int, int, int\u0026gt;; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; x(n), y(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; } string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;int3\u0026gt; v(n + 1); for (int i = 0; i \u0026lt; n; i++) { v[i] = {x[i], y[i], s[i]}; } v[n] = {-1, -1, -1}; sort(v.begin(), v.end(), [](int3 a, int3 b) { return std::get\u0026lt;1\u0026gt;(a) \u0026lt; std::get\u0026lt;1\u0026gt;(b); }); int l = -2E9, r = 2E9; for (int i = 0; i \u0026lt; n - 1; i++) { auto [x1, y1, s1] = v[i]; auto [x2, y2, s2] = v[i + 1]; if (y1 != y2) { l = -2E9, r = 2E9; } if (s2 == \u0026#39;L\u0026#39;) { l = max(l, x2); } else { r = min(r, x2); } if (l \u0026gt; r) { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34;; exit(0); } } cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34;; return 0; } 全部代码请看：Atcoder/ABC243/ABC243C.cpp。\nD. Moves on Binary Tree 你现在有一个数字 $X$，做 $N$ 次操作：\n如果是 $U$，则变成 $X \\gets X / 2$。 如果是 $L$，则变成 $X \\gets 2X$。 如果是 $R$，则变成 $X \\gets 2X + 1$。 保证 $X$ 和答案不超过 $10^{18}$。\n分析 注意到 $LU$ 和 $RU$ 可以消去，用栈不断的弹即可。\nint main() { ll N, X; string S; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; X \u0026gt;\u0026gt; S; string v; for (auto si : S) { if (si == \u0026#39;U\u0026#39; \u0026amp;\u0026amp; !v.empty() \u0026amp;\u0026amp; v.back() != \u0026#39;U\u0026#39;) { v.pop_back(); } else { v.push_back(si); } } for (auto vi : v) { if (vi == \u0026#39;L\u0026#39;) X = X * 2; else if (vi == \u0026#39;R\u0026#39;) X = X * 2 + 1; else X /= 2; } cout \u0026lt;\u0026lt; X; return 0; } 全部代码请看：Atcoder/ABC243/ABC243D.cpp。\nE. Edge Deletion 给定一个 $N$ 个点、$M$ 条边的图 $G$。你对这个图任意的删边得到 $G\u0026rsquo;$，但是要满足以下条件：\n这张图仍是连通的。 任意两点 $s,t$ 在 $G\u0026rsquo;$ 中的最短距离仍是 $G$ 中的最短距离。 分析 贪心很好想到，证明不会。对于一条边，如果存在别的路径比这条边短（或一样长），那么这条边就可以去掉。\n显然经过变换后图仍是连续的，因为最短路仍存在且未改变。\nconst int N = 300 + 10; const ll INF = 0x3f3f3f3f3f3f3f3f; ll G[N][N], f[N][N]; void floyd(int n); int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(G, 0x3f, sizeof(G)); memset(f, 0x3f, sizeof(f)); for (int i = 0; i \u0026lt; m; i++) { ll ai, bi, ci; cin \u0026gt;\u0026gt; ai \u0026gt;\u0026gt; bi \u0026gt;\u0026gt; ci; G[ai][bi] = G[bi][ai] = ci; f[ai][bi] = f[bi][ai] = ci; } for (int i = 1; i \u0026lt;= n; i++) { f[i][i] = G[i][i] = 0; } floyd(n); int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { if (G[i][j] == INF) continue; bool flag = false; for (int k = 1; k \u0026lt;= n; k++) { if (i == k || j == k) continue; if (f[i][k] + f[k][j] \u0026lt;= G[i][j]) flag = true; } ans += flag; } } cout \u0026lt;\u0026lt; ans; return 0; } 全部代码请看：Atcoder/ABC243/ABC243E.cpp。\nF. Lottery 一幅画可以获得 $N$ 种奖中的一种，每种中奖的概率是 $p_i = \\frac{W_i}{\\sum W_i}$。\n问 $K$ 幅画获得恰好 $M$ 种不同的奖的概率是多少。\n分析 我往容斥想了好久，没想明白。正解是用 DP 计算组合数。\n若我们假定第 $i$ 种奖获得了 $c_i$ 次，那么其机率是\n$$ \\frac{K!}{\\prod c_i!} \\prod p_i^{c_i} = K! \\prod_{i=1}^n\\frac{p_i^{c_i}}{c_i!} $$\n考虑 $DP[n][m][k]$，表示有 $n$ 种奖、获得了 $k$ 次奖、有 $m$ 种不同的奖。令 $S$ 是所有奖的全集，那么我们计算的是\n$$ DP[n][m][k] = \\sum_{C \\subset S, |C| = m} K! \\prod_{i=1}^n\\frac{p_i^{c_i}}{c_i!} $$\n可以观察多了第 $n$ 种奖时 DP 的转移情况，有刷表的转移方程（我将不清楚）。\nconst int N = 60; int dp[N][N][N]; int main() { pre_all(N * 10); int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; p(n); int tsum = 0; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; p[i]; tsum = (tsum + p[i]) % P; } int iv_sum = qpow(tsum); vector\u0026lt;int\u0026gt; pw[N]; for (int i = 0; i \u0026lt; n; i++) { p[i] = 1ll * p[i] * iv_sum % P; pw[i].resize(N); pw[i][0] = 1; int pi = p[i]; for (int j = 1; j \u0026lt; N; j++) { pw[i][j] = 1ll * pi * ifac[j] % P; pi = 1ll * pi * p[i] % P; } } dp[0][0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; n; j++) { for (int x = 0; x \u0026lt;= k; x++) { dp[i][j][x] = mo(dp[i][j][x] + dp[i - 1][j][x]); for (int y = 1; y \u0026lt;= k - x; y++) { ll mul = 1ll * dp[i - 1][j][x] * pw[i - 1][y]; dp[i][j + 1][x + y] = (dp[i][j + 1][x + y] + mul) % P; } } } } cout \u0026lt;\u0026lt; 1ll * dp[n][m][k] * fac[k] % P; return 0; } 全部代码请看：Atcoder/ABC243/ABC243F.cpp。\nG. Sqrt 初始给定仅有一个数字的序列 $A = (X)$。设 $Y$ 是这个序列的最后一个数，你可以在后面压入 $1$ 到 $\\lfloor\\sqrt{Y}\\rfloor$ 中的任何一个整数，如此操作 $10^{100}$ 次。\n问最终序列 $A$ 有多少可能性。\n分析 令 $f_n$ 是其解，容易得到\n$$ f_n = \\sum_{i=1}^{\\lfloor\\sqrt{n}\\rfloor} f_i = f_{\\lfloor n\\rfloor^2} $$\n因此答案只和 $\\lfloor \\sqrt{n} \\rfloor$ 有关。现在的范围是 $3 \\times 10^9$，仍需要优化。\n令 $g_n = f_{n^2}$，可以得到\n$$ g_n = g_{n-1} + g_{\\lfloor \\sqrt{n} \\rfloor} = g_{\\lfloor \\sqrt{n} \\rfloor^2} + (n - \\lfloor \\sqrt{n} \\rfloor^2) g_{\\lfloor \\sqrt{n} \\rfloor} $$\n因此\n$$ g_{(n+1)^2} = g_{(n+1)^2 - 1} + g_{n+1} = g_{n^2} + 2 n g_n + g_{n+1} $$\n故可以预处理平方，复杂度再降到 4 次根号。还需注意 sqrt 精度问题，最好手写二分开根。\nll lsqrt(ll x); // 二分开根 const ll N = 1E5; vector\u0026lt;ll\u0026gt; v1, v2; void pre(ll n) { v1.resize(n + 1), v2.resize(n + 1); v2[1] = v1[1] = 1; ll u = 2; for (ll i = 2; i \u0026lt;= n; i++) { if (u * u == i) u++; v1[i] = v1[i - 1] + v1[u - 1]; v2[i] = v2[i - 1] + 2 * (i - 1) * v1[i - 1] + v1[i]; } } int main() { int T; cin \u0026gt;\u0026gt; T; pre(N); while (T--) { ll x; cin \u0026gt;\u0026gt; x; ll n = lsqrt(x), sn = lsqrt(n), ret = v2[sn]; cout \u0026lt;\u0026lt; ret + (n - sn * sn) * v1[sn] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 全部代码请看：Atcoder/ABC243/ABC243G.cpp。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-03/abc243/","summary":"数学不行，摆烂。\nA. Shampoo 三个人 F, M, T 按顺序洗澡，其中洗发液用量分别是 $A, B, C$。\n现在洗发液的量 $V$，问谁先无法洗澡？\n分析 第一次没认真读，WA 了一发。\nint main() { int V, A, B, C; cin \u0026gt;\u0026gt; V \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; C; V %= A + B + C; if (V \u0026lt; A) { cout \u0026lt;\u0026lt; \u0026#34;F\u0026#34;; } else if (V \u0026lt; A + B) { cout \u0026lt;\u0026lt; \u0026#34;M\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;T\u0026#34;; } return 0; } 全部代码请看：Atcoder/ABC243/ABC243A.","title":"AtCoder Beginner Contest 243(A-G)"},{"content":"这场属实阴间。\nA. Acacius and String 替换字符串 $s$ 中的 ?，使得出现且仅出现一次 abacaba。\n分析 本题较为难写，因为很难判断恰好出现了一次。但是数据规模很小，可以采用非常暴力的写法。\n一种想法是，枚举每个出现 abacaba 的位置 $i$，把当前 $s[i, i + 6]$ 中的 ? 设为给定串，这样就得到了字符串 $t$。\n然后判断字符串 $t$ 中只出现了一次 abacaba，可以通过 substr 枚举所有长为 $6$ 的子串。\nstring what = \u0026#34;abacaba\u0026#34;; int N = what.length(); void solve() { int n; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt;= n - N; i++) { string tmp = s; for (int j = 0; j \u0026lt; N; j++) { if (tmp[i + j] == \u0026#39;?\u0026#39;) { tmp[i + j] = what[j]; } } for (int j = 0; j \u0026lt; tmp.length(); j++) { if (tmp[j] == \u0026#39;?\u0026#39;) tmp[j] = \u0026#39;z\u0026#39;; } int cnt = 0; for (int j = 0; j \u0026lt;= tmp.length() - N; j++) { if (tmp.substr(j, N) == what) cnt++; } if (cnt == 1) { cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34; \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } } cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; } 全部代码请看：Codeforces/CF1379/CF1379A.cpp。\nB. Dubious Cyrpto 给定 $l,r,m$，找到正整数 $a,b,c,n$ 满足 $m = an + b - c$，且 $l \\leqslant a,b,c \\leqslant r$。\n分析 反解 $n$ 得到\n$$ \\frac{m - (b - c)}{a} = n $$\n我们可以把 $b - c$ 当作一个整体。注意到 $n$ 是正整数，说明 $m - (b - c)$ 必须要能够整除 $a$，而且 $a$ 的范围不是很大，因此我们可以枚举 $a$。\n再注意到 $b-c$ 的范围是 $[l-r,r-l]$，即判断 $m \\bmod a$ 是否在这个范围内。\nvoid solve() { ll l, r, m; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; m; for (ll a = l; a \u0026lt;= r; a++) { int b_c = (m + r - l) % a - (r - l); if (b_c \u0026gt; r - l) continue; if (b_c \u0026lt; 0) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (r + b_c) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; else cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (l + b_c) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; } } 全部代码请看：Codeforces/CF1379/CF1379B.cpp。\nC. Choosing flowers 对于 $n$ 种花，如果其中第 $i$ 种选择了 $x_i \u0026gt; 0$ 朵，那么其贡献是\n$$ a_i + (x_i - 1) b_i $$\n怎样选择才能使整体的贡献最大。\n分析 很精妙的贪心。先假设选择的花的集合 $S \\subset \\mathbb{N}_{\\leqslant n}$，每种先选 $1$ 朵，接下来考虑剩下的数量如何分配。必然的，应该全部分配给 $S$ 中最大的 $b_i$。\n换种角度考虑，答案可能是全部只选了 $1$ 朵，或者必然只有一种多于 $1$ 朵。我们可以考虑枚举第 $i$ 朵花多于 $1$ 朵。\n再注意到，当第 $j$ 种花满足 $a_j \u0026gt; b_i$ 时，应该选择一朵 $a_j$。\n全部的 $a_j \u0026gt; b_i$ 可以通过二分 + 前缀和得到，需注意分类讨论前缀和是否包含了 $a_i$。\nvoid solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;pii\u0026gt; v(m + 1); for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; v[i].x \u0026gt;\u0026gt; v[i].y; } sort(v.begin() + 1, v.end()); vector\u0026lt;ll\u0026gt; sum(m + 1); for (int i = 1; i \u0026lt;= m; i++) { sum[i] = sum[i - 1] + v[i].x; } ll ans = 0; for (int i = 1; i \u0026lt;= m; i++) { int pos = upper(1, m, [\u0026amp;](int M) { return v[M].x \u0026gt; v[i].y; }); int num = m - pos + 1; if (num \u0026lt;= n) { ll tans = sum[m] - sum[pos - 1] + (n - num) * v[i].y; if (pos \u0026gt; i) { tans += v[i].x - v[i].y; } ans = max(ans, tans); } else { ans = max(ans, sum[m] - sum[max(0, m - n)]); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 全部代码请看：Codeforces/CF1379/CF1379C.cpp。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-03/cf1379/","summary":"这场属实阴间。\nA. Acacius and String 替换字符串 $s$ 中的 ?，使得出现且仅出现一次 abacaba。\n分析 本题较为难写，因为很难判断恰好出现了一次。但是数据规模很小，可以采用非常暴力的写法。\n一种想法是，枚举每个出现 abacaba 的位置 $i$，把当前 $s[i, i + 6]$ 中的 ? 设为给定串，这样就得到了字符串 $t$。\n然后判断字符串 $t$ 中只出现了一次 abacaba，可以通过 substr 枚举所有长为 $6$ 的子串。\nstring what = \u0026#34;abacaba\u0026#34;; int N = what.length(); void solve() { int n; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt;= n - N; i++) { string tmp = s; for (int j = 0; j \u0026lt; N; j++) { if (tmp[i + j] == \u0026#39;?","title":"Codeforces Round #657 (Div. 2)(A-C)"},{"content":"后悔没把 D 写快点。\nA. A ↔ BB 给定一个长为 $N$ 的仅包含 ABC 的字符串 $S$。可以做以下两种操作\n把 A 替换为 BB 把 BB 替换为 A 求操作后 $S$ 的字典序最小是多少。\n分析 我赛时是想到 BA 可以变为 AB，从而降低字典序。\nint main() { int N; string s; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; s.size() - 1; i++) { if (s[i] == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;B\u0026#39;) { s[i] = \u0026#39;A\u0026#39;; s.erase(s.begin() + i + 1); } if (s[i] == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;A\u0026#39;) { swap(s[i], s[i + 1]); } } cout \u0026lt;\u0026lt; s; return 0; } 全部代码请看：Atcoder/ARC136/ARC136A.cpp。\n现在想来，先进行操作 1 再进行操作 2 足以。\ninput() s = input() print(s.replace(\u0026#39;A\u0026#39;,\u0026#39;BB\u0026#39;).replace(\u0026#39;BB\u0026#39;,\u0026#39;A\u0026#39;)) B. Triple Shift 给定两个长为 $N$ 的排列 $A,B$，每一次操作可以选择 $A_{i},A_{i+1},A_{i+2}$ 变成 $A_{i+2}, A_{i}, A_{i+1}$。\n是否存在操作方法能够把 $A$ 变成 $B$。\n分析 第一想法就是观察到操作操作不改变逆序数的奇偶性，判断奇偶性是否相同即可。\n而且若序列中有相同的数，那么其奇偶性可以被任意的指定。\n至于具体为什么，我不会证。\nint inver(const vector\u0026lt;int\u0026gt; \u0026amp;v) { int ans = 0, n = v.size(); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { ans += v[i] \u0026gt; v[j]; } } return ans; } int main() { int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;int\u0026gt; A(N), B(N); for (auto \u0026amp;ai : A) cin \u0026gt;\u0026gt; ai; for (auto \u0026amp;bi : B) cin \u0026gt;\u0026gt; bi; int ivA = inver(A), ivB = inver(B); sort(A.begin(), A.end()); sort(B.begin(), B.end()); if (A == B) { bool same = false; for (int i = 0; i \u0026lt; N - 1; i++) same = same || A[i] == A[i + 1]; if (same || (ivA + ivB) % 2 == 0) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34;; } return 0; } 全部代码请看：Atcoder/ARC136/ARC136B.cpp。\nD. Without Carry 给定一个 $N$ 个数的序列，求使得 $A_i+A_j$ 不发生进位的二元对个数 $(i,j)$，且 $1 \\leqslant i \u0026lt; j \\leqslant N$。\n分析 我赛中写了一个六维 DP，调起来很费劲，赛后才发现写难了。\n我的六维 DP 的定义是小于 DP 位的数的个数，就是个六维前缀和。我想办法用 6 维容斥转移，勉强能过。\n实际上 6 维前缀和容斥转移需要 $2^6=64$ 个数参与计算，用刷表可以只用 $6$ 次。\nconst int M = 1E6; bool check(int x) { while (x) { if (x % 10 \u0026gt;= 5) return false; x /= 10; } return true; } int main() { int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;int\u0026gt; a(N), dp(M); for (int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; a[i]; dp[a[i]]++; } for (int k = 1; k \u0026lt; M; k *= 10) { for (int i = 0; i \u0026lt; M; i += k * 10) { for (int j = 0; j \u0026lt; k * 9; j++) { dp[i + j + k] += dp[i + j]; } } } ll ans = 0; for (int i = 0; i \u0026lt; N; i++) { ans += dp[M - 1 - a[i]] - check(a[i]); } cout \u0026lt;\u0026lt; ans / 2; return 0; } 全部代码请看：Atcoder/ARC136/ARC136D.cpp。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-02/arc136/","summary":"后悔没把 D 写快点。\nA. A ↔ BB 给定一个长为 $N$ 的仅包含 ABC 的字符串 $S$。可以做以下两种操作\n把 A 替换为 BB 把 BB 替换为 A 求操作后 $S$ 的字典序最小是多少。\n分析 我赛时是想到 BA 可以变为 AB，从而降低字典序。\nint main() { int N; string s; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; s.size() - 1; i++) { if (s[i] == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;B\u0026#39;) { s[i] = \u0026#39;A\u0026#39;; s.erase(s.begin() + i + 1); } if (s[i] == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;A\u0026#39;) { swap(s[i], s[i + 1]); } } cout \u0026lt;\u0026lt; s; return 0; } 全部代码请看：Atcoder/ARC136/ARC136A.","title":"AtCoder Regular Contest 136 (ABD)"},{"content":"这场感觉好卡。\nA - Digit Machine 如果当前数字是 $k$，按下一次后会变成 $a_k$。求按 $3$ 次后的数字。\n分析 模拟即可。\nint main() { vector\u0026lt;int\u0026gt; v(10); for (auto \u0026amp;vi : v) cin \u0026gt;\u0026gt; vi; int x = 0; for (int i = 0; i \u0026lt; 3; i++) x = v[x]; cout \u0026lt;\u0026lt; x; return 0; } 全部代码请看：Atcoder/ABC241/ABC241A.cpp。\nB - Pasta 把数组 $\\{b_m\\}$ 的数字映射到 $\\{a_n\\}$ 上，不能重复。问是否能够完全映射。\n分析 用 mutiset\u0026lt;int\u0026gt; 模拟即可。\nint main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; multiset\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; n; i++) { int t; cin \u0026gt;\u0026gt; t; s.insert(t); } for (int i = 0; i \u0026lt; m; i++) { int t; cin \u0026gt;\u0026gt; t; if (s.count(t) == 0) { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34;; return 0; } s.erase(s.find(t)); } cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34;; return 0; } 全部代码请看：Atcoder/ABC241/ABC241B.cpp。\nC - Connect 6 给定一个地图，你可以把两个位置改为 #，问是否能够产生连续的 $6$ 个 #。横、竖、斜皆可。\n分析 对于每个点，暴力搜一遍即可。\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;string\u0026gt; m(n); for (auto \u0026amp;mi : m) { cin \u0026gt;\u0026gt; mi; } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { auto sharp = [\u0026amp;](int x, int y) { int ti = i, tj = j; int sum = 0; for (int u = 0; u \u0026lt; 6; u++) { if (ti \u0026lt; 0 || tj \u0026lt; 0 || ti \u0026gt;= n || tj \u0026gt;= n) { return false; } sum += m[ti][tj] == \u0026#39;#\u0026#39;; ti += x, tj += y; } return sum \u0026gt;= 4; }; bool flag = false; flag = flag || sharp(1, 0) || sharp(1, 1) || sharp(0, 1) || sharp(-1, 1); flag = flag || sharp(-1, 0) || sharp(-1, -1) || sharp(0, -1) || sharp(1, -1); if (flag) { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34;; return 0; } } } cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34;; return 0; } 全部代码请看：Atcoder/ABC241/ABC241C.cpp。\nD - Sequence Query 给定一个空序列 $A$，和 $Q$ 个询问\n1 x，把 $x$ 插入 $A$。 2 x k，在所有小于等于 $x$ 的数中，找出第 $k$ 大数。 3 x k，在所有大于等于 $x$ 的数中，找出第 $k$ 小数。 其中 $k \\leqslant 5$。\n分析 我还楞了一会，发现 mutiset\u0026lt;ll\u0026gt; 好像可以直接秒。\nint main() { int Q; cin \u0026gt;\u0026gt; Q; multiset\u0026lt;ll\u0026gt; s; while (Q--) { ll op, x, k; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; if (op == 1) { s.insert(x); } else { cin \u0026gt;\u0026gt; k; auto iter = s.begin(); bool flag = false; if (op == 2) { iter = s.upper_bound(x); while (iter != s.begin() \u0026amp;\u0026amp; k--) iter--; flag = k \u0026gt; 0; } else { iter = s.lower_bound(x); k--; while (iter != s.end() \u0026amp;\u0026amp; k--) iter++; flag = iter == s.end(); } if (flag) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; *iter \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } 全部代码请看：Atcoder/ABC241/ABC241D.cpp。\nE - Putting Candies 给定一个长为 $N$ 的序列 $A$，初始数字 $X = 0$。\n每次让 $X \\gets X + A_{(X \\bmod N)}$。 问 $K$ 次操作后有答案是多少。\n分析 我第一想法是倍增，然后想了想存在循环节，就不写倍增了。\n注意到当值为 $X$ 时，其下一个位置和增加的量仅与 $X \\bmod N$ 有关，故取值最多 $n$ 种，必然存在循环。\n把环判出来，首尾额外处理一下即可。\nint main() { ll n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;ll\u0026gt; v(n), vis(n); for (auto \u0026amp;vi : v) cin \u0026gt;\u0026gt; vi; auto get = [\u0026amp;](ll u, const ll p = 0) { ll ans = p, pos = p % n; while (u--) { ans += v[pos]; pos = ans % n; } return ans - p; }; ll cnt = 0, pos = 0, tsum = 0; while (!vis[pos]) { vis[pos] = cnt++; tsum += v[pos]; pos = tsum % n; } ll crc = cnt - vis[pos], left = k - vis[pos]; ll ans = 0; if (left \u0026lt; 0) { ans += get(k); } else { ans = get(crc, pos) * (left / crc) + get(vis[pos] + left % crc); } cout \u0026lt;\u0026lt; ans; return 0; } 全部代码请看：Atcoder/ABC241/ABC241E.cpp。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-02/abc241/","summary":"这场感觉好卡。\nA - Digit Machine 如果当前数字是 $k$，按下一次后会变成 $a_k$。求按 $3$ 次后的数字。\n分析 模拟即可。\nint main() { vector\u0026lt;int\u0026gt; v(10); for (auto \u0026amp;vi : v) cin \u0026gt;\u0026gt; vi; int x = 0; for (int i = 0; i \u0026lt; 3; i++) x = v[x]; cout \u0026lt;\u0026lt; x; return 0; } 全部代码请看：Atcoder/ABC241/ABC241A.cpp。\nB - Pasta 把数组 $\\{b_m\\}$ 的数字映射到 $\\{a_n\\}$ 上，不能重复。问是否能够完全映射。\n分析 用 mutiset\u0026lt;int\u0026gt; 模拟即可。\nint main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; multiset\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; n; i++) { int t; cin \u0026gt;\u0026gt; t; s.","title":"AtCoder Beginner Contest 241 (A-E)"},{"content":"在学长的提示下成功做出 D，蓝了，开心。\nA. Hard Way 给定一个在第一象限的三角形座标，你可以从 $y=0$ 的任意位置出发，在平面中沿着折线前进但不能穿过三角形。\n问三角形的边界上无法到达的位置，其总长度是多少。\n分析 题面真 TM 难读，什么玩意。\n注意到如果这条边是斜的，那么我们总是可以走一条更斜的线直接到达。如果此边水平，则不能到达。\n即输出三角形水平边的长度。\nusing pii = pair\u0026lt;int, int\u0026gt;; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { vector\u0026lt;pii\u0026gt; v(3); for (auto \u0026amp;[x, y] : v) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; } sort(v.begin(), v.end(), [](pii a, pii b) { if (a.second == b.second) return a.first \u0026lt; b.first; return a.second \u0026gt; b.second; }); if (v[0].second == v[1].second) cout \u0026lt;\u0026lt; abs(v[0].first - v[1].first) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; } return 0; } B. Power Walking 有一些能量包，每个小孩的能力增幅是其得到不同种类能量包的个数。\n总共有 $n$ 个能量包，其类别分别是 $\\{a_i\\}$。假如把这些分给 $k$ 个小孩，每个小孩至少得到一个能量包。\n求对所有的 $0 \\leqslant k \\leqslant n$，求这 $k$ 个小孩最小的能量增幅。\n分析 设这 $n$ 个能量包中类别不同的共有 $m$ 个。\n若 $k \\leqslant m$，则至少有 $m$ 的增幅，多出来的 $n-m$ 个可以和相同类别塞给同一个小朋友，没有额外增幅。 若 $k \u0026gt; m$，则至少有 $k$ 的增幅，多出来的 $n-k$ 个仍可以和相同类别合并，没有额外增幅。 总之，最小的能量增幅是 $\\max(k, m)$。\nint main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); for (auto \u0026amp;ai : a) cin \u0026gt;\u0026gt; ai; int m = n; sort(a.begin(), a.end()); for (int i = 1; i \u0026lt; n; i++) m -= a[i] == a[i - 1]; for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; max(i, m) \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == n]; } } return 0; } C. Great Sequence 给定 $n$ 个数字 $\\{a_i\\}$，和一个数字 $x$。如果存在 $a_j$ 满足 $a_j = x a_i$，那么我们可以把这两个数配对。每个数字只能被配对一次。\n现在允许往序列 $\\{a_i\\}$ 中添加数字，问若要让序列中所有数字都被配对，最少添加几个数字。\n分析 排序后，双指针配对即可，时间复杂度 $O(n)$。Map 大概也能过，时间复杂度 $O(n \\log n)$。\nint main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; ll x; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; vector\u0026lt;ll\u0026gt; a(n); for (auto \u0026amp;ai : a) cin \u0026gt;\u0026gt; ai; sort(a.begin(), a.end()); vector\u0026lt;int\u0026gt; vis(n); int l = 0, r = -1; while (r \u0026lt; n - 1) { r++; while (a[l] * x \u0026lt; a[r] || (a[l] * x == a[r] \u0026amp;\u0026amp; vis[l])) l++; if (a[l] * x == a[r]) vis[l] = vis[r] = true; } int ans = 0; for (auto vi : vis) ans += vi; cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } D. Repetitions Decoding 给定一个长为 $n$ 的序列 $\\{a_i\\}$，可以在任意位置插入相同的两个元素 $[c, c]$。\nOlya 希望序列能够被分成一系列子序列，并且所有子序列左右重复。\n分析 对于左边第一个数 $a_1$，找到右侧与之相同的第一个数 $a_r$，不断在 $a_r$ 右侧插入数字使得 $a[1, r - 1]$ 到 $a[r, 2r - 2]$ 相同。然后再从 $2r-1$ 开始继续操作，直到序列结尾。\n若原序列存在数字是出现了奇数次，则一定无解。前述算法一定不能运行到结尾。\n注意到当原序列每个数字出现偶数次一定有解。而前述算法每次一定会减少一个数，故一定能找到解。\nusing pii = pair\u0026lt;int, int\u0026gt;; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v(n); for (auto \u0026amp;vi : v) cin \u0026gt;\u0026gt; vi; bool flag = true; vector\u0026lt;pii\u0026gt; ans; vector\u0026lt;int\u0026gt; ans2; int l = 0; while (l \u0026lt; v.size()) { int r = -1; for (int i = l + 1; i \u0026lt; v.size(); i++) { if (v[i] == v[l]) { r = i; break; } } if (r == -1) { flag = false; break; } int len = 1; while (l + len \u0026lt; r) { v.insert(v.begin() + r + len, {v[l + len], v[l + len]}); ans.emplace_back(r + len, v[l + len]); len++; } l = r + len; ans2.push_back(len * 2); } if (!flag) { cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; for (auto [x, y] : ans) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } cout \u0026lt;\u0026lt; ans2.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; for (auto ai : ans2) { cout \u0026lt;\u0026lt; ai \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-02/cf1642/","summary":"在学长的提示下成功做出 D，蓝了，开心。\nA. Hard Way 给定一个在第一象限的三角形座标，你可以从 $y=0$ 的任意位置出发，在平面中沿着折线前进但不能穿过三角形。\n问三角形的边界上无法到达的位置，其总长度是多少。\n分析 题面真 TM 难读，什么玩意。\n注意到如果这条边是斜的，那么我们总是可以走一条更斜的线直接到达。如果此边水平，则不能到达。\n即输出三角形水平边的长度。\nusing pii = pair\u0026lt;int, int\u0026gt;; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { vector\u0026lt;pii\u0026gt; v(3); for (auto \u0026amp;[x, y] : v) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; } sort(v.begin(), v.end(), [](pii a, pii b) { if (a.second == b.second) return a.first \u0026lt; b.first; return a.second \u0026gt; b.second; }); if (v[0].second == v[1].second) cout \u0026lt;\u0026lt; abs(v[0].","title":"Codeforces Round #773 (Div. 2)  (A-D)"},{"content":"A. Doors and Keys 有 RGB 三种门，和 rgb 三种钥匙。如果门先于其对应的钥匙出现，则会卡关。判断字符串是否意味着卡关。\n分析 枚举即可。\nint main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; flag(26); bool ans = true; for (char si : s) { if (si \u0026gt;= \u0026#39;a\u0026#39;) { flag[si - \u0026#39;a\u0026#39;] = true; } else { if (!flag[si - \u0026#39;A\u0026#39;]) { ans = false; } } } if (ans) cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; } return 0; } B. Anti-Fibonacci Permutation 如果长 $n$ 的排列 $p$ 是反斐波那契排列，即对所有元素\n$$ p_{i-2} + p_{i-1} \\neq p_i $$\n都成立。构造出 $n$ 个长为 $n$ 的反斐波那契排列。\n分析 我的第一想法是爆搜，后来想到 $1+2=3$ 会使得开始会 T，想到交换 $2,3$ 应该就没问题了。\nint main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v(n); for (int i = 0; i \u0026lt; n; i++) { v[i] = i + 1; } swap(v[1], v[2]); auto judge = [\u0026amp;]() { for (int i = 2; i \u0026lt; n; i++) { if (v[i] == v[i - 1] + v[i - 2]) return false; } return true; }; int cnt = 0; do { if (judge()) { cnt++; for (auto vi : v) cout \u0026lt;\u0026lt; vi \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; if (cnt == n) break; } } while (next_permutation(v.begin(), v.end())); } return 0; } 看了别人的代码，发现构造可以更加简单。\nint main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v(n + 1); for (int i = n; i \u0026gt;= 1; i--) { v[i] = n - i + 1; } for (int i = n; i \u0026gt;= 1; i--) { for (int j = 1; j \u0026lt;= n; j++) cout \u0026lt;\u0026lt; v[j] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[j == n]; swap(v[i - 1], v[i]); } } return 0; } C. Increase Subarray Sums 给定一个长为 $n$ 的序列 $\\{a_i\\}$，每次操作可以选择一个位置加上 $x$。记 $f(k)$ 为经过 $k$ 次操作后，最大的连续子序列和。\n分析 第一想法是贪心，但是 $f(n)$ 的选择可能和 $f(n-1)$ 完全不同。\n注意到我们之所以不能延后加 $x$，是因为答案长度不一定长于 $k$。只需把不同长度的答案分开即可，这可以通过 DP 得到。\nint main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n, x; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; a(n); for (auto \u0026amp;ai : a) cin \u0026gt;\u0026gt; ai; vector\u0026lt;int\u0026gt; dp(n + 1, -1E9); dp[0] = 0; for (int i = 0; i \u0026lt; n; i++) { int sum = 0; for (int j = i; j \u0026lt; n; j++) { sum += a[j]; dp[j - i + 1] = max(sum, dp[j - i + 1]); } } for (int k = 0; k \u0026lt;= n; k++) { int ans = 0; for (int i = 0; i \u0026lt;= n; i++) ans = max(ans, dp[i] + min(i, k) * x); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[k == n]; } } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-02/cf1644/","summary":"A. Doors and Keys 有 RGB 三种门，和 rgb 三种钥匙。如果门先于其对应的钥匙出现，则会卡关。判断字符串是否意味着卡关。\n分析 枚举即可。\nint main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; flag(26); bool ans = true; for (char si : s) { if (si \u0026gt;= \u0026#39;a\u0026#39;) { flag[si - \u0026#39;a\u0026#39;] = true; } else { if (!flag[si - \u0026#39;A\u0026#39;]) { ans = false; } } } if (ans) cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; } return 0; } B.","title":"Educational Codeforces Round 123 (Rated for Div. 2)(A-C)"},{"content":"题目大意 给定一个长为 $n$ 的数列 $\\{a_i\\}$，有如下操作\n询问区间 $[l, r]$ 上的和。 对 $[l, r]$ 区间上每个数异或上一个数 $x$。 分析 只需注意到异或是不进位的，我们可以单独维护数列的每一位。开二十棵线段树即可。\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } vector\u0026lt;SegmentTree\u0026lt;int\u0026gt;\u0026gt; tr; for (int k = 0; k \u0026lt; 20; k++) { tr.push_back(SegmentTree\u0026lt;int\u0026gt;(n + 1)); vector\u0026lt;int\u0026gt; tmp(n + 1); for (int i = 1; i \u0026lt;= n; i++) { if ((1 \u0026lt;\u0026lt; k) \u0026amp; a[i]) tmp[i] = 1; } tr[k].build(tmp); } int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int op, l, r; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; if (op == 1) { ll ans = 0; for (int k = 0; k \u0026lt; 20; k++) { ans += 1ll * tr[k].query(l, r) \u0026lt;\u0026lt; k; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { int x; cin \u0026gt;\u0026gt; x; for (int k = 0; k \u0026lt; 20; k++) { if (x \u0026amp; (1 \u0026lt;\u0026lt; k)) { tr[k].modify(l, r, 1); } } } } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-02/cf242e/","summary":"题目大意 给定一个长为 $n$ 的数列 $\\{a_i\\}$，有如下操作\n询问区间 $[l, r]$ 上的和。 对 $[l, r]$ 区间上每个数异或上一个数 $x$。 分析 只需注意到异或是不进位的，我们可以单独维护数列的每一位。开二十棵线段树即可。\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } vector\u0026lt;SegmentTree\u0026lt;int\u0026gt;\u0026gt; tr; for (int k = 0; k \u0026lt; 20; k++) { tr.push_back(SegmentTree\u0026lt;int\u0026gt;(n + 1)); vector\u0026lt;int\u0026gt; tmp(n + 1); for (int i = 1; i \u0026lt;= n; i++) { if ((1 \u0026lt;\u0026lt; k) \u0026amp; a[i]) tmp[i] = 1; } tr[k].","title":"CF242E XOR on Segment"},{"content":"题目大意 给定一个长度为 $n$ 的字符序列，初始全是 L。\n有 $q$ 次操作，每次将 $a_x$ 在 L 和 R 中切换。\n求每次操作后字符串中最长交错序列的长度。\n分析 首先需要逐位异或，把交错序列变成相同元素。我想到的是另一种办法，如果 $a_i$ 相对与 $a_{i-1}$ 是变化的，那么 $b_i$ 为 $1$。原问题即被转化为维护最长 $1$ 的个数。\n用线段树维护每一层的信息，其中 $l$ 表示左边界上的最长长度，$r$ 表示右边界上的最长长度，$val$ 表示整个区间上的最长长度。\n关键在于如何编写 pull 合并信息。\n如果整块区域都是 $1$，那么可以和另一块区域合并。 合并后的 $val$ 应该考虑在左边界、右边界、左子树、右子树和中间中取。 struct SegmentTree { vector\u0026lt;int\u0026gt; l, r, val; int N; SegmentTree(int n) { N = 2 \u0026lt;\u0026lt; std::__lg(n); l.resize(N * 2, 0); r.resize(N * 2, 0); val.resize(N * 2, 0); } void pull(int p, int len) { int ls = p * 2, rs = p * 2 + 1; l[p] = l[ls], r[p] = r[rs]; if (l[ls] == len) l[p] += l[rs]; if (r[rs] == len) r[p] += r[ls]; val[p] = max({l[p], r[p], val[ls], val[rs], r[ls] + l[rs]}); } void modify(int i) { i += N; l[i] = r[i] = val[i] = !val[i]; int len = 1; for (int k = i / 2; k \u0026gt;= 1; k /= 2, len *= 2) { pull(k, len); } } }; ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-02/p6492/","summary":"题目大意 给定一个长度为 $n$ 的字符序列，初始全是 L。\n有 $q$ 次操作，每次将 $a_x$ 在 L 和 R 中切换。\n求每次操作后字符串中最长交错序列的长度。\n分析 首先需要逐位异或，把交错序列变成相同元素。我想到的是另一种办法，如果 $a_i$ 相对与 $a_{i-1}$ 是变化的，那么 $b_i$ 为 $1$。原问题即被转化为维护最长 $1$ 的个数。\n用线段树维护每一层的信息，其中 $l$ 表示左边界上的最长长度，$r$ 表示右边界上的最长长度，$val$ 表示整个区间上的最长长度。\n关键在于如何编写 pull 合并信息。\n如果整块区域都是 $1$，那么可以和另一块区域合并。 合并后的 $val$ 应该考虑在左边界、右边界、左子树、右子树和中间中取。 struct SegmentTree { vector\u0026lt;int\u0026gt; l, r, val; int N; SegmentTree(int n) { N = 2 \u0026lt;\u0026lt; std::__lg(n); l.resize(N * 2, 0); r.resize(N * 2, 0); val.resize(N * 2, 0); } void pull(int p, int len) { int ls = p * 2, rs = p * 2 + 1; l[p] = l[ls], r[p] = r[rs]; if (l[ls] == len) l[p] += l[rs]; if (r[rs] == len) r[p] += r[ls]; val[p] = max({l[p], r[p], val[ls], val[rs], r[ls] + l[rs]}); } void modify(int i) { i += N; l[i] = r[i] = val[i] = !","title":"P6492 STEP"},{"content":"本次比赛 A 题还是出了小锅，幸好发现的比较早，最后影响还算不大。\nA - ABC202A 签到，不讲。我没想到读假了还能过（\nint main() { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; cout \u0026lt;\u0026lt; 21 - a - b - c; return 0; } B - CF567A 注意到座标是按照从小到大顺序的，那么对于第 $i$ 个人，最小值显然在 $x_{i-1}, x_{i+1}$ 中取到，最大值在 $x_{1}, x_n$ 中取到。\n注意特判左右两边。\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v(n); for (auto \u0026amp;vi : v) cin \u0026gt;\u0026gt; vi; for (int i = 0; i \u0026lt; n; i++) { int m1, m2; if (i == 0) { m1 = v[1] - v[i], m2 = v[n - 1] - v[i]; } else if (i == n - 1) { m2 = v[i] - v[0], m1 = v[i] - v[i - 1]; } else { m1 = min(v[i] - v[i - 1], v[i + 1] - v[i]); m2 = max(v[i] - v[0], v[n - 1] - v[i]); } cout \u0026lt;\u0026lt; m1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; m2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } C - CF765B 即第 $i$ 个字母第一次出现时，第 $1 \\sim i - 1$ 个字母都应该出现过。\nint main() { string s; cin \u0026gt;\u0026gt; s; char past = \u0026#39;a\u0026#39; - 1; for (auto si : s) { if (si \u0026gt; past) { if (si - past != 1) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34;; return 0; } past = si; } } cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34;; return 0; } D - CF675B 注意到中间那个格子取 $1 \\sim n$ 都行，四个角上的数字则是互相牵制的，可以枚举得到。\n或者进一步，四个数字之间的相对差值是固定的，答案只能在一个区间中取。我们可以直接计算出这个区间。\nint main() { ll a, b, c, d, n; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; auto il = {a + b, b + d, d + c, c + a}; ll L = max(il) - min(il) + 1, R = n; cout \u0026lt;\u0026lt; n * max\u0026lt;ll\u0026gt;(R - L + 1, 0); return 0; } E - CF660C 我们即需要找到最长的区间，其中 $0$ 的个数不超过 $k$。\n可以考虑枚举区间的右端点 $r$。当 $r$ 固定时，设 $[l,r]$ 中 $0$ 的个数是关于 $f(l)$ 的函数，那么 $f(l)$ 显然关于 $l$ 递减。可以使用二分寻找最左边且符合要求的 $l$。时间复杂度 $O(n \\log n)$。\n更进一步，可以考虑双指针法，时间复杂度 $O(n)$。\nint main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; v(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; v[i]; } int L = 0, R = -1, sum0 = 0; int tl = 0, tr = -1; for (int i = 0; i \u0026lt; n; i++) { if (v[i] == 0) { sum0++; while (sum0 \u0026gt; k) { sum0 -= v[tl++] == 0; } } tr = i; if (tr - tl \u0026gt; R - L) { L = tl, R = tr; } } int ans = R - L + 1; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; fill_n(v.begin() + L, ans, 1); for (auto vi : v) { cout \u0026lt;\u0026lt; vi \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } F - CF1208D 注意到最右边，$s_n$ 包含了所有比 $p_n$ 小的数，据此可以直接计算出 $p_n$。\n对于 $s_{n-1}$，我们可以排除掉 $p_n$ 的影响，那么 $p_{n-1}$ 也是类似可以直接计算的。如此前推，计算出所有的 $p$。\n具体的说，用树状数组维护 $1 \\sim n$ 的和，那么 $s_n$ 必然在树状数组中出现。找到 $p_n$ 后，树状数组减去 tr.add(p[n], -p[n])。之后，$s_{n-1}$ 也在树状数组中出现，再减去。以此类推。\n即是树状数组上二分，朴素实现的时间复杂度是 $O(n \\log^2 n)$，略微优化可以做到 $O(n \\log n)$。\ntemplate \u0026lt;class T\u0026gt; struct fwtree_1 { vector\u0026lt;T\u0026gt; v; fwtree_1(int n = 0) : v(n) {} int len() { return v.size(); } void add(int i, T x) { for (; 0 \u0026lt; i \u0026amp;\u0026amp; i \u0026lt; len(); i += i \u0026amp; -i) v[i] += x; } T sum(int i) { T sum = 0; for (; i \u0026gt; 0; i -= i \u0026amp; -i) sum += v[i]; return sum; } T sum(int l, int r) { return sum(r) - sum(l - 1); } int find(T x) { int i = 0; for (int k = 2 \u0026lt;\u0026lt; std::__lg(len()); k \u0026gt;= 1; k \u0026gt;\u0026gt;= 1) { int u = i + k; if (u \u0026lt; len() \u0026amp;\u0026amp; v[u] \u0026lt;= x) i = u, x -= v[u]; } return i; } }; int main() { int n; cin \u0026gt;\u0026gt; n; fwtree_1\u0026lt;ll\u0026gt; tr(n + 1); vector\u0026lt;ll\u0026gt; s(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; s[i]; tr.add(i, i); } vector\u0026lt;int\u0026gt; v(n + 1); for (int i = n; i \u0026gt;= 1; i--) { v[i] = tr.find(s[i]) + 1; tr.add(v[i], -v[i]); } for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } G - CF433C 若我们把第 $x$ 页合到第 $y$ 页，那么受影响的只有序列 $a$ 中所有 $x$ 相邻元素。我们可以考虑对 $1 \\sim n$ 的所有页码，记录所有与其相邻元素。\n假设对于页面 $x$，我们记录了所有相邻元素于 $\\{e_x\\}$ 中，当页面 $x$ 应该与序列 $\\{e_x\\}$ 的中位数合并时最优。\n获取中位数可以简单的通过排序得到。注意，相邻元素不能和自己相同，否则修改时应注意。\nint main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; v(m); for (auto \u0026amp;vi : v) cin \u0026gt;\u0026gt; vi; ll ans = 0; for (int i = 0; i \u0026lt; m - 1; i++) { ans += abs(v[i] - v[i + 1]); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; e(n + 1); for (int i = 0; i \u0026lt; m; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; v[i - 1] != v[i]) e[v[i]].push_back(v[i - 1]); if (i \u0026lt; m - 1 \u0026amp;\u0026amp; v[i + 1] != v[i]) e[v[i]].push_back(v[i + 1]); } ll sum = 0; for (int i = 1; i \u0026lt;= n; i++) { if (e[i].empty()) continue; sort(e[i].begin(), e[i].end()); int mid = e[i][(e[i].size() - 1) / 2]; ll s1 = 0, s2 = 0; for (auto eii : e[i]) { s1 += abs(mid - eii); s2 += abs(i - eii); } sum = max(sum, s2 - s1); } cout \u0026lt;\u0026lt; ans - sum; return 0; } H - ABC227G 这题一点也不数论呀，怎么没人做呢。\n注意到\n$$ \\binom{N}{K} = \\frac{N(N-1)\\cdots(N-K+1)}{1\\cdots (K-1)K} $$\n我们可以考虑对于每个质因子，分开计算其贡献。再注意到 $K \\leqslant 10^6$，这说明我们需要处理的数最多不会超过 $10^6$ 个，不用被 $N$ 吓到。\n处理时也需要一点技巧。不能分别对所有的 $1 \\sim K$ 因式分解，我们批量计算时可以仿照筛法，可以直接筛去 $2p,3p,\\cdots$。\n而对于大于 $\\sqrt{N}$ 的质因子，因为这些大的质因子每个数最多只有 $1$ 个，我们可以最后去除。\n对于 $1\\sim n$ 的计算还可以采用一些优化。回想 LightOJ - Trailing Zeroes (III)\n$n!$ 的末尾有几个零？$\\Longrightarrow$ $n!$ 有几个因子 $5$？\n类似的，可以通过不断对 $p$ 除去直接得到答案，不必真的计算。\nusing pll = pair\u0026lt;ll, ll\u0026gt;; const int P = 998244353; vector\u0026lt;bool\u0026gt; notp; vector\u0026lt;int\u0026gt; primes; void Euler(int n) { notp.resize(n + 1); auto _ = [\u0026amp;](int i) { if (!notp[i]) primes.push_back(i); for (auto pj : primes) { if (pj \u0026gt; n / i) break; notp[i * pj] = true; if (i % pj == 0) break; } }; _(2), _(3), _(5); for (int i = 1; i \u0026lt;= n / 6; i++) { _(i * 6 + 1), _(i * 6 + 5); } } int main() { ll n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; Euler(max\u0026lt;int\u0026gt;(sqrt(n * 1.0) + 1, k)); vector\u0026lt;ll\u0026gt; v2(k + 1); for (int i = 1; i \u0026lt;= k; i++) { v2[i] = n - k + i; } ll ans = 1; for (auto p : primes) { int cnt = 0; int tk = k; while (tk \u0026gt; 0) { tk /= p, cnt -= tk; } for (int i = p - (n - k) % p; i \u0026lt;= k; i += p) { while (v2[i] % p == 0) { cnt++, v2[i] /= p; } } ans = ans * (cnt + 1) % P; } for (auto v2i : v2) if (v2i \u0026gt; 1) ans = ans * 2 % P; cout \u0026lt;\u0026lt; ans; return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-02/hj6/","summary":"本次比赛 A 题还是出了小锅，幸好发现的比较早，最后影响还算不大。\nA - ABC202A 签到，不讲。我没想到读假了还能过（\nint main() { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; cout \u0026lt;\u0026lt; 21 - a - b - c; return 0; } B - CF567A 注意到座标是按照从小到大顺序的，那么对于第 $i$ 个人，最小值显然在 $x_{i-1}, x_{i+1}$ 中取到，最大值在 $x_{1}, x_n$ 中取到。\n注意特判左右两边。\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v(n); for (auto \u0026amp;vi : v) cin \u0026gt;\u0026gt; vi; for (int i = 0; i \u0026lt; n; i++) { int m1, m2; if (i == 0) { m1 = v[1] - v[i], m2 = v[n - 1] - v[i]; } else if (i == n - 1) { m2 = v[i] - v[0], m1 = v[i] - v[i - 1]; } else { m1 = min(v[i] - v[i - 1], v[i + 1] - v[i]); m2 = max(v[i] - v[0], v[n - 1] - v[i]); } cout \u0026lt;\u0026lt; m1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; m2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } C - CF765B 即第 $i$ 个字母第一次出现时，第 $1 \\sim i - 1$ 个字母都应该出现过。","title":"ZAFU 2022.02.16 个人赛题解"},{"content":"本次比赛翻译出现了大问题，想大家道歉。\n同时一些同学反映已经做过，下次个人赛会再拉更早的题目。\nA - ABC222A 签到，不讲。\nint main() { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); printf(\u0026#34;%04d\u0026#34;, x); return 0; } B - CF1395A 题目大意 给定四种颜色的球，允许把三个红、绿、蓝的球转换为三个白色的，问是否存在方法使得能够排成回文的一列。\n分析 注意到四种颜色个数只有 $0$ 个或 $1$ 个奇数时，才能够摆成回文的一列。\n而转换对四种颜色都意味着奇数变偶数，偶数变奇数。即转换两次又回到原先的奇偶序列，故只用变换一次。\nbool check(const vector\u0026lt;int\u0026gt; \u0026amp;v) { vector\u0026lt;int\u0026gt; cnt(2); for (auto i : v) { if (i \u0026lt; 0) return false; cnt[i % 2]++; } return cnt[1] \u0026lt;= 1; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { vector\u0026lt;int\u0026gt; v1(4), v2(4); for (int i = 0; i \u0026lt; 4; i++) cin \u0026gt;\u0026gt; v1[i], v2[i] = v1[i]; v2[0]--, v2[1]--, v2[2]--, v2[3] += 3; if (check(v1) || check(v2)) { printf(\u0026#34;Yes\\n\u0026#34;); } else { printf(\u0026#34;No\\n\u0026#34;); } } return 0; } C - CF1393B 题目大意 给定一些长度，问是否能够组成一个长方形和一个正方形。\n分析 分类需要分的很仔细。\n如果有 $(2, 2, 2, 2)$，那么可以拼成两个长方形。 如果有 $(2, 2, 4)$，那么可以拼成一个长方形和一个正方形。 如果有 $(2, 6)$，那么可以拼成一个长方形和一个正方形。 如果有 $(4, 4)$，那么可以拼成两个正方形。 如果有 $(8)$，那么可以拼成两个正方形。 如此\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(N + 1); for (int i = 1; i \u0026lt;= n; i++) { int t; cin \u0026gt;\u0026gt; t; a[t]++; } vector\u0026lt;int\u0026gt; num(10); auto add = [\u0026amp;](int t) { for (int j = 1; j \u0026lt;= min(t, 8); j++) { num[j]++; } }; auto sub = [\u0026amp;](int t) { for (int j = 1; j \u0026lt;= min(t, 8); j++) { num[j]--; } }; for (int i = 1; i \u0026lt;= N; i++) { add(a[i]); } int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { string op; int x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; sub(a[x]); if (op[0] == \u0026#39;+\u0026#39;) { a[x]++; } else { a[x]--; } add(a[x]); if (num[8] \u0026gt;= 1) { printf(\u0026#34;YES\\n\u0026#34;); } else if (num[6] \u0026gt;= 1 \u0026amp;\u0026amp; num[2] \u0026gt;= 2) { printf(\u0026#34;YES\\n\u0026#34;); } else if (num[4] \u0026gt;= 1 \u0026amp;\u0026amp; num[2] \u0026gt;= 3) { printf(\u0026#34;YES\\n\u0026#34;); } else if (num[4] \u0026gt;= 2) { printf(\u0026#34;YES\\n\u0026#34;); } else { printf(\u0026#34;NO\\n\u0026#34;); } } return 0; } D - CF908C 题目大意 有 $n$ 个半径为 $r$ 的盘子，当盘子碰到地面或者另一个盘子时立刻停止。给定每个盘子的 $x_i$，求解 $y_i$。\n分析 对每一个盘子，计算其与之前所有盘子的距离即可，解一个二次方程。\nint main() { int n; double r; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; r; vector\u0026lt;double\u0026gt; x(n), y(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x[i]; y[i] = r; for (int j = 0; j \u0026lt; i; j++) { double tx = x[i] - x[j]; double delta = 4 * r * r - tx * tx; if (delta + 1E-8 \u0026gt;= 0) { y[i] = max(y[j] + sqrt(delta), y[i]); } } printf(\u0026#34;%.10lf \u0026#34;, y[i]); } return 0; } E - CF1395C 题目大意 给定两个非负的整数数组 $a_1,\\cdots, a_n$ 和 $b_1,\\cdots,b_m$。\n对于每个 $i(1 \\leqslant i \\leqslant n)$，你可以选择一个 $j(1 \\leqslant j \\leqslant m)$ 并让\n$$ c_i = a_i \\land b_j $$\n需要让 $ c_1 \\lor \\cdots \\lor c_n $ 尽可能小。\n分析 注意到答案不可能超过 $512$，可以考虑枚举答案。\nint main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; va(n), vb(m); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; va[i]; } for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; vb[i]; } vector\u0026lt;int\u0026gt; vis(n); for (int o = 0; o \u0026lt; 512; o++) { bool f1 = true; for (int i = 0; i \u0026lt; n; i++) { bool f2 = false; for (int j = 0; j \u0026lt; m; j++) { int x = va[i] \u0026amp; vb[j]; if ((o | x) == o) { f2 = true; break; } } if (!f2) { f1 = false; break; } } if (f1) { cout \u0026lt;\u0026lt; o \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; } } return 0; } F - CF911D 题目大意 给定一个排列，支持操作 $[l,r]$ 翻转，问每次操作后排列的奇偶性。\n分析 回想一下线性代数的知识，交换两个数后，排列奇变偶，偶变奇。\n而区间翻转可以分解为交换两个数，故答案与翻转的长度有关。\nint main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; v(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; v[i]; int ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (v[i] \u0026gt; v[j]) ans++; } } ans %= 2; int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; int num = (r - l + 1) / 2; ans = (ans + num) % 2; if (ans == 1) printf(\u0026#34;odd\\n\u0026#34;); else printf(\u0026#34;even\\n\u0026#34;); } return 0; } G - 2020 CCPC 长春 D 本题是一场区域赛的真题，是该场的第二签到，过题人数 289/320。本题用来给大家对照自身水平。\n分析 注意到 $a_i = c^{\\operatorname{popcount}(i)}$，使用一些数位 DP 的技巧即可求和。\nH - ABC212G 分析 本题考察了 $\\varphi(n)$ 函数性质的简单应用。\n因为给定的 $p$ 一定是质数，也就一定存在原根 $g$，从而可以取离散对数。即\n$$ n \\log x \\equiv \\log y \\pmod {p-1} $$\n那么对于每个 $\\log x$，存在的 $\\log y$ 的个数为 $\\frac{p-1}{\\gcd(\\log x, p - 1)}$，那么求和即是答案\n$$ \\begin{aligned} \\sum_{a=1}^n \\frac{p - 1}{\\gcd(a, p - 1)} \u0026amp;= \\sum_{u \\mid p - 1}\\sum_{a=1}^n \\frac{p-1}{u}[\\gcd(a, p - 1) = u] \\\\ \u0026amp; = \\sum_{u \\mid p - 1} \\frac{p-1}{u} \\varphi\\left(\\frac{p-1}{u}\\right)\\\\ \u0026amp;= \\sum_{u \\mid p - 1} u \\varphi(u) \\end{aligned} $$\n令 $f(n) = \\sum_{u \\mid n} u \\varphi(u)$，注意到 $f$ 是一个积性函数，我们可以直接计算其在质数处的点值\n$$ f(p^e) = 1 + \\sum_{i=1}^e p^i \\varphi(p^i) = 1 + (p-1) \\sum_{i=1}^e p^{2i - 1} $$\n用等比数列还是直接求和都行，因为 $e$ 不会很大。最后用因式分解合并答案即可。\nconst int P = 998244353; using pll = pair\u0026lt;ll, ll\u0026gt;; vector\u0026lt;pll\u0026gt; factor(ll n) { vector\u0026lt;pll\u0026gt; ret; for (ll i = 2; 1ll * i * i \u0026lt;= n; i++) { int cnt = 0; while (n % i == 0) { n /= i, cnt++; } if (cnt \u0026gt; 0) { ret.push_back({i, cnt}); } } if (n \u0026gt; 1) { ret.push_back({n, 1}); } return ret; } int main() { ll pp, ans = 1; cin \u0026gt;\u0026gt; pp; for (auto [p, e] : factor(pp - 1)) { ll pk = 1, tsum = 1; p %= P; for (int k = 1; k \u0026lt;= e; k++) { tsum += 1ll * pk * pk % P * (p - 1) % P * p % P; pk = 1ll * pk * p % P; } ans = 1ll * ans * tsum % P; } cout \u0026lt;\u0026lt; (ans + 1) % P; return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-02/hj5/","summary":"本次比赛翻译出现了大问题，想大家道歉。\n同时一些同学反映已经做过，下次个人赛会再拉更早的题目。\nA - ABC222A 签到，不讲。\nint main() { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); printf(\u0026#34;%04d\u0026#34;, x); return 0; } B - CF1395A 题目大意 给定四种颜色的球，允许把三个红、绿、蓝的球转换为三个白色的，问是否存在方法使得能够排成回文的一列。\n分析 注意到四种颜色个数只有 $0$ 个或 $1$ 个奇数时，才能够摆成回文的一列。\n而转换对四种颜色都意味着奇数变偶数，偶数变奇数。即转换两次又回到原先的奇偶序列，故只用变换一次。\nbool check(const vector\u0026lt;int\u0026gt; \u0026amp;v) { vector\u0026lt;int\u0026gt; cnt(2); for (auto i : v) { if (i \u0026lt; 0) return false; cnt[i % 2]++; } return cnt[1] \u0026lt;= 1; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { vector\u0026lt;int\u0026gt; v1(4), v2(4); for (int i = 0; i \u0026lt; 4; i++) cin \u0026gt;\u0026gt; v1[i], v2[i] = v1[i]; v2[0]--, v2[1]--, v2[2]--, v2[3] += 3; if (check(v1) || check(v2)) { printf(\u0026#34;Yes\\n\u0026#34;); } else { printf(\u0026#34;No\\n\u0026#34;); } } return 0; } C - CF1393B 题目大意 给定一些长度，问是否能够组成一个长方形和一个正方形。","title":"ZAFU 2022.02.14 个人赛题解"},{"content":"新的一年，一样的菜。\n过于简单的题不记录。\n2022 年 01 月 01-14 | UOJ50 链式反应\n01-21 | ZAFU 2022.01.18 个人赛题解\n01-27 | P3373 线段树 2\n01-27 | P2023 维护序列\n01-28 | P1531 I Hate It\n01-28 | P5057 简单题\n01-28 | P4588 数学计算\n01-28 | P1637 三元上升子序列\n01-29 | P5431 乘法逆元 2\n2022 年 02 月 02-11 | P6186 冒泡排序\n02-14 | ZAFU 2022.02.14 个人赛题解\n02-16 | ZAFU 2022.02.16 个人赛题解\n02-22 | P6492 STEP\n2022 年 03 月 03-09 | P4717 快速莫比乌斯/沃尔什变换\n03-09 | P5110 块速递推\n03-22 | P5487 Berlekamp–Massey 算法\n03-22 | P4389 付公主的背包\n03-22 | P3366 最小生成树\n03-23 | P3389 高斯消元法\n03-24 | P4391 Radio Transmission 无线传输\n03-26 | P4841 城市规划\n03-29 | P2894 Hotel G\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/log2022/","summary":"新的一年，一样的菜。\n过于简单的题不记录。\n2022 年 01 月 01-14 | UOJ50 链式反应\n01-21 | ZAFU 2022.01.18 个人赛题解\n01-27 | P3373 线段树 2\n01-27 | P2023 维护序列\n01-28 | P1531 I Hate It\n01-28 | P5057 简单题\n01-28 | P4588 数学计算\n01-28 | P1637 三元上升子序列\n01-29 | P5431 乘法逆元 2\n2022 年 02 月 02-11 | P6186 冒泡排序\n02-14 | ZAFU 2022.02.14 个人赛题解\n02-16 | ZAFU 2022.02.16 个人赛题解\n02-22 | P6492 STEP\n2022 年 03 月 03-09 | P4717 快速莫比乌斯/沃尔什变换","title":"2022 年刷题日志"},{"content":"题目大意 给定一个长为 $n$ 的排列 $p$，有如下操作\n交换 $p_{x}, p_{x+1}$。 询问排列经过 $k$ 轮冒泡排序后的逆序数。 分析 难点在观察冒泡排序对逆序数的影响，考虑一个数 $p_i$ 受其前面的数影响：\n如果 $p_i$ 前面没有比 $p_i$ 大的，冒泡后 $p_{i\u0026rsquo;}$ 仍不贡献逆序数。 如果 $p_i$ 前面有 $j$ 个比当前数大的，冒泡后有且仅有一个数穿过了 $p_{i\u0026rsquo;}$，贡献的逆序数减 $1$。 故第 $k$ 轮冒泡后，即每个数贡献的逆序数都要减 $k$。又因为不应减到负数，因此需要用两个树状数组维护。\n#include \u0026#34;template/ds/fwtree/1.hpp\u0026#34; int main() { int n = rr(), m = rr(); vector\u0026lt;int\u0026gt; p(n); for (int i = 0; i \u0026lt; n; i++) p[i] = rr(); vector\u0026lt;ll\u0026gt; inver(n); { vector\u0026lt;pii\u0026gt; tp(n); for (int i = 0; i \u0026lt; n; i++) tp[i] = {p[i], i + 1}; sort(tp.begin(), tp.end()); fwtree_1\u0026lt;ll\u0026gt; tr(n + 1); for (auto [x, i] : tp) { inver[i - 1] = i - 1 - tr.sum(1, i); tr.add(i, 1); } } fwtree_1\u0026lt;ll\u0026gt; tr1(n + 1), tr2(n + 1); for (auto ii : inver) { tr1.add(ii, 1), tr2.add(ii, ii); } while (m--) { int op = rr(); if (op == 1) { int x = rr() - 1; swap(p[x], p[x + 1]); swap(inver[x], inver[x + 1]); if (p[x] \u0026lt; p[x + 1]) { auto \u0026amp;ii = inver[x]; tr1.add(ii, -1); tr2.add(ii, -ii); ii--; tr1.add(ii, 1); tr2.add(ii, ii); } else { auto \u0026amp;ii = inver[x + 1]; tr1.add(ii, -1); tr2.add(ii, -ii); ii++; tr1.add(ii, 1); tr2.add(ii, ii); } } else { ll k = rr(); if (k \u0026gt; n) { printf(\u0026#34;0\\n\u0026#34;); } else { ll ans = tr2.sum(k, n); ans -= tr1.sum(k, n) * k; printf(\u0026#34;%lld\\n\u0026#34;, ans); } } } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-02/p6186/","summary":"题目大意 给定一个长为 $n$ 的排列 $p$，有如下操作\n交换 $p_{x}, p_{x+1}$。 询问排列经过 $k$ 轮冒泡排序后的逆序数。 分析 难点在观察冒泡排序对逆序数的影响，考虑一个数 $p_i$ 受其前面的数影响：\n如果 $p_i$ 前面没有比 $p_i$ 大的，冒泡后 $p_{i\u0026rsquo;}$ 仍不贡献逆序数。 如果 $p_i$ 前面有 $j$ 个比当前数大的，冒泡后有且仅有一个数穿过了 $p_{i\u0026rsquo;}$，贡献的逆序数减 $1$。 故第 $k$ 轮冒泡后，即每个数贡献的逆序数都要减 $k$。又因为不应减到负数，因此需要用两个树状数组维护。\n#include \u0026#34;template/ds/fwtree/1.hpp\u0026#34; int main() { int n = rr(), m = rr(); vector\u0026lt;int\u0026gt; p(n); for (int i = 0; i \u0026lt; n; i++) p[i] = rr(); vector\u0026lt;ll\u0026gt; inver(n); { vector\u0026lt;pii\u0026gt; tp(n); for (int i = 0; i \u0026lt; n; i++) tp[i] = {p[i], i + 1}; sort(tp.","title":"P6186 冒泡排序"},{"content":"题目大意 给定 $n$ 个正整数 $\\{a_i\\}$ 和 $k$，求在模 $p$ 意义下的\n$$ \\sum_{i=1}^n \\frac{k^i}{a_i} \\bmod p $$\n分析 逐个求逆元是 $O(n \\log p)$ 的，肯定会 T，需要想想别的办法。\n批量求逆元的一个技巧，先求出 $a_i$ 的前缀积，然后求出全部积的逆元，再逐个往前推。即\n$$ (a_n)^{-1} = \\left(\\prod_{i=1}^{n-1} a_i\\right) \\left(\\prod_{i=1}^n a_i\\right)^{-1} $$\n显然，$\\{a_n\\}$ 中不能有 $0$。\nvi get_inv(const vi \u0026amp;a, int p) { int n = a.size() - 1; vi prod(n + 1); prod[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { prod[i] = 1ll * prod[i - 1] * a[i] % p; } prod[n] = qpow(prod[n], p - 2, p); vi iva(n + 1); for (int i = n; i \u0026gt;= 1; i--) { iva[i] = 1ll * prod[i] * prod[i - 1] % p; prod[i - 1] = 1ll * prod[i] * a[i] % p; } return iva; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p5431/","summary":"题目大意 给定 $n$ 个正整数 $\\{a_i\\}$ 和 $k$，求在模 $p$ 意义下的\n$$ \\sum_{i=1}^n \\frac{k^i}{a_i} \\bmod p $$\n分析 逐个求逆元是 $O(n \\log p)$ 的，肯定会 T，需要想想别的办法。\n批量求逆元的一个技巧，先求出 $a_i$ 的前缀积，然后求出全部积的逆元，再逐个往前推。即\n$$ (a_n)^{-1} = \\left(\\prod_{i=1}^{n-1} a_i\\right) \\left(\\prod_{i=1}^n a_i\\right)^{-1} $$\n显然，$\\{a_n\\}$ 中不能有 $0$。\nvi get_inv(const vi \u0026amp;a, int p) { int n = a.size() - 1; vi prod(n + 1); prod[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { prod[i] = 1ll * prod[i - 1] * a[i] % p; } prod[n] = qpow(prod[n], p - 2, p); vi iva(n + 1); for (int i = n; i \u0026gt;= 1; i--) { iva[i] = 1ll * prod[i] * prod[i - 1] % p; prod[i - 1] = 1ll * prod[i] * a[i] % p; } return iva; } ","title":"P5431 乘法逆元 2"},{"content":"题目大意 给定一个序列，求其中三元上升子序列的个数\n对于 $i,j,k$，若 $a_i \u0026lt; a_j \u0026lt; a_k$，则是一个满足要求的三元对。 分析 考虑枚举中间的数 $j$，设其左边有 $a$ 个数比它小，右边有 $b$ 个数比它大，则中间为 $j$ 的三元对个数为 $ab$。\n至此就和逆序对类似了，离散化后用树状数组即可。\n#include \u0026#34;template/ds/fwtree/0.hpp\u0026#34; int main() { int n = rr(); vector\u0026lt;pii\u0026gt; v(n + 1); for (int i = 1; i \u0026lt;= n; i++) { v[i] = {rr(), i}; } sort(v.begin(), v.end(), [](pii a, pii b) { if (a.first == b.first) return a.second \u0026gt; b.second; return a.first \u0026lt; b.first; }); fwtree_1\u0026lt;int\u0026gt; tr(n + 1); vector\u0026lt;ll\u0026gt; al(n + 1), ar(n + 1); for (int i = 1; i \u0026lt;= n; i++) { al[i] = tr.sum(1, v[i].second); tr.add(v[i].second, 1); } tr = fwtree_1\u0026lt;int\u0026gt;(n + 1); for (int i = n; i \u0026gt;= 1; i--) { ar[i] = tr.sum(v[i].second, n); tr.add(v[i].second, 1); } ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) ans += 1ll * al[i] * ar[i]; printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p1637/","summary":"题目大意 给定一个序列，求其中三元上升子序列的个数\n对于 $i,j,k$，若 $a_i \u0026lt; a_j \u0026lt; a_k$，则是一个满足要求的三元对。 分析 考虑枚举中间的数 $j$，设其左边有 $a$ 个数比它小，右边有 $b$ 个数比它大，则中间为 $j$ 的三元对个数为 $ab$。\n至此就和逆序对类似了，离散化后用树状数组即可。\n#include \u0026#34;template/ds/fwtree/0.hpp\u0026#34; int main() { int n = rr(); vector\u0026lt;pii\u0026gt; v(n + 1); for (int i = 1; i \u0026lt;= n; i++) { v[i] = {rr(), i}; } sort(v.begin(), v.end(), [](pii a, pii b) { if (a.first == b.first) return a.second \u0026gt; b.second; return a.first \u0026lt; b.first; }); fwtree_1\u0026lt;int\u0026gt; tr(n + 1); vector\u0026lt;ll\u0026gt; al(n + 1), ar(n + 1); for (int i = 1; i \u0026lt;= n; i++) { al[i] = tr.","title":"P1637 三元上升子序列"},{"content":"题目大意 给定一个数列，有如下操作：\n将区间 $[l,r]$ 上的数乘上 $x$ 将区间 $[l,r]$ 上的数加上 $x$ 询问区间 $[l,r]$ 上的数之和 分析 很经典的线段树教学题，写完后对线段树的理解确实更深了。\n从一次函数的角度考虑问题感觉更清晰。我们实际上在对每个序列上的值做一次函数\n$$ f_i(x) = k_i x + m_i $$\n先来看本题线段树的结构\ntemplate \u0026lt;class T\u0026gt; struct SegmentTree { vector\u0026lt;Seg\u0026gt; tr; void pushup(int p); void pushdown(int p); void build(int l, int r, int p = 1); void modify(int l, int r, T k, T m, int p = 1); T query(int l, int r, int p = 1); }; 懒标记：在知道一段当前值的情况下，可以立刻知道该段被操作后的值，不必重新计算所有的数。因此可以把当前的操作存起来，询问的时候再对子节点做真实操作。\n真实操作也称永久化，操作后懒标记就被下放子节点。懒标记意味着当前节点已经完成了永久化，子节点没有完成，故询问子节点值前需要更新。\npushup：当 $p$ 的子节点被改变时，需要用此方法对节点 $p$ 的值进行更新。 pushdown：当询问 $p$ 的子节点的值时，如果 $p$ 节点有懒标记，则下放到 $p$ 的子节点。 modify：对所有在 $[l,r]$ 区间内的节点做永久化，并打上懒标记。 query：询问在 $[l,r]$ 区间内的节点。 当子节点懒标记上已经有值时，下放标记需要合并，即是函数复合。\n$$ f_i(f_j(x)) = a_i(a_j x + b_j) + b_i = a_ia_j x + a_i b_j + b_i $$\n附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p3373/","summary":"题目大意 给定一个数列，有如下操作：\n将区间 $[l,r]$ 上的数乘上 $x$ 将区间 $[l,r]$ 上的数加上 $x$ 询问区间 $[l,r]$ 上的数之和 分析 很经典的线段树教学题，写完后对线段树的理解确实更深了。\n从一次函数的角度考虑问题感觉更清晰。我们实际上在对每个序列上的值做一次函数\n$$ f_i(x) = k_i x + m_i $$\n先来看本题线段树的结构\ntemplate \u0026lt;class T\u0026gt; struct SegmentTree { vector\u0026lt;Seg\u0026gt; tr; void pushup(int p); void pushdown(int p); void build(int l, int r, int p = 1); void modify(int l, int r, T k, T m, int p = 1); T query(int l, int r, int p = 1); }; 懒标记：在知道一段当前值的情况下，可以立刻知道该段被操作后的值，不必重新计算所有的数。因此可以把当前的操作存起来，询问的时候再对子节点做真实操作。","title":"P3373 线段树 2"},{"content":"题目大意 初始是 $x=1$，我们每轮对 $x$ 做一个操作\n将 $x$ 变为 $k x$，并输出 $x \\bmod M$。 将 $x$ 变为 $x / k_i$，即取消第 $i$ 次操作，并输出 $x \\bmod M$。 保证每个操作 1 的 $k$ 在操作 2 中至多被除一次。\n分析 $M$ 并不保证是质数，逆元可能不存在。\n可以把操作序列看作一个乘积式，初始情况下全为 $1$。\n操作 1 即是把第 $i$ 个数变为 $k$。 操作 2 即是把第 $i$ 个数变回 $1$。 修改结束后，询问所有数的乘积。单点修改，区间查询，标准的线段树。\n因为只询问全体和，zkw 好写的多。\ntemplate \u0026lt;class T\u0026gt; struct SegmentTree { vector\u0026lt;T\u0026gt; tr; int N; SegmentTree(int l, int r) { int n = r - l + 1; N = 2 \u0026lt;\u0026lt; std::__lg(n); tr.resize(N * 2 + 2, 1); } void pushdown(int i) { tr[i] = 1ll * tr[i * 2] * tr[i * 2 + 1] % M; } void modify(int i, T x) { tr[i += N] = x; for (i /= 2; i; i /= 2) { pushdown(i); } } }; 附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p4588/","summary":"题目大意 初始是 $x=1$，我们每轮对 $x$ 做一个操作\n将 $x$ 变为 $k x$，并输出 $x \\bmod M$。 将 $x$ 变为 $x / k_i$，即取消第 $i$ 次操作，并输出 $x \\bmod M$。 保证每个操作 1 的 $k$ 在操作 2 中至多被除一次。\n分析 $M$ 并不保证是质数，逆元可能不存在。\n可以把操作序列看作一个乘积式，初始情况下全为 $1$。\n操作 1 即是把第 $i$ 个数变为 $k$。 操作 2 即是把第 $i$ 个数变回 $1$。 修改结束后，询问所有数的乘积。单点修改，区间查询，标准的线段树。\n因为只询问全体和，zkw 好写的多。\ntemplate \u0026lt;class T\u0026gt; struct SegmentTree { vector\u0026lt;T\u0026gt; tr; int N; SegmentTree(int l, int r) { int n = r - l + 1; N = 2 \u0026lt;\u0026lt; std::__lg(n); tr.","title":"P4588 数学计算"},{"content":"题目大意 给定一个 01 序列，有如下操作：\n将区间 $[l,r]$ 上的数 01 翻转。 询问第 $i$ 个数的值。 分析 区间操作，单点查询，很自然的想到了差分。\n用异或或者加减代替翻转都可以，用树状数组维护。我选择了加减，这样询问时对 $2$ 取余即可。\n#include \u0026#34;template/ds/fwtree/0.hpp\u0026#34; int main() { int n = rr(), m = rr(); fwtree_1\u0026lt;int\u0026gt; tr(n + 2); while (m--) { int t = rr(); if (t == 1) { int l = rr() + 1, r = rr() + 1; tr.modify(l - 1, -1), tr.modify(r, 1); } else { int i = rr(); i = tr.query(i); printf(\u0026#34;%d\\n\u0026#34;, i \u0026amp; 1); } } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p5057/","summary":"题目大意 给定一个 01 序列，有如下操作：\n将区间 $[l,r]$ 上的数 01 翻转。 询问第 $i$ 个数的值。 分析 区间操作，单点查询，很自然的想到了差分。\n用异或或者加减代替翻转都可以，用树状数组维护。我选择了加减，这样询问时对 $2$ 取余即可。\n#include \u0026#34;template/ds/fwtree/0.hpp\u0026#34; int main() { int n = rr(), m = rr(); fwtree_1\u0026lt;int\u0026gt; tr(n + 2); while (m--) { int t = rr(); if (t == 1) { int l = rr() + 1, r = rr() + 1; tr.modify(l - 1, -1), tr.modify(r, 1); } else { int i = rr(); i = tr.","title":"P5057 简单题"},{"content":"我的代码模板依赖于我自定义的预处理器，它通过 DFS 把所有引入的模板展开。\nindex.hpp：公共文件头。 我的模板风格是简单封装：在保持易用的同时，封装尽量的薄。\nData Struct 基础数据结构。\nfwtree/1.hpp：普通树状数组。 fwtree/2.hpp：支持区间修改、区间查询的树状数组。 SegmentTree/1.hpp：普通线段树示例，不可引入。 SegmentTree/2.hpp：带懒标记的线段树示例，不可引入。 Math 基础数学算法。\nqpow.hpp：快速幂。 qpow128.hpp：64 位类型的快速幂。 Basic 我也不知道这东西该放哪，就放到这里吧。\nmodint：m32。 NTT-int 简化多项式板子，码量少，常数较大。\nfps/O.hpp：多项式基础结构，用牛顿迭代完成操作。 fps/F.hpp：与上面的相同，略卡常数。 cdq.hpp：非递归 CDQ 分治。 eval.hpp：多点插值，多点求值。 没有用的 NTT-mint 基于 modint 的多项式板子，注重易用性和常数，码量较大。\n每一种算法可能有多种实现。\n多项式类的定义\npoly/1.hpp：继承于 vector\u0026lt;m32\u0026gt;。 NTT\nntt/1.hpp：无 rev 的 NTT。 ntt/2.hpp：略微卡常的 NTT。 多项式逆\ninv/1.hpp：12E 的牛顿迭代 inv，和 16E 的牛顿迭代 div。 inv/2.hpp：10E 的牛顿迭代 inv，和 13E 的牛顿迭代 div。 inv/3.hpp：24E 的牛顿迭代 inv，和 28E 的牛顿迭代 div。 inv/6.hpp：半在线卷积实现的 inv \u0026amp; div。 inv/7.hpp：全在线卷积实现的 inv \u0026amp; div。（没啥用） inv/8.hpp：10E 的分块牛顿迭代 inv，和 10E 的分块牛顿迭代 div。 多项式 exp\nexp/1.hpp：20E 的牛顿迭代 exp。 exp/2.hpp：17E 的牛顿迭代 exp。 exp/3.hpp：32E 的牛顿迭代 exp。 exp/5.hpp：半在线卷积实现的 exp。 exp/6.hpp：全在线卷积实现的 exp。（没啥用） exp/7.hpp：14E 的分块牛顿迭代 exp。 半在线卷积（CDQ 分治）\ncdq/3.hpp：2 叉的半在线卷积实现，不保存卷积结果。 cdq/4.hpp：B 叉的半在线卷积实现，不保存卷积结果。 cdq/5.hpp：2 叉的半在线卷积实现，保存卷积结果。 cdq/6.hpp：B 叉的半在线卷积实现，保存卷积结果。 cdq/7.hpp：略微卡常的 B 叉在线卷积实现。 全在线卷积\noc/1.hpp：全在线卷积的实现。（感觉挺快的 多项式 sqrt\nsqrt/1.hpp：11E 的牛顿迭代 sqrt。 sqrt/5.hpp：全在线卷积实现的 sqrt。 sqrt/8.hpp：8E 的分块牛顿迭代 sqrt。 积分、求导、多点求值、多点插值、快速幂。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/docs/","summary":"我的代码模板依赖于我自定义的预处理器，它通过 DFS 把所有引入的模板展开。\nindex.hpp：公共文件头。 我的模板风格是简单封装：在保持易用的同时，封装尽量的薄。\nData Struct 基础数据结构。\nfwtree/1.hpp：普通树状数组。 fwtree/2.hpp：支持区间修改、区间查询的树状数组。 SegmentTree/1.hpp：普通线段树示例，不可引入。 SegmentTree/2.hpp：带懒标记的线段树示例，不可引入。 Math 基础数学算法。\nqpow.hpp：快速幂。 qpow128.hpp：64 位类型的快速幂。 Basic 我也不知道这东西该放哪，就放到这里吧。\nmodint：m32。 NTT-int 简化多项式板子，码量少，常数较大。\nfps/O.hpp：多项式基础结构，用牛顿迭代完成操作。 fps/F.hpp：与上面的相同，略卡常数。 cdq.hpp：非递归 CDQ 分治。 eval.hpp：多点插值，多点求值。 没有用的 NTT-mint 基于 modint 的多项式板子，注重易用性和常数，码量较大。\n每一种算法可能有多种实现。\n多项式类的定义\npoly/1.hpp：继承于 vector\u0026lt;m32\u0026gt;。 NTT\nntt/1.hpp：无 rev 的 NTT。 ntt/2.hpp：略微卡常的 NTT。 多项式逆\ninv/1.hpp：12E 的牛顿迭代 inv，和 16E 的牛顿迭代 div。 inv/2.hpp：10E 的牛顿迭代 inv，和 13E 的牛顿迭代 div。 inv/3.hpp：24E 的牛顿迭代 inv，和 28E 的牛顿迭代 div。 inv/6.hpp：半在线卷积实现的 inv \u0026amp; div。 inv/7.hpp：全在线卷积实现的 inv \u0026amp; div。（没啥用） inv/8.","title":"代码模板"},{"content":"你好！\n如你所见，这里放的都是我的 ACM 刷题记录。主博客在 这里。\n刷题日志 2020 年刷题日志\n2021 年刷题日志\n2022 年刷题日志\n代码模板文档 代码模板\n小工具 展示代码\n题号跳转\n","permalink":"https://rogeryoungh.github.io/code-of-acm/about/","summary":"你好！\n如你所见，这里放的都是我的 ACM 刷题记录。主博客在 这里。\n刷题日志 2020 年刷题日志\n2021 年刷题日志\n2022 年刷题日志\n代码模板文档 代码模板\n小工具 展示代码\n题号跳转","title":"About"},{"content":"非常抱歉，本次比赛对难度估计不当，给大家造成了不好的体验，在此向大家致歉。\nA - CF1379A 见 CF Round #657 (Div. 2) 。\nB - CF1379B 见 CF Round #657 (Div. 2) 。\nC - CF1313B 题目大意 有 $n$ 位参赛者参加两轮比赛，ff 获得的名次分别是 $x$ 和 $y$，其他人的名次是未知的，求 ff 最终可能的最高排名和最低排名。\n分析 结论是很容易猜到的，证明有些困难。\n首先构造最低排名，让尽量多的同学有总分 $x+y$，此时 ff 的排名为 $S_1 = \\min(n, x + y - 1)$。\n证明\n如果某人的总分满足 $x_i + y_i \\leqslant x + y$，那么其两次排名一定满足 $$ x_i \\leqslant x+y-1\\ 且\\ y_i \\leqslant x+y-1$$ 这样的数对显然是不多于 $\\min(n, x + y - 1) = S_1$ 个的，而 $S_1$ 的构造已给出，故最多为 $S_1$ 个。\n之后构造最高排名，让尽量多的同学有总分 $x+y+1$，此时 ff 的排名是 $S_2 = \\max(1, \\min(n, x + y - n + 1))$。\n证明\n主要思路是把排名变成 $n-x$，这样又回到最低排名的问题了。\n如果某人的总分满足 $x_i + y_i \\geqslant x + y + 1$，即 $$n - x_i + n - y_i \\leqslant 2n - x - y - 1$$ 那么其两次排名一定满足 $$n - x_i \\leqslant 2n - x - y - 2\\ 且\\ n - y_i \\leqslant 2n - x - y - 2$$ 故这样的数对不会多于 $S_3 = \\min(n - 1, \\max(2n - x - y - 2, 1))$ 个。\n反过来，不大于 $x+y$ 的数对个数不会少于 $$n - S_3 = \\max(1, \\min(n, x + y - n + 1))$$\nD - CF1496E 见 CF Round 706(Div 2) 。\nE - 2020 ICPC Latin American D 题目大意 给定一些 $2$ 的幂，分成两组使得各组和都是二的幂。\n分析 首先判掉 $n=1$，只有一个盒子不可能的，我们只需关注 $n \\geqslant 2$。\n设两组的和分别为 $2^a, 2^b$，那么 $2^a+2^b$ 在二进制下最多只能有 $2$ 位是 $1$。\n于是我们可以用模拟二进制加法的方式，计算最后到底有几位有 $1$。\n如果有 $2$ 位是 $1$，则统计这两位是由哪些盒子贡献的，即是分组方案。 如果有 $1$ 位是 $1$，那么少合并最后一步，也回归到 $2$ 个的情况。 注意有个坑点，进位可能多进 30 位，数组要预留够足够大的空间。\nint main() { int n = rr(); vector\u0026lt;int\u0026gt; aa(100086); if (n == 1) { printf(\u0026#34;N\\n\u0026#34;); return 0; } for (int i = 0; i \u0026lt; n; i++) { aa[rr()]++; } int tot = 0; for (int i = 0; i \u0026lt; N - 1; i++) { aa[i + 1] += aa[i] / 2; aa[i] %= 2; if (aa[i] \u0026gt; 0) tot++; } if (tot \u0026lt;= 2) printf(\u0026#34;Y\\n\u0026#34;); else printf(\u0026#34;N\\n\u0026#34;); return 0; } F - CF1382D 题目大意 定义 $\\operatorname{merge}(a,b)$ 函数为不断从 $a,b$ 的开头取出较小者放入答案数组的过程。\n问是否存在两个长为 $n$ 的数组 $a,b$，使得 $\\operatorname{merge}(a,b)$ 等于给定的排列 $P$。\n分析 注意到对于每个降序的序列，它不可能是两个序列交替得到的，只是另外一个序列首个数字比较大，所以一直是一个序列在输出，直到第一个比它大的数字。\n即每一段降序序列都可以打包起来，分配给 $a$ 和 $b$，判断最后是否能否分出两个长为 $n$ 的序列。\n对于 $a$ 来说，每一段序列有选和不选两种状态，我们可以用 01 背包来判断。\nint main() { int T = rr(); while (T--) { int n = rr(); vector\u0026lt;int\u0026gt; P(n * 2 + 1), v, dp(n + 1); for (int i = 0; i \u0026lt; n * 2; i++) P[i] = rr(); int m = 0; for (int i = 1; i \u0026lt; n * 2 + 1; i++) { if (P[i] \u0026gt; P[m]) { v.push_back(i - m); m = i; } } for (auto vi : v) { for (int j = n; j \u0026gt;= vi; j--) { dp[j] = max(dp[j], dp[j - vi] + vi); } } if (dp[n] == n) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } G - CF1384B2 见 CF1384B2 Koa and the Beach 。\nH - CF1382C1 题目大意 你可以对 01 串做一种操作：\n对前 $p$ 个字符 01 翻转，并逆序。 在 $3n$ 复杂度内把 $a$ 串变成 $b$ 串。\n分析 我们对前 $p$ 项做操作是不会影响后面的，最简单的想法就是，从后往前依次使 $a$ 与 $b$ 相等。\n假如我们已经完成 $p+1$ 后面的操作，现在要使第 $p$ 位相等。\n如果 $a,b$ 第 $p$ 位相等，无需操作。 如果 $a,b$ 第 $p$ 位不相等，但 $a_1 = \\neg b_p$，那么对前 $p$ 项做一次操作即可。 如果 $a,b$ 第 $p$ 位不相等，但 $a_1 = b_p$，那么先对第一项做操作，之后对前 $p$ 项做一次操作。 总之，我们对每一位最多花 $2$ 次操作使得 $a_i=b_i$，故总共操作次数为 $2n$。\nconst int N = 1e5 + 86; char A[N], B[N]; void op(int p) { for (int i = 0; i \u0026lt; p; i++) A[i] ^= 1; std::reverse(A, A + p); } int main() { int T = rr(); while (T--) { int n = rr(); scanf(\u0026#34;%s%s\u0026#34;, A, B); vector\u0026lt;int\u0026gt; ans; for (int i = n - 1; i \u0026gt;= 0; i--) { if (A[i] == B[i]) continue; if (A[i] == A[0]) { op(i + 1); ans.push_back(i + 1); } else { op(1); ans.push_back(1); op(i + 1); ans.push_back(i + 1); } } printf(\u0026#34;%zu \u0026#34;, ans.size()); for (int i = 0; i \u0026lt; ans.size(); i++) printf(\u0026#34;%d%c\u0026#34;, ans[i], \u0026#34; \\n\u0026#34;[i == ans.size() - 1]); } return 0; } 但是这还不够通过 C2，因为太慢了。注意到我们每次只需要取头和尾两个值，可以用 $l,r$ 加上一个翻转标记代替真实操作。\n这里考虑另一种方式，把 $a$ 变成全为 $0$ 或者 $1$ 的序列，再变成序列 $b$。\n而把一个序列变成全为 $1$ 或 $0$ 是容易的，只需要从开头遍历每个字符即可。\nconst int N = 1e5 + 86; char A[N], B[N]; int main() { int T = rr(); while (T--) { int n = rr(); scanf(\u0026#34;%s%s\u0026#34;, A, B); vector\u0026lt;int\u0026gt; op1, op2; for (int i = 1; i \u0026lt; n; i++) { if (A[i] != A[i - 1]) op1.push_back(i); if (B[i] != B[i - 1]) op2.push_back(i); } if (A[n - 1] != B[n - 1]) op1.push_back(n); reverse(op2.begin(), op2.end()); printf(\u0026#34;%zu \u0026#34;, op1.size() + op2.size()); for (auto i : op1) printf(\u0026#34;%d \u0026#34;, i); for (auto i : op2) printf(\u0026#34;%d \u0026#34;, i); printf(\u0026#34;\\n\u0026#34;); } return 0; } I - CF1382A 题目大意 找到数组 $a,b$ 的最短公共子序列 $c$。\n分析 最短即长度为 $1$，只需找 $a,b$ 中是否出现过相同的元素即可。\nJ - CF1382B 题目大意 两人轮流从下标最小的非空堆中任意的拿取石子，谁拿到最后一个石头谁赢。\n分析 本题非常适合拿来学习 SG 函数，推起来不用动脑子，感兴趣的可以自行了解。这里我们只讲普通推法。\n如果只有一堆石头，先手必胜。\n假设对于给定的石头个数序列 $A_n : a_1,a_2,\\cdots, a_n$，其胜负态是已知的。\n那么在前面插一个 $a_0$，分类讨论有：\n如果 $a_0 = 1$，没有变数，发生一次先手后手转化。 如果 $a_0 \u0026gt; 1$，如果 $A_n$ 必输，先手可以拿走 $n$ 个，后手承担必输结局。 如果 $A_n$ 必胜，先手可以拿走 $n-1$ 个，自己必胜。 总之，答案之和前缀的 $1$ 的个数有关。\nint main() { int T = rr(); while (T--) { int n = rr(), cnt = 0; bool all_1 = true; for (int i = 0; i \u0026lt; n; i++) { int a = rr(); if (all_1) { if (a != 1) all_1 = false; else cnt++; } } if (all_1) cnt++; printf(\u0026#34;%s\\n\u0026#34;, cnt % 2 == 0 ? \u0026#34;First\u0026#34; : \u0026#34;Second\u0026#34;); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/hj1/","summary":"非常抱歉，本次比赛对难度估计不当，给大家造成了不好的体验，在此向大家致歉。\nA - CF1379A 见 CF Round #657 (Div. 2) 。\nB - CF1379B 见 CF Round #657 (Div. 2) 。\nC - CF1313B 题目大意 有 $n$ 位参赛者参加两轮比赛，ff 获得的名次分别是 $x$ 和 $y$，其他人的名次是未知的，求 ff 最终可能的最高排名和最低排名。\n分析 结论是很容易猜到的，证明有些困难。\n首先构造最低排名，让尽量多的同学有总分 $x+y$，此时 ff 的排名为 $S_1 = \\min(n, x + y - 1)$。\n证明\n如果某人的总分满足 $x_i + y_i \\leqslant x + y$，那么其两次排名一定满足 $$ x_i \\leqslant x+y-1\\ 且\\ y_i \\leqslant x+y-1$$ 这样的数对显然是不多于 $\\min(n, x + y - 1) = S_1$ 个的，而 $S_1$ 的构造已给出，故最多为 $S_1$ 个。","title":"ZAFU 2022.01.18 个人赛题解"},{"content":"D. Let's Go Hiking 两人在序列上移动，Qingshan 只能往值更高的地方走，Daniel 只能往低处走。两人不能重叠，求 Qingshan 中有多少可以赢的位置。\n分析 其实我们只用关注上升和下降的序列有多长，而不必关心它们具体是几。\n如果 Qingshan 选边界上的坡，或者不选在坡顶，那么 Daniel 可以紧挨着它，从而必输。\n如果 Qingshan 不选最长的坡，则 Danniel 可以选最长的坡，从而必输。\n如果最长的坡存在没有公共最高点的两个，Danniel 可以避开 Qingshan 选，从而必输。\n剩下的情况只有两种：\n最长的坡只有一个，Qingshan 只能选在此坡坡顶，Danniel 可以选在靠近坡底的地方，使得两人碰面，从而必输。 最长的坡有两个且有公共最高点，Qingshan 选在坡顶，则可以选择避开 Danniel 下坡，从而必胜。 附：代码，展开\nE. Garden of the Sun 在棋盘的格子中有不连续的 X，请连接使得其满足如下条件\nX 组成的图案是连通的。 X 组成的图案不存在环。 分析 X 不连续是一个比较强的性质。\n构造类似 丰 字形的图案，横与横之间空两行，这样可以使得所有 X 都附在一条横上，且互相不连接。\n接下来考虑如何把横连起来，可以发现只用在第一列、第二列中选一列进行连接即可。\n附：代码，展开\nF. BFS Trees 第一次补题补到 F 耶！什么时候才能在赛中做到 F 呢……\n我们定义一个图上的生成树是以 $s$ 点为根的 BFS 树，当且仅当：对于任意的节点 $t$，$s\\to t$ 在 BFS 树上的最短路等于图上的最短路。\n定义 $f(i,j)$ 为根可以在 $i$ 且可以在 $j$ 的 BFS 树的个数，求所有的 $f(i,j) \\bmod P$。\n分析 题目有点绕，要好好的读一读。\n注意到一个关键点：若 $i \\to j$ 最短路有两条，而在生成树中只能有一条，则这些被断掉的节点到 $i,j$ 的最短路一定不能同时取到最小值，故答案不存在，即 $f(i,j) = 0$。\n因此 $i \\to j$ 只能有一条路。想象 $i$ 侧剩余的点按照到 $i$ 的距离分成层级，每个点 $k$ 满足 BFS 树条件的接入方式就是连到更近一层的点 $e$，即判据为\n$$ dis(i, e) + 1 = dis(i, k)\\ \\text{且}\\ dis(j, e) + 1 = dis(j, k) $$\n注意到每次接入是独立的，答案即用乘法合并。\n至于判最短路的条数，注意到 $dis(i,k) + dis(k,j) = dis(i,j)$ 即意味着 $k$ 在 $i \\to j$ 的最短路上，计算满足条件的点数是否是 $dis(i,j) + 1$ 即可。\nfor (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026lt;= n; j++) { ll tans = 1, cnt = 0; for (int k = 1; k \u0026lt;= n; k++) { if (f[i][k] + f[j][k] == f[i][j]) { cnt++; } else { int s = 0; for (auto e : G[k]) { s += f[i][e] + 1 == f[i][k] \u0026amp;\u0026amp; f[e][j] + 1 == f[k][j]; } tans = tans * s % P; } } if (cnt != f[i][j] + 1) { tans = 0; } ans[i][j] = ans[j][i] = tans; } } 附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-11/cf1496/","summary":"D. Let's Go Hiking 两人在序列上移动，Qingshan 只能往值更高的地方走，Daniel 只能往低处走。两人不能重叠，求 Qingshan 中有多少可以赢的位置。\n分析 其实我们只用关注上升和下降的序列有多长，而不必关心它们具体是几。\n如果 Qingshan 选边界上的坡，或者不选在坡顶，那么 Daniel 可以紧挨着它，从而必输。\n如果 Qingshan 不选最长的坡，则 Danniel 可以选最长的坡，从而必输。\n如果最长的坡存在没有公共最高点的两个，Danniel 可以避开 Qingshan 选，从而必输。\n剩下的情况只有两种：\n最长的坡只有一个，Qingshan 只能选在此坡坡顶，Danniel 可以选在靠近坡底的地方，使得两人碰面，从而必输。 最长的坡有两个且有公共最高点，Qingshan 选在坡顶，则可以选择避开 Danniel 下坡，从而必胜。 附：代码，展开\nE. Garden of the Sun 在棋盘的格子中有不连续的 X，请连接使得其满足如下条件\nX 组成的图案是连通的。 X 组成的图案不存在环。 分析 X 不连续是一个比较强的性质。\n构造类似 丰 字形的图案，横与横之间空两行，这样可以使得所有 X 都附在一条横上，且互相不连接。\n接下来考虑如何把横连起来，可以发现只用在第一列、第二列中选一列进行连接即可。\n附：代码，展开\nF. BFS Trees 第一次补题补到 F 耶！什么时候才能在赛中做到 F 呢……\n我们定义一个图上的生成树是以 $s$ 点为根的 BFS 树，当且仅当：对于任意的节点 $t$，$s\\to t$ 在 BFS 树上的最短路等于图上的最短路。","title":"CF Round 706(Div 2)"},{"content":"过于简单的题不记录。\n洛谷：更新至：2021.11.10(\u0026ndash;.\u0026ndash;)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2021 年 01 月 01-25 | P3378 堆\n2021 年 02 月 02-28 | P1216 数字三角形\n2021 年 03 月 03-02 | P3382 三分法\n03-06 | P3865 ST 表\n03-17 | P1162 填涂颜色\n03-17 | P1019 单词接龙\n03-19 | P1014 Cantor 表\n03-19 | P3370 字符串哈希\n03-20 | P3375 KMP 字符串匹配\n03-20 | P3374 树状数组 1\n03-20 | P3368 树状数组 2\n03-28 | P1177 快速排序\n03-29 | P2678 跳石头\n03-29 | P1908 逆序对\n03-30 | P2602 数字计数\n2021 年 04 月 04-09 | P1495 中国剩余定理(CRT)/曹冲养猪\n04-11 | P1706 全排列问题\n04-11 | P1902 刺杀大使\n04-13 | P1314 聪明的质检员\n04-13 | P4838 P哥破解密码\n04-15 | P5410 扩展 KMP（Z 函数）\n04-22 | P3372 线段树 1\n04-26 | P5638 光骓者的荣耀\n04-30 | P2261 余数求和\n2021 年 05 月 05-19 | P2522 Problem B\n05-20 | P1082 同余方程\n05-20 | P2613 有理数取余\n05-20 | P2158 仪仗队\n05-24 | P2303 Longge 的问题\n05-25 | P5091 扩展欧拉定理\n05-25 | P2350 外星人\n05-26 | P3455 ZAP-Queries\n05-26 | P2257 YY 的 GCD\n05-27 | P4139 上帝与集合的正确用法\n05-27 | P2568 GCD\n05-29 | P4781 拉格朗日插值\n05-30 | P1886 滑动窗口 / 单调队列\n2021 年 06 月 06-01 | P3802 小魔女帕琪\n06-01 | P5104 红包发红包\n06-01 | P3805 manacher 算法\n2021 年 07 月 07-12 | P1762 偶数\n07-20 | P3803 多项式乘法（FFT）\n07-23 | HDU多校2021-2\nHUD6972 I love 114514 HDU6971 I love max and multiply HDU6965 I love string HDU6961 I love cube 07-28 | P4173 残缺的字符串\n2021 年 08 月 08-15 | LOJ6053 简单的函数\n08-15 | P5325 Min_25筛\n08-15 | P4213 杜教筛\n08-21 | P4245 任意模数多项式乘法\n08-24 | P4238 多项式乘法逆\n08-24 | P4721 分治 FFT\n2021 年 09 月 09-09 | P4725 多项式对数函数\n09-09 | P4726 多项式指数函数\n09-09 | P5349 幂\n09-22 | HDU6750 Function\n09-22 | HDU6537 Neko and function\n09-23 | HDU6755 Fibonacci Sum\n09-24 | HDU6833 A Very Easy Math Problem\n09-28 | P5205 多项式开根\n2021 年 10 月 10-11 | HDU6955 Xor sum\n10-17 | P4059 找爸爸\n10-18 | P3052 Cows in a Skyscraper G\n10-19 | NC11255B Sample Game\n10-26 | P5170 类欧几里得算法\n10-28 | P5171 Earthquake\n10-31 | P5179 Fraction\n2021 年 11 月 11-02 | P1393 Mivik 的标题\n11-02 | P5491 二次剩余\n11-02 | P5277 多项式开根（加强版）\n11-03 | P4718 Pollard-Rho 算法\n11-03 | P5245 多项式快速幂\n11-04 | P4512 多项式除法\n11-06 | P5050 多项式多点求值\n11-07 | P5158 多项式快速插值\n11-08 | P3846 可爱的质数/BSGS\n11-09 | P3846 常系数齐次线性递推\n11-10 | P2657 windy 数\n11-17 | P3586 LOG\n11-18 | P4777 扩展中国剩余定理\n2021 年 12 月 12-10 | P3369 普通平衡树\n12-18 | P6613 一阶微分方程\n12-20 | P5748 集合划分计数\n这段时间大概被出题人卡多项式搞自闭了，猛卡常数，甚至读了些论文。现在想想纯属浪费时间。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/log2021/","summary":"过于简单的题不记录。\n洛谷：更新至：2021.11.10(\u0026ndash;.\u0026ndash;)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2021 年 01 月 01-25 | P3378 堆\n2021 年 02 月 02-28 | P1216 数字三角形\n2021 年 03 月 03-02 | P3382 三分法\n03-06 | P3865 ST 表\n03-17 | P1162 填涂颜色\n03-17 | P1019 单词接龙\n03-19 | P1014 Cantor 表\n03-19 | P3370 字符串哈希\n03-20 | P3375 KMP 字符串匹配\n03-20 | P3374 树状数组 1\n03-20 | P3368 树状数组 2\n03-28 | P1177 快速排序","title":"2021 年刷题日志"},{"content":"题目大意 在字符集中有 $m$ 个不同的字符，求给定字符串 $S$ 在长度为 $n$ 的字符串的全集中出现的概率。\n分析 参考 Mivik 的字符串公开赛。\n定义 $A$ 类字符串为，在整个字符串中 $S$ 只出现过一次，且恰好 $S$ 出现在末尾的字符串。\n设 $\\{f_i\\}$ 是长度为 $i$ 的字符串中 $A$ 类字符串的个数。再定义 $\\{g_i\\}$ 是长度为 $i$ 的字符串中没有出现过 $S$ 的个数。\n在长为 $i$ 的没有出现过 $S$ 的字符串后面加上一个字符，则可能出现 $S$ 也可能没有出现 $S$。\n$$ m g_i = f_{i+1} + g_{i+1} $$\n定义关于 $S$ 的数列 $\\{s_i\\}$ 为\n$$ s_i = [i \\ \\text{is a period of}\\ S] $$\n即当 $i$ 是 $S$ 的一个循环节时，$s_i$ 为 $1$，否则为 $0$。\n我们在所有未出现过 $S$ 的长为 $n - |S|$ 的字符串后面拼接上 $S$，当 $i$ 是 $S$ 的周期时 $n-i$ 是其完整出现 $S$ 的位置。有\n$$ g_{n - |S|} = \\sum_{i=0}^n f_{n - i} s_{i} $$\n写成生成函数形式，可以得到 $f_i$ 的生成函数\n$$ f(x) = \\frac{x^{|S|}}{x^{|S|} + (1 - m x) s(x)} $$\n我们要计算的是长为 $n$ 的符合要求的字符串总数，即是把字符串填充至 $n$ 的长度即可，即\n$$ E(x) = \\frac{f(x)}{1 - m x} $$\n我们只需计算 $E[n]/m^n$ 即可。循环节可以用 KMP 预处理。\n附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-11/p1393/","summary":"题目大意 在字符集中有 $m$ 个不同的字符，求给定字符串 $S$ 在长度为 $n$ 的字符串的全集中出现的概率。\n分析 参考 Mivik 的字符串公开赛。\n定义 $A$ 类字符串为，在整个字符串中 $S$ 只出现过一次，且恰好 $S$ 出现在末尾的字符串。\n设 $\\{f_i\\}$ 是长度为 $i$ 的字符串中 $A$ 类字符串的个数。再定义 $\\{g_i\\}$ 是长度为 $i$ 的字符串中没有出现过 $S$ 的个数。\n在长为 $i$ 的没有出现过 $S$ 的字符串后面加上一个字符，则可能出现 $S$ 也可能没有出现 $S$。\n$$ m g_i = f_{i+1} + g_{i+1} $$\n定义关于 $S$ 的数列 $\\{s_i\\}$ 为\n$$ s_i = [i \\ \\text{is a period of}\\ S] $$\n即当 $i$ 是 $S$ 的一个循环节时，$s_i$ 为 $1$，否则为 $0$。","title":"P1393 Mivik 的标题"},{"content":"题目大意 求最简分数 $p/q$ 满足\n$$ \\frac{a}{b} \u0026lt; \\frac{p}{q} \u0026lt; \\frac{c}{d} $$\n若有多组解，输出 $q$ 最小的；仍有多组解，输出 $p$ 最小的一组。\n分析 分类讨论：\n首先当 $\\lfloor a/b \\rfloor + 1 \\leqslant \\lceil c/d \\rceil - 1$ 时，说明两个数之间存在一个整数，直接返回 $p = 1, q = \\lfloor a / b \\rfloor + 1$ 即可。 其次当 $a = 0$ 时，直接解得 $p = 1, q = \\lfloor d / c \\rfloor + 1$。 当 $a \u0026lt; b$ 时，这意味着我们无法直接求解。考虑翻转，转化问题为 $$ \\frac{d}{c} \u0026lt; \\frac{q}{p} \u0026lt; \\frac{b}{a} $$ 递归即可。 当 $a \u0026gt; b$ 时，考虑求解 $$ \\frac{a}{b} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor \u0026lt; \\frac{p}{q} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor \u0026lt; \\frac{c}{d} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor $$ 也是递归即可，还原出结果以后返回。 唯一需要确认的就是，翻转后仍是最优解，考虑反证。\n设存在 $p_0 \\geqslant p$ 且 $q_0 \u0026lt; q$ 使得 $p_0/q_0$ 在翻转前不是最优解，但是翻转后是最优解。从而有 $$ \\frac{d}{c} \u0026lt; \\frac{p_0}{q_0} \u0026lt; \\frac{p_0}{q} \\leqslant \\frac{p}{q} \u0026lt; \\frac{b}{a} $$ 即 $p_0/q$ 是翻转前的更优解，与 $p/q$ 是最优解矛盾。\nvoid solve(ll a, ll b, ll \u0026amp;p, ll \u0026amp;q, ll c, ll d) { ll x = a / b, y = (c - 1) / d; if (x \u0026lt; y) { p = x + 1, q = 1; } else if (a == 0) { p = 1, q = d / c + 1; } else if (a \u0026lt; b) { solve(d, c, q, p, b, a); } else { solve(a - b * x, b, p, q, c - d * x, d); p += q * x; } } 附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5179/","summary":"题目大意 求最简分数 $p/q$ 满足\n$$ \\frac{a}{b} \u0026lt; \\frac{p}{q} \u0026lt; \\frac{c}{d} $$\n若有多组解，输出 $q$ 最小的；仍有多组解，输出 $p$ 最小的一组。\n分析 分类讨论：\n首先当 $\\lfloor a/b \\rfloor + 1 \\leqslant \\lceil c/d \\rceil - 1$ 时，说明两个数之间存在一个整数，直接返回 $p = 1, q = \\lfloor a / b \\rfloor + 1$ 即可。 其次当 $a = 0$ 时，直接解得 $p = 1, q = \\lfloor d / c \\rfloor + 1$。 当 $a \u0026lt; b$ 时，这意味着我们无法直接求解。考虑翻转，转化问题为 $$ \\frac{d}{c} \u0026lt; \\frac{q}{p} \u0026lt; \\frac{b}{a} $$ 递归即可。 当 $a \u0026gt; b$ 时，考虑求解 $$ \\frac{a}{b} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor \u0026lt; \\frac{p}{q} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor \u0026lt; \\frac{c}{d} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor $$ 也是递归即可，还原出结果以后返回。 唯一需要确认的就是，翻转后仍是最优解，考虑反证。","title":"P5179 Fraction"},{"content":"题目大意 给定 $a,b,c$，求满足方程 $ax + by \\leqslant c$ 的非负整数解的个数。\n分析 令 $n = \\lfloor c / a \\rfloor$，容易推出让我们求的是\n$$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{c - ax}{b} \\right\\rfloor $$\n直接套类欧是不行的，因为系数有负数。其他题解感觉推麻烦了，直接考虑水平翻转，令 $x \\to (n - x)$，代入有\n$$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{ax + c - an}{b} \\right\\rfloor $$\n显然 $c - an$ 是 c % a，于是套类欧即可\n附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5171/","summary":"题目大意 给定 $a,b,c$，求满足方程 $ax + by \\leqslant c$ 的非负整数解的个数。\n分析 令 $n = \\lfloor c / a \\rfloor$，容易推出让我们求的是\n$$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{c - ax}{b} \\right\\rfloor $$\n直接套类欧是不行的，因为系数有负数。其他题解感觉推麻烦了，直接考虑水平翻转，令 $x \\to (n - x)$，代入有\n$$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{ax + c - an}{b} \\right\\rfloor $$\n显然 $c - an$ 是 c % a，于是套类欧即可\n附：代码，展开","title":"P5171 Earthquake"},{"content":"题目大意 给定生成 $1$ 到 $n$ 数字的概率分布，不断生成随机数 $x$ 直到 $x$ 不是已经生成过的最大的数停止，求生成次数平方的期望。\n分析 设期望的随机次数为 $f_x = E(x)$，我们需要计算的次数为 $g_x = E(x^2)$。\n关于 $f_i$ 的 DP 是显然的，计算有\n$$ f_x = \\sum_{i = 1}^{x - 1} p_i + \\sum_{i = x}^n p_i(1 + f_i) = 1 + \\sum_{i = x}^n p_i f_i $$\n容易观察到\n$$ f_{x + 1} =(1 - p_x) f_x \\Rightarrow f_x = \\prod_{i = x}^n \\frac{1}{1 - p_x} $$\n接下来需要一个套路\n$$ E((x + 1)^2) = E(x^2) + 2 E(x) + 1 $$\n类似的可以推得\n$$ g_x = \\sum_{i = 1}^{x - 1} p_i + \\sum_{i = x}^n p_i(g_i + 2 f_i + 1) = 1\n\\sum_{i = x}^n p_i g_i + 2 \\sum_{i = x}^n p_i f_i = \\sum_{i = x}^n p_i g_i + 2 f_x - 1 $$ 最终答案即是\n$$ ans = \\sum_{i = 1}^n p_i(g_i + 2 f_i + 1) = g_1 $$\n至此，倒着递推已经可以线性求解了。但是我们还可以继续优化，逐项相减有\n$$ g_{x + 1} - g_x = 2(f_{x + 1} - f_x) - p_x g_x = - 2 p_x f_x - p_x g_x $$\n即\n$$ \\frac{g_x}{f_x} - \\frac{g_{x + 1}}{f_{x + 1}} = \\frac{2}{1 - p_x} - 2 $$\n因此\n$$ {\\rm ans} = g_1 = f_1 \\left( \\frac{g_n}{f_n} - 2(n - 1) + 2 \\sum_{i = 1}^{n - 1} \\frac{1}{1 - p_x} \\right) = \\left( \\prod_{i = x}^n \\frac{1}{1 - p_x} \\right) \\left( 1 + 2 \\sum_{i = 1}^n \\frac{1}{1 - p_x} - 2 n \\right) $$\n至此，我们可以 $O(n)$ 的解决问题。\n#define ACM_MOD 998244353 const ll mod = ACM_MOD; #include \u0026#34;template/basic/qpow.hpp\u0026#34; #include \u0026#34;template/basic/inv.hpp\u0026#34; ll p[10086]; int main() { ll n = rr(), sum = 0; for (int i = 1; i \u0026lt;= n; i++) p[i] = rr(), sum = (sum + p[i]) % mod; sum = inv(sum); for (int i = 1; i \u0026lt;= n; i++) { p[i] = p[i] * sum % mod; p[i] = inv(mod + 1 - p[i]); } ll ans = 1, w = mod - n; for (int i = 1; i \u0026lt;= n; i++) { ans = ans * p[i] % mod; w = (w + p[i]) % mod; } ans = ans * (1 + 2 * w) % mod; printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 我们经过了很长的化简过程才导出这一结果，实际上生成函数更为快捷。\n设 $f(x)$ 是生成长度为 $i$ 的非递减序列的生成函数，即 $P(len \u0026gt; i)$，可以推出\n$$ f(x) = \\prod_{i = 1}^n \\frac{1}{1 - p_i x} $$\n而我们需要求\n$$ \\sum_{i = 1}^{\\infty} (f_{i - 1} - f_i) i^2 = \\sum_{i = 0}^{\\infty} f_i (2 i + 1) = 2 f\u0026rsquo;(1) + f(1) $$\n化简即可得到上式。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/nc11255b/","summary":"题目大意 给定生成 $1$ 到 $n$ 数字的概率分布，不断生成随机数 $x$ 直到 $x$ 不是已经生成过的最大的数停止，求生成次数平方的期望。\n分析 设期望的随机次数为 $f_x = E(x)$，我们需要计算的次数为 $g_x = E(x^2)$。\n关于 $f_i$ 的 DP 是显然的，计算有\n$$ f_x = \\sum_{i = 1}^{x - 1} p_i + \\sum_{i = x}^n p_i(1 + f_i) = 1 + \\sum_{i = x}^n p_i f_i $$\n容易观察到\n$$ f_{x + 1} =(1 - p_x) f_x \\Rightarrow f_x = \\prod_{i = x}^n \\frac{1}{1 - p_x} $$\n接下来需要一个套路\n$$ E((x + 1)^2) = E(x^2) + 2 E(x) + 1 $$","title":"NC11255B Sample Game"},{"content":"题目大意 有 $n$ 头牛坐电梯，重量分别为 $c_i$，电梯的最大限额是 $W$，求最少分多少次能够全部上去。\n分析 注意 $n \\leqslant 18$，枚举全排列是不行的。考虑用状态压缩，将第 $j$ 头奶牛的选和不选用状态 $i$ 的第 $j$ 位数字表示。设 $f_i$ 表示状态为 $i$ 时最小乘电梯次数，$g_i$ 表示此状态下最新那个电梯已经有的重量。\n首先令 cow = i \u0026lt;\u0026lt; (j - 1)，若 i \u0026amp; cow 为 $1$ 则说明这个奶牛已经坐上电梯了，不计算。 当 $W - g_i \\geqslant c_i$ 时，最后那个电梯坐的下这头牛。 当 $W - g_i \u0026lt; c_i$ 时，只能新开一个电梯。 还是代码更清晰\nconst int maxn = 18; ll ci[maxn]; ll ff[1 \u0026lt;\u0026lt; maxn], gg[1 \u0026lt;\u0026lt; maxn]; int main() { ll n = rr(), W = rr(); for (int i = 1; i \u0026lt;= n; i++) ci[i] = rr(); fill_n(ff, 1 \u0026lt;\u0026lt; maxn, n); fill_n(gg, 1 \u0026lt;\u0026lt; maxn, W); ff[0] = 1, gg[0] = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { for (int j = 1; j \u0026lt;= n; j++) { ll cow = 1 \u0026lt;\u0026lt; (j - 1); if (i \u0026amp; cow) continue; if (W - gg[i] \u0026gt;= ci[j]) { ff[i | cow] = ff[i]; gg[i | cow] = min(gg[i | cow], gg[i] + ci[j]); } else if (W - gg[i] \u0026lt; ci[j] \u0026amp;\u0026amp; ff[i | cow] \u0026gt;= ff[i] + 1) { ff[i | cow] = ff[i] + 1; gg[i | cow] = min(gg[i | cow], ci[j]); } } } printf(\u0026#34;%lld\u0026#34;, ff[(1 \u0026lt;\u0026lt; n) - 1]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p3052/","summary":"题目大意 有 $n$ 头牛坐电梯，重量分别为 $c_i$，电梯的最大限额是 $W$，求最少分多少次能够全部上去。\n分析 注意 $n \\leqslant 18$，枚举全排列是不行的。考虑用状态压缩，将第 $j$ 头奶牛的选和不选用状态 $i$ 的第 $j$ 位数字表示。设 $f_i$ 表示状态为 $i$ 时最小乘电梯次数，$g_i$ 表示此状态下最新那个电梯已经有的重量。\n首先令 cow = i \u0026lt;\u0026lt; (j - 1)，若 i \u0026amp; cow 为 $1$ 则说明这个奶牛已经坐上电梯了，不计算。 当 $W - g_i \\geqslant c_i$ 时，最后那个电梯坐的下这头牛。 当 $W - g_i \u0026lt; c_i$ 时，只能新开一个电梯。 还是代码更清晰\nconst int maxn = 18; ll ci[maxn]; ll ff[1 \u0026lt;\u0026lt; maxn], gg[1 \u0026lt;\u0026lt; maxn]; int main() { ll n = rr(), W = rr(); for (int i = 1; i \u0026lt;= n; i++) ci[i] = rr(); fill_n(ff, 1 \u0026lt;\u0026lt; maxn, n); fill_n(gg, 1 \u0026lt;\u0026lt; maxn, W); ff[0] = 1, gg[0] = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { for (int j = 1; j \u0026lt;= n; j++) { ll cow = 1 \u0026lt;\u0026lt; (j - 1); if (i \u0026amp; cow) continue; if (W - gg[i] \u0026gt;= ci[j]) { ff[i | cow] = ff[i]; gg[i | cow] = min(gg[i | cow], gg[i] + ci[j]); } else if (W - gg[i] \u0026lt; ci[j] \u0026amp;\u0026amp; ff[i | cow] \u0026gt;= ff[i] + 1) { ff[i | cow] = ff[i] + 1; gg[i | cow] = min(gg[i | cow], ci[j]); } } } printf(\u0026#34;%lld\u0026#34;, ff[(1 \u0026lt;\u0026lt; n) - 1]); return 0; } ","title":"P3052 Cows in a Skyscraper G"},{"content":"题目大意 给定两串 DNA 序列，可以在其中任意插空格，然后逐位比较，当两位都是字母时查表得到相似度。\n长度为 $k$ 的空格有额外相似度 $- A - B(k - 1)$。求两序列的最大相似度。\n分析 若不考虑空格的贡献，容易想到二维 DP，记 ${\\rm DP}[i,j]$ 是 $A$ 串到位置 $i$ 同时 $B$ 串到位置 $j$ 时最大的相似度，有\n$$ {\\rm DP}[i, j] = \\max\\{ {\\rm DP}[i - 1, j - 1] + D[i, j], {\\rm DP}[i - 1, j], {\\rm DP}[i, j - 1] \\} $$\n当我们考虑空格的贡献时，可以发现空格的额外贡献只与前面一位有关。若两个序列此位都是空格，则把去掉后相似度一定会增加，故只有三种可能：设 ${\\rm DP}_0$ 是结尾没有空格；${\\rm DP}_1$ 是空格在 $A$ 串；${\\rm DP}_2$ 是空格在 $B$ 串。\n思考最后一个空格的转移方式，自然有方程\n$$ \\begin{aligned} {\\rm DP}_0[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i - 1, j - 1], {\\rm DP}_1[i - 1, j - 1], {\\rm DP}_2[i - 1, j - 1] \\} + D[i, j] \\\\ {\\rm DP}_1[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i, j - 1] - A, {\\rm DP}_1[i, j - 1]- B, {\\rm DP}_2[i, j - 1] - A\\} \\\\ {\\rm DP}_2[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i - 1, j] - A, {\\rm DP}_1[i - 1, j] - A, {\\rm DP}_2[i, j - 1] - B \\} \\\\ \\end{aligned} $$\n随手加滚动数组 WA 了好久，发现每次都要清空为 -INF，否则会 WA。\n#include \u0026#34;template/index.hpp\u0026#34; const int maxn = 3000 + 10; int dp_1[maxn][3], dp_2[maxn][3]; char sa[maxn], sb[maxn]; int D[5][5]; int DNA(char c); // AGTC -\u0026gt; 1..4 int main() { scanf(\u0026#34;%s %s\u0026#34;, sa + 1, sb + 1); int n = strlen(sa + 1), m = strlen(sb + 1); for (int i = 1; i \u0026lt;= 4; i++) for (int j = 1; j \u0026lt;= 4; j++) D[i][j] = rr(); int A = rr(), B = rr(), *p; memset(dp_1, -0x7f, sizeof(dp_1)); memset(dp_2, -0x7f, sizeof(dp_2)); auto \u0026amp;dp1 = dp_1, \u0026amp;dp2 = dp_2; dp2[0][0] = 0; for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { int da = DNA(sa[i]), db = DNA(sb[j]); if (i \u0026gt; 0 \u0026amp;\u0026amp; j \u0026gt; 0) { p = dp1[j - 1]; dp2[j][0] = max3(p[0], p[1], p[2]) + D[da][db]; } if (i \u0026gt; 0) { p = dp1[j]; dp2[j][2] = max3(p[0] - A, p[1] - A, p[2] - B); } if (j \u0026gt; 0) { p = dp2[j - 1]; dp2[j][1] = max3(p[0] - A, p[1] - B, p[2] - A); } } swap(dp1, dp2); memset(dp2, -0x7f, sizeof(dp2)); } p = dp1[m]; int ans = max3(p[0], p[1], p[2]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p4059/","summary":"题目大意 给定两串 DNA 序列，可以在其中任意插空格，然后逐位比较，当两位都是字母时查表得到相似度。\n长度为 $k$ 的空格有额外相似度 $- A - B(k - 1)$。求两序列的最大相似度。\n分析 若不考虑空格的贡献，容易想到二维 DP，记 ${\\rm DP}[i,j]$ 是 $A$ 串到位置 $i$ 同时 $B$ 串到位置 $j$ 时最大的相似度，有\n$$ {\\rm DP}[i, j] = \\max\\{ {\\rm DP}[i - 1, j - 1] + D[i, j], {\\rm DP}[i - 1, j], {\\rm DP}[i, j - 1] \\} $$\n当我们考虑空格的贡献时，可以发现空格的额外贡献只与前面一位有关。若两个序列此位都是空格，则把去掉后相似度一定会增加，故只有三种可能：设 ${\\rm DP}_0$ 是结尾没有空格；${\\rm DP}_1$ 是空格在 $A$ 串；${\\rm DP}_2$ 是空格在 $B$ 串。\n思考最后一个空格的转移方式，自然有方程\n$$ \\begin{aligned} {\\rm DP}_0[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i - 1, j - 1], {\\rm DP}_1[i - 1, j - 1], {\\rm DP}_2[i - 1, j - 1] \\} + D[i, j] \\\\ {\\rm DP}_1[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i, j - 1] - A, {\\rm DP}_1[i, j - 1]- B, {\\rm DP}_2[i, j - 1] - A\\} \\\\ {\\rm DP}_2[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i - 1, j] - A, {\\rm DP}_1[i - 1, j] - A, {\\rm DP}_2[i, j - 1] - B \\} \\\\ \\end{aligned} $$","title":"P4059 找爸爸"},{"content":"题目大意 给定整数序列 $\\{a_n\\}$，寻找满足区间异或和大于等于 $k$ 的连续序列中最短的。\n若有多个同样长度的答案，输出位置靠前的，若不存在输出 -1。\n分析 看到异或最值就应该想到 01trie。做前缀异或和，这样我们的问题就变成找到最靠近的两个数，其异或大于等于 $k$。\n因为要求位置最靠前的，所以我选择倒着遍历。当遍历到第 $i$ 个数 $a_i$ 时，字典树已经维护好此位置之后的数据，即每个值出现最左边的位置。\nconst int maxn = 1e5 + 10, o = 30 - 1; int trie[maxn * 30][2], val[maxn * 30], tot, n, k; void insert(int ai, int i) { int p = 1; for (int j = o; j \u0026gt;= 0; j--) { int ch = (ai \u0026gt;\u0026gt; j) \u0026amp; 1; if (trie[p][ch] == 0) trie[p][ch] = ++tot; p = trie[p][ch]; val[p] = i; } } 我们只需从高位到低位遍历第 $j$ 位，分类讨论：\n若 $k[j] = 1$，则说明 $a_i[j] \\oplus a_u[j]$ 只能为 $1$，在字典树中选择 $a_i[j] \\oplus 1$ 深入（什么都不做）。 若 $k[j] = 0$，那么若 $a_i[j] \\oplus a_u[j] = 1$ 则一定大于 $k$，记录字典树中 $a_i[j] \\oplus 1$ 的值，然后在字典树中选择 $a_i[j]$ 深入。 int search(int ai, int i) { int p = 1, res = -1; for (int j = o; j \u0026gt;= 0; j--) { int x1 = (k \u0026gt;\u0026gt; j) \u0026amp; 1, x2 = (ai \u0026gt;\u0026gt; j) \u0026amp; 1; if (x1 == 0) { int tp = trie[p][x2 ^ 1]; if (tp \u0026gt; 0) res = max(res, val[tp]); } p = trie[p][x1 ^ x2]; if (p == 0) break; } if (p \u0026gt; 0) res = max(res, val[p]); return res; } 因为我们是从前往后查的，因此同样长度中总是先查到考前的，汇总有\nint main() { int ttt = rr(); while (ttt--) { n = rr(), k = rr(), tot = 1; int anl = -1, anr = n + 1, pre_sum = 0; fill_n(trie[0], 2 * o * n, 0); for (int i = 1; i \u0026lt;= n; i++) { int ai = pre_sum ^ rr(); int res = search(ai, i); if (res \u0026gt;= 0 \u0026amp;\u0026amp; i - res \u0026lt; anr - anl) anl = res, anr = i; insert(ai, i); pre_sum = ai; } if (anl \u0026gt;= 0) printf(\u0026#34;%d %d\\n\u0026#34;, anl + 1, anr); else printf(\u0026#34;-1\\n\u0026#34;); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/hdu6955/","summary":"题目大意 给定整数序列 $\\{a_n\\}$，寻找满足区间异或和大于等于 $k$ 的连续序列中最短的。\n若有多个同样长度的答案，输出位置靠前的，若不存在输出 -1。\n分析 看到异或最值就应该想到 01trie。做前缀异或和，这样我们的问题就变成找到最靠近的两个数，其异或大于等于 $k$。\n因为要求位置最靠前的，所以我选择倒着遍历。当遍历到第 $i$ 个数 $a_i$ 时，字典树已经维护好此位置之后的数据，即每个值出现最左边的位置。\nconst int maxn = 1e5 + 10, o = 30 - 1; int trie[maxn * 30][2], val[maxn * 30], tot, n, k; void insert(int ai, int i) { int p = 1; for (int j = o; j \u0026gt;= 0; j--) { int ch = (ai \u0026gt;\u0026gt; j) \u0026amp; 1; if (trie[p][ch] == 0) trie[p][ch] = ++tot; p = trie[p][ch]; val[p] = i; } } 我们只需从高位到低位遍历第 $j$ 位，分类讨论：","title":"HDU6955 Xor sum"},{"content":"题目大意 即求\n$$ S (n) = \\sum^n_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k f (\\gcd \\{ a_x \\}) \\gcd \\{ a_x \\} $$\n我自己随便简写了，全打太麻烦了。\n分析 这东西看着很吓人，其实是纸老虎。首先 $f(x) = \\mu(x)^2$。提出 $\\gcd$ 有\n$$ \\begin{aligned} S (n) \u0026amp; =\\sum_{d=1}^{n}\\sum^{n}_{\\{ a_{x}\\}=1}(\\prod_{j=1}^{x}a_{j})^{k}{\\mu}(d)^{2}d [gcd \\{ a_{x}\\} =d]\\\\ \u0026amp; =\\sum_{d=1}^{n}{\\mu}(d)^{2}d^{k x+1}\\sum^{n/d}_{\\{ a_{x}\\} =1}(\\prod_{j=1}^{x}a_{j})^{k}[gcd \\{ a_{x}\\} =1] \\end{aligned} $$\n对后面这部分反演有\n$$ \\begin{aligned} \u0026amp; \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t \\mid \\gcd \\{ a_x \\}} \\mu (t) \\right)\\\\ = \u0026amp; \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t = 1}^{n / d} [t \\mid \\gcd \\{ a_x \\}] \\mu (t) \\right)\\\\ = \u0026amp; \\sum_{t = 1}^{n / d} \\mu (t) t^{k x} \\sum^{n / d t}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\end{aligned} $$\n代回去，枚举 $T = d t$\n$$ \\begin{aligned} S (n) \u0026amp; = \\sum_{d = 1}^n d \\mu (d)^2 (d t)^{k x} \\sum_{t = 1}^{n / d} \\mu (t) \\sum^{n / d t}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k\\\\ \u0026amp; = \\sum_{T = 1}^n \\sum_{d \\mid T} d \\mu (d)^2 T^{k x} \\mu \\left(\\frac{T}{d} \\right) \\sum^{n / T}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k\\\\ \u0026amp; = \\sum_{T = 1}^n T^{k x} \\left( \\sum^{n / T}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\right) \\sum_{d \\mid T} d \\mu (d)^2 \\mu \\left( \\frac{T}{d} \\right)\\\\ \u0026amp; = \\sum_{T = 1}^n T^{k x} \\left( \\sum^{n / T}_{i = 1} i^k \\right)^x \\sum_{d \\mid T} d \\mu (d)^2 \\mu \\left( \\frac{T}{d} \\right) \\end{aligned} $$\n到这里已经差不多化完了。令\n$$ G (x) = \\sum^x_{i = 1} i^k, H (x) = \\sum_{d \\mid x} d \\mu (d)^2 \\mu \\left( \\frac{x}{d} \\right) $$\n其中 $G (x)$ 显然可以预处理，而 $H (x)$ 是积性函数的卷积，故也是积性函数，其中\n$$ H (p^c) = \\begin{cases} p - 1,\u0026amp; c = 1\\\\ -p, \u0026amp; c = 2 \\\\ 0, \u0026amp; c \u0026gt; 2 \\end{cases} $$\n可以线性筛得到。\nconst ll maxn = 2e5 + 86; const ll mod = 1e9 + 7; #define ACM_MOD mod bool notp[maxn + 10]; int prime[maxn/10 + 10], cnt; ll hh[maxn + 10]; void sieve(int n) { hh[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { if (!notp[i]) { prime[++cnt] = i; hh[i] = i - 1; } int t = n / i; for (int j = 1; j \u0026lt;= cnt;j++) { int pj = prime[j], ti = i * pj; if (pj \u0026gt; t) break; notp[ti] = true; if (i % pj == 0) { int tj = i / pj; if (tj % pj != 0) { hh[ti] = hh[tj] * (mod - pj) % mod; } else { hh[ti] = 0; } break; } hh[ti] = hh[i] * hh[pj] % mod; } } } 总之\n$$ S (n) = \\sum_{T = 1}^n T^{k x} H (T) G \\left( \\left\\lfloor \\frac{n}{T} \\right\\rfloor \\right)^x $$\n可以用整数分块。\n#include \u0026#34;template/basic/qpow.hpp\u0026#34; ll gg[maxn + 10]; void pre(ll k, ll x) { sieve(maxn); for (ll i = 1; i \u0026lt;= maxn; i++) { gg[i] = (gg[i - 1] + qpow(i, k)) % mod; } for (ll i = 1; i \u0026lt;= maxn; i++) { hh[i] = (hh[i - 1] + qpow(i, k * x % (mod - 1)) * hh[i]) % mod; gg[i] = qpow(gg[i], x); } } int main() { ll ttt = rr(), k = rr(), x = rr(); pre(k, x); while(ttt--) { ll n = rr(); ll ans = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ll tsum = hh[r] - hh[l - 1] + mod; tsum = tsum * gg[n / l] % mod; ans = ans + tsum; } printf(\u0026#34;%lld\\n\u0026#34;, ans % mod); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6833/","summary":"题目大意 即求\n$$ S (n) = \\sum^n_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k f (\\gcd \\{ a_x \\}) \\gcd \\{ a_x \\} $$\n我自己随便简写了，全打太麻烦了。\n分析 这东西看着很吓人，其实是纸老虎。首先 $f(x) = \\mu(x)^2$。提出 $\\gcd$ 有\n$$ \\begin{aligned} S (n) \u0026amp; =\\sum_{d=1}^{n}\\sum^{n}_{\\{ a_{x}\\}=1}(\\prod_{j=1}^{x}a_{j})^{k}{\\mu}(d)^{2}d [gcd \\{ a_{x}\\} =d]\\\\ \u0026amp; =\\sum_{d=1}^{n}{\\mu}(d)^{2}d^{k x+1}\\sum^{n/d}_{\\{ a_{x}\\} =1}(\\prod_{j=1}^{x}a_{j})^{k}[gcd \\{ a_{x}\\} =1] \\end{aligned} $$\n对后面这部分反演有\n$$ \\begin{aligned} \u0026amp; \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t \\mid \\gcd \\{ a_x \\}} \\mu (t) \\right)\\\\ = \u0026amp; \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t = 1}^{n / d} [t \\mid \\gcd \\{ a_x \\}] \\mu (t) \\right)\\\\ = \u0026amp; \\sum_{t = 1}^{n / d} \\mu (t) t^{k x} \\sum^{n / d t}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\end{aligned} $$","title":"HDU6833 A Very Easy Math Problem"},{"content":"题目大意 设 Fibonacci 数列第 $i$ 项为 $F_i$，求\n$$ S = \\sum_{i = 0}^n (F_{i c})^k $$\n分析 由特征方程法，设\n$$ x^2 + x - 1 = 0 \\Longrightarrow A, B = \\frac{1 \\pm \\sqrt{5}}{2} $$\n因此 Fibonacci 通项公式即可表示为\n$$ F_n = \\frac{A^n - B^n}{A - B} $$\n根据二次剩余的知识，模意义下是可以开方的。因此\n$$ (F_{i c})^k = \\left( \\frac{A^{i c} - B^{i c}}{A - B} \\right)^k = \\frac{1}{(A - B)^k} \\sum_{j = 0}^k \\binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$\n求和有\n$$ (A - B)^k S = (A - B)^k \\sum_{i = 0}^n (F_{i c})^k = \\sum_{i = 0}^n \\sum_{j = 0}^k \\binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$\n换序求和，即是等比数列（公比可能为 $1$，需要特判）\n$$ \\begin{aligned} (A-B)^{k}S \u0026amp; =\\sum_{j=0}^{k}\\binom{k}{j}(-1)^{k-j}\\sum_{i=0}^{n}(A^{j}B^{k-j})^{ic}\\\\ \u0026amp; =\\sum_{j=0}^{k}\\binom{k}{j}(-1)^{k-j}{\\frac{(A^{j}B^{k-j})^{c(n+1)}-1}{(A^{j}B^{k-j})^{c}-1}} \\end{aligned} $$\n直接计算会 TLE，需要用中间变量简化\n$$ \\frac{(A^j B^{k - j})^{c (n + 1)} - 1}{(A^j B^{k - j})^c - 1} = \\frac{B^{k c (n + 1)} {(A B^{- 1})^{c (n + 1) j}} - 1}{B^{k c} (A B^{- 1})^{c j} - 1} $$\n用中间变量在循环中递推，再加上 Euler 降幂，就可以过题了。\nconst ll mod = 1e9 + 9, phi_mod = mod - 1; const ll maxn = 1e5 + 10; #define ACM_MOD mod #include \u0026#34;template/basic/qpow.hpp\u0026#34; #include \u0026#34;template/basic/inv.hpp\u0026#34; const ll sqrt_5 = 383008016; const ll A = (1 + sqrt_5) * inv(2) % mod, B = (1 - sqrt_5 + mod) * inv(2) % mod; ll euler_pow(ll a, ll b) { return qpow(a, b % phi_mod); } ll fac[maxn], ind[maxn]; void pre(ll n) { fac[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) { fac[i] = fac[i - 1] * i % mod; } ind[n] = inv(fac[n]); for (ll i = n - 1; i \u0026gt;= 0; i--) { ind[i] = ind[i + 1] * (i + 1) % mod; } } ll binom(ll a, ll b) { if (b \u0026gt; a) b = a - b; return fac[a] * ind[b] % mod * ind[a - b] % mod; } int main() { pre(1e5 + 1); ll ttt = rr(); while (ttt--) { ll n = rr(), c = rr(), k = rr(); ll step1 = euler_pow(A * inv(B) % mod, c), step2 = euler_pow(step1, n + 1); ll T1 = euler_pow(B, c % phi_mod * k), T2 = euler_pow(T1, n + 1); ll ans = 0; for (ll j = 0; j \u0026lt;= k; j++) { ll tsum = binom(k, j); if (T1 != 1) { tsum = tsum * (T2 - 1) % mod * inv(T1 - 1) % mod; } else { tsum = (n + 1) % mod * tsum % mod; } if ((k - j) % 2 == 1) tsum *= -1; ans = (ans + tsum + mod) % mod; T1 = T1 * step1 % mod, T2 = T2 * step2 % mod; } ans = ans % mod * euler_pow(inv(A - B), k) % mod; printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6755/","summary":"题目大意 设 Fibonacci 数列第 $i$ 项为 $F_i$，求\n$$ S = \\sum_{i = 0}^n (F_{i c})^k $$\n分析 由特征方程法，设\n$$ x^2 + x - 1 = 0 \\Longrightarrow A, B = \\frac{1 \\pm \\sqrt{5}}{2} $$\n因此 Fibonacci 通项公式即可表示为\n$$ F_n = \\frac{A^n - B^n}{A - B} $$\n根据二次剩余的知识，模意义下是可以开方的。因此\n$$ (F_{i c})^k = \\left( \\frac{A^{i c} - B^{i c}}{A - B} \\right)^k = \\frac{1}{(A - B)^k} \\sum_{j = 0}^k \\binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$","title":"HDU6755 Fibonacci Sum"},{"content":"题目大意 定义 $f(n, k)$ 为满足如下要求的，长度为 $k$ 的数列 $\\\\{a_i\\\\}$ 个数：\n要求每个数字都大于 $1$； 数列各项之积恰为 $n$。 求其前缀和 $S(n, k) = \\sum f(i, k)$。\n分析 多组输入好坑啊。\n先允许 $a_i=1$，将结果记为 $g(n,k)$，容易利用隔板法求得\n$$ g (p^c, k) = \\binom{t + k - 1}{k - 1} $$\n对于多个质因数，显然其贡献是相互独立的，即 $g$ 是积性函数。考虑选取 $i$ 个数令其 $a_i\u0026gt;1$，枚举有\n$$ g (n, k) = \\sum_{i = 1}^k \\binom{n}{i} f (n, i) $$\n二项式反演（或者直接容斥）有\n$$ f (n, k) = \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} g (n, i) $$\n求和并换序\n$$ \\begin{aligned} \\sum_{i = 1}^x f (i, k) \u0026amp;= \\sum_{n = 1}^x \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} g (n, i) \\\\ \u0026amp;= \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} \\sum_{n = 1}^x g (n, i) \\end{aligned} $$\n后面即是 $g$ 的前缀和，可以用 Min25 筛。\nconst ll mod = 1e9 + 7; const int maxn = 1e6 + 5; ll cc[70][70]; void pre_binom(ll n) { for (ll i = 0; i \u0026lt;= n; i++) { cc[i][0] = 1; for (ll j = 1; j \u0026lt;= i; j++) { cc[i][j] = (cc[i - 1][j - 1] + cc[i - 1][j]) % mod; } } } namespace min25 { ll n, prime[maxn], cnt, w[maxn], c[maxn]; ll sqrt_n, m, kkk; ll f_p(ll e, ll k) { return cc[e + k - 1][k - 1]; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } void pre(ll _n) { n = _n, sqrt_n = sqrt(n + 0.01); m = cnt = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { w[++m] = r = n / (n / l); c[m] = r - 1; } for (ll p = 2; p \u0026lt;= sqrt_n; p++) { if (c[p] != c[p - 1]) { prime[++cnt] = p; for (ll j = m; w[j] \u0026gt;= p * p; j--) { c[j] -= c[id(w[j] / p)] - c[p - 1]; } } } } ll F(ll n, int k, int tk) { if (n \u0026lt;= prime[k]) return 0; ll ret = (c[id(n)] - c[prime[k]]) * tk; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int e = 1; pk * pi \u0026lt;= n; e++, pk *= pi) ret = (ret + f_p(e, tk) * F(n / pk, i, tk) + f_p(e + 1, tk)); } return ret % mod; } ll solve(ll n, ll k) { return F(n, 0, k); } } // namespace min25 int main() { ll x, k; pre_binom(70); while (scanf(\u0026#34;%lld %lld\u0026#34;, \u0026amp;x, \u0026amp;k) != EOF) { min25::pre(x); ll ans = 0; for (ll i = 1; i \u0026lt;= k; i++) { if (cc[k][i] == 0) continue; ll tsum = cc[k][i] * min25::solve(x, i); if ((k - i) % 2 == 1) tsum *= -1; ans += tsum; } printf(\u0026#34;%lld\\n\u0026#34;, (ans % mod + mod) % mod); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6537/","summary":"题目大意 定义 $f(n, k)$ 为满足如下要求的，长度为 $k$ 的数列 $\\\\{a_i\\\\}$ 个数：\n要求每个数字都大于 $1$； 数列各项之积恰为 $n$。 求其前缀和 $S(n, k) = \\sum f(i, k)$。\n分析 多组输入好坑啊。\n先允许 $a_i=1$，将结果记为 $g(n,k)$，容易利用隔板法求得\n$$ g (p^c, k) = \\binom{t + k - 1}{k - 1} $$\n对于多个质因数，显然其贡献是相互独立的，即 $g$ 是积性函数。考虑选取 $i$ 个数令其 $a_i\u0026gt;1$，枚举有\n$$ g (n, k) = \\sum_{i = 1}^k \\binom{n}{i} f (n, i) $$\n二项式反演（或者直接容斥）有\n$$ f (n, k) = \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} g (n, i) $$","title":"HDU6537 Neko and function"},{"content":"题目大意 定义\n$$ f (n) = \\sum_{d \\mid n} d \\left[ \\gcd \\left( d, \\frac{n}{d} \\right) = 1 \\right] $$\n求其前缀和 $S(n)$。\n分析 首先 Min25 筛是过不了的，内存不够。先推式子\n$$ \\begin{aligned} S (n) \u0026amp;= \\sum_{i = 1}^n \\sum_{d \\mid i} d \\left[ \\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026amp;= \\sum_{d = 1}^n \\sum_{i = 1}^n d [d \\mid i] \\left[\\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026amp;= \\sum_{d = 1}^n \\sum_{i = 1}^{n / d} d [\\gcd (i, d) = 1] \\end{aligned} $$\n看到 $\\gcd = 1$ 就应该想起来 Mobius 反演，容易化简有\n$$ S (n) = \\sum_{d = 1}^n \\sum_{i = 1}^{n / d} d \\sum_{u \\mid \\gcd (i, d)} \\mu(u) = \\sum_{u = 1}^{\\sqrt{n}} u \\mu (u) \\sum_{d = 1}^{n / u^2} d \\left\\lfloor \\frac{n}{d u^2} \\right\\rfloor $$\n用数论分块即可，计算复杂度 $O ( \\sqrt{n} \\log n )$。\nconst ll maxn = 1e6 + 20; const ll mod = 1e9 + 7; bool notp[maxn]; int prime[maxn / 10], cnt; ll mu[maxn]; void sieve(int n); // 筛 Mobius 函数 ll g[maxn]; ll G(ll n) { if (n \u0026lt;= 1e6 \u0026amp;\u0026amp; g[n] \u0026gt; 0) return g[n]; // 不做记忆化会 T __int128_t ret = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = n / (n / l); __int128_t t = __int128_t(l + r) * (r - l + 1) / 2; ret += t * (n / l); } if (n \u0026lt;= 1e6) g[n] = ret % mod; return ret % mod; } int main() { ll ttt = rr(); sieve(1e6 + 1); for (ll i = 1; i \u0026lt;= 1e6+1; i++) { mu[i] = (mu[i - 1] + mu[i] * i) % mod; } while (ttt--) { ll n = rr(), sn = sqrt(n * 1.0); __int128_t ans = 0; for (ll l = 1, r; l \u0026lt;= sn; l = r + 1) { ll t = n / l / l; r = sqrt(n / (n / l / l) * 1.0); ans += (mu[r] - mu[l - 1]) * G(n / l / l); } ans = (ans % mod + mod) % mod; printf(\u0026#34;%lld\\n\u0026#34;, ll(ans)); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6750/","summary":"题目大意 定义\n$$ f (n) = \\sum_{d \\mid n} d \\left[ \\gcd \\left( d, \\frac{n}{d} \\right) = 1 \\right] $$\n求其前缀和 $S(n)$。\n分析 首先 Min25 筛是过不了的，内存不够。先推式子\n$$ \\begin{aligned} S (n) \u0026amp;= \\sum_{i = 1}^n \\sum_{d \\mid i} d \\left[ \\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026amp;= \\sum_{d = 1}^n \\sum_{i = 1}^n d [d \\mid i] \\left[\\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026amp;= \\sum_{d = 1}^n \\sum_{i = 1}^{n / d} d [\\gcd (i, d) = 1] \\end{aligned} $$","title":"HDU6750 Function"},{"content":"题目大意 即求\n$$ S = \\sum_{n=0}^\\infty f(n)r^n $$\n分析 换序\n$$ S = \\sum_{n = 0}^{\\infty} \\left( \\sum_{i = 0}^m f_i n^i \\right) r^n = \\sum_{i = 0}^m f_i \\sum_{n = 0}^{\\infty} n^i r^n $$\n令\n$$ S_i = \\sum_{n = 0}^{\\infty} n^i r^n $$\n套路的逐项相减，主动的凑二项式\n$$ (1 - r) S_i = 1 + \\sum_{n = 1}^{\\infty} n^i r^n - \\sum_{n = 1}^{\\infty} (n - 1)^i r^n = 1 + \\sum_{n = 0}^{\\infty} r^{n + 1} \\sum_{j = 0}^{i - 1} \\binom{k}{j} n^j $$\n交换求和顺序\n$$ (1 - r) S_i = 1 + \\sum_{j = 0}^{i - 1} \\binom{k}{j} \\sum_{n = 0}^{\\infty}r^{n + 1} n^j = 1 + \\sum_{j = 0}^{i - 1} \\binom{k}{j} r S_j $$\n再凑成完整的二项式卷积\n$$ \\frac{S_i - 1}{r} = \\sum_{j = 0}^i \\binom{k}{j} S_j $$\n我们设 $\\{ S_i \\}$ 的 EGF 为 $g(x)$，可以得到方程\n$$ \\frac{g(x) - 1}{r} = {\\rm e}^x g(x) $$\n解得\n$$ g(x) = \\frac{1}{1 - r {\\rm e}^x} $$\n因此最终多项式逆即可，EGF 和 OGF 的转化就是点乘阶乘。\nint main() { int m = rr() + 1, r = rr(); int lim = get_lim(m, m); w = pre_w(lim); Inv = pre_inv(lim); fac = pre_fac(lim); ifac = pre_ifac(fac); poly_t gg(lim, 1); // 初始化为 1 gg = ntt_ogf2egf(gg, lim); for (int i = 0; i \u0026lt; lim; i++) gg[i] = Mint(0) - gg[i] * r; gg[0] += 1; gg = ntt_inv(gg, lim); gg = ntt_egf2ogf(gg, lim); Mint ans = 0; for (int i = 0; i \u0026lt; m; i++) { int fi = rr(); ans += gg[i] * fi; } printf(\u0026#34;%d\u0026#34;, ans.v); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/p5349/","summary":"题目大意 即求\n$$ S = \\sum_{n=0}^\\infty f(n)r^n $$\n分析 换序\n$$ S = \\sum_{n = 0}^{\\infty} \\left( \\sum_{i = 0}^m f_i n^i \\right) r^n = \\sum_{i = 0}^m f_i \\sum_{n = 0}^{\\infty} n^i r^n $$\n令\n$$ S_i = \\sum_{n = 0}^{\\infty} n^i r^n $$\n套路的逐项相减，主动的凑二项式\n$$ (1 - r) S_i = 1 + \\sum_{n = 1}^{\\infty} n^i r^n - \\sum_{n = 1}^{\\infty} (n - 1)^i r^n = 1 + \\sum_{n = 0}^{\\infty} r^{n + 1} \\sum_{j = 0}^{i - 1} \\binom{k}{j} n^j $$","title":"P5349 幂"},{"content":"题目大意 给定积性函数 $f(p^c) = p \\oplus c$。对 $1000000007$ 取模求前缀和。\n分析 Min25 板子题。\nconst ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n \u0026lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi \u0026lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.01); m = cnt = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { w[++m] = r = n / (n / l); ll mr = mo(r); s[m] = mr * (mr + 1) % mod * inv2 % mod - 1; c[m] = mr - 1; } for (ll p = 2; p \u0026lt;= sqrt_n; p++) { if (c[p] != c[p - 1]) { prime[++cnt] = p; for (ll j = m; w[j] \u0026gt;= p * p; j--) { s[j] = mo(s[j] - p * mo(s[id(w[j] / p)] - s[p - 1])); c[j] = mo(c[j] - (c[id(w[j] / p)] - c[p - 1])); } } } for (int i = 2; i \u0026lt;= m; i++) s[i] = mo(s[i] - c[i] + 2); printf(\u0026#34;%lld\u0026#34;, F(n, 0) + 1); } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-08/loj6053/","summary":"题目大意 给定积性函数 $f(p^c) = p \\oplus c$。对 $1000000007$ 取模求前缀和。\n分析 Min25 板子题。\nconst ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n \u0026lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi \u0026lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.","title":"LOJ6053 简单的函数"},{"content":"题目大意 给定文本串 $S$ 和模式串 $T$，对每个位置进行匹配，得到失配次数。\n统计此失配次数，计算前缀和。\n分析 我是没料到 HDOJ 没有 M_PI，CE 了几发。\nFFT 字符串匹配模板题，我在 ZAFU Wiki 中讲过，即对每个字符卷积。\n#include \u0026#34;template/basic/complex.hpp\u0026#34; const int maxn = 1 \u0026lt;\u0026lt; 20; using img = Complex\u0026lt;double\u0026gt;; using poly_t = vector\u0026lt;img\u0026gt;; poly_t w; #include \u0026#34;template/poly-fft/fft_init.hpp\u0026#34; #include \u0026#34;template/poly-fft/fft.hpp\u0026#34; char a[maxn], b[maxn]; int sum[maxn], ans[maxn]; char ch[] = \u0026#34;0123456789*\u0026#34;; int main() { w = fft_init(maxn); int ttt = rr(); while (ttt--) { int n = rr(), m = rr(); fill(sum, sum + m + n + 12, 0); fill(ans, ans + m + 12, 0); int lim = getlim(m, n); scanf(\u0026#34;%s %s\u0026#34;, b, a); int tsum = 0; for (int i = 0; i \u0026lt; m - 1; i++) { tsum += b[i] == \u0026#39;*\u0026#39;; tsum += a[i] == \u0026#39;*\u0026#39;; } tsum += a[m - 1] == \u0026#39;*\u0026#39;; reverse(a, a + m + 1); for (int k = 0; k \u0026lt;= 10; k++) { poly_t SS(lim); for (int i = 0; i \u0026lt; n; i++) SS[i].x = b[i] == ch[k]; for (int i = 1; i \u0026lt;= m; i++) SS[i].y = a[i] == ch[k]; fft(SS); for (int i = 0; i \u0026lt; lim; i++) SS[i] = SS[i] * SS[i]; ifft(SS); if (k == 10) { for (int i = 0; i \u0026lt;= m + n; i++) sum[i] -= int(SS[i].y / 2 + 0.5); } else { for (int i = 0; i \u0026lt;= m + n; i++) sum[i] += int(SS[i].y / 2 + 0.5); } } for (int i = m; i \u0026lt;= n; i++) { tsum += (b[i - 1] == \u0026#39;*\u0026#39;) - (b[i - m - 1] == \u0026#39;*\u0026#39;); int tans = tsum + sum[i]; ans[m - tans]++; } tsum = 0; for (int i = 0; i \u0026lt;= m; i++) { tsum += ans[i]; printf(\u0026#34;%d\\n\u0026#34;, tsum); } } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/hdu6975/","summary":"题目大意 给定文本串 $S$ 和模式串 $T$，对每个位置进行匹配，得到失配次数。\n统计此失配次数，计算前缀和。\n分析 我是没料到 HDOJ 没有 M_PI，CE 了几发。\nFFT 字符串匹配模板题，我在 ZAFU Wiki 中讲过，即对每个字符卷积。\n#include \u0026#34;template/basic/complex.hpp\u0026#34; const int maxn = 1 \u0026lt;\u0026lt; 20; using img = Complex\u0026lt;double\u0026gt;; using poly_t = vector\u0026lt;img\u0026gt;; poly_t w; #include \u0026#34;template/poly-fft/fft_init.hpp\u0026#34; #include \u0026#34;template/poly-fft/fft.hpp\u0026#34; char a[maxn], b[maxn]; int sum[maxn], ans[maxn]; char ch[] = \u0026#34;0123456789*\u0026#34;; int main() { w = fft_init(maxn); int ttt = rr(); while (ttt--) { int n = rr(), m = rr(); fill(sum, sum + m + n + 12, 0); fill(ans, ans + m + 12, 0); int lim = getlim(m, n); scanf(\u0026#34;%s %s\u0026#34;, b, a); int tsum = 0; for (int i = 0; i \u0026lt; m - 1; i++) { tsum += b[i] == \u0026#39;*\u0026#39;; tsum += a[i] == \u0026#39;*\u0026#39;; } tsum += a[m - 1] == \u0026#39;*\u0026#39;; reverse(a, a + m + 1); for (int k = 0; k \u0026lt;= 10; k++) { poly_t SS(lim); for (int i = 0; i \u0026lt; n; i++) SS[i].","title":"HDU6975 Forgiving Matching"},{"content":"魔改 KMP 大概是不行的，卷积在这里出现的很妙。\n卷积处理匹配 定义匹配函数\n$$ d(x,y) = [x = y] $$\n给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义\n$$ f(k) = \\sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k}) $$\n即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算\n$$ d(x,y) = (x - y)^2 $$\n再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有\n$$ \\begin{aligned} f(k) \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\\\ \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k} \\end{aligned} $$\n前面两项能够预处理，最后一项是卷积。于是最终复杂度是 $O(n \\log n)$。\n考虑通配符 仅令通配符的字符值为 $0$，再搓个匹配函数\n$$ d(x,y) = xy(x-y)^2 $$\n然后大力展开\n$$ \\begin{aligned} f(k) \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^3B_{i-m+k} + \\sum_{i=0}^{m-1}A_{i}B_{i-m+k}^3 - 2\\sum_{i=0}^{m-1} A_{i}^2B_{i-m+k}^2\\\\ \u0026amp;= \\sum_{i=0}^{m-1}S_{m-i}^3B_{i-m+k} + \\sum_{i=0}^{m-1}S_{m-i}B_{i-m+k}^3 - 2\\sum_{i=0}^{m-1} S_{m-i}^2B_{i-m+k}^2 \\end{aligned} $$\n注意到三个都是卷积，于是最终复杂度是 $O(n \\log n)$。\n记得优化取模。我换 NTT 之后 TLE 了好几次，最后发现是 NTT 里取模写多了。。\n#define ACM_MOD 998244353 const int mod = ACM_MOD; #include \u0026#34;template/basic/qpow.hpp\u0026#34; #include \u0026#34;template/basic/inv.hpp\u0026#34; #include \u0026#34;template/basic/mint.hpp\u0026#34; using poly_t = vector\u0026lt;Mint\u0026gt;; poly_t w; #include \u0026#34;template/poly-ntt/pre_w.hpp\u0026#34; #include \u0026#34;template/poly-ntt/ntt.hpp\u0026#34; const int maxn = 1 \u0026lt;\u0026lt; 21; char a[maxn], b[maxn]; int stk[maxn], cnt = 0; int main() { int m = rr(), n = rr(); int lim = get_lim(m, n); w = pre_w(lim); poly_t B1(lim), B2(lim), B3(lim), S1(lim), S2(lim), S3(lim); scanf(\u0026#34;%s %s\u0026#34;, a, b); for (int i = 1; i \u0026lt;= m; i++) { int j = m - i, t = a[j] - \u0026#39;a\u0026#39; + 1; if (a[j] == \u0026#39;*\u0026#39;) t = 0; S1[i] = t; S2[i] = S1[i] * S1[i]; S3[i] = S2[i] * S1[i]; } for (int i = 0; i \u0026lt; n; i++) { int t = b[i] - \u0026#39;a\u0026#39; + 1; if (b[i] == \u0026#39;*\u0026#39;) t = 0; B1[i] = t; B2[i] = B1[i] * B1[i]; B3[i] = B2[i] * B1[i]; } ntt(S1), ntt(S2), ntt(S3); ntt(B1), ntt(B2), ntt(B3); for (int i = 0; i \u0026lt; lim; i++) S1[i] = S1[i] * B3[i] + S3[i] * B1[i] - S2[i] * B2[i] * 2; intt(S1); for (int i = m; i \u0026lt;= n; i++) { if (S1[i].v == 0) stk[++cnt] = i - m + 1; } printf(\u0026#34;%d\\n\u0026#34;, cnt); for (int i = 1; i \u0026lt;= cnt; i++) { printf(\u0026#34;%d \u0026#34;, stk[i]); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/p4173/","summary":"魔改 KMP 大概是不行的，卷积在这里出现的很妙。\n卷积处理匹配 定义匹配函数\n$$ d(x,y) = [x = y] $$\n给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义\n$$ f(k) = \\sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k}) $$\n即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算\n$$ d(x,y) = (x - y)^2 $$\n再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有\n$$ \\begin{aligned} f(k) \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\\\ \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k} \\end{aligned} $$","title":"P4173 残缺的字符串"},{"content":"题目大意 求杨辉三角形前 $n$ 行的偶数个数，对 $1000003$ 取模。\n分析 对杨辉三角奇数打表。\n1 1 1 1 1 1 1 1 1 1\t1 1 1\t1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\t1 1 1\t1 1 1 1\t1 1 1 1 1 1\t1 1 1 1 1\t1\t1\t1 1 1\t1 1\t1 1\t1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\t1 1 1\t1 1 1 1\t1 1 1 1 1 1\t1 1 1 1 1\t1\t1\t1 1 1\t1 1\t1 1\t1 1 1 1 1 1\t1 1 1 1 1 1 1 1 1 1 1 1\t1 1 1 1 1 1 1 1 1\t1\t1\t1 1 1\t1 1\t1 1\t1 1 1 1\t1 1\t1 1\t1 1 1 1 1 1\t1 1 1 1\t1 1 1 1\t1 1 1 1 1\t1\t1\t1\t1\t1\t1\t1 1 1\t1 1\t1 1\t1 1\t1 1\t1 1\t1 1\t1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 于是递推公式\n$$ f(2^t+n) = f(2^t) + 2f(n) $$\n就是显然的了，那么偶数即是全部的减去奇数个数。\nconst ll MOD = 1000003; ll nn[10086]; #define ACM_MOD MOD #include \u0026#34;template/basic/qpow.hpp\u0026#34; #include \u0026#34;template/basic/inv.hpp\u0026#34; int main() { ll n = rr(); nn[1] = 1; for (ll i = 2; i \u0026lt;= 100; i++) nn[i] = nn[i - 1] * 3 % MOD; ll t = 1, ans = 0; for (ll i = 1; i \u0026lt;= 100; i++) { if ((t \u0026amp; n) \u0026gt; 0) ans = (ans * 2 + nn[i]) % MOD; t = t \u0026lt;\u0026lt; 1; if (t \u0026gt; n) break; } n = n % MOD; ll sum = n * (n + 1) % MOD * inv(2) % MOD; printf(\u0026#34;%lld\\n\u0026#34;, (sum - ans + MOD) % MOD); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/p1762/","summary":"题目大意 求杨辉三角形前 $n$ 行的偶数个数，对 $1000003$ 取模。\n分析 对杨辉三角奇数打表。\n1 1 1 1 1 1 1 1 1 1\t1 1 1\t1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\t1 1 1\t1 1 1 1\t1 1 1 1 1 1\t1 1 1 1 1\t1\t1\t1 1 1\t1 1\t1 1\t1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\t1 1 1\t1 1 1 1\t1 1 1 1 1 1\t1 1 1 1 1\t1\t1\t1 1 1\t1 1\t1 1\t1 1 1 1 1 1\t1 1 1 1 1 1 1 1 1 1 1 1\t1 1 1 1 1 1 1 1 1\t1\t1\t1 1 1\t1 1\t1 1\t1 1 1 1\t1 1\t1 1\t1 1 1 1 1 1\t1 1 1 1\t1 1 1 1\t1 1 1 1 1\t1\t1\t1\t1\t1\t1\t1 1 1\t1 1\t1 1\t1 1\t1 1\t1 1\t1 1\t1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 于是递推公式","title":"P1762 偶数"},{"content":"题目大意 即求\n$$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] $$\n分析 先转化一下\n$$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] = \\sum_{p}\\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) = p] $$\n在 P2522 中得到\n$$ \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tk} \\right\\rfloor \\left\\lfloor \\frac{y}{tk} \\right\\rfloor $$\n代入有\n$$ \\sum_{p} \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tp} \\right\\rfloor \\left\\lfloor \\frac{y}{tp} \\right\\rfloor $$\n令 $T = tp$，$T$ 的上界应还是 $\\min(x,y)$，代入有\n$$ \\sum_{T=1}^{\\min(x,y)} \\left\\lfloor \\frac{x}{T} \\right\\rfloor \\left\\lfloor \\frac{y}{T} \\right\\rfloor \\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right) $$\n后面那个在 Euler 筛后再求和一下，是可以预处理的。\nconst ll MN = 1e7 + 100; int mu[MN], f[MN], dp[MN]; bool notp[MN]; int prime[MN/10], cnt; void sieve(int n) { mu[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { if (!notp[i]) prime[++cnt] = i, mu[i] = -1; int t = n / i; for (ll j = 1; j \u0026lt;= cnt; j++) { if (prime[j] \u0026gt; t) break; notp[i * prime[j]] = true; if (i % prime[j] == 0) { mu[i * prime[j]] = 0; break; } mu[i * prime[j]] = - mu[i]; } } for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= cnt; j++) { ll t = i * prime[j]; if(t \u0026gt; n) break; dp[t] += mu[i]; } } for (ll i = 1; i \u0026lt;= n; i++) f[i] = f[i - 1] + dp[i]; } 此时 $dp(T)$ 中存的是 $\\displaystyle\\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right)$，$f_i$ 是其前缀和。\n之后整数分块即可\nll calc(ll a, ll b) { ll mab = min(a, b); ll sum = 0; for (ll l = 1, r; l \u0026lt;= mab; l = r + 1) { r = min(a / (a / l), b / (b / l)); sum += (f[r] - f[l - 1]) * (a / l) * (b / l); } return sum; } int main() { ll ttt = rr(); sieve(MN - 10); for (ll i = 1; i \u0026lt;= ttt; i++) { ll a = rr(), b = rr(); printf(\u0026#34;%lld\\n\u0026#34;, calc(a,b)); } return 0; } 相似题目 P2568 GCD 即 $M = N = n$ 的特殊情况，可以再优化。即求\n$$ \\sum_{i=1}^n \\sum_{j=1}^n [\\gcd(i,j) \\in \\mathbb{P}] $$\n化简有\n$$ \\begin{aligned} \\sum_{p} \\sum_{i=1}^n \\sum_{j=1}^n [\\gcd(i,j) = p] \u0026amp;= \\sum_{p} \\sum_{i=1}^{\\lfloor n/p\\rfloor} \\sum_{j=1}^{\\lfloor n/p\\rfloor} [\\gcd(i,j) = 1]\\\\\\\\ \u0026amp;= \\sum_{p} \\left(2\\sum_{j=1}^{\\lfloor n/p\\rfloor} \\sum_{j=1}^{i} [\\gcd(i,j) = p] - 1\\right)\\\\\\\\ \u0026amp;= \\sum_{p}\\left( 2\\sum_{i=1}^{\\lfloor n/p \\rfloor} \\varphi(i) - 1 \\right) \\end{aligned} $$\n预处理出 $\\varphi(i)$ 的前缀和后，对每个素数筛一遍即可。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2257/","summary":"题目大意 即求\n$$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] $$\n分析 先转化一下\n$$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] = \\sum_{p}\\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) = p] $$\n在 P2522 中得到\n$$ \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tk} \\right\\rfloor \\left\\lfloor \\frac{y}{tk} \\right\\rfloor $$\n代入有\n$$ \\sum_{p} \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tp} \\right\\rfloor \\left\\lfloor \\frac{y}{tp} \\right\\rfloor $$\n令 $T = tp$，$T$ 的上界应还是 $\\min(x,y)$，代入有\n$$ \\sum_{T=1}^{\\min(x,y)} \\left\\lfloor \\frac{x}{T} \\right\\rfloor \\left\\lfloor \\frac{y}{T} \\right\\rfloor \\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right) $$","title":"P2257 YY 的 GCD"},{"content":"题目大意 设\n$$ \\varphi_{x+1}(m) = \\varphi(\\varphi_x(m)) $$\n求最小的 $x$ 使得 $\\varphi_x(m) = 1$。\n其中 $\\varphi(m)$ 是欧拉函数。\n分析 注意到仅有 $\\varphi(1) = \\varphi(2) = 1$，再有公式\n$$ \\varphi\\left(\\prod_{i=1}^mp_i^{q_i}\\right) = \\prod_{i=1}^m(p_i-1)p_i^{q_i-1} $$\n因此从唯一分解形式的角度来看，迭代一次消去了一个 $2$，也生成了一些 $2$。\n考虑设 $f(n)$ 为 $\\varphi(n)$ 中因子 $2$ 的个数。\n设 $\\gcd(a,b) = 1$，可以证明 $f(ab) = f(a) f(b)$。同时 $f(p) = f(p-1)$。\n这说明 $f(x)$ 是一个积性函数，可以用 Euler 筛递推。\nconst ll MN = 1e5 + 10; bool notp[1000001]; int prime[200001], cnt, phi[1000001]; void sieve(int n) { phi[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { if (!notp[i]) { prime[++cnt] = i; phi[i] = phi[i - 1]; } int t = n / i; for (ll j = 1; j \u0026lt;= cnt; j++) { if (prime[j] \u0026gt; t) break; int ti = i * prime[j]; notp[ti] = true; phi[ti] = phi[i] + phi[prime[j]]; if (i % prime[j] == 0) break; } } } 然后在 main 中输出即可。注意若没有质因子 $2$，则答案需要加 $1$。\nint main() { sieve(MN - 10); ll ttt = rr(); while (ttt--) { ll m = rr(), ans = 1; for (ll i = 1; i \u0026lt;= m; i++) { ll p = rr(), q = rr(); if (p == 2) ans--; ans += phi[p] * q; } printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2350/","summary":"题目大意 设\n$$ \\varphi_{x+1}(m) = \\varphi(\\varphi_x(m)) $$\n求最小的 $x$ 使得 $\\varphi_x(m) = 1$。\n其中 $\\varphi(m)$ 是欧拉函数。\n分析 注意到仅有 $\\varphi(1) = \\varphi(2) = 1$，再有公式\n$$ \\varphi\\left(\\prod_{i=1}^mp_i^{q_i}\\right) = \\prod_{i=1}^m(p_i-1)p_i^{q_i-1} $$\n因此从唯一分解形式的角度来看，迭代一次消去了一个 $2$，也生成了一些 $2$。\n考虑设 $f(n)$ 为 $\\varphi(n)$ 中因子 $2$ 的个数。\n设 $\\gcd(a,b) = 1$，可以证明 $f(ab) = f(a) f(b)$。同时 $f(p) = f(p-1)$。\n这说明 $f(x)$ 是一个积性函数，可以用 Euler 筛递推。\nconst ll MN = 1e5 + 10; bool notp[1000001]; int prime[200001], cnt, phi[1000001]; void sieve(int n) { phi[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { if (!","title":"P2350 外星人"},{"content":"Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。\n若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。\n求一年有几对。\n$$ xd+y \\equiv yd+x \\pmod w $$\n即\n$$ (x-y)(d-1) \\equiv 0 \\Rightarrow (x-y)(d-1) \\in w\\mathbb{Z} $$\n于是有\n$$ y-x = \\frac{wk}{\\gcd(w,d-1)} $$\n又 $x \u0026lt; y \\leqslant \\min(m,d)$​，\nint main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/cf1389e/","summary":"Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。\n若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。\n求一年有几对。\n$$ xd+y \\equiv yd+x \\pmod w $$\n即\n$$ (x-y)(d-1) \\equiv 0 \\Rightarrow (x-y)(d-1) \\in w\\mathbb{Z} $$\n于是有\n$$ y-x = \\frac{wk}{\\gcd(w,d-1)} $$\n又 $x \u0026lt; y \\leqslant \\min(m,d)$​，\nint main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","title":"CF1389E Calendar Ambiguity"},{"content":"题目大意 即求\n$$ \\sum_{i=1}^n \\gcd(i,n) $$\n分析 联想到\n$$ \\varphi(n) = \\sum_{i=1}^n [\\gcd(i,n) = 1] $$\n尝试凑这个形式\n$$ \\begin{aligned} \\sum_{i=1}^n \\gcd(i,n) \u0026amp;= \\sum_{d \\mid n} d \\sum_{i=1}^n [\\gcd(i,n) = d] \\\\ \u0026amp;= \\sum_{d \\mid n} d \\sum_{i=1}^{n/d} [\\gcd(i,n/d) = 1] \\\\ \u0026amp;= \\sum_{d \\mid n} d \\varphi(n/d) \\end{aligned} $$\n这里其实已经可以过题了，但还可以再瞎搞一下，令\n$$ nf(n) = \\sum_{d \\mid n} d \\varphi(n/d) = n\\sum_{d \\mid n} \\frac{\\varphi(d)}{d} $$\n尝试证明 $f(n)$ 是一个积性函数。设 $\\gcd(a,b) = 1$，有\n$$ \\begin{aligned} f(a)f(b) \u0026amp;= \\left(\\sum_{d_1 \\mid a} \\frac{\\varphi(d_1)}{d_1}\\right) \\left(\\sum_{d_2 \\mid b} \\frac{\\varphi(d_2)}{d_2}\\right)\\\\ \u0026amp;= \\sum_{d_1 \\mid a} \\sum_{d_2 \\mid b} \\frac{\\varphi(d_1)}{d_1} \\frac{\\varphi(d_2)}{d_2}\\\\ \u0026amp;= \\sum_{d_1 \\mid a} \\sum_{d_2 \\mid b} \\frac{\\varphi(d_1d_2)}{d_1d_2}\\\\ \u0026amp;= f(ab) \\end{aligned} $$\n再来推一下素数，注意 $1 \\mid p^k$，有\n$$ f(p^k) = \\sum_{d \\mid p^k} \\frac{\\varphi(d)}{d} = \\sum_{i=0}^k \\frac{\\varphi(p^i)}{p^i} = k\\left(1 - \\frac{1}{p}\\right) + 1 $$\n类似于 $\\varphi(m)$ 唯一分解形式，我们还有\n$$ f(n) = \\prod_{i=1}^sf(p_i^{k_i}) = \\prod_{i=1}^s \\frac{k_ip_i - k_i + p_i}{p_i} $$\n于是答案即为 $nf(n)$，复杂度 $O(\\sqrt{n})$。\nint main() { ll n = rr(), ans = n; for (ll i = 2; i * i \u0026lt;= n; i++) { ll k = 0; while (n % i == 0) k++, n /= i; if (k \u0026gt; 0) ans += ans / i * k * (i - 1); } if (n \u0026gt; 1) ans += ans / n * (n - 1); printf(\u0026#34;%lld\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2303/","summary":"题目大意 即求\n$$ \\sum_{i=1}^n \\gcd(i,n) $$\n分析 联想到\n$$ \\varphi(n) = \\sum_{i=1}^n [\\gcd(i,n) = 1] $$\n尝试凑这个形式\n$$ \\begin{aligned} \\sum_{i=1}^n \\gcd(i,n) \u0026amp;= \\sum_{d \\mid n} d \\sum_{i=1}^n [\\gcd(i,n) = d] \\\\ \u0026amp;= \\sum_{d \\mid n} d \\sum_{i=1}^{n/d} [\\gcd(i,n/d) = 1] \\\\ \u0026amp;= \\sum_{d \\mid n} d \\varphi(n/d) \\end{aligned} $$\n这里其实已经可以过题了，但还可以再瞎搞一下，令\n$$ nf(n) = \\sum_{d \\mid n} d \\varphi(n/d) = n\\sum_{d \\mid n} \\frac{\\varphi(d)}{d} $$\n尝试证明 $f(n)$ 是一个积性函数。设 $\\gcd(a,b) = 1$，有","title":"P2303 Longge 的问题"},{"content":"题目大意 给定 $g[1], \\cdots, g[m]$，求序列 $f$。\n$$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$\n分析 不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程\n$$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$\n这个形式看似卷积，但实际上它缺了一项。对 $n \u0026gt; 0$ 凑卷积\n$$ f [n] (h [0] + 1) = \\sum_{j = 0}^n f [n - j] h [j] = (f \\ast h) [n] $$\n又 $f [0] = 1$，有\n$$ f \\ast (1 + h [0]) - f \\ast h = f [0] (1 + h [0]) - f [0] h [0] = f [0] $$\n解得\n$$ f (x) = \\frac{f [0]}{1 + h [0] - h (x)} = \\frac{1}{1 - g (x)} $$\n于是求逆即可\n#define ACM_MOD 998244353 const int mod = ACM_MOD; using poly_t = vector\u0026lt;int\u0026gt;; poly_t w; #include \u0026#34;template/basic/qpow.hpp\u0026#34; #include \u0026#34;template/basic/mint.hpp\u0026#34; #include \u0026#34;template/basic/inv.hpp\u0026#34; #include \u0026#34;template/poly-ntt/ntt_init.hpp\u0026#34; #include \u0026#34;template/poly-ntt/ntt.hpp\u0026#34; #include \u0026#34;template/poly-ntt/ntt_inv.hpp\u0026#34; int main() { int n = rr(); int lim = getlin(n, n); w = ntt_init(lim); poly_t ans, ff(lim); for (int i = 1; i \u0026lt; n; i++) ff[i] = mod - rr(); ff[0] = 1; ans = ntt_inv(ff, lim); for (int i = 0; i \u0026lt; n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p4721/","summary":"题目大意 给定 $g[1], \\cdots, g[m]$，求序列 $f$。\n$$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$\n分析 不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程\n$$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$\n这个形式看似卷积，但实际上它缺了一项。对 $n \u0026gt; 0$ 凑卷积","title":"P4721 分治 FFT"},{"content":"题目大意 即求\n$$ \\sum_{i=a}^b \\sum_{j=c}^d [\\gcd(i,j) = k] $$\n分析 容易想到，独立出函数 $f(k)$ 使得\n$$ f(k) = \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] $$\n利用 Mobius 反演化简，设 $F(d)$\n$$ F(n) = \\sum_{n \\mid d} f(d) = \\sum_{i=1}^x \\sum_{j=1}^y [n \\mid i][n \\mid j] = \\left\\lfloor \\frac{x}{n} \\right\\rfloor \\left\\lfloor \\frac{y}{n} \\right\\rfloor $$\n反演化简有\n$$ f(n) = \\sum_{n \\mid d} \\mu\\left(\\frac{d}{n}\\right)F(d) = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tn} \\right\\rfloor \\left\\lfloor \\frac{y}{tn} \\right\\rfloor $$\n预处理出 $\\mu(t)$ 的前缀和，剩下的就是一个二重分块了。\nconst ll MN = 50000; bool notp[1000001]; int prime[200001], cnt, mu[MN]; void Mobius(int n); // 预处理 Mobius 函数 ll f(ll a, ll b) { ll mab = min(a, b); ll sum = 0; for (ll l = 1, r; l \u0026lt;= mab; l = r + 1) { r = min(a / (a / l), b / (b / l)); sum += (mu[r] - mu[l - 1]) * (a / l) * (b / l); } return sum; } int main() { ll ttt = rr(); Mobius(MN - 1); for (ll i = 1; i \u0026lt;= MN - 1; i++) mu[i] += mu[i - 1]; for (ll i = 1; i \u0026lt;= ttt; i++) { ll a = rr(), b = rr(), c = rr(), d = rr(); ll k = rr(); a--, c--; a /= k, b /= k, c /= k, d /= k; ll ans = f(b, d) - f(a, d) - f(b, c) + f(a, c); printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } 类似题目 P2158 仪仗队：即 $k = 1$ 的特殊情况。\nP3455 ZAP-Queries：几乎一样。\nP2257 YY 的 GCD：比这题难，单独开篇。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2522/","summary":"题目大意 即求\n$$ \\sum_{i=a}^b \\sum_{j=c}^d [\\gcd(i,j) = k] $$\n分析 容易想到，独立出函数 $f(k)$ 使得\n$$ f(k) = \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] $$\n利用 Mobius 反演化简，设 $F(d)$\n$$ F(n) = \\sum_{n \\mid d} f(d) = \\sum_{i=1}^x \\sum_{j=1}^y [n \\mid i][n \\mid j] = \\left\\lfloor \\frac{x}{n} \\right\\rfloor \\left\\lfloor \\frac{y}{n} \\right\\rfloor $$\n反演化简有\n$$ f(n) = \\sum_{n \\mid d} \\mu\\left(\\frac{d}{n}\\right)F(d) = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tn} \\right\\rfloor \\left\\lfloor \\frac{y}{tn} \\right\\rfloor $$\n预处理出 $\\mu(t)$ 的前缀和，剩下的就是一个二重分块了。","title":"P2522 Problem B"},{"content":"题目大意 给出正整数 $n$ 和 $k$，请计算\n$$ G(n, k) = \\sum_{i = 1}^n k \\bmod i $$\n分析 因为\n$$ k \\bmod i = k - i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$\n因此有\n$$ G(n,k) = nk - \\sum_{i=1}^n i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$\n后面需要整数分块。\nint main() { ll n = rr(); ll k = rr(); ll sum = n * k; n = min(n, k); for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = min(n, k / (k / l)); ll t = (l + r) * (r - l + 1) / 2; sum -= t * (k / l); } printf(\u0026#34;%lld\u0026#34;, sum); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-04/p2261/","summary":"题目大意 给出正整数 $n$ 和 $k$，请计算\n$$ G(n, k) = \\sum_{i = 1}^n k \\bmod i $$\n分析 因为\n$$ k \\bmod i = k - i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$\n因此有\n$$ G(n,k) = nk - \\sum_{i=1}^n i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$\n后面需要整数分块。\nint main() { ll n = rr(); ll k = rr(); ll sum = n * k; n = min(n, k); for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = min(n, k / (k / l)); ll t = (l + r) * (r - l + 1) / 2; sum -= t * (k / l); } printf(\u0026#34;%lld\u0026#34;, sum); return 0; } ","title":"P2261 余数求和"},{"content":"题目大意 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：\n$$ y_i=\\sum_{j=l_i}^{r_i}[w_j \\geqslant W] \\times \\sum_{j=l_i}^{r_i}[w_j \\geqslant W]v_j $$\n记检验结果为 $y=\\sum y_i$，对于给定的 $s$，求 $|y-s|$ 的最小值。\n分析 注意到 $y(w)$ 是关于 $W$ 的递减函数，对 $w$ 在 $[w_{\\min},w_{\\max}]$ 上进行二分。\nconst ll MN = 2e5 + 10; ll vv[MN], ww[MN], li[MN], ri[MN], f1[MN], f2[MN]; ll n, m, s; int main() { n = rr(), m = rr(), s = rr(); ll minw = 0x3f3f3f3f, maxw = 0; f1[0] = f2[0] = 0; for (ll i = 1; i \u0026lt;= n; i++) { ww[i] = rr(), vv[i] = rr(); maxw = max(ww[i], maxw); minw = min(ww[i], minw); } for (ll i = 1; i \u0026lt;= m; i++) { li[i] = rr(), ri[i] = rr(); } ll l = minw, r = maxw + 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (sum(mid) \u0026lt;= s) r = mid; else l = mid + 1; } ll rst = min(sum(l - 1) - s, s - sum(l)); printf(\u0026#34;%lld\u0026#34;, rst); return 0; } 区间求和可以用前缀和优化。\nll f1[MN], f2[MN]; ll sum(ll w) { for (ll i = 1; i \u0026lt;= n; i++) { ll f = ww[i] \u0026gt;= w; f1[i] = f1[i - 1] + f; f2[i] = f2[i - 1] + f * vv[i]; } ll sum = 0; for (ll k = 1; k \u0026lt;= m; k++) { ll l = li[k], r = ri[k]; sum += (f1[r] - f1[l - 1]) * (f2[r] - f2[l - 1]); } return sum; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-04/p1314/","summary":"题目大意 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：\n$$ y_i=\\sum_{j=l_i}^{r_i}[w_j \\geqslant W] \\times \\sum_{j=l_i}^{r_i}[w_j \\geqslant W]v_j $$\n记检验结果为 $y=\\sum y_i$，对于给定的 $s$，求 $|y-s|$ 的最小值。\n分析 注意到 $y(w)$ 是关于 $W$ 的递减函数，对 $w$ 在 $[w_{\\min},w_{\\max}]$ 上进行二分。\nconst ll MN = 2e5 + 10; ll vv[MN], ww[MN], li[MN], ri[MN], f1[MN], f2[MN]; ll n, m, s; int main() { n = rr(), m = rr(), s = rr(); ll minw = 0x3f3f3f3f, maxw = 0; f1[0] = f2[0] = 0; for (ll i = 1; i \u0026lt;= n; i++) { ww[i] = rr(), vv[i] = rr(); maxw = max(ww[i], maxw); minw = min(ww[i], minw); } for (ll i = 1; i \u0026lt;= m; i++) { li[i] = rr(), ri[i] = rr(); } ll l = minw, r = maxw + 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (sum(mid) \u0026lt;= s) r = mid; else l = mid + 1; } ll rst = min(sum(l - 1) - s, s - sum(l)); printf(\u0026#34;%lld\u0026#34;, rst); return 0; } 区间求和可以用前缀和优化。","title":"P1314 聪明的质检员"},{"content":"题目链接：Link 。\nA. ABC String 这么水的题竟然 wa 了 4 发。。\n题目大意 给定一个长 $n$ 的字符串 $a$，仅由 A，B，C 组成，$n$ 为偶数。\n对于仅含 ( 和 ) 的括号序列，当我们能够在其中添加 1 使得其为合法的表达式，则序列合法。\n构造合法的长为 $n$ 的括号序列 $b$，要求在 $a$ 同为 A 的，在 $b$ 中也要相同；B，C 也是如此。\n分析 序列合法的定义即对任意位置，其左侧的 ) 总比 ( 少，且整体左右括号数相等。\n首个字母必为左括号，末尾字母必为右括号。剩下的那个讨论一下即可。\nchar ss[60]; int main() { ll ttt = rr(); while (ttt--) { scanf(\u0026#34;%s\u0026#34;, ss + 1); ll len = strlen(ss + 1); if (ss[1] == ss[len]) { printf(\u0026#34;NO\\n\u0026#34;); continue; } ll sa[3] = {0, 0, 0}; for (ll i = 1; i \u0026lt;= len; i++) sa[ss[i] - \u0026#39;A\u0026#39;]++; ll sl = ss[1] - \u0026#39;A\u0026#39;, sr = ss[len] - \u0026#39;A\u0026#39;; ll sm = 3ll - sl - sr; bool flag = false; sa[0] = sa[1] = sa[2] = 0; if (sa[sl] + sa[sm] == sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] + sa[sm] \u0026lt; sa[sr]; } } else if (sa[sl] == sa[sm] + sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] \u0026lt; sa[sm] + sa[sr]; } } else { printf(\u0026#34;NO\\n\u0026#34;); continue; } if (flag) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); } return 0; } B. Berland Crossword 题目大意 对于一个边长为 $n$ 的正方形黑白棋盘，指定其最顶行的黑色块数为 $u$，最左列、最右侧、最底行的黑色块数分别为 $l,r,d$。\n判断棋盘是否存在。\n分析 关键点在于四个角，然而也就只有 $16$ 种可能，枚举即可。\nll ff[10], aa[10]; int main() { ll ttt = rr(); while (ttt--) { ll n = rr(); for (ll i = 0; i \u0026lt;= 3; i++) aa[i] = rr(); bool flag = false; for (ll k = 0; k \u0026lt;= 15; k++) { memset(ff, 0, sizeof(ff)); int f = 1; for (ll j = 0; j \u0026lt;= 3; j++) { ff[j] = ((k \u0026amp; f) \u0026gt; 0); f = f \u0026lt;\u0026lt; 1; } bool tflag = false; for (ll j = 0; j \u0026lt;= 3; j++) { ll u = aa[j] - ff[j] - ff[(j + 1) % 4]; tflag = tflag || u \u0026lt; 0 || u \u0026gt; n - 2; } flag = flag || !tflag; } if (flag) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } C. 1D Sokoban 题目大意 假设一个直线上的推箱子游戏，你的出生点位于 $0$，在 $a_i$ 处有 $n$ 个箱子，在 $b_i$ 处有 $m$ 个目标点。箱子可能初始化在目标点，但不会在 $0$。\n就像推箱子一样，你可以把箱子推到目标点而不能越过箱子。求最多能使目标点上有几个箱子。\n分析 首先看正半轴，推的时候箱子会积起来，关注点在“箱子队列”的右端。\n容易发现，当右端未碰到新目标点时，结果是不可能变多的。分类讨论\n当右端碰到恰在目标点的新箱子时，ans+1，计算此时覆盖个数，取最值，len+1。 当右端碰到箱子时，len+1。 当右端碰到目标点时，计算此时覆盖个数，取最值。 计算箱子下覆盖目标点个数可以用双指针法维护。\n有些地方可以用二分？但好像没有变快啊\nconst ll inf = 0x3f3f3f3f3f3f3f3f; ll aa[200086], bb[200086]; int main() { ll ttt = rr(); while (ttt--) { ll n = rr(); ll m = rr(); ll a0 = 0, b0 = 0; for (ll i = 1; i \u0026lt;= n; i++) aa[i] = rr(); for (ll i = 1; i \u0026lt;= m; i++) bb[i] = rr(); a0 = lower_bound(aa + 1, aa + n + 1, 0) - aa - 1; b0 = lower_bound(bb + 1, bb + m + 1, 0) - bb - 1; aa[0] = bb[0] = -inf; aa[n + 1] = bb[m + 1] = inf; ll ra1 = a0 + 1, rb1 = b0 + 1; ll sum = 0, ans = 0, len = 0; ll sl = rb1, sr = rb1; while (ra1 \u0026lt;= n || rb1 \u0026lt;= m) { if (aa[ra1] \u0026lt; bb[rb1]) { len++, ra1++; continue; } sr++; ll tsum = sr - sl; if (aa[ra1] \u0026gt; bb[rb1]) { while (bb[sl] \u0026lt;= bb[rb1] - len \u0026amp;\u0026amp; tsum \u0026gt; 0) sl++, tsum--; } else { ans++; while (bb[sl] \u0026lt;= bb[rb1] - len - 1 \u0026amp;\u0026amp; tsum \u0026gt; 0) sl++, tsum--; len++, ra1++; } rb1++; ans = max(ans, tsum); } sum += ans; ra1 = a0; sl = sr = rb1 = b0; ans = len = 0; while (ra1 \u0026gt;= 1 || rb1 \u0026gt;= 1) { if (aa[ra1] \u0026gt; bb[rb1]) { len++, ra1--; continue; } sl--; ll tsum = sr - sl; if (aa[ra1] \u0026lt; bb[rb1]) { while (bb[sr] \u0026gt;= bb[rb1] + len \u0026amp;\u0026amp; tsum \u0026gt; 0) sr--, tsum--; } else { ans++; while (bb[sr] \u0026gt;= bb[rb1] + len + 1 \u0026amp;\u0026amp; tsum \u0026gt; 0) sr--, tsum--; len++, ra1--; } rb1--; ans = max(ans, tsum); } sum += ans; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/cfedu105/","summary":"题目链接：Link 。\nA. ABC String 这么水的题竟然 wa 了 4 发。。\n题目大意 给定一个长 $n$ 的字符串 $a$，仅由 A，B，C 组成，$n$ 为偶数。\n对于仅含 ( 和 ) 的括号序列，当我们能够在其中添加 1 使得其为合法的表达式，则序列合法。\n构造合法的长为 $n$ 的括号序列 $b$，要求在 $a$ 同为 A 的，在 $b$ 中也要相同；B，C 也是如此。\n分析 序列合法的定义即对任意位置，其左侧的 ) 总比 ( 少，且整体左右括号数相等。\n首个字母必为左括号，末尾字母必为右括号。剩下的那个讨论一下即可。\nchar ss[60]; int main() { ll ttt = rr(); while (ttt--) { scanf(\u0026#34;%s\u0026#34;, ss + 1); ll len = strlen(ss + 1); if (ss[1] == ss[len]) { printf(\u0026#34;NO\\n\u0026#34;); continue; } ll sa[3] = {0, 0, 0}; for (ll i = 1; i \u0026lt;= len; i++) sa[ss[i] - \u0026#39;A\u0026#39;]++; ll sl = ss[1] - \u0026#39;A\u0026#39;, sr = ss[len] - \u0026#39;A\u0026#39;; ll sm = 3ll - sl - sr; bool flag = false; sa[0] = sa[1] = sa[2] = 0; if (sa[sl] + sa[sm] == sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] + sa[sm] \u0026lt; sa[sr]; } } else if (sa[sl] == sa[sm] + sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] \u0026lt; sa[sm] + sa[sr]; } } else { printf(\u0026#34;NO\\n\u0026#34;); continue; } if (flag) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); } return 0; } B.","title":"CF1494 Educational Round 105 (Rated for Div. 2)"},{"content":"题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。\n给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。\n分析 我是没想出来，经题解提示了拼接函数才写出来的。\n设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。\nchar s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; for (ll i = 1; i \u0026lt;= ml; i++) { int flag = 1; for (ll j = 0; j \u0026lt;= i - 1; j++) { if (s[x][len[x] + j - i] != s[y][j]) { flag = 0; break; } } if (flag) { mt[x][y] = i; break; } } } 然后回溯 dfs，搜索即可。\nll n; int vis[30]; ll dfs(int x) { if (vis[x] \u0026gt;= 2) return 0; vis[x]++; ll maxlen = 0; for (ll i = 1; i \u0026lt;= n; i++) { if (mt[x][i] \u0026gt; 0) { maxlen = max(maxlen, dfs(i) - mt[x][i]); } } vis[x]--; return maxlen + len[x]; } int main() { n = rr(); for (ll i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%s\u0026#34;, s[i]); len[i] = strlen(s[i]); } for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= n; j++) { init(i, j); } } ll maxlen = 0; scanf(\u0026#34;%s\u0026#34;, s[0]); for (ll i = 1; i \u0026lt;= n; i++) { if (s[i][0] == s[0][0]) { maxlen = max(maxlen, dfs(i)); } } printf(\u0026#34;%lld\\n\u0026#34;, maxlen); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/p1019/","summary":"题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。\n给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。\n分析 我是没想出来，经题解提示了拼接函数才写出来的。\n设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。\nchar s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; for (ll i = 1; i \u0026lt;= ml; i++) { int flag = 1; for (ll j = 0; j \u0026lt;= i - 1; j++) { if (s[x][len[x] + j - i] !","title":"P1019 单词接龙"},{"content":"题目大意 在 $0$ 到 $L$ 的位置间，有 $N$ 块岩石。若要使得岩石间距最小值最大，允许移除 $M$ 块，求此时间距最小值。\n分析 定义函数 $f(x)$，输入为最小值，输出为被移除岩石的个数，实现如下\nll L, N, M, aa[100086]; ll f(ll x) { ll ans = 0; ll l = 0, r = 1; while (r \u0026lt;= N) { if (aa[r] - aa[l] \u0026gt;= x) l = r; else ans++; r++; } return ans; } 显然 $f(x)$ 是单调递减的函数，二分查找即可。\nint main() { L = rr(), N = rr(), M = rr(); for (ll i = 1; i \u0026lt;= N; i++) aa[i] = rr(); aa[++N] = L; ll l = 1, r = L; while (l \u0026lt; r) { ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; ll fm = f(mid); if (fm \u0026lt;= M) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/p2678/","summary":"题目大意 在 $0$ 到 $L$ 的位置间，有 $N$ 块岩石。若要使得岩石间距最小值最大，允许移除 $M$ 块，求此时间距最小值。\n分析 定义函数 $f(x)$，输入为最小值，输出为被移除岩石的个数，实现如下\nll L, N, M, aa[100086]; ll f(ll x) { ll ans = 0; ll l = 0, r = 1; while (r \u0026lt;= N) { if (aa[r] - aa[l] \u0026gt;= x) l = r; else ans++; r++; } return ans; } 显然 $f(x)$ 是单调递减的函数，二分查找即可。\nint main() { L = rr(), N = rr(), M = rr(); for (ll i = 1; i \u0026lt;= N; i++) aa[i] = rr(); aa[++N] = L; ll l = 1, r = L; while (l \u0026lt; r) { ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; ll fm = f(mid); if (fm \u0026lt;= M) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } ","title":"P2678 跳石头"},{"content":"过于简单的题不记录。\n洛谷：更新至：2020.12.31(2020.10)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2020 年 09 月 开始 ACM。不记录 HDU 150 的基础题。\n09-20 | CF1384B2 Koa and the Beach\n09-20 | P1004 方格取数\n09-22 | P2181 对角线\n09-23 | P1042 乒乓球\n2020 年 10 月 10-09 | P1095 守望者的逃离\n10-13 | P5143 攀爬者\n10-16 | P1923 求第 $k$ 小的数\n10-16 | P1928 外星密码\n10-16 | P1990 覆盖墙壁\n10-16 | P1090 合并果子\n10-16 | P4995 跳跳！\n10-16 | P1077 摆花\n2020 年 11 月 11-10 | P3842 线段\n11-10 | P1541 乌龟棋\n11-11 | P1833 樱花\n11-11 | P1064 金明的预算方案\n11-12 | P1941 飞扬的小鸟\n11-16 | P1160 队列安排\n11-17 | P1106 删数问题\n11-17 | P2058 海港\n11-17 | P4715 淘汰赛\n11-17 | P4913 二叉树深度\n11-26 | P3367 并查集\n11-26 | P1226 快速幂 || 取余运算\n11-26 | P3383 线性筛素数\n11-27 | P1636 Einstein 学画画\n11-30 | P1880 石子合并\n2020 年 12 月 12-01 | P3146 248 G\n12-01 | P3371 单源最短路径（弱化版）\n12-01 | P1352 没有上司的舞会\n12-02 | P2052 道路修建\n12-02 | P3379 最近公共祖先（LCA）\n12-02 | P3884 二叉树问题\n12-03 | P2016 战略游戏\n12-03 | P1359 租用游艇\n12-04 | P1629 邮递员送信\n12-14 | P4779 单源最短路径（标准版）\n12-17 | P5656 二元一次不定方程 (exgcd)\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/log2020/","summary":"过于简单的题不记录。\n洛谷：更新至：2020.12.31(2020.10)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2020 年 09 月 开始 ACM。不记录 HDU 150 的基础题。\n09-20 | CF1384B2 Koa and the Beach\n09-20 | P1004 方格取数\n09-22 | P2181 对角线\n09-23 | P1042 乒乓球\n2020 年 10 月 10-09 | P1095 守望者的逃离\n10-13 | P5143 攀爬者\n10-16 | P1923 求第 $k$ 小的数\n10-16 | P1928 外星密码\n10-16 | P1990 覆盖墙壁\n10-16 | P1090 合并果子\n10-16 | P4995 跳跳！\n10-16 | P1077 摆花","title":"2020 年刷题日志"},{"content":"题目大意 环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。\n求最终分数的最小值和最大值。\n分析 考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为\n$$ dp(i,j) = \\max_{i \\leqslant k \\leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j)) $$\n其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。\n然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。\n细节：前缀和、循环开两倍。\nint dmax[205][205], dmin[205][205]; int f[205], s[205]; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) f[i + n] = f[i] = rr(); for (ll i = 1; i \u0026lt;= n * 2; i++) s[i] = s[i - 1] + f[i]; for (ll len = 2; len \u0026lt;= n; len++) { for (ll i = 1; i \u0026lt;= 2 * n - len + 1; i++) { int j = i + len - 1; int tmax = 0, tmin = 0x3f3f3f3f; int ss = s[j] - s[i - 1]; for (ll k = i; k \u0026lt;= j - 1; k++) { tmax = max(tmax, dmax[i][k] + dmax[k + 1][j] + ss); tmin = min(tmin, dmin[i][k] + dmin[k + 1][j] + ss); } dmax[i][j] = tmax; dmin[i][j] = tmin; } } int mmin = 0x3f3f3f3f, mmax = 0; for (ll p = 0; p \u0026lt;= n - 1; p++) { mmin = min(mmin, dmin[p + 1][p + n]); mmax = max(mmax, dmax[p + 1][p + n]); } printf(\u0026#34;%d\\n%d\\n\u0026#34;, mmin, mmax); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1880/","summary":"题目大意 环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。\n求最终分数的最小值和最大值。\n分析 考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为\n$$ dp(i,j) = \\max_{i \\leqslant k \\leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j)) $$\n其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。\n然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。\n细节：前缀和、循环开两倍。\nint dmax[205][205], dmin[205][205]; int f[205], s[205]; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) f[i + n] = f[i] = rr(); for (ll i = 1; i \u0026lt;= n * 2; i++) s[i] = s[i - 1] + f[i]; for (ll len = 2; len \u0026lt;= n; len++) { for (ll i = 1; i \u0026lt;= 2 * n - len + 1; i++) { int j = i + len - 1; int tmax = 0, tmin = 0x3f3f3f3f; int ss = s[j] - s[i - 1]; for (ll k = i; k \u0026lt;= j - 1; k++) { tmax = max(tmax, dmax[i][k] + dmax[k + 1][j] + ss); tmin = min(tmin, dmin[i][k] + dmin[k + 1][j] + ss); } dmax[i][j] = tmax; dmin[i][j] = tmin; } } int mmin = 0x3f3f3f3f, mmax = 0; for (ll p = 0; p \u0026lt;= n - 1; p++) { mmin = min(mmin, dmin[p + 1][p + n]); mmax = max(mmax, dmax[p + 1][p + n]); } printf(\u0026#34;%d\\n%d\\n\u0026#34;, mmin, mmax); return 0; } ","title":"P1880 石子合并"},{"content":"题目大意 混合背包。每棵树都有美学值 $C_i$，共有三种：\n一种只能看一遍。 一种最多看 $A_i$ 遍。 一种可以看无数遍。 分析 对于混合背包，我们可以对物品拆分，得到多个物品。\nll dp[1086], tt[100086], cc[100086]; int main() { int tsh = rr(), tsm = rr(), teh = rr(), tem = rr(); int tsum = (teh - tsh) * 60 + tem - tsm; int n = rr(); int tp = 1; for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(), c = rr(), p = rr(); if (p == 1) { tt[tp] = t, cc[tp] = c; tp++; } else { p = p != 0 ? p : 99999; int b = 1; while (b \u0026lt; p) { tt[tp] = t * b, cc[tp] = c * b; p -= b, b *= 2; tp++; } tt[tp] = t * p, cc[tp] = c * p; tp++; } } for (ll i = 1; i \u0026lt;= tp - 1; i++) { for (ll j = tsum; j \u0026gt;= tt[i]; j--) { dp[j] = max(dp[j], dp[j - tt[i]] + cc[i]); } } ll ans = 0; for (ll ic = 0; ic \u0026lt;= tsum; ic++) { ans = max(dp[ic], ans); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1833/","summary":"题目大意 混合背包。每棵树都有美学值 $C_i$，共有三种：\n一种只能看一遍。 一种最多看 $A_i$ 遍。 一种可以看无数遍。 分析 对于混合背包，我们可以对物品拆分，得到多个物品。\nll dp[1086], tt[100086], cc[100086]; int main() { int tsh = rr(), tsm = rr(), teh = rr(), tem = rr(); int tsum = (teh - tsh) * 60 + tem - tsm; int n = rr(); int tp = 1; for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(), c = rr(), p = rr(); if (p == 1) { tt[tp] = t, cc[tp] = c; tp++; } else { p = p !","title":"P1833 樱花"},{"content":"题目大意 初始有四种卡片，消耗后分别可以前进 $1$、$2$、$3$ 和 $4$ 格。棋盘上每个点都有个分数，求从第 $1$ 格到达第 $N$ 格途径分数的最大值。\n分析 设状态 $F[i, j, k, w]$ 为使用 $i$ 张前进 $1$、……、$w$ 张前进 $4$ 之后的状态，容易得到转移方程\n$$ F[i, j, k, w] = \\max\\left\\{ \\begin{matrix} dp[i - 1, j, k, w] \\\\ dp[i, j - 1, k, w] \\\\ dp[i, j, k - 1, w] \\\\ dp[i, j, k, w - 1] \\end{matrix}\\right\\} + a[i + 2j + 3k + 4w] $$\n处理一下边界情况，滚动数组即可。\nll dp[50][50][50], aa[400], tt[10]; int main() { ll n = rr(), m = rr(); for (ll i = 1; i \u0026lt;= n; i++) { aa[i] = rr(); } for (ll i = 1; i \u0026lt;= m; i++) { tt[rr()]++; } for (ll i = 0; i \u0026lt;= tt[1]; i++) { for (ll j = 0; j \u0026lt;= tt[2]; j++) { for (ll k = 0; k \u0026lt;= tt[3]; k++) { for (ll w = 0; w \u0026lt;= tt[4]; w++) { dp[j][k][w] = aa[i * 1 + j * 2 + k * 3 + w * 4 + 1] + max4( j == 0 ? 0 : dp[j - 1][k][w], k == 0 ? 0 : dp[j][k - 1][w], w == 0 ? 0 : dp[j][k][w - 1], dp[j][k][w]); } } } } printf(\u0026#34;%lld\\n\u0026#34;, dp[tt[2]][tt[3]][tt[4]]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1541/","summary":"题目大意 初始有四种卡片，消耗后分别可以前进 $1$、$2$、$3$ 和 $4$ 格。棋盘上每个点都有个分数，求从第 $1$ 格到达第 $N$ 格途径分数的最大值。\n分析 设状态 $F[i, j, k, w]$ 为使用 $i$ 张前进 $1$、……、$w$ 张前进 $4$ 之后的状态，容易得到转移方程\n$$ F[i, j, k, w] = \\max\\left\\{ \\begin{matrix} dp[i - 1, j, k, w] \\\\ dp[i, j - 1, k, w] \\\\ dp[i, j, k - 1, w] \\\\ dp[i, j, k, w - 1] \\end{matrix}\\right\\} + a[i + 2j + 3k + 4w] $$\n处理一下边界情况，滚动数组即可。\nll dp[50][50][50], aa[400], tt[10]; int main() { ll n = rr(), m = rr(); for (ll i = 1; i \u0026lt;= n; i++) { aa[i] = rr(); } for (ll i = 1; i \u0026lt;= m; i++) { tt[rr()]++; } for (ll i = 0; i \u0026lt;= tt[1]; i++) { for (ll j = 0; j \u0026lt;= tt[2]; j++) { for (ll k = 0; k \u0026lt;= tt[3]; k++) { for (ll w = 0; w \u0026lt;= tt[4]; w++) { dp[j][k][w] = aa[i * 1 + j * 2 + k * 3 + w * 4 + 1] + max4( j == 0 ?","title":"P1541 乌龟棋"},{"content":"题目大意 在 $n \\times n$ 的格上，在每行中各有一条线段 $(i, l_i) \\to (i, r_i)$。\n你从 $(1,1)$ 出发，只能沿着格子直走，最终走到 $(n,n)$。要求沿途经过所有的线段，且所走路程长度尽量的短。\n分析 显然是一行一行的递推。维护两个数据，一个是走完该行后停留在左侧的，记作 ${\\rm DP}_l$，相应的停留在右侧的记作 ${\\rm DP}_r$。\n若停在左侧，可能从上一行的右侧走来，也可能是由左侧走来，故转移方程有\n$$ {\\rm DP}_l[i] = r_i - l_i + \\min\\{{\\rm DP}_l[i - 1] + |l_{i-1} - r_i|, {\\rm DP}_r[i - 1] + |r_{i - 1} - r_i|\\} $$\n右侧类似，故可以写出代码\nint main() { int n = rr(); ll past_l = 1, past_r = 1, dpl = 0, dpr = 0; for (ll i = 1; i \u0026lt;= n; i++) { ll l = rr(), r = rr(); ll tl = min(dpl + abs(past_l - r), dpr + abs(past_r - r)) + r - l; ll tr = min(dpl + abs(past_l - l), dpr + abs(past_r - l)) + r - l; dpl = tl, dpr = tr; past_l = l, past_r = r; } printf(\u0026#34;%lld\\n\u0026#34;, min(dpl + n - past_l, dpr + n - past_r) + n - 1); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p3842/","summary":"题目大意 在 $n \\times n$ 的格上，在每行中各有一条线段 $(i, l_i) \\to (i, r_i)$。\n你从 $(1,1)$ 出发，只能沿着格子直走，最终走到 $(n,n)$。要求沿途经过所有的线段，且所走路程长度尽量的短。\n分析 显然是一行一行的递推。维护两个数据，一个是走完该行后停留在左侧的，记作 ${\\rm DP}_l$，相应的停留在右侧的记作 ${\\rm DP}_r$。\n若停在左侧，可能从上一行的右侧走来，也可能是由左侧走来，故转移方程有\n$$ {\\rm DP}_l[i] = r_i - l_i + \\min\\{{\\rm DP}_l[i - 1] + |l_{i-1} - r_i|, {\\rm DP}_r[i - 1] + |r_{i - 1} - r_i|\\} $$\n右侧类似，故可以写出代码\nint main() { int n = rr(); ll past_l = 1, past_r = 1, dpl = 0, dpr = 0; for (ll i = 1; i \u0026lt;= n; i++) { ll l = rr(), r = rr(); ll tl = min(dpl + abs(past_l - r), dpr + abs(past_r - r)) + r - l; ll tr = min(dpl + abs(past_l - l), dpr + abs(past_r - l)) + r - l; dpl = tl, dpr = tr; past_l = l, past_r = r; } printf(\u0026#34;%lld\\n\u0026#34;, min(dpl + n - past_l, dpr + n - past_r) + n - 1); return 0; } ","title":"P3842 线段"},{"content":"题目大意 要从 $n$ 种花中挑出 $m$ 盆展览，其中第 $i$ 种花不得多于 $a_i$ 种。求有几种选法。\n分析 考虑动态规划，记状态 $dp[i,j]$ 为摆完前 $i$ 种花，共 $j$ 盆时的方案数。容易得到递推式\n$$ dp[i,j] = \\sum_{k = j - \\min(a_i, j)}^j dp[i-1,k] $$\n边界条件是 $dp[0,0] = 1$。可以用滚动数组、前缀和优化。\nconst ll mod = 1e6 + 7; ll dp[110], aa[110], sum[110]; int main() { ll n = rr(), m = rr(); sum[0] = dp[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) aa[i] = rr(); for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= m; j++) sum[j] = (sum[j - 1] + dp[j]) % mod; for (ll j = m; j \u0026gt;= 0; j--) { int t = j - 1 - min(aa[i], j); if (t \u0026gt; 0) dp[j] = (dp[j] + sum[j - 1] - sum[t]) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, (dp[m] + mod) % mod); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1077/","summary":"题目大意 要从 $n$ 种花中挑出 $m$ 盆展览，其中第 $i$ 种花不得多于 $a_i$ 种。求有几种选法。\n分析 考虑动态规划，记状态 $dp[i,j]$ 为摆完前 $i$ 种花，共 $j$ 盆时的方案数。容易得到递推式\n$$ dp[i,j] = \\sum_{k = j - \\min(a_i, j)}^j dp[i-1,k] $$\n边界条件是 $dp[0,0] = 1$。可以用滚动数组、前缀和优化。\nconst ll mod = 1e6 + 7; ll dp[110], aa[110], sum[110]; int main() { ll n = rr(), m = rr(); sum[0] = dp[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) aa[i] = rr(); for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= m; j++) sum[j] = (sum[j - 1] + dp[j]) % mod; for (ll j = m; j \u0026gt;= 0; j--) { int t = j - 1 - min(aa[i], j); if (t \u0026gt; 0) dp[j] = (dp[j] + sum[j - 1] - sum[t]) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, (dp[m] + mod) % mod); return 0; } ","title":"P1077 摆花"},{"content":"题目大意 可以合并两堆果子成一堆新果子，消耗两堆果子数目之和的体力。给定 $n$ 堆果子的数目 $a_i$，求体力耗费最小的方案。\n分析 很容易猜到贪心结论，不断选取两个最小的堆进行合并。\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(); q.push(t); } int sum = 0; while (q.size() \u0026gt;= 2) { int x = q.top(); q.pop(); int y = q.top(); q.pop(); sum += x + y; q.push(x + y); } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } 本质上是证明 Huffman 树的构造的正确性，有点复杂。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1090/","summary":"题目大意 可以合并两堆果子成一堆新果子，消耗两堆果子数目之和的体力。给定 $n$ 堆果子的数目 $a_i$，求体力耗费最小的方案。\n分析 很容易猜到贪心结论，不断选取两个最小的堆进行合并。\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(); q.push(t); } int sum = 0; while (q.size() \u0026gt;= 2) { int x = q.top(); q.pop(); int y = q.top(); q.pop(); sum += x + y; q.push(x + y); } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } 本质上是证明 Huffman 树的构造的正确性，有点复杂。","title":"P1090 合并果子"},{"content":"题目大意 给定数列，求第 $k$ 小的数。\n分析 模板题。考虑分治，随便选一个数 $x$，然后把比 $x$ 大的数移到右边，比 $x$ 小的数移到左边。因此得到了数 $x$ 的排位，若恰为第 $k$ 个则返回，否则根据大小在左右寻找。\n该算法是不稳定的，期望复杂度 $O(n)$，最坏复杂度 $O(n^2)$。\n实际上存在最坏复杂度为 $O(n)$ 的 BFPTR 算法，但因为其常数过大实现复杂而很少应用。\nll nn[5000010], k, n; ll quicksort(ll l, ll r) { ll i = l, j = r; ll x = nn[(l + r) / 2]; while (i \u0026lt;= j) { while (nn[j] \u0026gt; x) j--; while (nn[i] \u0026lt; x) i++; if (i \u0026lt;= j) { swap(nn[i], nn[j]); i++, j--; } } // l \u0026lt;= j \u0026lt;= i \u0026lt;=r if (k \u0026lt;= j) return quicksort(l, j); else if (k \u0026gt;= i) return quicksort(i, r); else return nn[k + 1]; } int main() { n = rr(), k = rr(); for (ll i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;nn[i]); printf(\u0026#34;%lld\u0026#34;, quicksort(1, n)); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1923/","summary":"题目大意 给定数列，求第 $k$ 小的数。\n分析 模板题。考虑分治，随便选一个数 $x$，然后把比 $x$ 大的数移到右边，比 $x$ 小的数移到左边。因此得到了数 $x$ 的排位，若恰为第 $k$ 个则返回，否则根据大小在左右寻找。\n该算法是不稳定的，期望复杂度 $O(n)$，最坏复杂度 $O(n^2)$。\n实际上存在最坏复杂度为 $O(n)$ 的 BFPTR 算法，但因为其常数过大实现复杂而很少应用。\nll nn[5000010], k, n; ll quicksort(ll l, ll r) { ll i = l, j = r; ll x = nn[(l + r) / 2]; while (i \u0026lt;= j) { while (nn[j] \u0026gt; x) j--; while (nn[i] \u0026lt; x) i++; if (i \u0026lt;= j) { swap(nn[i], nn[j]); i++, j--; } } // l \u0026lt;= j \u0026lt;= i \u0026lt;=r if (k \u0026lt;= j) return quicksort(l, j); else if (k \u0026gt;= i) return quicksort(i, r); else return nn[k + 1]; } int main() { n = rr(), k = rr(); for (ll i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;nn[i]); printf(\u0026#34;%lld\u0026#34;, quicksort(1, n)); return 0; } ","title":"P1923 求第 $k$ 小的数"},{"content":"题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。\n分析 我考虑用类似状态机的方式解析字符串。\n当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$ 写成 BNF 更直观一点\n\u0026lt;pwd\u0026gt; ::= \u0026lt;EMPTY\u0026gt; | {\u0026lt;ALPHA\u0026gt;} | \u0026lt;pwd\u0026gt; \u0026#34;[\u0026#34; \u0026lt;NUMBER\u0026gt; \u0026lt;pwd\u0026gt; \u0026#34;]\u0026#34; \u0026lt;pwd\u0026gt; string read() { string s = \u0026#34;\u0026#34;; char c; while (cin \u0026gt;\u0026gt; c) { if (c == \u0026#39;[\u0026#39;) { int n; cin \u0026gt;\u0026gt; n; string ts = read(); while (n--) s += ts; } else if (c == \u0026#39;]\u0026#39;) { return s; } else { s += c; } } return s; } int main() { cout \u0026lt;\u0026lt; read(); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1928/","summary":"题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。\n分析 我考虑用类似状态机的方式解析字符串。\n当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$ 写成 BNF 更直观一点\n\u0026lt;pwd\u0026gt; ::= \u0026lt;EMPTY\u0026gt; | {\u0026lt;ALPHA\u0026gt;} | \u0026lt;pwd\u0026gt; \u0026#34;[\u0026#34; \u0026lt;NUMBER\u0026gt; \u0026lt;pwd\u0026gt; \u0026#34;]\u0026#34; \u0026lt;pwd\u0026gt; string read() { string s = \u0026#34;\u0026#34;; char c; while (cin \u0026gt;\u0026gt; c) { if (c == \u0026#39;[\u0026#39;) { int n; cin \u0026gt;\u0026gt; n; string ts = read(); while (n--) s += ts; } else if (c == \u0026#39;]\u0026#39;) { return s; } else { s += c; } } return s; } int main() { cout \u0026lt;\u0026lt; read(); return 0; } ","title":"P1928 外星密码"},{"content":"题目大意 有 I 形和 L 形两种砖头，分别能覆盖 2 个单元和 3 个单元。求 $2 \\times n$ 的墙有多少不重复的覆盖方式，结果对 $10^4$ 取模。\n分析 其中 I 形砖块仅有横放和竖放两种。关键在于 L 形，两个 L 形之间可以用 I 形填充，这让情况变得复杂起来。\n对于 $F_n$ 的递推，我们可以想到\n在 $F_{n-1}$ 后放一个 I 形砖块。 在 $F_{n-2}$ 后放两个横着的 I 形砖块。 对于更前面的递推，较为复杂。 两个 L 形砖块对齐，上下翻转也可以，即 $2 F_{n-3}$。 两个 L 形砖块可以对顶放，空缺恰用一个 I 填充，即 $2 F_{n-4}$。 类似 $2F_{n-3}$，中间可以再插入两个 I 形，即 $2 F_{n-5}$。 …… 直到 I 形和 L 形砖块恰好铺满墙壁，即 $2F_{0}$。 容易得到我们的递推式\n$$ F_n = F_{n-1} + F_{n-2} + 2 \\sum_{i=0}^{n-3} F_i $$\n利用错位相减法，不难化简得到\n$$ F_n = 2 F_{n-1} + F_{n-3} $$\n于是代码有\nint dp[1000000]; int main() { int n = rr(); dp[1] = 1, dp[2] = 2, dp[3] = 5; for (ll i = 4; i \u0026lt;= n; i++) dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 10000; printf(\u0026#34;%d\\n\u0026#34;, dp[n]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1990/","summary":"题目大意 有 I 形和 L 形两种砖头，分别能覆盖 2 个单元和 3 个单元。求 $2 \\times n$ 的墙有多少不重复的覆盖方式，结果对 $10^4$ 取模。\n分析 其中 I 形砖块仅有横放和竖放两种。关键在于 L 形，两个 L 形之间可以用 I 形填充，这让情况变得复杂起来。\n对于 $F_n$ 的递推，我们可以想到\n在 $F_{n-1}$ 后放一个 I 形砖块。 在 $F_{n-2}$ 后放两个横着的 I 形砖块。 对于更前面的递推，较为复杂。 两个 L 形砖块对齐，上下翻转也可以，即 $2 F_{n-3}$。 两个 L 形砖块可以对顶放，空缺恰用一个 I 填充，即 $2 F_{n-4}$。 类似 $2F_{n-3}$，中间可以再插入两个 I 形，即 $2 F_{n-5}$。 …… 直到 I 形和 L 形砖块恰好铺满墙壁，即 $2F_{0}$。 容易得到我们的递推式\n$$ F_n = F_{n-1} + F_{n-2} + 2 \\sum_{i=0}^{n-3} F_i $$","title":"P1990 覆盖墙壁"},{"content":"题目大意 给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$ ，求最耗体力的路径。\n分析 容易猜到贪心结论，是不断的在剩余石头中最大最小的来回跳。\n考虑证明结论，设 $h_i$ 是将要跳的序列，展开求和式\n$$ S = \\sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \\sum_{k=1}^nh_k^2 - 2\\sum_{k=1}^{n-1}h_kh_{k+1} $$\n注意到平方和为一个定值，重点在后半式。记 $H_k = h_{k+1}$，有\n$$ \\sum_{k=1}^{n-1}h_kH_k $$\n利用高中时学的排序不等式，有\n$$ \\text{反序和} \\leqslant \\text{乱序和} \\leqslant \\text{顺序和} $$\n于是有反序最小。双指针维护即可。\nll nn[310]; int main() { ll n = rr(); for (ll i = 1; i \u0026lt;= n; i++) nn[i] = rr(); sort(nn + 1, nn + n + 1); ll l = 0, r = n, sum = 0; while (l \u0026lt; r) { ll t1 = nn[l] - nn[r], t2 = nn[l + 1] - nn[r]; sum += t1 * t1 + t2 * t2; l++, r--; } printf(\u0026#34;%lld\\n\u0026#34;, sum); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p4995/","summary":"题目大意 给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$ ，求最耗体力的路径。\n分析 容易猜到贪心结论，是不断的在剩余石头中最大最小的来回跳。\n考虑证明结论，设 $h_i$ 是将要跳的序列，展开求和式\n$$ S = \\sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \\sum_{k=1}^nh_k^2 - 2\\sum_{k=1}^{n-1}h_kh_{k+1} $$\n注意到平方和为一个定值，重点在后半式。记 $H_k = h_{k+1}$，有\n$$ \\sum_{k=1}^{n-1}h_kH_k $$\n利用高中时学的排序不等式，有\n$$ \\text{反序和} \\leqslant \\text{乱序和} \\leqslant \\text{顺序和} $$\n于是有反序最小。双指针维护即可。\nll nn[310]; int main() { ll n = rr(); for (ll i = 1; i \u0026lt;= n; i++) nn[i] = rr(); sort(nn + 1, nn + n + 1); ll l = 0, r = n, sum = 0; while (l \u0026lt; r) { ll t1 = nn[l] - nn[r], t2 = nn[l + 1] - nn[r]; sum += t1 * t1 + t2 * t2; l++, r--; } printf(\u0026#34;%lld\\n\u0026#34;, sum); return 0; } ","title":"P4995 跳跳！"},{"content":"题目大意 在三维空间中，HKE 只能往上走，求攀爬总长。\n分析 对所有座标的 $z$ 分量排序即可。\nstruct POINT { double x, y, z; bool operator\u0026lt;(POINT p) { return z \u0026gt; p.z; } } nn[50010]; double dis(POINT \u0026amp;p1, POINT \u0026amp;p2) { double t1 = p1.x - p2.x, t2 = p1.y - p2.y, t3 = p1.z - p2.z; return sqrt(t1 * t1 + t2 * t2 + t3 * t3); } int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; nn[i].x \u0026gt;\u0026gt; nn[i].y \u0026gt;\u0026gt; nn[i].z; sort(nn + 1, nn + n + 1); double len = 0; for (ll i = 2; i \u0026lt;= n; i++) len += dis(nn[i], nn[i-1]); printf(\u0026#34;%.3lf\\n\u0026#34;, len); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p5143/","summary":"题目大意 在三维空间中，HKE 只能往上走，求攀爬总长。\n分析 对所有座标的 $z$ 分量排序即可。\nstruct POINT { double x, y, z; bool operator\u0026lt;(POINT p) { return z \u0026gt; p.z; } } nn[50010]; double dis(POINT \u0026amp;p1, POINT \u0026amp;p2) { double t1 = p1.x - p2.x, t2 = p1.y - p2.y, t3 = p1.z - p2.z; return sqrt(t1 * t1 + t2 * t2 + t3 * t3); } int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; nn[i].","title":"P5143 攀爬者"},{"content":"P1095 守望者的逃离 题目大意 守望者的可以在一秒逃出 $17 {\\rm m}$，或者消耗 $10$ 点魔法值闪现 $60 {\\rm m}$。原地休息时每秒回复 $4$ 点魔法值。\n守望者开始有 $M$ 点魔法，需要在 $T$ 秒内逃离距离 $S$。若能逃离则求最短逃离时间，否则求最远距离。\n分析 设 $s_1$为一直走路，$s_2$ 为一直闪现恢复。当 $s_2$ 快了就把 $s_1$ 更新为 $s_2$。\nint main() { int m = rr(), s = rr(), t = rr(); int time = t, s1 = 0, s2 = 0; while (time \u0026gt; 0 \u0026amp;\u0026amp; s1 \u0026lt; s) { s1 += 17; if (m \u0026gt;= 10) m -= 10, s2 += 60; else m += 4; s1 = max(s1, s2); time--; } if (s1 \u0026lt; s) printf(\u0026#34;No\\n%d\\n\u0026#34;, s1); else printf(\u0026#34;Yes\\n%d\\n\u0026#34;, t - time); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1095/","summary":"P1095 守望者的逃离 题目大意 守望者的可以在一秒逃出 $17 {\\rm m}$，或者消耗 $10$ 点魔法值闪现 $60 {\\rm m}$。原地休息时每秒回复 $4$ 点魔法值。\n守望者开始有 $M$ 点魔法，需要在 $T$ 秒内逃离距离 $S$。若能逃离则求最短逃离时间，否则求最远距离。\n分析 设 $s_1$为一直走路，$s_2$ 为一直闪现恢复。当 $s_2$ 快了就把 $s_1$ 更新为 $s_2$。\nint main() { int m = rr(), s = rr(), t = rr(); int time = t, s1 = 0, s2 = 0; while (time \u0026gt; 0 \u0026amp;\u0026amp; s1 \u0026lt; s) { s1 += 17; if (m \u0026gt;= 10) m -= 10, s2 += 60; else m += 4; s1 = max(s1, s2); time--; } if (s1 \u0026lt; s) printf(\u0026#34;No\\n%d\\n\u0026#34;, s1); else printf(\u0026#34;Yes\\n%d\\n\u0026#34;, t - time); return 0; } ","title":"P1095 守望者的逃离"},{"content":"题目大意 赢 11 分并且压对手两分以上则一局结束，否则要追分至压对手两分。\n给定 $\\texttt{WL}$ 序列，分别求 11 分制和 21 分制下每场比分，$\\texttt{E}$ 是结束符。\n分析 这是一道比较烦的模拟题，很绕。\nchar ch[62510]; int solve(int win, int len) { int w = 0, l = 0; for (ll i = 0; i \u0026lt; len; i++) { w += ch[i] == \u0026#39;W\u0026#39;; l += ch[i] == \u0026#39;L\u0026#39;; if (max(w, l) \u0026gt;= win \u0026amp;\u0026amp; abs(w - l) \u0026gt;= 2) { printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); w = l = 0; } } printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); } int main() { char ccc; int len = 0; while (scanf(\u0026#34;%c\u0026#34;, \u0026amp;ccc) != EOF) { if (ccc != \u0026#39;E\u0026#39;) ch[len++] = ccc; else break; } solve(11, len); LN; solve(21, len); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1042/","summary":"题目大意 赢 11 分并且压对手两分以上则一局结束，否则要追分至压对手两分。\n给定 $\\texttt{WL}$ 序列，分别求 11 分制和 21 分制下每场比分，$\\texttt{E}$ 是结束符。\n分析 这是一道比较烦的模拟题，很绕。\nchar ch[62510]; int solve(int win, int len) { int w = 0, l = 0; for (ll i = 0; i \u0026lt; len; i++) { w += ch[i] == \u0026#39;W\u0026#39;; l += ch[i] == \u0026#39;L\u0026#39;; if (max(w, l) \u0026gt;= win \u0026amp;\u0026amp; abs(w - l) \u0026gt;= 2) { printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); w = l = 0; } } printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); } int main() { char ccc; int len = 0; while (scanf(\u0026#34;%c\u0026#34;, \u0026amp;ccc) !","title":"P1042 乒乓球"},{"content":"题目大意 凸 $n$ 边形中，任意三条对角线不共点，求所有对角线交点的个数。\n分析 注意到一个交点对应凸多边形 $4$ 个定点，于是等价于 $n$ 个点任选 $4$ 个点的选法种数，即\n$$ \\binom{n}{4} = \\frac{n(n-1)(n-2)(n-3)}{24} $$\n注意爆 long long，需要写成 n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4。\nint main() { unsigned long long n; scanf(\u0026#34;%llu\u0026#34;, \u0026amp;n); n = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4; printf(\u0026#34;%llu\u0026#34;, n); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p2181/","summary":"题目大意 凸 $n$ 边形中，任意三条对角线不共点，求所有对角线交点的个数。\n分析 注意到一个交点对应凸多边形 $4$ 个定点，于是等价于 $n$ 个点任选 $4$ 个点的选法种数，即\n$$ \\binom{n}{4} = \\frac{n(n-1)(n-2)(n-3)}{24} $$\n注意爆 long long，需要写成 n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4。\nint main() { unsigned long long n; scanf(\u0026#34;%llu\u0026#34;, \u0026amp;n); n = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4; printf(\u0026#34;%llu\u0026#34;, n); return 0; } ","title":"P2181 对角线"},{"content":"题目大意 海里每一个位置都有一个深度，而且水里随着时间有锯齿状周期为 $2k$ 的潮汐。\n当潮汐与深度之和大于给定值 $l$ 时 Koa 会溺水，游泳、海岸、岛上永远是安全的。\n在任意时间 Koa 可以选择游到 $x+1$ 或停留在 $x$，试问 Koa 是否能够安全的从海岸 $0$ 到达岛上 $n+1$。\n分析 开始的想法是随着时间 DP，更好的解法是贪心。\n若一个位置在水位最高时仍不会溺水，则称这个位置是安全的，并且可以任意选择出发时机。\n即安全位置之间是相互独立的，我们只需判断可达性，尽量到达每一个安全位置。若之后 $2k$ 个位置没有安全位置，必死。\nKoa 的最优决策是在刚退潮时出发，如果能走就尽量往前走，不能走就等，等到涨潮就说明不存在通过方法。\nint main() { int ttt = rr(); while (ttt--) { int n = rr(), k = rr(), l = rr(); int flag = 0; int last = k; for (ll i = 1; i \u0026lt;= n; i++) { int d = rr(); flag += l \u0026lt; d; if (l - d \u0026gt;= k) last = k; else last = min(last - 1, l - d); flag += abs(last) \u0026gt; l - d; } if (flag) printf(\u0026#34;No\\n\u0026#34;); else printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/cf1384b2/","summary":"题目大意 海里每一个位置都有一个深度，而且水里随着时间有锯齿状周期为 $2k$ 的潮汐。\n当潮汐与深度之和大于给定值 $l$ 时 Koa 会溺水，游泳、海岸、岛上永远是安全的。\n在任意时间 Koa 可以选择游到 $x+1$ 或停留在 $x$，试问 Koa 是否能够安全的从海岸 $0$ 到达岛上 $n+1$。\n分析 开始的想法是随着时间 DP，更好的解法是贪心。\n若一个位置在水位最高时仍不会溺水，则称这个位置是安全的，并且可以任意选择出发时机。\n即安全位置之间是相互独立的，我们只需判断可达性，尽量到达每一个安全位置。若之后 $2k$ 个位置没有安全位置，必死。\nKoa 的最优决策是在刚退潮时出发，如果能走就尽量往前走，不能走就等，等到涨潮就说明不存在通过方法。\nint main() { int ttt = rr(); while (ttt--) { int n = rr(), k = rr(), l = rr(); int flag = 0; int last = k; for (ll i = 1; i \u0026lt;= n; i++) { int d = rr(); flag += l \u0026lt; d; if (l - d \u0026gt;= k) last = k; else last = min(last - 1, l - d); flag += abs(last) \u0026gt; l - d; } if (flag) printf(\u0026#34;No\\n\u0026#34;); else printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } ","title":"CF1384B2 Koa and the Beach"},{"content":"题目大意 在 $n \\times n$ 的方格（$n \\leqslant 9$）中存在一些正整数，经过格子时获得格子上的数，但只能获得一次。\n某人只能向右或向下走，从格子的左上角走到到右下角，共走两次，求最大能取得的数字。\n分析 考虑把先走后走转化为两个人同时走，只需要处理遇到两次的值即可。\n考虑四维 DP，用 $dp[x_1,y_1,x_2,y_2]$ 表示第一个人走到 $(x_1,y_1)$ 和第二个人走到 $(x_2,y_2)$。\n再考虑转移，每一个位置仅可能从其左面或上面转移来，于是可以写出（$x_1 \\ne y_1$ 或 $x_2 \\ne y_2$ 时）\n$$ dp[x_1,y_1,x_2,y_2] = \\max\\left\\{ \\begin{matrix} dp[x_1-1,y_1,x_2-1,y_2] \\\\ dp[x_1,y_1-1,x_2-1,y_2] \\\\ dp[x_1-1,y_1,x_2,y_2-1] \\\\ dp[x_1,y_1-1,x_2,y_2-1] \\end{matrix}\\right\\} + a[x_1,y_1] + a[x_2,y_2] $$\n当 $x_1=y_1,x_2=y_2$ 时，只加一次即可。到这里 $O(n^4)$ 其实已经可以过题了，但还可以优化。\n注意到一些状态是不可达的，因为 $x_1+y_1 = x_2+y_2$，因此存在 $O(n^3)$ 的 DP。\n考虑当前已走长度 $h=x_1+y_1=x_2+y_2$，于是可以把两个人的座标表示为 $(x_1,h-x_1)$ 和 $(x_2,h-x_2)$。\n于是记状态为 $dp[h,x_1,x_2]$，当 $x_1 \\ne x_2$ 时有\n$$ dp[h,x_1,x_2] = \\max\\left\\{ \\begin{matrix} dp[h-1,x_1,x_2] \\\\ dp[h-1,x_1,x_2-1] \\\\ dp[h-1,x_1-1,x_2] \\\\ dp[h-1,x_1-1,x_2-1] \\end{matrix}\\right\\} + a[x_1,h-x_1] + a[x_2,h-x_2] $$\n再注意到可以使用滚动数组，因此有\nll mtx[10][10], dp[10][10]; int main() { ll N = rr(); while (true) { ll a = rr(), b = rr(), c = rr(); if (a + b + c == 0) break; mtx[a][b] = c; } for (ll ss = 2; ss \u0026lt;= 2 * N; ss++) { ll max_x1 = min(N, ss - 1), min_x1 = max(1ll, ss - N); for (ll x1 = max_x1; x1 \u0026gt;= min_x1; x1--) { ll max_x2 = min(N, ss - 1), min_x2 = max(1ll, ss - N); for (ll x2 = max_x2; x2 \u0026gt;= min_x2; x2--) { dp[x1][x2] = max4( dp[x1 - 1][x2 - 1], dp[x1][x2 - 1], dp[x1 - 1][x2], dp[x1][x2] ); dp[x1][x2] += mtx[x1][ss - x1] + mtx[x2][ss - x2]; if (x1 == x2) dp[x1][x2] -= mtx[x1][ss - x1]; } } } printf(\u0026#34;%lld\\n\u0026#34;, dp[N][N]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1004/","summary":"题目大意 在 $n \\times n$ 的方格（$n \\leqslant 9$）中存在一些正整数，经过格子时获得格子上的数，但只能获得一次。\n某人只能向右或向下走，从格子的左上角走到到右下角，共走两次，求最大能取得的数字。\n分析 考虑把先走后走转化为两个人同时走，只需要处理遇到两次的值即可。\n考虑四维 DP，用 $dp[x_1,y_1,x_2,y_2]$ 表示第一个人走到 $(x_1,y_1)$ 和第二个人走到 $(x_2,y_2)$。\n再考虑转移，每一个位置仅可能从其左面或上面转移来，于是可以写出（$x_1 \\ne y_1$ 或 $x_2 \\ne y_2$ 时）\n$$ dp[x_1,y_1,x_2,y_2] = \\max\\left\\{ \\begin{matrix} dp[x_1-1,y_1,x_2-1,y_2] \\\\ dp[x_1,y_1-1,x_2-1,y_2] \\\\ dp[x_1-1,y_1,x_2,y_2-1] \\\\ dp[x_1,y_1-1,x_2,y_2-1] \\end{matrix}\\right\\} + a[x_1,y_1] + a[x_2,y_2] $$\n当 $x_1=y_1,x_2=y_2$ 时，只加一次即可。到这里 $O(n^4)$ 其实已经可以过题了，但还可以优化。\n注意到一些状态是不可达的，因为 $x_1+y_1 = x_2+y_2$，因此存在 $O(n^3)$ 的 DP。\n考虑当前已走长度 $h=x_1+y_1=x_2+y_2$，于是可以把两个人的座标表示为 $(x_1,h-x_1)$ 和 $(x_2,h-x_2)$。\n于是记状态为 $dp[h,x_1,x_2]$，当 $x_1 \\ne x_2$ 时有\n$$ dp[h,x_1,x_2] = \\max\\left\\{ \\begin{matrix} dp[h-1,x_1,x_2] \\\\ dp[h-1,x_1,x_2-1] \\\\ dp[h-1,x_1-1,x_2] \\\\ dp[h-1,x_1-1,x_2-1] \\end{matrix}\\right\\} + a[x_1,h-x_1] + a[x_2,h-x_2] $$","title":"P1004 方格取数"},{"content":"","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/jump/","summary":"","title":"OJ 题目跳转"},{"content":"","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/template-gen/","summary":"","title":"模板生成"},{"content":"","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/code/","summary":"","title":"贴代码"}]