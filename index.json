[{"content":"题目大意 在字符集中有 $m$ 个不同的字符，求给定字符串 $S$ 在长度为 $n$ 的字符串的全集中出现的概率。\n分析 参考 Mivik 的字符串公开赛。\n定义 $A$ 类字符串为，在整个字符串中 $S$ 只出现过一次，且恰好 $S$ 出现在末尾的字符串。\n设 ${f_i}$ 是长度为 $i$ 的字符串中 $A$ 类字符串的个数。再定义 ${g_i}$ 是长度为 $i$ 的字符串中没有出现过 $S$ 的个数。\n在长为 $i$ 的没有出现过 $S$ 的字符串后面加上一个字符，则可能出现 $S$ 也可能没有出现 $S$。\n$$ m g_i = f_{i+1} + g_{i+1} $$\n定义关于 $S$ 的数列 ${s_i}$ 为\n$$ s_i = [i \\ \\text{is a period of}\\ S] $$\n即当 $i$ 是 $S$ 的一个循环节时，$s_i$ 为 $1$，否则为 $0$。\n我们在所有未出现过 $S$ 的长为 $n - |S|$ 的字符串后面拼接上 $S$，当 $i$ 是 $S$ 的周期时 $n-i$ 是其完整出现 $S$ 的位置。有\n$$ g_{n - |S|} = \\sum_{i=0}^n f_{n - i} s_{i} $$\n写成生成函数形式，可以得到 $f_i$ 的生成函数\n$$ f(x) = \\frac{x^{|S|}}{x^{|S|} + (1 - m x) s(x)} $$\n我们要计算的是长为 $n$ 的符合要求的字符串总数，即是把字符串填充至 $n$ 的长度即可，即\n$$ E(x) = \\frac{f(x)}{1 - m x} $$\n我们只需计算 $E[n]/m^n$ 即可。循环节可以用 KMP 预处理。\n#define ACM_MOD 998244353 const ll mod = ACM_MOD, maxn = 2e5 + 10; #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34;#include \u0026#34;template/basic/mint.hpp\u0026#34; using poly_t = std::vector\u0026lt;Mint\u0026gt;; poly_t w; #include \u0026#34;template/poly-ntt/pre_w.hpp\u0026#34;#include \u0026#34;template/poly-ntt/ntt.hpp\u0026#34;#include \u0026#34;template/poly-ntt/ntt_inv.hpp\u0026#34; #include \u0026#34;template/debug.hpp\u0026#34; vector\u0026lt;int\u0026gt; pre_kmp(const ll* s, ll lens) { vector\u0026lt;int\u0026gt; pi(lens + 1); for (int i = 1; i \u0026lt; lens; i++) { ll j = pi[i - 1]; while(j \u0026amp;\u0026amp; s[i] != s[j]) j = pi[j - 1]; pi[i] = j + (s[i] == s[j]); } return pi; } ll aa[maxn]; int main() { ll n = rr(), m = rr(), S = rr(); if (m == 1) { printf(\u0026#34;1\u0026#34;); return 0; } else if (n == S) { printf(\u0026#34;%lld\u0026#34;, inv(qpow(m, n))); return 0; } for (int i = 0; i \u0026lt; S; i++) aa[i] = rr(); int lim = max(n - S, S); lim = get_lim(lim, lim); w = pre_w(lim); poly_t ss(lim), dd(lim); auto pi = pre_kmp(aa, S); ll tm = S - 1; while (tm \u0026gt;= 0) { ss[S - tm - 1] = 1; tm = pi[tm] - 1; } dd[0] = 1, dd[1] = (mod - m) * 2 % mod, dd[2] = m * m % mod; ntt(ss, lim), ntt(dd, lim); for (int i = 0; i \u0026lt; lim; i++) dd[i] = ss[i] * dd[i]; intt(dd, lim); dd[S] += 1, dd[S + 1] += mod - m; dd = ntt_inv(dd, lim); auto ans = dd[n - S] * inv(qpow(m, n)); printf(\u0026#34;%d\u0026#34;, ans.v); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-11/p1393/","summary":"题目大意 在字符集中有 $m$ 个不同的字符，求给定字符串 $S$ 在长度为 $n$ 的字符串的全集中出现的概率。\n分析 参考 Mivik 的字符串公开赛。\n定义 $A$ 类字符串为，在整个字符串中 $S$ 只出现过一次，且恰好 $S$ 出现在末尾的字符串。\n设 ${f_i}$ 是长度为 $i$ 的字符串中 $A$ 类字符串的个数。再定义 ${g_i}$ 是长度为 $i$ 的字符串中没有出现过 $S$ 的个数。\n在长为 $i$ 的没有出现过 $S$ 的字符串后面加上一个字符，则可能出现 $S$ 也可能没有出现 $S$。\n$$ m g_i = f_{i+1} + g_{i+1} $$\n定义关于 $S$ 的数列 ${s_i}$ 为\n$$ s_i = [i \\ \\text{is a period of}\\ S] $$\n即当 $i$ 是 $S$ 的一个循环节时，$s_i$ 为 $1$，否则为 $0$。","title":"P1393 Mivik 的标题"},{"content":"题目大意 求最简分数 $p/q$ 满足\n $$ \\frac{a}{b} 若有多组解，输出 $q$ 最小的；仍有多组解，输出 $p$ 最小的一组。\n分析 分类讨论：\n 首先当 $\\lfloor a/b \\rfloor + 1 \\leqslant \\lceil c/d \\rceil - 1$ 时，说明两个数之间存在一个整数，直接返回 $p = 1, q = \\lfloor a / b \\rfloor + 1$ 即可。 其次当 $a = 0$ 时，直接解得 $p = 1, q = \\lfloor d / c \\rfloor + 1$。 当 $a \u0026lt; b$ 时，这意味着我们无法直接求解。考虑翻转，转化问题为  $$ \\frac{d}{c} 当 $a \u0026gt; b$ 时，考虑求解  $$ \\frac{a}{b} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor  唯一需要确认的就是，翻转后仍是最优解，考虑反证。\n设存在 $p_0 \\geqslant p$ 且 $q_0 \u0026lt; q$ 使得 $p_0/q_0$ 在翻转前不是最优解，但是翻转后是最优解。从而有  $$ \\frac{d}{c} void solve(ll a, ll b, ll \u0026amp;p, ll \u0026amp;q, ll c, ll d) { ll x = a / b, y = (c - 1) / d; if (x \u0026lt; y) { p = x + 1, q = 1; } else if (a == 0) { p = 1, q = d / c + 1; } else if (a \u0026lt; b) { solve(d, c, q, p, b, a); } else { solve(a - b * x, b, p, q, c - d * x, d); p += q * x; } } int main() { ll a, b, p, q, c, d; while (~scanf(\u0026#34;%lld %lld %lld %lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d)) { solve(a, b, p, q, c, d); printf(\u0026#34;%lld/%lld\\n\u0026#34;, p, q); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5179/","summary":"题目大意 求最简分数 $p/q$ 满足\n $$ \\frac{a}{b} 若有多组解，输出 $q$ 最小的；仍有多组解，输出 $p$ 最小的一组。\n分析 分类讨论：\n 首先当 $\\lfloor a/b \\rfloor + 1 \\leqslant \\lceil c/d \\rceil - 1$ 时，说明两个数之间存在一个整数，直接返回 $p = 1, q = \\lfloor a / b \\rfloor + 1$ 即可。 其次当 $a = 0$ 时，直接解得 $p = 1, q = \\lfloor d / c \\rfloor + 1$。 当 $a \u0026lt; b$ 时，这意味着我们无法直接求解。考虑翻转，转化问题为  $$ \\frac{d}{c} 当 $a \u0026gt; b$ 时，考虑求解  $$ \\frac{a}{b} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor  唯一需要确认的就是，翻转后仍是最优解，考虑反证。","title":"P5179 Fraction"},{"content":"题目大意 给定 $a,b,c$，求满足方程 $ax + by \\leqslant c$ 的非负整数解的个数。\n分析 令 $n = \\lfloor c / a \\rfloor$，容易推出让我们求的是\n $$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{c - ax}{b} \\right\\rfloor $$ 直接套类欧是不行的，因为系数有负数。其他题解感觉推麻烦了，直接考虑水平翻转，令 $x \\to (n - x)$，代入有\n $$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{ax + c - an}{b} \\right\\rfloor $$ 显然 $c - an$ 是 c % a，于是套类欧即可\nll Euclid(ll a, ll b, ll c, ll n) { ll m = (a * n + b) / c, S1 = n * (n + 1) / 2; if (a == 0) { return b / c * (n + 1); } else if (a \u0026gt;= c || b \u0026gt;= c) { ll f = S1 * (a / c) + b / c * (n + 1); return f + Euclid(a % c, b % c, c, n); } else { return m * n - Euclid(c, c - b - 1, a, m - 1); } } int main() { ll a = rr(), b = rr(), c = rr(); ll n = c / a; printf(\u0026#34;%lld\\n\u0026#34;, Euclid(a, c % a, b, n) + n + 1); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5171/","summary":"题目大意 给定 $a,b,c$，求满足方程 $ax + by \\leqslant c$ 的非负整数解的个数。\n分析 令 $n = \\lfloor c / a \\rfloor$，容易推出让我们求的是\n $$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{c - ax}{b} \\right\\rfloor $$ 直接套类欧是不行的，因为系数有负数。其他题解感觉推麻烦了，直接考虑水平翻转，令 $x \\to (n - x)$，代入有\n $$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{ax + c - an}{b} \\right\\rfloor $$ 显然 $c - an$ 是 c % a，于是套类欧即可\nll Euclid(ll a, ll b, ll c, ll n) { ll m = (a * n + b) / c, S1 = n * (n + 1) / 2; if (a == 0) { return b / c * (n + 1); } else if (a \u0026gt;= c || b \u0026gt;= c) { ll f = S1 * (a / c) + b / c * (n + 1); return f + Euclid(a % c, b % c, c, n); } else { return m * n - Euclid(c, c - b - 1, a, m - 1); } } int main() { ll a = rr(), b = rr(), c = rr(); ll n = c / a; printf(\u0026#34;%lld\\n\u0026#34;, Euclid(a, c % a, b, n) + n + 1); return 0; } ","title":"P5171 Earthquake"},{"content":"题目大意 给定生成 $1$ 到 $n$ 数字的概率分布，不断生成随机数 $x$ 直到 $x$ 不是已经生成过的最大的数停止，求生成次数平方的期望。\n分析 设期望的随机次数为 $f_x = E(x)$，我们需要计算的次数为 $g_x = E(x^2)$。\n关于 $f_i$ 的 DP 是显然的，计算有\n $$ f_x = \\sum_{i = 1}^{x - 1} p_i + \\sum_{i = x}^n p_i(1 + f_i) = 1 + \\sum_{i = x}^n p_i f_i $$ 容易观察到\n $$ f_{x + 1} =(1 - p_x) f_x \\Rightarrow f_x = \\prod_{i = x}^n \\frac{1}{1 - p_x} $$ 接下来需要一个套路\n $$ E((x + 1)^2) = E(x^2) + 2 E(x) + 1 $$ 类似的可以推得\n $$ g_x = \\sum_{i = 1}^{x - 1} p_i + \\sum_{i = x}^n p_i(g_i + 2 f_i + 1) = 1 + \\sum_{i = x}^n p_i g_i + 2 \\sum_{i = x}^n p_i f_i = \\sum_{i = x}^n p_i g_i + 2 f_x - 1 $$ 最终答案即是\n $$ ans = \\sum_{i = 1}^n p_i(g_i + 2 f_i + 1) = g_1 $$ 至此，倒着递推已经可以线性求解了。但是我们还可以继续优化，逐项相减有\n $$ g_{x + 1} - g_x = 2(f_{x + 1} - f_x) - p_x g_x = - 2 p_x f_x - p_x g_x $$ 即\n $$ \\frac{g_x}{f_x} - \\frac{g_{x + 1}}{f_{x + 1}} = \\frac{2}{1 - p_x} - 2 $$ 因此\n $$ {\\rm ans} = g_1 = f_1 \\left( \\frac{g_n}{f_n} - 2(n - 1) + 2 \\sum_{i = 1}^{n - 1} \\frac{1}{1 - p_x} \\right) = \\left( \\prod_{i = x}^n \\frac{1}{1 - p_x} \\right) \\left( 1 + 2 \\sum_{i = 1}^n \\frac{1}{1 - p_x} - 2 n \\right) $$ 至此，我们可以 $O(n)$ 的解决问题。\n#define ACM_MOD 998244353 const ll mod = ACM_MOD; #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34; ll p[10086]; int main() { ll n = rr(), sum = 0; for (int i = 1; i \u0026lt;= n; i++) p[i] = rr(), sum = (sum + p[i]) % mod; sum = inv(sum); for (int i = 1; i \u0026lt;= n; i++) { p[i] = p[i] * sum % mod; p[i] = inv(mod + 1 - p[i]); } ll ans = 1, w = mod - n; for (int i = 1; i \u0026lt;= n; i++) { ans = ans * p[i] % mod; w = (w + p[i]) % mod; } ans = ans * (1 + 2 * w) % mod; printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 我们经过了很长的化简过程才导出这一结果，实际上生成函数更为快捷。\n设 $f(x)$ 是生成长度为 $i$ 的非递减序列的生成函数，即 $P(len \u0026gt; i)$，可以推出\n $$ f(x) = \\prod_{i = 1}^n \\frac{1}{1 - p_i x} $$ 而我们需要求\n $$ \\sum_{i = 1}^{\\infty} (f_{i - 1} - f_i) i^2 = \\sum_{i = 0}^{\\infty} f_i (2 i + 1) = 2 f'(1) + f(1) $$ 化简即可得到上式。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/nc11255b/","summary":"题目大意 给定生成 $1$ 到 $n$ 数字的概率分布，不断生成随机数 $x$ 直到 $x$ 不是已经生成过的最大的数停止，求生成次数平方的期望。\n分析 设期望的随机次数为 $f_x = E(x)$，我们需要计算的次数为 $g_x = E(x^2)$。\n关于 $f_i$ 的 DP 是显然的，计算有\n $$ f_x = \\sum_{i = 1}^{x - 1} p_i + \\sum_{i = x}^n p_i(1 + f_i) = 1 + \\sum_{i = x}^n p_i f_i $$ 容易观察到\n $$ f_{x + 1} =(1 - p_x) f_x \\Rightarrow f_x = \\prod_{i = x}^n \\frac{1}{1 - p_x} $$ 接下来需要一个套路","title":"NC11255B Sample Game"},{"content":"题目大意 有 $n$ 头牛坐电梯，重量分别为 $c_i$，电梯的最大限额是 $W$，求最少分多少次能够全部上去。\n分析 注意 $n \\leqslant 18$，枚举全排列是不行的。考虑用状态压缩，将第 $j$ 头奶牛的选和不选用状态 $i$ 的第 $j$ 位数字表示。设 $f_i$ 表示状态为 $i$ 时最小乘电梯次数，$g_i$ 表示此状态下最新那个电梯已经有的重量。\n 首先令 cow = i \u0026lt;\u0026lt; (j - 1)，若 i \u0026amp; cow 为 $1$ 则说明这个奶牛已经坐上电梯了，不计算。 当 $W - g_i \\geqslant c_i$ 时，最后那个电梯坐的下这头牛。 当 $W - g_i \u0026lt; c_i$ 时，只能新开一个电梯。  还是代码更清晰\nconst int maxn = 18; ll ci[maxn]; ll ff[1 \u0026lt;\u0026lt; maxn], gg[1 \u0026lt;\u0026lt; maxn]; int main() { ll n = rr(), W = rr(); for (int i = 1; i \u0026lt;= n; i++) ci[i] = rr(); fill_n(ff, 1 \u0026lt;\u0026lt; maxn, n); fill_n(gg, 1 \u0026lt;\u0026lt; maxn, W); ff[0] = 1, gg[0] = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { for (int j = 1; j \u0026lt;= n; j++) { ll cow = 1 \u0026lt;\u0026lt; (j - 1); if (i \u0026amp; cow) continue; if (W - gg[i] \u0026gt;= ci[j]) { ff[i | cow] = ff[i]; gg[i | cow] = min(gg[i | cow], gg[i] + ci[j]); } else if (W - gg[i] \u0026lt; ci[j] \u0026amp;\u0026amp; ff[i | cow] \u0026gt;= ff[i] + 1) { ff[i | cow] = ff[i] + 1; gg[i | cow] = min(gg[i | cow], ci[j]); } } } printf(\u0026#34;%lld\u0026#34;, ff[(1 \u0026lt;\u0026lt; n) - 1]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p3052/","summary":"题目大意 有 $n$ 头牛坐电梯，重量分别为 $c_i$，电梯的最大限额是 $W$，求最少分多少次能够全部上去。\n分析 注意 $n \\leqslant 18$，枚举全排列是不行的。考虑用状态压缩，将第 $j$ 头奶牛的选和不选用状态 $i$ 的第 $j$ 位数字表示。设 $f_i$ 表示状态为 $i$ 时最小乘电梯次数，$g_i$ 表示此状态下最新那个电梯已经有的重量。\n 首先令 cow = i \u0026lt;\u0026lt; (j - 1)，若 i \u0026amp; cow 为 $1$ 则说明这个奶牛已经坐上电梯了，不计算。 当 $W - g_i \\geqslant c_i$ 时，最后那个电梯坐的下这头牛。 当 $W - g_i \u0026lt; c_i$ 时，只能新开一个电梯。  还是代码更清晰\nconst int maxn = 18; ll ci[maxn]; ll ff[1 \u0026lt;\u0026lt; maxn], gg[1 \u0026lt;\u0026lt; maxn]; int main() { ll n = rr(), W = rr(); for (int i = 1; i \u0026lt;= n; i++) ci[i] = rr(); fill_n(ff, 1 \u0026lt;\u0026lt; maxn, n); fill_n(gg, 1 \u0026lt;\u0026lt; maxn, W); ff[0] = 1, gg[0] = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { for (int j = 1; j \u0026lt;= n; j++) { ll cow = 1 \u0026lt;\u0026lt; (j - 1); if (i \u0026amp; cow) continue; if (W - gg[i] \u0026gt;= ci[j]) { ff[i | cow] = ff[i]; gg[i | cow] = min(gg[i | cow], gg[i] + ci[j]); } else if (W - gg[i] \u0026lt; ci[j] \u0026amp;\u0026amp; ff[i | cow] \u0026gt;= ff[i] + 1) { ff[i | cow] = ff[i] + 1; gg[i | cow] = min(gg[i | cow], ci[j]); } } } printf(\u0026#34;%lld\u0026#34;, ff[(1 \u0026lt;\u0026lt; n) - 1]); return 0; } ","title":"P3052 Cows in a Skyscraper G"},{"content":"过于简单的题不记录。\n洛谷：更新至：2021.10.17(\u0026ndash;.\u0026ndash;)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2021 年 10 月 NC11255B Sample Game\nP3052 Cows in a Skyscraper G\nP4059 找爸爸\nHDU6955 Xor sum\n2021 年 09 月 HDU6833 A Very Easy Math Problem\nHDU6755 Fibonacci Sum\nHDU6537 Neko and function\nHDU6750 Function\nP5349 幂\n2021 年 08 月 P4721 分治 FFT\nP4238 多项式乘法逆\nP4245 任意模数多项式乘法\nP4213 杜教筛\nP5325 Min_25筛\nLOJ6053 简单的函数\n2021 年 07 月 P4173 残缺的字符串\nHDU多校2021-2\n HDU6961 I love cube HDU6965 I love string HDU6971 I love max and multiply HUD6972 I love 114514  P3803 多项式乘法（FFT）\nP1762 偶数 ==DONE==\n2021 年 06 月 P3805 manacher 算法\nP5104 红包发红包\nP3802 小魔女帕琪\n2021 年 05 月 P1886 滑动窗口 / 单调队列\nP4781 拉格朗日插值\nP2568 GCD\nP4139 上帝与集合的正确用法\nP2303 Longge 的问题\nP2257 YY 的 GCD ==DONE==\nP3455 ZAP-Queries\nP2350 外星人 ==DONE==\nP5091 扩展欧拉定理\nP2303 Longge 的问题 ==DONE==\nP2158 仪仗队\nP2613 有理数取余\nP1082 同余方程\nP2522 Problem B ==DONE==\n2021 年 04 月 P2261 余数求和 ==DONE==\nP3372 线段树 1\nP5410 扩展 KMP（Z 函数）\nP4838 P哥破解密码\nP1314 聪明的质检员 ==DONE==\nP1902 刺杀大使\nP1706 全排列问题\nP1495 中国剩余定理(CRT)/曹冲养猪\n2021 年 03 月 P2602 数字计数\nP1908 逆序对\nP2678 跳石头 ==DONE==\nP1177 快速排序\nP3368 树状数组 2\nP3374 树状数组 1\nP3375 KMP 字符串匹配\nP3370 字符串哈希\nP1014 Cantor 表\nP1019 单词接龙 ==DONE==\nP1162 填涂颜色\nP3865 ST 表\nP3382 三分法\n2021 年 02 月 P1216 数字三角形\n2021 年 01 月 P3378 堆\n2021 年 02 月 P1216 数字三角形\n2021 年 01 月 P3378 堆\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/log/log2021/","summary":"过于简单的题不记录。\n洛谷：更新至：2021.10.17(\u0026ndash;.\u0026ndash;)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2021 年 10 月 NC11255B Sample Game\nP3052 Cows in a Skyscraper G\nP4059 找爸爸\nHDU6955 Xor sum\n2021 年 09 月 HDU6833 A Very Easy Math Problem\nHDU6755 Fibonacci Sum\nHDU6537 Neko and function\nHDU6750 Function\nP5349 幂\n2021 年 08 月 P4721 分治 FFT\nP4238 多项式乘法逆\nP4245 任意模数多项式乘法\nP4213 杜教筛\nP5325 Min_25筛\nLOJ6053 简单的函数\n2021 年 07 月 P4173 残缺的字符串\nHDU多校2021-2\n HDU6961 I love cube HDU6965 I love string HDU6971 I love max and multiply HUD6972 I love 114514  P3803 多项式乘法（FFT）","title":"2021 年刷题日志"},{"content":"题目大意 给定两串 DNA 序列，可以在其中任意插空格，然后逐位比较，当两位都是字母时查表得到相似度。\n长度为 $k$ 的空格有额外相似度 $- A - B(k - 1)$。求两序列的最大相似度。\n分析 若不考虑空格的贡献，容易想到二维 DP，记 ${\\rm DP}[i,j]$ 是 $A$ 串到位置 $i$ 同时 $B$ 串到位置 $j$ 时最大的相似度，有\n $$ {\\rm DP}[i, j] = \\max\\{ {\\rm DP}[i - 1, j - 1] + D[i, j], {\\rm DP}[i - 1, j], {\\rm DP}[i, j - 1] \\} $$ 当我们考虑空格的贡献时，可以发现空格的额外贡献只与前面一位有关。若两个序列此位都是空格，则把去掉后相似度一定会增加，故只有三种可能：设 ${\\rm DP}_0$ 是结尾没有空格；${\\rm DP}_1$ 是空格在 $A$ 串；${\\rm DP}_2$ 是空格在 $B$ 串。\n思考最后一个空格的转移方式，自然有方程\n $$ \\begin{aligned} {\\rm DP}_0[i, j] \u0026= \\max\\{ {\\rm DP}_0[i - 1, j - 1], {\\rm DP}_1[i - 1, j - 1], {\\rm DP}_2[i - 1, j - 1] \\} + D[i, j] \\\\ {\\rm DP}_1[i, j] \u0026= \\max\\{ {\\rm DP}_0[i, j - 1] - A, {\\rm DP}_1[i, j - 1]- B, {\\rm DP}_2[i, j - 1] - A\\} \\\\ {\\rm DP}_2[i, j] \u0026= \\max\\{ {\\rm DP}_0[i - 1, j] - A, {\\rm DP}_1[i - 1, j] - A, {\\rm DP}_2[i, j - 1] - B \\} \\\\ \\end{aligned} $$ 随手加滚动数组 WA 了好久，发现每次都要清空为 -INF，否则会 WA。\n#include \u0026#34;template/index.hpp\u0026#34; const int maxn = 3000 + 10; int dp_1[maxn][3], dp_2[maxn][3]; char sa[maxn], sb[maxn]; int D[5][5]; int DNA(char c); // AGTC -\u0026gt; 1..4  int main() { scanf(\u0026#34;%s %s\u0026#34;, sa + 1, sb + 1); int n = strlen(sa + 1), m = strlen(sb + 1); for (int i = 1; i \u0026lt;= 4; i++) for (int j = 1; j \u0026lt;= 4; j++) D[i][j] = rr(); int A = rr(), B = rr(), *p; memset(dp_1, -0x7f, sizeof(dp_1)); memset(dp_2, -0x7f, sizeof(dp_2)); auto \u0026amp;dp1 = dp_1, \u0026amp;dp2 = dp_2; dp2[0][0] = 0; for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { int da = DNA(sa[i]), db = DNA(sb[j]); if (i \u0026gt; 0 \u0026amp;\u0026amp; j \u0026gt; 0) { p = dp1[j - 1]; dp2[j][0] = max3(p[0], p[1], p[2]) + D[da][db]; } if (i \u0026gt; 0) { p = dp1[j]; dp2[j][2] = max3(p[0] - A, p[1] - A, p[2] - B); } if (j \u0026gt; 0) { p = dp2[j - 1]; dp2[j][1] = max3(p[0] - A, p[1] - B, p[2] - A); } } swap(dp1, dp2); memset(dp2, -0x7f, sizeof(dp2)); } p = dp1[m]; int ans = max3(p[0], p[1], p[2]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p4059/","summary":"题目大意 给定两串 DNA 序列，可以在其中任意插空格，然后逐位比较，当两位都是字母时查表得到相似度。\n长度为 $k$ 的空格有额外相似度 $- A - B(k - 1)$。求两序列的最大相似度。\n分析 若不考虑空格的贡献，容易想到二维 DP，记 ${\\rm DP}[i,j]$ 是 $A$ 串到位置 $i$ 同时 $B$ 串到位置 $j$ 时最大的相似度，有\n $$ {\\rm DP}[i, j] = \\max\\{ {\\rm DP}[i - 1, j - 1] + D[i, j], {\\rm DP}[i - 1, j], {\\rm DP}[i, j - 1] \\} $$ 当我们考虑空格的贡献时，可以发现空格的额外贡献只与前面一位有关。若两个序列此位都是空格，则把去掉后相似度一定会增加，故只有三种可能：设 ${\\rm DP}_0$ 是结尾没有空格；${\\rm DP}_1$ 是空格在 $A$ 串；${\\rm DP}_2$ 是空格在 $B$ 串。\n思考最后一个空格的转移方式，自然有方程\n $$ \\begin{aligned} {\\rm DP}_0[i, j] \u0026= \\max\\{ {\\rm DP}_0[i - 1, j - 1], {\\rm DP}_1[i - 1, j - 1], {\\rm DP}_2[i - 1, j - 1] \\} + D[i, j] \\\\ {\\rm DP}_1[i, j] \u0026= \\max\\{ {\\rm DP}_0[i, j - 1] - A, {\\rm DP}_1[i, j - 1]- B, {\\rm DP}_2[i, j - 1] - A\\} \\\\ {\\rm DP}_2[i, j] \u0026= \\max\\{ {\\rm DP}_0[i - 1, j] - A, {\\rm DP}_1[i - 1, j] - A, {\\rm DP}_2[i, j - 1] - B \\} \\\\ \\end{aligned} $$ 随手加滚动数组 WA 了好久，发现每次都要清空为 -INF，否则会 WA。","title":"P4059 找爸爸"},{"content":"题目大意 给定整数序列 ${a_n}$，寻找满足区间异或和大于等于 $k$ 的连续序列中最短的。\n若有多个同样长度的答案，输出位置靠前的，若不存在输出 -1。\n分析 看到异或最值就应该想到 01trie。做前缀异或和，这样我们的问题就变成找到最靠近的两个数，其异或大于等于 $k$。\n因为要求位置最靠前的，所以我选择倒着遍历。当遍历到第 $i$ 个数 $a_i$ 时，字典树已经维护好此位置之后的数据，即每个值出现最左边的位置。\nconst int maxn = 1e5 + 10, o = 30 - 1; int trie[maxn * 30][2], val[maxn * 30], tot, n, k; void insert(int ai, int i) { int p = 1; for (int j = o; j \u0026gt;= 0; j--) { int ch = (ai \u0026gt;\u0026gt; j) \u0026amp; 1; if (trie[p][ch] == 0) trie[p][ch] = ++tot; p = trie[p][ch]; val[p] = i; } } 我们只需从高位到低位遍历第 $j$ 位，分类讨论：\n 若 $k[j] = 1$，则说明 $a_i[j] \\oplus a_u[j]$ 只能为 $1$，在字典树中选择 $a_i[j] \\oplus 1$ 深入（什么都不做）。 若 $k[j] = 0$，那么若 $a_i[j] \\oplus a_u[j] = 1$ 则一定大于 $k$，记录字典树中 $a_i[j] \\oplus 1 的值，然后在字典树中选择 $a_i[j]$ 深入。  int search(int ai, int i) { int p = 1, res = -1; for (int j = o; j \u0026gt;= 0; j--) { int x1 = (k \u0026gt;\u0026gt; j) \u0026amp; 1, x2 = (ai \u0026gt;\u0026gt; j) \u0026amp; 1; if (x1 == 0) { int tp = trie[p][x2 ^ 1]; if (tp \u0026gt; 0) res = max(res, val[tp]); } p = trie[p][x1 ^ x2]; if (p == 0) break; } if (p \u0026gt; 0) res = max(res, val[p]); return res; } 因为我们是从前往后查的，因此同样长度中总是先查到考前的，汇总有\nint main() { int ttt = rr(); while (ttt--) { n = rr(), k = rr(), tot = 1; int anl = -1, anr = n + 1, pre_sum = 0; fill_n(trie[0], 2 * o * n, 0); for (int i = 1; i \u0026lt;= n; i++) { int ai = pre_sum ^ rr(); int res = search(ai, i); if (res \u0026gt;= 0 \u0026amp;\u0026amp; i - res \u0026lt; anr - anl) anl = res, anr = i; insert(ai, i); pre_sum = ai; } if (anl \u0026gt;= 0) printf(\u0026#34;%d %d\\n\u0026#34;, anl + 1, anr); else printf(\u0026#34;-1\\n\u0026#34;); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/hdu6955/","summary":"题目大意 给定整数序列 ${a_n}$，寻找满足区间异或和大于等于 $k$ 的连续序列中最短的。\n若有多个同样长度的答案，输出位置靠前的，若不存在输出 -1。\n分析 看到异或最值就应该想到 01trie。做前缀异或和，这样我们的问题就变成找到最靠近的两个数，其异或大于等于 $k$。\n因为要求位置最靠前的，所以我选择倒着遍历。当遍历到第 $i$ 个数 $a_i$ 时，字典树已经维护好此位置之后的数据，即每个值出现最左边的位置。\nconst int maxn = 1e5 + 10, o = 30 - 1; int trie[maxn * 30][2], val[maxn * 30], tot, n, k; void insert(int ai, int i) { int p = 1; for (int j = o; j \u0026gt;= 0; j--) { int ch = (ai \u0026gt;\u0026gt; j) \u0026amp; 1; if (trie[p][ch] == 0) trie[p][ch] = ++tot; p = trie[p][ch]; val[p] = i; } } 我们只需从高位到低位遍历第 $j$ 位，分类讨论：","title":"HDU6955 Xor sum"},{"content":"题目大意 即求\n $$ S (n) = \\sum^n_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k f (\\gcd \\{ a_x \\}) \\gcd \\{ a_x \\} $$ 我自己随便简写了，全打太麻烦了。\n分析 这东西看着很吓人，其实是纸老虎。首先 $f(x) = \\mu(x)^2$。提出 $\\gcd$ 有\n $$ \\begin{aligned} S (n) \u0026 =\\sum_{d=1}^{n}\\sum^{n}_{\\{ a_{x}\\}=1}(\\prod_{j=1}^{x}a_{j})^{k}{\\mu}(d)^{2}d [gcd \\{ a_{x}\\} =d]\\\\ \u0026 =\\sum_{d=1}^{n}{\\mu}(d)^{2}d^{k x+1}\\sum^{n/d}_{\\{ a_{x}\\} =1}(\\prod_{j=1}^{x}a_{j})^{k}[gcd \\{ a_{x}\\} =1] \\end{aligned} $$ 对后面这部分反演有\n $$ \\begin{aligned} \u0026 \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t \\mid \\gcd \\{ a_x \\}} \\mu (t) \\right)\\\\ = \u0026 \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t = 1}^{n / d} [t \\mid \\gcd \\{ a_x \\}] \\mu (t) \\right)\\\\ = \u0026 \\sum_{t = 1}^{n / d} \\mu (t) t^{k x} \\sum^{n / d t}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\end{aligned} $$ 代回去，枚举 $T = d t$\n $$ \\begin{aligned} S (n) \u0026 = \\sum_{d = 1}^n d \\mu (d)^2 (d t)^{k x} \\sum_{t = 1}^{n / d} \\mu (t) \\sum^{n / d t}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k\\\\ \u0026 = \\sum_{T = 1}^n \\sum_{d \\mid T} d \\mu (d)^2 T^{k x} \\mu \\left(\\frac{T}{d} \\right) \\sum^{n / T}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k\\\\ \u0026 = \\sum_{T = 1}^n T^{k x} \\left( \\sum^{n / T}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\right) \\sum_{d \\mid T} d \\mu (d)^2 \\mu \\left( \\frac{T}{d} \\right)\\\\ \u0026 = \\sum_{T = 1}^n T^{k x} \\left( \\sum^{n / T}_{i = 1} i^k \\right)^x \\sum_{d \\mid T} d \\mu (d)^2 \\mu \\left( \\frac{T}{d} \\right) \\end{aligned} $$ 到这里已经差不多化完了。令\n $$ G (x) = \\sum^x_{i = 1} i^k, H (x) = \\sum_{d \\mid x} d \\mu (d)^2 \\mu \\left( \\frac{x}{d} \\right) $$ 其中 $G (x)$ 显然可以预处理，而 $H (x)$ 是积性函数的卷积，故也是积性函数，其中\n $$ H (p^c) = \\begin{cases} p - 1,\u0026 c = 1\\\\ -p, \u0026 c = 2 \\\\ 0, \u0026 c  2 \\end{cases} $$ 可以线性筛得到。\nconst ll maxn = 2e5 + 86; const ll mod = 1e9 + 7; #define ACM_MOD mod  bool notp[maxn + 10]; int prime[maxn/10 + 10], cnt; ll hh[maxn + 10]; void sieve(int n) { hh[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { if (!notp[i]) { prime[++cnt] = i; hh[i] = i - 1; } int t = n / i; for (int j = 1; j \u0026lt;= cnt;j++) { int pj = prime[j], ti = i * pj; if (pj \u0026gt; t) break; notp[ti] = true; if (i % pj == 0) { int tj = i / pj; if (tj % pj != 0) { hh[ti] = hh[tj] * (mod - pj) % mod; } else { hh[ti] = 0; } break; } hh[ti] = hh[i] * hh[pj] % mod; } } } 总之\n $$ S (n) = \\sum_{T = 1}^n T^{k x} H (T) G \\left( \\left\\lfloor \\frac{n}{T} \\right\\rfloor \\right)^x $$ 可以用整数分块。\n#include \u0026#34;template/basic/qpow.hpp\u0026#34; ll gg[maxn + 10]; void pre(ll k, ll x) { sieve(maxn); for (ll i = 1; i \u0026lt;= maxn; i++) { gg[i] = (gg[i - 1] + qpow(i, k)) % mod; } for (ll i = 1; i \u0026lt;= maxn; i++) { hh[i] = (hh[i - 1] + qpow(i, k * x % (mod - 1)) * hh[i]) % mod; gg[i] = qpow(gg[i], x); } } int main() { ll ttt = rr(), k = rr(), x = rr(); pre(k, x); while(ttt--) { ll n = rr(); ll ans = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ll tsum = hh[r] - hh[l - 1] + mod; tsum = tsum * gg[n / l] % mod; ans = ans + tsum; } printf(\u0026#34;%lld\\n\u0026#34;, ans % mod); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6833/","summary":"题目大意 即求\n $$ S (n) = \\sum^n_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k f (\\gcd \\{ a_x \\}) \\gcd \\{ a_x \\} $$ 我自己随便简写了，全打太麻烦了。\n分析 这东西看着很吓人，其实是纸老虎。首先 $f(x) = \\mu(x)^2$。提出 $\\gcd$ 有\n $$ \\begin{aligned} S (n) \u0026 =\\sum_{d=1}^{n}\\sum^{n}_{\\{ a_{x}\\}=1}(\\prod_{j=1}^{x}a_{j})^{k}{\\mu}(d)^{2}d [gcd \\{ a_{x}\\} =d]\\\\ \u0026 =\\sum_{d=1}^{n}{\\mu}(d)^{2}d^{k x+1}\\sum^{n/d}_{\\{ a_{x}\\} =1}(\\prod_{j=1}^{x}a_{j})^{k}[gcd \\{ a_{x}\\} =1] \\end{aligned} $$ 对后面这部分反演有\n $$ \\begin{aligned} \u0026 \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t \\mid \\gcd \\{ a_x \\}} \\mu (t) \\right)\\\\ = \u0026 \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t = 1}^{n / d} [t \\mid \\gcd \\{ a_x \\}] \\mu (t) \\right)\\\\ = \u0026 \\sum_{t = 1}^{n / d} \\mu (t) t^{k x} \\sum^{n / d t}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\end{aligned} $$ 代回去，枚举 $T = d t$","title":"HDU6833 A Very Easy Math Problem"},{"content":"题目大意 设 Fibonacci 数列第 $i$ 项为 $F_i$，求\n $$ S = \\sum_{i = 0}^n (F_{i c})^k $$ 分析 由特征方程法，设\n $$ x^2 + x - 1 = 0 \\Longrightarrow A, B = \\frac{1 \\pm \\sqrt{5}}{2} $$ 因此 Fibonacci 通项公式即可表示为\n $$ F_n = \\frac{A^n - B^n}{A - B} $$ 根据二次剩余的知识，模意义下是可以开方的。因此\n $$ (F_{i c})^k = \\left( \\frac{A^{i c} - B^{i c}}{A - B} \\right)^k = \\frac{1}{(A - B)^k} \\sum_{j = 0}^k \\binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$ 求和有\n $$ (A - B)^k S = (A - B)^k \\sum_{i = 0}^n (F_{i c})^k = \\sum_{i = 0}^n \\sum_{j = 0}^k \\binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$ 换序求和，即是等比数列（公比可能为 $1$，需要特判）\n $$ \\begin{aligned} (A-B)^{k}S \u0026 =\\sum_{j=0}^{k}\\binom{k}{j}(-1)^{k-j}\\sum_{i=0}^{n}(A^{j}B^{k-j})^{ic}\\\\ \u0026 =\\sum_{j=0}^{k}\\binom{k}{j}(-1)^{k-j}{\\frac{(A^{j}B^{k-j})^{c(n+1)}-1}{(A^{j}B^{k-j})^{c}-1}} \\end{aligned} $$ 直接计算会 TLE，需要用中间变量简化\n $$ \\frac{(A^j B^{k - j})^{c (n + 1)} - 1}{(A^j B^{k - j})^c - 1} = \\frac{B^{k c (n + 1)} {(A B^{- 1})^{c (n + 1) j}} - 1}{B^{k c} (A B^{- 1})^{c j} - 1} $$ 用中间变量在循环中递推，再加上 Euler 降幂，就可以过题了。\nconst ll mod = 1e9 + 9, phi_mod = mod - 1; const ll maxn = 1e5 + 10; #define ACM_MOD mod  #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34; const ll sqrt_5 = 383008016; const ll A = (1 + sqrt_5) * inv(2) % mod, B = (1 - sqrt_5 + mod) * inv(2) % mod; ll euler_pow(ll a, ll b) { return qpow(a, b % phi_mod); } ll fac[maxn], ind[maxn]; void pre(ll n) { fac[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) { fac[i] = fac[i - 1] * i % mod; } ind[n] = inv(fac[n]); for (ll i = n - 1; i \u0026gt;= 0; i--) { ind[i] = ind[i + 1] * (i + 1) % mod; } } ll binom(ll a, ll b) { if (b \u0026gt; a) b = a - b; return fac[a] * ind[b] % mod * ind[a - b] % mod; } int main() { pre(1e5 + 1); ll ttt = rr(); while (ttt--) { ll n = rr(), c = rr(), k = rr(); ll step1 = euler_pow(A * inv(B) % mod, c), step2 = euler_pow(step1, n + 1); ll T1 = euler_pow(B, c % phi_mod * k), T2 = euler_pow(T1, n + 1); ll ans = 0; for (ll j = 0; j \u0026lt;= k; j++) { ll tsum = binom(k, j); if (T1 != 1) { tsum = tsum * (T2 - 1) % mod * inv(T1 - 1) % mod; } else { tsum = (n + 1) % mod * tsum % mod; } if ((k - j) % 2 == 1) tsum *= -1; ans = (ans + tsum + mod) % mod; T1 = T1 * step1 % mod, T2 = T2 * step2 % mod; } ans = ans % mod * euler_pow(inv(A - B), k) % mod; printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6755/","summary":"题目大意 设 Fibonacci 数列第 $i$ 项为 $F_i$，求\n $$ S = \\sum_{i = 0}^n (F_{i c})^k $$ 分析 由特征方程法，设\n $$ x^2 + x - 1 = 0 \\Longrightarrow A, B = \\frac{1 \\pm \\sqrt{5}}{2} $$ 因此 Fibonacci 通项公式即可表示为\n $$ F_n = \\frac{A^n - B^n}{A - B} $$ 根据二次剩余的知识，模意义下是可以开方的。因此\n $$ (F_{i c})^k = \\left( \\frac{A^{i c} - B^{i c}}{A - B} \\right)^k = \\frac{1}{(A - B)^k} \\sum_{j = 0}^k \\binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$ 求和有","title":"HDU6755 Fibonacci Sum"},{"content":"题目大意 定义 $f(n, k)$ 为满足如下要求的，长度为 $k$ 的数列 $\\{a_i\\}$ 个数：\n 要求每个数字都大于 $1$； 数列各项之积恰为 $n$。  求其前缀和 $S(n, k) = \\sum f(i, k)$。\n分析 多组输入好坑啊。\n先允许 $a_i=1$，将结果记为 $g(n,k)$，容易利用隔板法求得\n $$ g (p^c, k) = \\binom{t + k - 1}{k - 1} $$ 对于多个质因数，显然其贡献是相互独立的，即 $g$ 是积性函数。考虑选取 $i$ 个数令其 $a_i\u0026gt;1$，枚举有\n $$ g (n, k) = \\sum_{i = 1}^k \\binom{n}{i} f (n, i) $$ 二项式反演（或者直接容斥）有\n $$ f (n, k) = \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} g (n, i) $$ 求和并换序\n $$ \\begin{aligned} \\sum_{i = 1}^x f (i, k) \u0026= \\sum_{n = 1}^x \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} g (n, i) \\\\ \u0026= \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} \\sum_{n = 1}^x g (n, i) \\end{aligned} $$ 后面即是 $g$ 的前缀和，可以用 Min25 筛。\nconst ll mod = 1e9 + 7; const int maxn = 1e6 + 5; ll cc[70][70]; void pre_binom(ll n) { for (ll i = 0; i \u0026lt;= n; i++) { cc[i][0] = 1; for (ll j = 1; j \u0026lt;= i; j++) { cc[i][j] = (cc[i - 1][j - 1] + cc[i - 1][j]) % mod; } } } namespace min25 { ll n, prime[maxn], cnt, w[maxn], c[maxn]; ll sqrt_n, m, kkk; ll f_p(ll e, ll k) { return cc[e + k - 1][k - 1]; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } void pre(ll _n) { n = _n, sqrt_n = sqrt(n + 0.01); m = cnt = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { w[++m] = r = n / (n / l); c[m] = r - 1; } for (ll p = 2; p \u0026lt;= sqrt_n; p++) { if (c[p] != c[p - 1]) { prime[++cnt] = p; for (ll j = m; w[j] \u0026gt;= p * p; j--) { c[j] -= c[id(w[j] / p)] - c[p - 1]; } } } } ll F(ll n, int k, int tk) { if (n \u0026lt;= prime[k]) return 0; ll ret = (c[id(n)] - c[prime[k]]) * tk; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int e = 1; pk * pi \u0026lt;= n; e++, pk *= pi) ret = (ret + f_p(e, tk) * F(n / pk, i, tk) + f_p(e + 1, tk)); } return ret % mod; } ll solve(ll n, ll k) { return F(n, 0, k); } } // namespace min25  int main() { ll x, k; pre_binom(70); while (scanf(\u0026#34;%lld %lld\u0026#34;, \u0026amp;x, \u0026amp;k) != EOF) { min25::pre(x); ll ans = 0; for (ll i = 1; i \u0026lt;= k; i++) { if (cc[k][i] == 0) continue; ll tsum = cc[k][i] * min25::solve(x, i); if ((k - i) % 2 == 1) tsum *= -1; ans += tsum; } printf(\u0026#34;%lld\\n\u0026#34;, (ans % mod + mod) % mod); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6537/","summary":"题目大意 定义 $f(n, k)$ 为满足如下要求的，长度为 $k$ 的数列 $\\{a_i\\}$ 个数：\n 要求每个数字都大于 $1$； 数列各项之积恰为 $n$。  求其前缀和 $S(n, k) = \\sum f(i, k)$。\n分析 多组输入好坑啊。\n先允许 $a_i=1$，将结果记为 $g(n,k)$，容易利用隔板法求得\n $$ g (p^c, k) = \\binom{t + k - 1}{k - 1} $$ 对于多个质因数，显然其贡献是相互独立的，即 $g$ 是积性函数。考虑选取 $i$ 个数令其 $a_i\u0026gt;1$，枚举有\n $$ g (n, k) = \\sum_{i = 1}^k \\binom{n}{i} f (n, i) $$ 二项式反演（或者直接容斥）有\n $$ f (n, k) = \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} g (n, i) $$ 求和并换序","title":"HDU6537 Neko and function"},{"content":"题目大意 定义\n $$ f (n) = \\sum_{d \\mid n} d \\left[ \\gcd \\left( d, \\frac{n}{d} \\right) = 1 \\right] $$ 求其前缀和 $S(n)$。\n分析 首先 Min25 筛是过不了的，内存不够。先推式子\n $$ \\begin{aligned} S (n) \u0026= \\sum_{i = 1}^n \\sum_{d \\mid i} d \\left[ \\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026= \\sum_{d = 1}^n \\sum_{i = 1}^n d [d \\mid i] \\left[\\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026= \\sum_{d = 1}^n \\sum_{i = 1}^{n / d} d [\\gcd (i, d) = 1] \\end{aligned} $$ 看到 $\\gcd = 1$ 就应该想起来 Mobius 反演，容易化简有\n $$ S (n) = \\sum_{d = 1}^n \\sum_{i = 1}^{n / d} d \\sum_{u \\mid \\gcd (i, d)} \\mu(u) = \\sum_{u = 1}^{\\sqrt{n}} u \\mu (u) \\sum_{d = 1}^{n / u^2} d \\left\\lfloor \\frac{n}{d u^2} \\right\\rfloor $$ 用数论分块即可，计算复杂度 $O ( \\sqrt{n} \\log n )$。\nconst ll maxn = 1e6 + 20; const ll mod = 1e9 + 7; bool notp[maxn]; int prime[maxn / 10], cnt; ll mu[maxn]; void sieve(int n); // 筛 Mobius 函数  ll g[maxn]; ll G(ll n) { if (n \u0026lt;= 1e6 \u0026amp;\u0026amp; g[n] \u0026gt; 0) return g[n]; // 不做记忆化会 T  __int128_t ret = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = n / (n / l); __int128_t t = __int128_t(l + r) * (r - l + 1) / 2; ret += t * (n / l); } if (n \u0026lt;= 1e6) g[n] = ret % mod; return ret % mod; } int main() { ll ttt = rr(); sieve(1e6 + 1); for (ll i = 1; i \u0026lt;= 1e6+1; i++) { mu[i] = (mu[i - 1] + mu[i] * i) % mod; } while (ttt--) { ll n = rr(), sn = sqrt(n * 1.0); __int128_t ans = 0; for (ll l = 1, r; l \u0026lt;= sn; l = r + 1) { ll t = n / l / l; r = sqrt(n / (n / l / l) * 1.0); ans += (mu[r] - mu[l - 1]) * G(n / l / l); } ans = (ans % mod + mod) % mod; printf(\u0026#34;%lld\\n\u0026#34;, ll(ans)); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6750/","summary":"题目大意 定义\n $$ f (n) = \\sum_{d \\mid n} d \\left[ \\gcd \\left( d, \\frac{n}{d} \\right) = 1 \\right] $$ 求其前缀和 $S(n)$。\n分析 首先 Min25 筛是过不了的，内存不够。先推式子\n $$ \\begin{aligned} S (n) \u0026= \\sum_{i = 1}^n \\sum_{d \\mid i} d \\left[ \\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026= \\sum_{d = 1}^n \\sum_{i = 1}^n d [d \\mid i] \\left[\\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026= \\sum_{d = 1}^n \\sum_{i = 1}^{n / d} d [\\gcd (i, d) = 1] \\end{aligned} $$ 看到 $\\gcd = 1$ 就应该想起来 Mobius 反演，容易化简有","title":"HDU6750 Function"},{"content":"题目大意 即求\n $$ S = \\sum_{n=0}^\\infty f(n)r^n $$ 分析 换序\n $$ S = \\sum_{n = 0}^{\\infty} \\left( \\sum_{i = 0}^m f_i n^i \\right) r^n = \\sum_{i = 0}^m f_i \\sum_{n = 0}^{\\infty} n^i r^n $$ 令\n $$ S_i = \\sum_{n = 0}^{\\infty} n^i r^n $$ 套路的逐项相减，主动的凑二项式\n $$ (1 - r) S_i = 1 + \\sum_{n = 1}^{\\infty} n^i r^n - \\sum_{n = 1}^{\\infty} (n - 1)^i r^n = 1 + \\sum_{n = 0}^{\\infty} r^{n + 1} \\sum_{j = 0}^{i - 1} \\binom{k}{j} n^j $$ 交换求和顺序\n $$ (1 - r) S_i = 1 + \\sum_{j = 0}^{i - 1} \\binom{k}{j} \\sum_{n = 0}^{\\infty}r^{n + 1} n^j = 1 + \\sum_{j = 0}^{i - 1} \\binom{k}{j} r S_j $$ 再凑成完整的二项式卷积\n $$ \\frac{S_i - 1}{r} = \\sum_{j = 0}^i \\binom{k}{j} S_j $$ 我们设 ${ S_i }$ 的 EGF 为 $g(x)$，可以得到方程\n $$ \\frac{g(x) - 1}{r} = {\\rm e}^x g(x) $$ 解得\n $$ g(x) = \\frac{1}{1 - r {\\rm e}^x} $$ 因此最终多项式逆即可，EGF 和 OGF 的转化就是点乘阶乘。\nint main() { int m = rr() + 1, r = rr(); int lim = get_lim(m, m); w = pre_w(lim); Inv = pre_inv(lim); fac = pre_fac(lim); ifac = pre_ifac(fac); poly_t gg(lim, 1); // 初始化为 1  gg = ntt_ogf2egf(gg, lim); for (int i = 0; i \u0026lt; lim; i++) gg[i] = Mint(0) - gg[i] * r; gg[0] += 1; gg = ntt_inv(gg, lim); gg = ntt_egf2ogf(gg, lim); Mint ans = 0; for (int i = 0; i \u0026lt; m; i++) { int fi = rr(); ans += gg[i] * fi; } printf(\u0026#34;%d\u0026#34;, ans.v); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/p5349/","summary":"题目大意 即求\n $$ S = \\sum_{n=0}^\\infty f(n)r^n $$ 分析 换序\n $$ S = \\sum_{n = 0}^{\\infty} \\left( \\sum_{i = 0}^m f_i n^i \\right) r^n = \\sum_{i = 0}^m f_i \\sum_{n = 0}^{\\infty} n^i r^n $$ 令\n $$ S_i = \\sum_{n = 0}^{\\infty} n^i r^n $$ 套路的逐项相减，主动的凑二项式\n $$ (1 - r) S_i = 1 + \\sum_{n = 1}^{\\infty} n^i r^n - \\sum_{n = 1}^{\\infty} (n - 1)^i r^n = 1 + \\sum_{n = 0}^{\\infty} r^{n + 1} \\sum_{j = 0}^{i - 1} \\binom{k}{j} n^j $$ 交换求和顺序","title":"P5349 幂"},{"content":"题目大意 给定积性函数 $f(p^c) = p \\oplus c$。对 $1000000007$ 取模求前缀和。\n分析 Min25 板子题。\nconst ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n \u0026lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi \u0026lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.01); m = cnt = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { w[++m] = r = n / (n / l); ll mr = mo(r); s[m] = mr * (mr + 1) % mod * inv2 % mod - 1; c[m] = mr - 1; } for (ll p = 2; p \u0026lt;= sqrt_n; p++) { if (c[p] != c[p - 1]) { prime[++cnt] = p; for (ll j = m; w[j] \u0026gt;= p * p; j--) { s[j] = mo(s[j] - p * mo(s[id(w[j] / p)] - s[p - 1])); c[j] = mo(c[j] - (c[id(w[j] / p)] - c[p - 1])); } } } for (int i = 2; i \u0026lt;= m; i++) s[i] = mo(s[i] - c[i] + 2); printf(\u0026#34;%lld\u0026#34;, F(n, 0) + 1); } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-08/loj6053/","summary":"题目大意 给定积性函数 $f(p^c) = p \\oplus c$。对 $1000000007$ 取模求前缀和。\n分析 Min25 板子题。\nconst ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n \u0026lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi \u0026lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.","title":"LOJ6053 简单的函数"},{"content":"题目大意 给定文本串 $S$ 和模式串 $T$，对每个位置进行匹配，得到失配次数。\n统计此失配次数，计算前缀和。\n分析 我是没料到 HDOJ 没有 M_PI，CE 了几发。\nFFT 字符串匹配模板题，我在 ZAFU Wiki 中讲过，即对每个字符卷积。\n#include \u0026#34;template/basic/complex.hpp\u0026#34; const int maxn = 1 \u0026lt;\u0026lt; 20; using img = Complex\u0026lt;double\u0026gt;; using poly_t = vector\u0026lt;img\u0026gt;; poly_t w; #include \u0026#34;template/poly-fft/fft_init.hpp\u0026#34;#include \u0026#34;template/poly-fft/fft.hpp\u0026#34; char a[maxn], b[maxn]; int sum[maxn], ans[maxn]; char ch[] = \u0026#34;0123456789*\u0026#34;; int main() { w = fft_init(maxn); int ttt = rr(); while (ttt--) { int n = rr(), m = rr(); fill(sum, sum + m + n + 12, 0); fill(ans, ans + m + 12, 0); int lim = getlim(m, n); scanf(\u0026#34;%s %s\u0026#34;, b, a); int tsum = 0; for (int i = 0; i \u0026lt; m - 1; i++) { tsum += b[i] == \u0026#39;*\u0026#39;; tsum += a[i] == \u0026#39;*\u0026#39;; } tsum += a[m - 1] == \u0026#39;*\u0026#39;; reverse(a, a + m + 1); for (int k = 0; k \u0026lt;= 10; k++) { poly_t SS(lim); for (int i = 0; i \u0026lt; n; i++) SS[i].x = b[i] == ch[k]; for (int i = 1; i \u0026lt;= m; i++) SS[i].y = a[i] == ch[k]; fft(SS); for (int i = 0; i \u0026lt; lim; i++) SS[i] = SS[i] * SS[i]; ifft(SS); if (k == 10) { for (int i = 0; i \u0026lt;= m + n; i++) sum[i] -= int(SS[i].y / 2 + 0.5); } else { for (int i = 0; i \u0026lt;= m + n; i++) sum[i] += int(SS[i].y / 2 + 0.5); } } for (int i = m; i \u0026lt;= n; i++) { tsum += (b[i - 1] == \u0026#39;*\u0026#39;) - (b[i - m - 1] == \u0026#39;*\u0026#39;); int tans = tsum + sum[i]; ans[m - tans]++; } tsum = 0; for (int i = 0; i \u0026lt;= m; i++) { tsum += ans[i]; printf(\u0026#34;%d\\n\u0026#34;, tsum); } } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/hdu6975/","summary":"题目大意 给定文本串 $S$ 和模式串 $T$，对每个位置进行匹配，得到失配次数。\n统计此失配次数，计算前缀和。\n分析 我是没料到 HDOJ 没有 M_PI，CE 了几发。\nFFT 字符串匹配模板题，我在 ZAFU Wiki 中讲过，即对每个字符卷积。\n#include \u0026#34;template/basic/complex.hpp\u0026#34; const int maxn = 1 \u0026lt;\u0026lt; 20; using img = Complex\u0026lt;double\u0026gt;; using poly_t = vector\u0026lt;img\u0026gt;; poly_t w; #include \u0026#34;template/poly-fft/fft_init.hpp\u0026#34;#include \u0026#34;template/poly-fft/fft.hpp\u0026#34; char a[maxn], b[maxn]; int sum[maxn], ans[maxn]; char ch[] = \u0026#34;0123456789*\u0026#34;; int main() { w = fft_init(maxn); int ttt = rr(); while (ttt--) { int n = rr(), m = rr(); fill(sum, sum + m + n + 12, 0); fill(ans, ans + m + 12, 0); int lim = getlim(m, n); scanf(\u0026#34;%s %s\u0026#34;, b, a); int tsum = 0; for (int i = 0; i \u0026lt; m - 1; i++) { tsum += b[i] == \u0026#39;*\u0026#39;; tsum += a[i] == \u0026#39;*\u0026#39;; } tsum += a[m - 1] == \u0026#39;*\u0026#39;; reverse(a, a + m + 1); for (int k = 0; k \u0026lt;= 10; k++) { poly_t SS(lim); for (int i = 0; i \u0026lt; n; i++) SS[i].","title":"HDU6975 Forgiving Matching"},{"content":"魔改 KMP 大概是不行的，卷积在这里出现的很妙。\n卷积处理匹配 定义匹配函数\n $$ d(x,y) = [x = y] $$ 给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义\n $$ f(k) = \\sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k}) $$ 即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算\n $$ d(x,y) = (x - y)^2 $$ 再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有\n $$ \\begin{aligned} f(k) \u0026= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\\\ \u0026= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k} \\end{aligned} $$ 前面两项能够预处理，最后一项是卷积。于是最终复杂度是 $O(n \\log n)$。\n考虑通配符 仅令通配符的字符值为 $0$，再搓个匹配函数\n $$ d(x,y) = xy(x-y)^2 $$ 然后大力展开\n $$ \\begin{aligned} f(k) \u0026= \\sum_{i=0}^{m-1}A_{i}^3B_{i-m+k} + \\sum_{i=0}^{m-1}A_{i}B_{i-m+k}^3 - 2\\sum_{i=0}^{m-1} A_{i}^2B_{i-m+k}^2\\\\ \u0026= \\sum_{i=0}^{m-1}S_{m-i}^3B_{i-m+k} + \\sum_{i=0}^{m-1}S_{m-i}B_{i-m+k}^3 - 2\\sum_{i=0}^{m-1} S_{m-i}^2B_{i-m+k}^2 \\end{aligned} $$ 注意到三个都是卷积，于是最终复杂度是 $O(n \\log n)$。\n 记得优化取模。我换 NTT 之后 TLE 了好几次，最后发现是 NTT 里取模写多了。。\n #define ACM_MOD 998244353 const int mod = ACM_MOD; #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34;#include \u0026#34;template/basic/mint.hpp\u0026#34; using poly_t = vector\u0026lt;Mint\u0026gt;; poly_t w; #include \u0026#34;template/poly-ntt/pre_w.hpp\u0026#34;#include \u0026#34;template/poly-ntt/ntt.hpp\u0026#34; const int maxn = 1 \u0026lt;\u0026lt; 21; char a[maxn], b[maxn]; int stk[maxn], cnt = 0; int main() { int m = rr(), n = rr(); int lim = get_lim(m, n); w = pre_w(lim); poly_t B1(lim), B2(lim), B3(lim), S1(lim), S2(lim), S3(lim); scanf(\u0026#34;%s %s\u0026#34;, a, b); for (int i = 1; i \u0026lt;= m; i++) { int j = m - i, t = a[j] - \u0026#39;a\u0026#39; + 1; if (a[j] == \u0026#39;*\u0026#39;) t = 0; S1[i] = t; S2[i] = S1[i] * S1[i]; S3[i] = S2[i] * S1[i]; } for (int i = 0; i \u0026lt; n; i++) { int t = b[i] - \u0026#39;a\u0026#39; + 1; if (b[i] == \u0026#39;*\u0026#39;) t = 0; B1[i] = t; B2[i] = B1[i] * B1[i]; B3[i] = B2[i] * B1[i]; } ntt(S1), ntt(S2), ntt(S3); ntt(B1), ntt(B2), ntt(B3); for (int i = 0; i \u0026lt; lim; i++) S1[i] = S1[i] * B3[i] + S3[i] * B1[i] - S2[i] * B2[i] * 2; intt(S1); for (int i = m; i \u0026lt;= n; i++) { if (S1[i].v == 0) stk[++cnt] = i - m + 1; } printf(\u0026#34;%d\\n\u0026#34;, cnt); for (int i = 1; i \u0026lt;= cnt; i++) { printf(\u0026#34;%d \u0026#34;, stk[i]); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/p4173/","summary":"魔改 KMP 大概是不行的，卷积在这里出现的很妙。\n卷积处理匹配 定义匹配函数\n $$ d(x,y) = [x = y] $$ 给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义\n $$ f(k) = \\sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k}) $$ 即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算\n $$ d(x,y) = (x - y)^2 $$ 再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有\n $$ \\begin{aligned} f(k) \u0026= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\\\ \u0026= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k} \\end{aligned} $$ 前面两项能够预处理，最后一项是卷积。于是最终复杂度是 $O(n \\log n)$。","title":"P4173 残缺的字符串"},{"content":"题目大意 求杨辉三角形前 $n$ 行的偶数个数，对 $1000003$ 取模。\n分析 对杨辉三角奇数打表。\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 于是递推公式\n $$ f(2^t+n) = f(2^t) + 2f(n) $$ 就是显然的了，那么偶数即是全部的减去奇数个数。\nconst ll MOD = 1000003; ll nn[10086]; #define ACM_MOD MOD  #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34; int main() { ll n = rr(); nn[1] = 1; for (ll i = 2; i \u0026lt;= 100; i++) nn[i] = nn[i - 1] * 3 % MOD; ll t = 1, ans = 0; for (ll i = 1; i \u0026lt;= 100; i++) { if ((t \u0026amp; n) \u0026gt; 0) ans = (ans * 2 + nn[i]) % MOD; t = t \u0026lt;\u0026lt; 1; if (t \u0026gt; n) break; } n = n % MOD; ll sum = n * (n + 1) % MOD * inv(2) % MOD; printf(\u0026#34;%lld\\n\u0026#34;, (sum - ans + MOD) % MOD); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/p1762/","summary":"题目大意 求杨辉三角形前 $n$ 行的偶数个数，对 $1000003$ 取模。\n分析 对杨辉三角奇数打表。\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 于是递推公式","title":"P1762 偶数"},{"content":"题目大意 即求\n $$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] $$ 分析 先转化一下\n $$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] = \\sum_{p}\\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) = p] $$ 在 P2522 中得到\n $$ \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tk} \\right\\rfloor \\left\\lfloor \\frac{y}{tk} \\right\\rfloor $$ 代入有\n $$ \\sum_{p} \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tp} \\right\\rfloor \\left\\lfloor \\frac{y}{tp} \\right\\rfloor $$ 令 $T = tp$，$T$ 的上界应还是 $\\min(x,y)$，代入有\n $$ \\sum_{T=1}^{\\min(x,y)} \\left\\lfloor \\frac{x}{T} \\right\\rfloor \\left\\lfloor \\frac{y}{T} \\right\\rfloor \\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right) $$ 后面那个在 Euler 筛后再求和一下，是可以预处理的。\nconst ll MN = 1e7 + 100; int mu[MN], f[MN], dp[MN]; bool notp[MN]; int prime[MN/10], cnt; void sieve(int n) { mu[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { if (!notp[i]) prime[++cnt] = i, mu[i] = -1; int t = n / i; for (ll j = 1; j \u0026lt;= cnt; j++) { if (prime[j] \u0026gt; t) break; notp[i * prime[j]] = true; if (i % prime[j] == 0) { mu[i * prime[j]] = 0; break; } mu[i * prime[j]] = - mu[i]; } } for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= cnt; j++) { ll t = i * prime[j]; if(t \u0026gt; n) break; dp[t] += mu[i]; } } for (ll i = 1; i \u0026lt;= n; i++) f[i] = f[i - 1] + dp[i]; } 此时 $dp(T)$ 中存的是 $\\displaystyle\\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right)$，$f_i$ 是其前缀和。\n之后整数分块即可\nll calc(ll a, ll b) { ll mab = min(a, b); ll sum = 0; for (ll l = 1, r; l \u0026lt;= mab; l = r + 1) { r = min(a / (a / l), b / (b / l)); sum += (f[r] - f[l - 1]) * (a / l) * (b / l); } return sum; } int main() { ll ttt = rr(); sieve(MN - 10); for (ll i = 1; i \u0026lt;= ttt; i++) { ll a = rr(), b = rr(); printf(\u0026#34;%lld\\n\u0026#34;, calc(a,b)); } return 0; } 相似题目 P2568 GCD 即 $M = N = n$ 的特殊情况，可以再优化。即求\n $$ \\sum_{i=1}^n \\sum_{j=1}^n [\\gcd(i,j) \\in \\mathbb{P}] $$ 化简有\n $$ \\begin{aligned} \\sum_{p} \\sum_{i=1}^n \\sum_{j=1}^n [\\gcd(i,j) = p] \u0026= \\sum_{p} \\sum_{i=1}^{\\lfloor n/p\\rfloor} \\sum_{j=1}^{\\lfloor n/p\\rfloor} [\\gcd(i,j) = 1]\\\\\\\\ \u0026= \\sum_{p} \\left(2\\sum_{j=1}^{\\lfloor n/p\\rfloor} \\sum_{j=1}^{i} [\\gcd(i,j) = p] - 1\\right)\\\\\\\\ \u0026= \\sum_{p}\\left( 2\\sum_{i=1}^{\\lfloor n/p \\rfloor} \\varphi(i) - 1 \\right) \\end{aligned} $$ 预处理出 $\\varphi(i)$ 的前缀和后，对每个素数筛一遍即可。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2257/","summary":"题目大意 即求\n $$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] $$ 分析 先转化一下\n $$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] = \\sum_{p}\\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) = p] $$ 在 P2522 中得到\n $$ \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tk} \\right\\rfloor \\left\\lfloor \\frac{y}{tk} \\right\\rfloor $$ 代入有\n $$ \\sum_{p} \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tp} \\right\\rfloor \\left\\lfloor \\frac{y}{tp} \\right\\rfloor $$ 令 $T = tp$，$T$ 的上界应还是 $\\min(x,y)$，代入有\n $$ \\sum_{T=1}^{\\min(x,y)} \\left\\lfloor \\frac{x}{T} \\right\\rfloor \\left\\lfloor \\frac{y}{T} \\right\\rfloor \\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right) $$ 后面那个在 Euler 筛后再求和一下，是可以预处理的。","title":"P2257 YY 的 GCD"},{"content":"题目大意 设\n $$ \\varphi_{x+1}(m) = \\varphi(\\varphi_x(m)) $$ 求最小的 $x$ 使得 $\\varphi_x(m) = 1$。\n其中 $\\varphi(m)$ 是欧拉函数。\n分析 注意到仅有 $\\varphi(1) = \\varphi(2) = 1$，再有公式\n $$ \\varphi\\left(\\prod_{i=1}^mp_i^{q_i}\\right) = \\prod_{i=1}^m(p_i-1)p_i^{q_i-1} $$ 因此从唯一分解形式的角度来看，迭代一次消去了一个 $2$，也生成了一些 $2$。\n考虑设 $f(n)$ 为 $\\varphi(n)$ 中因子 $2$ 的个数。\n设 $\\gcd(a,b) = 1$，可以证明 $f(ab) = f(a) f(b)$。同时 $f(p) = f(p-1)$。\n这说明 $f(x)$ 是一个积性函数，可以用 Euler 筛递推。\nconst ll MN = 1e5 + 10; bool notp[1000001]; int prime[200001], cnt, phi[1000001]; void sieve(int n) { phi[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { if (!notp[i]) { prime[++cnt] = i; phi[i] = phi[i - 1]; } int t = n / i; for (ll j = 1; j \u0026lt;= cnt; j++) { if (prime[j] \u0026gt; t) break; int ti = i * prime[j]; notp[ti] = true; phi[ti] = phi[i] + phi[prime[j]]; if (i % prime[j] == 0) break; } } } 然后在 main 中输出即可。注意若没有质因子 $2$，则答案需要加 $1$。\nint main() { sieve(MN - 10); ll ttt = rr(); while (ttt--) { ll m = rr(), ans = 1; for (ll i = 1; i \u0026lt;= m; i++) { ll p = rr(), q = rr(); if (p == 2) ans--; ans += phi[p] * q; } printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2350/","summary":"题目大意 设\n $$ \\varphi_{x+1}(m) = \\varphi(\\varphi_x(m)) $$ 求最小的 $x$ 使得 $\\varphi_x(m) = 1$。\n其中 $\\varphi(m)$ 是欧拉函数。\n分析 注意到仅有 $\\varphi(1) = \\varphi(2) = 1$，再有公式\n $$ \\varphi\\left(\\prod_{i=1}^mp_i^{q_i}\\right) = \\prod_{i=1}^m(p_i-1)p_i^{q_i-1} $$ 因此从唯一分解形式的角度来看，迭代一次消去了一个 $2$，也生成了一些 $2$。\n考虑设 $f(n)$ 为 $\\varphi(n)$ 中因子 $2$ 的个数。\n设 $\\gcd(a,b) = 1$，可以证明 $f(ab) = f(a) f(b)$。同时 $f(p) = f(p-1)$。\n这说明 $f(x)$ 是一个积性函数，可以用 Euler 筛递推。\nconst ll MN = 1e5 + 10; bool notp[1000001]; int prime[200001], cnt, phi[1000001]; void sieve(int n) { phi[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { if (!","title":"P2350 外星人"},{"content":"Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。\n若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。\n求一年有几对。\n $$ xd+y \\equiv yd+x \\pmod w $$ 即\n $$ (x-y)(d-1) \\equiv 0 \\Rightarrow (x-y)(d-1) \\in w\\mathbb{Z} $$ 于是有\n $$ y-x = \\frac{wk}{\\gcd(w,d-1)} $$ 又 $x \u0026lt; y \\leqslant \\min(m,d)$​，\nint main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/cf1389e/","summary":"Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。\n若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。\n求一年有几对。\n $$ xd+y \\equiv yd+x \\pmod w $$ 即\n $$ (x-y)(d-1) \\equiv 0 \\Rightarrow (x-y)(d-1) \\in w\\mathbb{Z} $$ 于是有\n $$ y-x = \\frac{wk}{\\gcd(w,d-1)} $$ 又 $x \u0026lt; y \\leqslant \\min(m,d)$​，\nint main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","title":"CF1389E Calendar Ambiguity"},{"content":"题目大意 即求\n $$ \\sum_{i=1}^n \\gcd(i,n) $$ 分析 联想到\n $$ \\varphi(n) = \\sum_{i=1}^n [\\gcd(i,n) = 1] $$ 尝试凑这个形式\n $$ \\begin{aligned} \\sum_{i=1}^n \\gcd(i,n) \u0026= \\sum_{d \\mid n} d \\sum_{i=1}^n [\\gcd(i,n) = d] \\\\ \u0026= \\sum_{d \\mid n} d \\sum_{i=1}^{n/d} [\\gcd(i,n/d) = 1] \\\\ \u0026= \\sum_{d \\mid n} d \\varphi(n/d) \\end{aligned} $$ 这里其实已经可以过题了，但还可以再瞎搞一下，令\n $$ nf(n) = \\sum_{d \\mid n} d \\varphi(n/d) = n\\sum_{d \\mid n} \\frac{\\varphi(d)}{d} $$ 尝试证明 $f(n)$ 是一个积性函数。设 $\\gcd(a,b) = 1$，有\n $$ \\begin{aligned} f(a)f(b) \u0026= \\left(\\sum_{d_1 \\mid a} \\frac{\\varphi(d_1)}{d_1}\\right) \\left(\\sum_{d_2 \\mid b} \\frac{\\varphi(d_2)}{d_2}\\right)\\\\ \u0026= \\sum_{d_1 \\mid a} \\sum_{d_2 \\mid b} \\frac{\\varphi(d_1)}{d_1} \\frac{\\varphi(d_2)}{d_2}\\\\ \u0026= \\sum_{d_1 \\mid a} \\sum_{d_2 \\mid b} \\frac{\\varphi(d_1d_2)}{d_1d_2}\\\\ \u0026= f(ab) \\end{aligned} $$ 再来推一下素数，注意 $1 \\mid p^k$，有\n $$ f(p^k) = \\sum_{d \\mid p^k} \\frac{\\varphi(d)}{d} = \\sum_{i=0}^k \\frac{\\varphi(p^i)}{p^i} = k\\left(1 - \\frac{1}{p}\\right) + 1 $$ 类似于 $\\varphi(m)$ 唯一分解形式，我们还有\n $$ f(n) = \\prod_{i=1}^sf(p_i^{k_i}) = \\prod_{i=1}^s \\frac{k_ip_i - k_i + p_i}{p_i} $$ 于是答案即为 $nf(n)$，复杂度 $O(\\sqrt{n})$。\nint main() { ll n = rr(), ans = n; for (ll i = 2; i * i \u0026lt;= n; i++) { ll k = 0; while (n % i == 0) k++, n /= i; if (k \u0026gt; 0) ans += ans / i * k * (i - 1); } if (n \u0026gt; 1) ans += ans / n * (n - 1); printf(\u0026#34;%lld\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2303/","summary":"题目大意 即求\n $$ \\sum_{i=1}^n \\gcd(i,n) $$ 分析 联想到\n $$ \\varphi(n) = \\sum_{i=1}^n [\\gcd(i,n) = 1] $$ 尝试凑这个形式\n $$ \\begin{aligned} \\sum_{i=1}^n \\gcd(i,n) \u0026= \\sum_{d \\mid n} d \\sum_{i=1}^n [\\gcd(i,n) = d] \\\\ \u0026= \\sum_{d \\mid n} d \\sum_{i=1}^{n/d} [\\gcd(i,n/d) = 1] \\\\ \u0026= \\sum_{d \\mid n} d \\varphi(n/d) \\end{aligned} $$ 这里其实已经可以过题了，但还可以再瞎搞一下，令\n $$ nf(n) = \\sum_{d \\mid n} d \\varphi(n/d) = n\\sum_{d \\mid n} \\frac{\\varphi(d)}{d} $$ 尝试证明 $f(n)$ 是一个积性函数。设 $\\gcd(a,b) = 1$，有","title":"P2303 Longge 的问题"},{"content":"题目大意 给定 $g[1], \\cdots, g[m]$，求序列 $f$。\n $$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$ 分析 不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程\n $$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$ 这个形式看似卷积，但实际上它缺了一项。对 $n \u0026gt; 0$ 凑卷积\n $$ f [n] (h [0] + 1) = \\sum_{j = 0}^n f [n - j] h [j] = (f \\ast h) [n] $$ 又 $f [0] = 1$，有\n $$ f \\ast (1 + h [0]) - f \\ast h = f [0] (1 + h [0]) - f [0] h [0] = f [0] $$ 解得\n $$ f (x) = \\frac{f [0]}{1 + h [0] - h (x)} = \\frac{1}{1 - g (x)} $$ 于是求逆即可\n#define ACM_MOD 998244353 const int mod = ACM_MOD; using poly_t = vector\u0026lt;int\u0026gt;; poly_t w; #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/mint.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34; #include \u0026#34;template/poly-ntt/ntt_init.hpp\u0026#34;#include \u0026#34;template/poly-ntt/ntt.hpp\u0026#34;#include \u0026#34;template/poly-ntt/ntt_inv.hpp\u0026#34; int main() { int n = rr(); int lim = getlin(n, n); w = ntt_init(lim); poly_t ans, ff(lim); for (int i = 1; i \u0026lt; n; i++) ff[i] = mod - rr(); ff[0] = 1; ans = ntt_inv(ff, lim); for (int i = 0; i \u0026lt; n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p4721/","summary":"题目大意 给定 $g[1], \\cdots, g[m]$，求序列 $f$。\n $$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$ 分析 不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程\n $$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$ 这个形式看似卷积，但实际上它缺了一项。对 $n \u0026gt; 0$ 凑卷积","title":"P4721 分治 FFT"},{"content":"题目大意 即求\n $$ \\sum_{i=a}^b \\sum_{j=c}^d [\\gcd(i,j) = k] $$ 分析 容易想到，独立出函数 $f(k)$ 使得\n $$ f(k) = \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] $$ 利用 Mobius 反演化简，设 $F(d)$\n $$ F(n) = \\sum_{n \\mid d} f(d) = \\sum_{i=1}^x \\sum_{j=1}^y [n \\mid i][n \\mid j] = \\left\\lfloor \\frac{x}{n} \\right\\rfloor \\left\\lfloor \\frac{y}{n} \\right\\rfloor $$ 反演化简有\n $$ f(n) = \\sum_{n \\mid d} \\mu\\left(\\frac{d}{n}\\right)F(d) = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tn} \\right\\rfloor \\left\\lfloor \\frac{y}{tn} \\right\\rfloor $$ 预处理出 $\\mu(t)$ 的前缀和，剩下的就是一个二重分块了。\nconst ll MN = 50000; bool notp[1000001]; int prime[200001], cnt, mu[MN]; void Mobius(int n); // 预处理 Mobius 函数  ll f(ll a, ll b) { ll mab = min(a, b); ll sum = 0; for (ll l = 1, r; l \u0026lt;= mab; l = r + 1) { r = min(a / (a / l), b / (b / l)); sum += (mu[r] - mu[l - 1]) * (a / l) * (b / l); } return sum; } int main() { ll ttt = rr(); Mobius(MN - 1); for (ll i = 1; i \u0026lt;= MN - 1; i++) mu[i] += mu[i - 1]; for (ll i = 1; i \u0026lt;= ttt; i++) { ll a = rr(), b = rr(), c = rr(), d = rr(); ll k = rr(); a--, c--; a /= k, b /= k, c /= k, d /= k; ll ans = f(b, d) - f(a, d) - f(b, c) + f(a, c); printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } 类似题目 P2158 仪仗队：即 $k = 1$ 的特殊情况。\nP3455 ZAP-Queries：几乎一样。\nP2257 YY 的 GCD：比这题难，单独开篇。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2522/","summary":"题目大意 即求\n $$ \\sum_{i=a}^b \\sum_{j=c}^d [\\gcd(i,j) = k] $$ 分析 容易想到，独立出函数 $f(k)$ 使得\n $$ f(k) = \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] $$ 利用 Mobius 反演化简，设 $F(d)$\n $$ F(n) = \\sum_{n \\mid d} f(d) = \\sum_{i=1}^x \\sum_{j=1}^y [n \\mid i][n \\mid j] = \\left\\lfloor \\frac{x}{n} \\right\\rfloor \\left\\lfloor \\frac{y}{n} \\right\\rfloor $$ 反演化简有\n $$ f(n) = \\sum_{n \\mid d} \\mu\\left(\\frac{d}{n}\\right)F(d) = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tn} \\right\\rfloor \\left\\lfloor \\frac{y}{tn} \\right\\rfloor $$ 预处理出 $\\mu(t)$ 的前缀和，剩下的就是一个二重分块了。","title":"P2522 Problem B"},{"content":"题目大意 给出正整数 $n$ 和 $k$，请计算\n $$ G(n, k) = \\sum_{i = 1}^n k \\bmod i $$ 分析 因为\n $$ k \\bmod i = k - i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$ 因此有\n $$ G(n,k) = nk - \\sum_{i=1}^n i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$ 后面需要整数分块。\nint main() { ll n = rr(); ll k = rr(); ll sum = n * k; n = min(n, k); for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = min(n, k / (k / l)); ll t = (l + r) * (r - l + 1) / 2; sum -= t * (k / l); } printf(\u0026#34;%lld\u0026#34;, sum); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-04/p2261/","summary":"题目大意 给出正整数 $n$ 和 $k$，请计算\n $$ G(n, k) = \\sum_{i = 1}^n k \\bmod i $$ 分析 因为\n $$ k \\bmod i = k - i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$ 因此有\n $$ G(n,k) = nk - \\sum_{i=1}^n i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$ 后面需要整数分块。\nint main() { ll n = rr(); ll k = rr(); ll sum = n * k; n = min(n, k); for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = min(n, k / (k / l)); ll t = (l + r) * (r - l + 1) / 2; sum -= t * (k / l); } printf(\u0026#34;%lld\u0026#34;, sum); return 0; } ","title":"P2261 余数求和"},{"content":"题目大意 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：\n $$ y_i=\\sum_{j=l_i}^{r_i}[w_j \\geqslant W] \\times \\sum_{j=l_i}^{r_i}[w_j \\geqslant W]v_j $$ 记检验结果为 $y=\\sum y_i$，对于给定的 $s$，求 $|y-s|$ 的最小值。\n分析 注意到 $y(w)$ 是关于 $W$ 的递减函数，对 $w$ 在 $[w_{\\min},w_{\\max}]$ 上进行二分。\nconst ll MN = 2e5 + 10; ll vv[MN], ww[MN], li[MN], ri[MN], f1[MN], f2[MN]; ll n, m, s; int main() { n = rr(), m = rr(), s = rr(); ll minw = 0x3f3f3f3f, maxw = 0; f1[0] = f2[0] = 0; for (ll i = 1; i \u0026lt;= n; i++) { ww[i] = rr(), vv[i] = rr(); maxw = max(ww[i], maxw); minw = min(ww[i], minw); } for (ll i = 1; i \u0026lt;= m; i++) { li[i] = rr(), ri[i] = rr(); } ll l = minw, r = maxw + 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (sum(mid) \u0026lt;= s) r = mid; else l = mid + 1; } ll rst = min(sum(l - 1) - s, s - sum(l)); printf(\u0026#34;%lld\u0026#34;, rst); return 0; } 区间求和可以用前缀和优化。\nll f1[MN], f2[MN]; ll sum(ll w) { for (ll i = 1; i \u0026lt;= n; i++) { ll f = ww[i] \u0026gt;= w; f1[i] = f1[i - 1] + f; f2[i] = f2[i - 1] + f * vv[i]; } ll sum = 0; for (ll k = 1; k \u0026lt;= m; k++) { ll l = li[k], r = ri[k]; sum += (f1[r] - f1[l - 1]) * (f2[r] - f2[l - 1]); } return sum; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-04/p1314/","summary":"题目大意 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：\n $$ y_i=\\sum_{j=l_i}^{r_i}[w_j \\geqslant W] \\times \\sum_{j=l_i}^{r_i}[w_j \\geqslant W]v_j $$ 记检验结果为 $y=\\sum y_i$，对于给定的 $s$，求 $|y-s|$ 的最小值。\n分析 注意到 $y(w)$ 是关于 $W$ 的递减函数，对 $w$ 在 $[w_{\\min},w_{\\max}]$ 上进行二分。\nconst ll MN = 2e5 + 10; ll vv[MN], ww[MN], li[MN], ri[MN], f1[MN], f2[MN]; ll n, m, s; int main() { n = rr(), m = rr(), s = rr(); ll minw = 0x3f3f3f3f, maxw = 0; f1[0] = f2[0] = 0; for (ll i = 1; i \u0026lt;= n; i++) { ww[i] = rr(), vv[i] = rr(); maxw = max(ww[i], maxw); minw = min(ww[i], minw); } for (ll i = 1; i \u0026lt;= m; i++) { li[i] = rr(), ri[i] = rr(); } ll l = minw, r = maxw + 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (sum(mid) \u0026lt;= s) r = mid; else l = mid + 1; } ll rst = min(sum(l - 1) - s, s - sum(l)); printf(\u0026#34;%lld\u0026#34;, rst); return 0; } 区间求和可以用前缀和优化。","title":"P1314 聪明的质检员"},{"content":"题目链接：Link 。\nA. ABC String 这么水的题竟然 wa 了 4 发。。\n题目大意 给定一个长 $n$ 的字符串 $a$，仅由 A，B，C 组成，$n$ 为偶数。\n对于仅含 ( 和 ) 的括号序列，当我们能够在其中添加 1 使得其为合法的表达式，则序列合法。\n构造合法的长为 $n$ 的括号序列 $b$，要求在 $a$ 同为 A 的，在 $b$ 中也要相同；B，C 也是如此。\n分析 序列合法的定义即对任意位置，其左侧的 ) 总比 ( 少，且整体左右括号数相等。\n首个字母必为左括号，末尾字母必为右括号。剩下的那个讨论一下即可。\nchar ss[60]; int main() { ll ttt = rr(); while (ttt--) { scanf(\u0026#34;%s\u0026#34;, ss + 1); ll len = strlen(ss + 1); if (ss[1] == ss[len]) { printf(\u0026#34;NO\\n\u0026#34;); continue; } ll sa[3] = {0, 0, 0}; for (ll i = 1; i \u0026lt;= len; i++) sa[ss[i] - \u0026#39;A\u0026#39;]++; ll sl = ss[1] - \u0026#39;A\u0026#39;, sr = ss[len] - \u0026#39;A\u0026#39;; ll sm = 3ll - sl - sr; bool flag = false; sa[0] = sa[1] = sa[2] = 0; if (sa[sl] + sa[sm] == sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] + sa[sm] \u0026lt; sa[sr]; } } else if (sa[sl] == sa[sm] + sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] \u0026lt; sa[sm] + sa[sr]; } } else { printf(\u0026#34;NO\\n\u0026#34;); continue; } if (flag) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); } return 0; } B. Berland Crossword 题目大意 对于一个边长为 $n$ 的正方形黑白棋盘，指定其最顶行的黑色块数为 $u$，最左列、最右侧、最底行的黑色块数分别为 $l,r,d$。\n判断棋盘是否存在。\n分析 关键点在于四个角，然而也就只有 $16$ 种可能，枚举即可。\nll ff[10], aa[10]; int main() { ll ttt = rr(); while (ttt--) { ll n = rr(); for (ll i = 0; i \u0026lt;= 3; i++) aa[i] = rr(); bool flag = false; for (ll k = 0; k \u0026lt;= 15; k++) { memset(ff, 0, sizeof(ff)); int f = 1; for (ll j = 0; j \u0026lt;= 3; j++) { ff[j] = ((k \u0026amp; f) \u0026gt; 0); f = f \u0026lt;\u0026lt; 1; } bool tflag = false; for (ll j = 0; j \u0026lt;= 3; j++) { ll u = aa[j] - ff[j] - ff[(j + 1) % 4]; tflag = tflag || u \u0026lt; 0 || u \u0026gt; n - 2; } flag = flag || !tflag; } if (flag) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } C. 1D Sokoban 题目大意 假设一个直线上的推箱子游戏，你的出生点位于 $0$，在 $a_i$ 处有 $n$ 个箱子，在 $b_i$ 处有 $m$ 个目标点。箱子可能初始化在目标点，但不会在 $0$。\n就像推箱子一样，你可以把箱子推到目标点而不能越过箱子。求最多能使目标点上有几个箱子。\n分析 首先看正半轴，推的时候箱子会积起来，关注点在“箱子队列”的右端。\n容易发现，当右端未碰到新目标点时，结果是不可能变多的。分类讨论\n 当右端碰到恰在目标点的新箱子时，ans+1，计算此时覆盖个数，取最值，len+1。 当右端碰到箱子时，len+1。 当右端碰到目标点时，计算此时覆盖个数，取最值。  计算箱子下覆盖目标点个数可以用双指针法维护。\n有些地方可以用二分？但好像没有变快啊\nconst ll inf = 0x3f3f3f3f3f3f3f3f; ll aa[200086], bb[200086]; int main() { ll ttt = rr(); while (ttt--) { ll n = rr(); ll m = rr(); ll a0 = 0, b0 = 0; for (ll i = 1; i \u0026lt;= n; i++) aa[i] = rr(); for (ll i = 1; i \u0026lt;= m; i++) bb[i] = rr(); a0 = lower_bound(aa + 1, aa + n + 1, 0) - aa - 1; b0 = lower_bound(bb + 1, bb + m + 1, 0) - bb - 1; aa[0] = bb[0] = -inf; aa[n + 1] = bb[m + 1] = inf; ll ra1 = a0 + 1, rb1 = b0 + 1; ll sum = 0, ans = 0, len = 0; ll sl = rb1, sr = rb1; while (ra1 \u0026lt;= n || rb1 \u0026lt;= m) { if (aa[ra1] \u0026lt; bb[rb1]) { len++, ra1++; continue; } sr++; ll tsum = sr - sl; if (aa[ra1] \u0026gt; bb[rb1]) { while (bb[sl] \u0026lt;= bb[rb1] - len \u0026amp;\u0026amp; tsum \u0026gt; 0) sl++, tsum--; } else { ans++; while (bb[sl] \u0026lt;= bb[rb1] - len - 1 \u0026amp;\u0026amp; tsum \u0026gt; 0) sl++, tsum--; len++, ra1++; } rb1++; ans = max(ans, tsum); } sum += ans; ra1 = a0; sl = sr = rb1 = b0; ans = len = 0; while (ra1 \u0026gt;= 1 || rb1 \u0026gt;= 1) { if (aa[ra1] \u0026gt; bb[rb1]) { len++, ra1--; continue; } sl--; ll tsum = sr - sl; if (aa[ra1] \u0026lt; bb[rb1]) { while (bb[sr] \u0026gt;= bb[rb1] + len \u0026amp;\u0026amp; tsum \u0026gt; 0) sr--, tsum--; } else { ans++; while (bb[sr] \u0026gt;= bb[rb1] + len + 1 \u0026amp;\u0026amp; tsum \u0026gt; 0) sr--, tsum--; len++, ra1--; } rb1--; ans = max(ans, tsum); } sum += ans; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/cfedu105/","summary":"题目链接：Link 。\nA. ABC String 这么水的题竟然 wa 了 4 发。。\n题目大意 给定一个长 $n$ 的字符串 $a$，仅由 A，B，C 组成，$n$ 为偶数。\n对于仅含 ( 和 ) 的括号序列，当我们能够在其中添加 1 使得其为合法的表达式，则序列合法。\n构造合法的长为 $n$ 的括号序列 $b$，要求在 $a$ 同为 A 的，在 $b$ 中也要相同；B，C 也是如此。\n分析 序列合法的定义即对任意位置，其左侧的 ) 总比 ( 少，且整体左右括号数相等。\n首个字母必为左括号，末尾字母必为右括号。剩下的那个讨论一下即可。\nchar ss[60]; int main() { ll ttt = rr(); while (ttt--) { scanf(\u0026#34;%s\u0026#34;, ss + 1); ll len = strlen(ss + 1); if (ss[1] == ss[len]) { printf(\u0026#34;NO\\n\u0026#34;); continue; } ll sa[3] = {0, 0, 0}; for (ll i = 1; i \u0026lt;= len; i++) sa[ss[i] - \u0026#39;A\u0026#39;]++; ll sl = ss[1] - \u0026#39;A\u0026#39;, sr = ss[len] - \u0026#39;A\u0026#39;; ll sm = 3ll - sl - sr; bool flag = false; sa[0] = sa[1] = sa[2] = 0; if (sa[sl] + sa[sm] == sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] + sa[sm] \u0026lt; sa[sr]; } } else if (sa[sl] == sa[sm] + sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] \u0026lt; sa[sm] + sa[sr]; } } else { printf(\u0026#34;NO\\n\u0026#34;); continue; } if (flag) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); } return 0; } B.","title":"CF1494 Educational Round 105 (Rated for Div. 2)"},{"content":"题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。\n给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。\n分析 我是没想出来，经题解提示了拼接函数才写出来的。\n设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。\nchar s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; for (ll i = 1; i \u0026lt;= ml; i++) { int flag = 1; for (ll j = 0; j \u0026lt;= i - 1; j++) { if (s[x][len[x] + j - i] != s[y][j]) { flag = 0; break; } } if (flag) { mt[x][y] = i; break; } } } 然后回溯 dfs，搜索即可。\nll n; int vis[30]; ll dfs(int x) { if (vis[x] \u0026gt;= 2) return 0; vis[x]++; ll maxlen = 0; for (ll i = 1; i \u0026lt;= n; i++) { if (mt[x][i] \u0026gt; 0) { maxlen = max(maxlen, dfs(i) - mt[x][i]); } } vis[x]--; return maxlen + len[x]; } int main() { n = rr(); for (ll i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%s\u0026#34;, s[i]); len[i] = strlen(s[i]); } for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= n; j++) { init(i, j); } } ll maxlen = 0; scanf(\u0026#34;%s\u0026#34;, s[0]); for (ll i = 1; i \u0026lt;= n; i++) { if (s[i][0] == s[0][0]) { maxlen = max(maxlen, dfs(i)); } } printf(\u0026#34;%lld\\n\u0026#34;, maxlen); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/p1019/","summary":"题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。\n给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。\n分析 我是没想出来，经题解提示了拼接函数才写出来的。\n设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。\nchar s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; for (ll i = 1; i \u0026lt;= ml; i++) { int flag = 1; for (ll j = 0; j \u0026lt;= i - 1; j++) { if (s[x][len[x] + j - i] !","title":"P1019 单词接龙"},{"content":"题目大意 在 $0$ 到 $L$ 的位置间，有 $N$ 块岩石。若要使得岩石间距最小值最大，允许移除 $M$ 块，求此时间距最小值。\n分析 定义函数 $f(x)$，输入为最小值，输出为被移除岩石的个数，实现如下\nll L, N, M, aa[100086]; ll f(ll x) { ll ans = 0; ll l = 0, r = 1; while (r \u0026lt;= N) { if (aa[r] - aa[l] \u0026gt;= x) l = r; else ans++; r++; } return ans; } 显然 $f(x)$ 是单调递减的函数，二分查找即可。\nint main() { L = rr(), N = rr(), M = rr(); for (ll i = 1; i \u0026lt;= N; i++) aa[i] = rr(); aa[++N] = L; ll l = 1, r = L; while (l \u0026lt; r) { ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; ll fm = f(mid); if (fm \u0026lt;= M) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/p2678/","summary":"题目大意 在 $0$ 到 $L$ 的位置间，有 $N$ 块岩石。若要使得岩石间距最小值最大，允许移除 $M$ 块，求此时间距最小值。\n分析 定义函数 $f(x)$，输入为最小值，输出为被移除岩石的个数，实现如下\nll L, N, M, aa[100086]; ll f(ll x) { ll ans = 0; ll l = 0, r = 1; while (r \u0026lt;= N) { if (aa[r] - aa[l] \u0026gt;= x) l = r; else ans++; r++; } return ans; } 显然 $f(x)$ 是单调递减的函数，二分查找即可。\nint main() { L = rr(), N = rr(), M = rr(); for (ll i = 1; i \u0026lt;= N; i++) aa[i] = rr(); aa[++N] = L; ll l = 1, r = L; while (l \u0026lt; r) { ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; ll fm = f(mid); if (fm \u0026lt;= M) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } ","title":"P2678 跳石头"},{"content":"过于简单的题不记录。\n洛谷：更新至：2020.12.31(2020.10)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2020 年 12 月 P5656 二元一次不定方程 (exgcd)\nP4779 单源最短路径（标准版）\nP1629 邮递员送信\nP1359 租用游艇\nP2016 战略游戏\nP3884 二叉树问题\nP3379 最近公共祖先（LCA）\nP2052 道路修建\nP1352 没有上司的舞会\nP3371 单源最短路径（弱化版）\nP3146 248 G\n2020 年 11 月 P1880 石子合并 ==DONE==\nP1636 Einstein 学画画\nP3383 线性筛素数\nP1226 快速幂 || 取余运算\nP3367 并查集\nP4913 二叉树深度\nP4715 淘汰赛\nP2058 海港\nP1106 删数问题\nP1160 队列安排\nP1941 飞扬的小鸟\nP1064 金明的预算方案\nP1833 樱花\nP1541 乌龟棋 ==DONE==\nP3842 线段 ==DONE==\n2020 年 10 月 P1077 摆花 ==DONE==\nP4995 跳跳！ ==DONE==\nP1090 合并果子 ==DONE==\nP1990 覆盖墙壁 ==DONE==\nP1928 外星密码 ==DONE==\nP1923 求第 $k$ 小的数 ==DONE==\nP5143 攀爬者 ==X==\nP1095 守望者的逃离 ==DONE==\n2020 年 09 月 开始 ACM。不记录 HDU 150 的基础题。\nP1042 乒乓球 ==X==\nP2181 对角线 ==DONE==\nP1004 方格取数 ==DONE==\nCF1384B2 Koa and the Beach ==DONE==\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/log/log2020/","summary":"过于简单的题不记录。\n洛谷：更新至：2020.12.31(2020.10)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2020 年 12 月 P5656 二元一次不定方程 (exgcd)\nP4779 单源最短路径（标准版）\nP1629 邮递员送信\nP1359 租用游艇\nP2016 战略游戏\nP3884 二叉树问题\nP3379 最近公共祖先（LCA）\nP2052 道路修建\nP1352 没有上司的舞会\nP3371 单源最短路径（弱化版）\nP3146 248 G\n2020 年 11 月 P1880 石子合并 ==DONE==\nP1636 Einstein 学画画\nP3383 线性筛素数\nP1226 快速幂 || 取余运算\nP3367 并查集\nP4913 二叉树深度\nP4715 淘汰赛\nP2058 海港\nP1106 删数问题\nP1160 队列安排\nP1941 飞扬的小鸟\nP1064 金明的预算方案\nP1833 樱花\nP1541 乌龟棋 ==DONE==","title":"2020 年刷题日志"},{"content":"题目大意 环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。\n求最终分数的最小值和最大值。\n分析 考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为\n $$ dp(i,j) = \\max_{i \\leqslant k \\leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j)) $$ 其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。\n然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。\n细节：前缀和、循环开两倍。\nint dmax[205][205], dmin[205][205]; int f[205], s[205]; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) f[i + n] = f[i] = rr(); for (ll i = 1; i \u0026lt;= n * 2; i++) s[i] = s[i - 1] + f[i]; for (ll len = 2; len \u0026lt;= n; len++) { for (ll i = 1; i \u0026lt;= 2 * n - len + 1; i++) { int j = i + len - 1; int tmax = 0, tmin = 0x3f3f3f3f; int ss = s[j] - s[i - 1]; for (ll k = i; k \u0026lt;= j - 1; k++) { tmax = max(tmax, dmax[i][k] + dmax[k + 1][j] + ss); tmin = min(tmin, dmin[i][k] + dmin[k + 1][j] + ss); } dmax[i][j] = tmax; dmin[i][j] = tmin; } } int mmin = 0x3f3f3f3f, mmax = 0; for (ll p = 0; p \u0026lt;= n - 1; p++) { mmin = min(mmin, dmin[p + 1][p + n]); mmax = max(mmax, dmax[p + 1][p + n]); } printf(\u0026#34;%d\\n%d\\n\u0026#34;, mmin, mmax); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1880/","summary":"题目大意 环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。\n求最终分数的最小值和最大值。\n分析 考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为\n $$ dp(i,j) = \\max_{i \\leqslant k \\leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j)) $$ 其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。\n然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。\n细节：前缀和、循环开两倍。\nint dmax[205][205], dmin[205][205]; int f[205], s[205]; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) f[i + n] = f[i] = rr(); for (ll i = 1; i \u0026lt;= n * 2; i++) s[i] = s[i - 1] + f[i]; for (ll len = 2; len \u0026lt;= n; len++) { for (ll i = 1; i \u0026lt;= 2 * n - len + 1; i++) { int j = i + len - 1; int tmax = 0, tmin = 0x3f3f3f3f; int ss = s[j] - s[i - 1]; for (ll k = i; k \u0026lt;= j - 1; k++) { tmax = max(tmax, dmax[i][k] + dmax[k + 1][j] + ss); tmin = min(tmin, dmin[i][k] + dmin[k + 1][j] + ss); } dmax[i][j] = tmax; dmin[i][j] = tmin; } } int mmin = 0x3f3f3f3f, mmax = 0; for (ll p = 0; p \u0026lt;= n - 1; p++) { mmin = min(mmin, dmin[p + 1][p + n]); mmax = max(mmax, dmax[p + 1][p + n]); } printf(\u0026#34;%d\\n%d\\n\u0026#34;, mmin, mmax); return 0; } ","title":"P1880 石子合并"},{"content":"题目大意 混合背包。每棵树都有美学值 $C_i$，共有三种：\n 一种只能看一遍。 一种最多看 $A_i$ 遍。 一种可以看无数遍。  分析 对于混合背包，我们可以对物品拆分，得到多个物品。\nll dp[1086], tt[100086], cc[100086]; int main() { int tsh = rr(), tsm = rr(), teh = rr(), tem = rr(); int tsum = (teh - tsh) * 60 + tem - tsm; int n = rr(); int tp = 1; for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(), c = rr(), p = rr(); if (p == 1) { tt[tp] = t, cc[tp] = c; tp++; } else { p = p != 0 ? p : 99999; int b = 1; while (b \u0026lt; p) { tt[tp] = t * b, cc[tp] = c * b; p -= b, b *= 2; tp++; } tt[tp] = t * p, cc[tp] = c * p; tp++; } } for (ll i = 1; i \u0026lt;= tp - 1; i++) { for (ll j = tsum; j \u0026gt;= tt[i]; j--) { dp[j] = max(dp[j], dp[j - tt[i]] + cc[i]); } } ll ans = 0; for (ll ic = 0; ic \u0026lt;= tsum; ic++) { ans = max(dp[ic], ans); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1833/","summary":"题目大意 混合背包。每棵树都有美学值 $C_i$，共有三种：\n 一种只能看一遍。 一种最多看 $A_i$ 遍。 一种可以看无数遍。  分析 对于混合背包，我们可以对物品拆分，得到多个物品。\nll dp[1086], tt[100086], cc[100086]; int main() { int tsh = rr(), tsm = rr(), teh = rr(), tem = rr(); int tsum = (teh - tsh) * 60 + tem - tsm; int n = rr(); int tp = 1; for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(), c = rr(), p = rr(); if (p == 1) { tt[tp] = t, cc[tp] = c; tp++; } else { p = p !","title":"P1833 樱花"},{"content":"题目大意 初始有四种卡片，消耗后分别可以前进 $1$、$2$、$3$ 和 $4$ 格。棋盘上每个点都有个分数，求从第 $1$ 格到达第 $N$ 格途径分数的最大值。\n分析 设状态 $F[i, j, k, w]$ 为使用 $i$ 张前进 $1$、……、$w$ 张前进 $4$ 之后的状态，容易得到转移方程\n $$ F[i, j, k, w] = \\max\\left\\{ \\begin{matrix} dp[i - 1, j, k, w] \\\\ dp[i, j - 1, k, w] \\\\ dp[i, j, k - 1, w] \\\\ dp[i, j, k, w - 1] \\end{matrix}\\right\\} + a[i + 2j + 3k + 4w] $$ 处理一下边界情况，滚动数组即可。\nll dp[50][50][50], aa[400], tt[10]; int main() { ll n = rr(), m = rr(); for (ll i = 1; i \u0026lt;= n; i++) { aa[i] = rr(); } for (ll i = 1; i \u0026lt;= m; i++) { tt[rr()]++; } for (ll i = 0; i \u0026lt;= tt[1]; i++) { for (ll j = 0; j \u0026lt;= tt[2]; j++) { for (ll k = 0; k \u0026lt;= tt[3]; k++) { for (ll w = 0; w \u0026lt;= tt[4]; w++) { dp[j][k][w] = aa[i * 1 + j * 2 + k * 3 + w * 4 + 1] + max4( j == 0 ? 0 : dp[j - 1][k][w], k == 0 ? 0 : dp[j][k - 1][w], w == 0 ? 0 : dp[j][k][w - 1], dp[j][k][w]); } } } } printf(\u0026#34;%lld\\n\u0026#34;, dp[tt[2]][tt[3]][tt[4]]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1541/","summary":"题目大意 初始有四种卡片，消耗后分别可以前进 $1$、$2$、$3$ 和 $4$ 格。棋盘上每个点都有个分数，求从第 $1$ 格到达第 $N$ 格途径分数的最大值。\n分析 设状态 $F[i, j, k, w]$ 为使用 $i$ 张前进 $1$、……、$w$ 张前进 $4$ 之后的状态，容易得到转移方程\n $$ F[i, j, k, w] = \\max\\left\\{ \\begin{matrix} dp[i - 1, j, k, w] \\\\ dp[i, j - 1, k, w] \\\\ dp[i, j, k - 1, w] \\\\ dp[i, j, k, w - 1] \\end{matrix}\\right\\} + a[i + 2j + 3k + 4w] $$ 处理一下边界情况，滚动数组即可。","title":"P1541 乌龟棋"},{"content":"题目大意 在 $n \\times n$ 的格上，在每行中各有一条线段 $(i, l_i) \\to (i, r_i)$。\n你从 $(1,1)$ 出发，只能沿着格子直走，最终走到 $(n,n)$。要求沿途经过所有的线段，且所走路程长度尽量的短。\n分析 显然是一行一行的递推。维护两个数据，一个是走完该行后停留在左侧的，记作 ${\\rm DP}_l$，相应的停留在右侧的记作 ${\\rm DP}_r$。\n若停在左侧，可能从上一行的右侧走来，也可能是由左侧走来，故转移方程有\n $$ {\\rm DP}_l[i] = r_i - l_i + \\min\\{{\\rm DP}_l[i - 1] + |l_{i-1} - r_i|, {\\rm DP}_r[i - 1] + |r_{i - 1} - r_i|\\} $$ 右侧类似，故可以写出代码\nint main() { int n = rr(); ll past_l = 1, past_r = 1, dpl = 0, dpr = 0; for (ll i = 1; i \u0026lt;= n; i++) { ll l = rr(), r = rr(); ll tl = min(dpl + abs(past_l - r), dpr + abs(past_r - r)) + r - l; ll tr = min(dpl + abs(past_l - l), dpr + abs(past_r - l)) + r - l; dpl = tl, dpr = tr; past_l = l, past_r = r; } printf(\u0026#34;%lld\\n\u0026#34;, min(dpl + n - past_l, dpr + n - past_r) + n - 1); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p3842/","summary":"题目大意 在 $n \\times n$ 的格上，在每行中各有一条线段 $(i, l_i) \\to (i, r_i)$。\n你从 $(1,1)$ 出发，只能沿着格子直走，最终走到 $(n,n)$。要求沿途经过所有的线段，且所走路程长度尽量的短。\n分析 显然是一行一行的递推。维护两个数据，一个是走完该行后停留在左侧的，记作 ${\\rm DP}_l$，相应的停留在右侧的记作 ${\\rm DP}_r$。\n若停在左侧，可能从上一行的右侧走来，也可能是由左侧走来，故转移方程有\n $$ {\\rm DP}_l[i] = r_i - l_i + \\min\\{{\\rm DP}_l[i - 1] + |l_{i-1} - r_i|, {\\rm DP}_r[i - 1] + |r_{i - 1} - r_i|\\} $$ 右侧类似，故可以写出代码\nint main() { int n = rr(); ll past_l = 1, past_r = 1, dpl = 0, dpr = 0; for (ll i = 1; i \u0026lt;= n; i++) { ll l = rr(), r = rr(); ll tl = min(dpl + abs(past_l - r), dpr + abs(past_r - r)) + r - l; ll tr = min(dpl + abs(past_l - l), dpr + abs(past_r - l)) + r - l; dpl = tl, dpr = tr; past_l = l, past_r = r; } printf(\u0026#34;%lld\\n\u0026#34;, min(dpl + n - past_l, dpr + n - past_r) + n - 1); return 0; } ","title":"P3842 线段"},{"content":"题目大意 要从 $n$ 种花中挑出 $m$ 盆展览，其中第 $i$ 种花不得多于 $a_i$ 种。求有几种选法。\n分析 考虑动态规划，记状态 $dp[i,j]$ 为摆完前 $i$ 种花，共 $j$ 盆时的方案数。容易得到递推式\n $$ dp[i,j] = \\sum_{k = j - \\min(a_i, j)}^j dp[i-1,k] $$ 边界条件是 $dp[0,0] = 1$。可以用滚动数组、前缀和优化。\nconst ll mod = 1e6 + 7; ll dp[110], aa[110], sum[110]; int main() { ll n = rr(), m = rr(); sum[0] = dp[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) aa[i] = rr(); for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= m; j++) sum[j] = (sum[j - 1] + dp[j]) % mod; for (ll j = m; j \u0026gt;= 0; j--) { int t = j - 1 - min(aa[i], j); if (t \u0026gt; 0) dp[j] = (dp[j] + sum[j - 1] - sum[t]) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, (dp[m] + mod) % mod); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1077/","summary":"题目大意 要从 $n$ 种花中挑出 $m$ 盆展览，其中第 $i$ 种花不得多于 $a_i$ 种。求有几种选法。\n分析 考虑动态规划，记状态 $dp[i,j]$ 为摆完前 $i$ 种花，共 $j$ 盆时的方案数。容易得到递推式\n $$ dp[i,j] = \\sum_{k = j - \\min(a_i, j)}^j dp[i-1,k] $$ 边界条件是 $dp[0,0] = 1$。可以用滚动数组、前缀和优化。\nconst ll mod = 1e6 + 7; ll dp[110], aa[110], sum[110]; int main() { ll n = rr(), m = rr(); sum[0] = dp[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) aa[i] = rr(); for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= m; j++) sum[j] = (sum[j - 1] + dp[j]) % mod; for (ll j = m; j \u0026gt;= 0; j--) { int t = j - 1 - min(aa[i], j); if (t \u0026gt; 0) dp[j] = (dp[j] + sum[j - 1] - sum[t]) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, (dp[m] + mod) % mod); return 0; } ","title":"P1077 摆花"},{"content":"题目大意 可以合并两堆果子成一堆新果子，消耗两堆果子数目之和的体力。给定 $n$ 堆果子的数目 $a_i$，求体力耗费最小的方案。\n分析 很容易猜到贪心结论，不断选取两个最小的堆进行合并。\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(); q.push(t); } int sum = 0; while (q.size() \u0026gt;= 2) { int x = q.top(); q.pop(); int y = q.top(); q.pop(); sum += x + y; q.push(x + y); } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } 本质上是证明 Huffman 树的构造的正确性，有点复杂。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1090/","summary":"题目大意 可以合并两堆果子成一堆新果子，消耗两堆果子数目之和的体力。给定 $n$ 堆果子的数目 $a_i$，求体力耗费最小的方案。\n分析 很容易猜到贪心结论，不断选取两个最小的堆进行合并。\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(); q.push(t); } int sum = 0; while (q.size() \u0026gt;= 2) { int x = q.top(); q.pop(); int y = q.top(); q.pop(); sum += x + y; q.push(x + y); } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } 本质上是证明 Huffman 树的构造的正确性，有点复杂。","title":"P1090 合并果子"},{"content":"题目大意 给定数列，求第 $k$ 小的数。\n分析 模板题。考虑分治，随便选一个数 $x$，然后把比 $x$ 大的数移到右边，比 $x$ 小的数移到左边。因此得到了数 $x$ 的排位，若恰为第 $k$ 个则返回，否则根据大小在左右寻找。\n该算法是不稳定的，期望复杂度 $O(n)$，最坏复杂度 $O(n^2)$。\n实际上存在最坏复杂度为 $O(n)$ 的 BFPTR 算法，但因为其常数过大实现复杂而很少应用。\nll nn[5000010], k, n; ll quicksort(ll l, ll r) { ll i = l, j = r; ll x = nn[(l + r) / 2]; while (i \u0026lt;= j) { while (nn[j] \u0026gt; x) j--; while (nn[i] \u0026lt; x) i++; if (i \u0026lt;= j) { swap(nn[i], nn[j]); i++, j--; } } // l \u0026lt;= j \u0026lt;= i \u0026lt;=r  if (k \u0026lt;= j) return quicksort(l, j); else if (k \u0026gt;= i) return quicksort(i, r); else return nn[k + 1]; } int main() { n = rr(), k = rr(); for (ll i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;nn[i]); printf(\u0026#34;%lld\u0026#34;, quicksort(1, n)); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1923/","summary":"题目大意 给定数列，求第 $k$ 小的数。\n分析 模板题。考虑分治，随便选一个数 $x$，然后把比 $x$ 大的数移到右边，比 $x$ 小的数移到左边。因此得到了数 $x$ 的排位，若恰为第 $k$ 个则返回，否则根据大小在左右寻找。\n该算法是不稳定的，期望复杂度 $O(n)$，最坏复杂度 $O(n^2)$。\n实际上存在最坏复杂度为 $O(n)$ 的 BFPTR 算法，但因为其常数过大实现复杂而很少应用。\nll nn[5000010], k, n; ll quicksort(ll l, ll r) { ll i = l, j = r; ll x = nn[(l + r) / 2]; while (i \u0026lt;= j) { while (nn[j] \u0026gt; x) j--; while (nn[i] \u0026lt; x) i++; if (i \u0026lt;= j) { swap(nn[i], nn[j]); i++, j--; } } // l \u0026lt;= j \u0026lt;= i \u0026lt;=r  if (k \u0026lt;= j) return quicksort(l, j); else if (k \u0026gt;= i) return quicksort(i, r); else return nn[k + 1]; } int main() { n = rr(), k = rr(); for (ll i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;nn[i]); printf(\u0026#34;%lld\u0026#34;, quicksort(1, n)); return 0; } ","title":"P1923 求第 $k$ 小的数"},{"content":"题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。\n分析 我考虑用类似状态机的方式解析字符串。\n 当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$  写成 BNF 更直观一点\n\u0026lt;pwd\u0026gt; ::= \u0026lt;EMPTY\u0026gt; | {\u0026lt;ALPHA\u0026gt;} | \u0026lt;pwd\u0026gt; \u0026#34;[\u0026#34; \u0026lt;NUMBER\u0026gt; \u0026lt;pwd\u0026gt; \u0026#34;]\u0026#34; \u0026lt;pwd\u0026gt; string read() { string s = \u0026#34;\u0026#34;; char c; while (cin \u0026gt;\u0026gt; c) { if (c == \u0026#39;[\u0026#39;) { int n; cin \u0026gt;\u0026gt; n; string ts = read(); while (n--) s += ts; } else if (c == \u0026#39;]\u0026#39;) { return s; } else { s += c; } } return s; } int main() { cout \u0026lt;\u0026lt; read(); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1928/","summary":"题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。\n分析 我考虑用类似状态机的方式解析字符串。\n 当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$  写成 BNF 更直观一点\n\u0026lt;pwd\u0026gt; ::= \u0026lt;EMPTY\u0026gt; | {\u0026lt;ALPHA\u0026gt;} | \u0026lt;pwd\u0026gt; \u0026#34;[\u0026#34; \u0026lt;NUMBER\u0026gt; \u0026lt;pwd\u0026gt; \u0026#34;]\u0026#34; \u0026lt;pwd\u0026gt; string read() { string s = \u0026#34;\u0026#34;; char c; while (cin \u0026gt;\u0026gt; c) { if (c == \u0026#39;[\u0026#39;) { int n; cin \u0026gt;\u0026gt; n; string ts = read(); while (n--) s += ts; } else if (c == \u0026#39;]\u0026#39;) { return s; } else { s += c; } } return s; } int main() { cout \u0026lt;\u0026lt; read(); return 0; } ","title":"P1928 外星密码"},{"content":"题目大意 有 I 形和 L 形两种砖头，分别能覆盖 2 个单元和 3 个单元。求 $2 \\times n$ 的墙有多少不重复的覆盖方式，结果对 $10^4$ 取模。\n分析 其中 I 形砖块仅有横放和竖放两种。关键在于 L 形，两个 L 形之间可以用 I 形填充，这让情况变得复杂起来。\n对于 $F_n$ 的递推，我们可以想到\n 在 $F_{n-1}$ 后放一个 I 形砖块。 在 $F_{n-2}$ 后放两个横着的 I 形砖块。 对于更前面的递推，较为复杂。  两个 L 形砖块对齐，上下翻转也可以，即 $2 F_{n-3}$。 两个 L 形砖块可以对顶放，空缺恰用一个 I 填充，即 $2 F_{n-4}$。 类似 $2F_{n-3}$，中间可以再插入两个 I 形，即 $2 F_{n-5}$。 …… 直到 I 形和 L 形砖块恰好铺满墙壁，即 $2F_{0}$。    容易得到我们的递推式\n $$ F_n = F_{n-1} + F_{n-2} + 2 \\sum_{i=0}^{n-3} F_i $$ 利用错位相减法，不难化简得到\n $$ F_n = 2 F_{n-1} + F_{n-3} $$ 于是代码有\nint dp[1000000]; int main() { int n = rr(); dp[1] = 1, dp[2] = 2, dp[3] = 5; for (ll i = 4; i \u0026lt;= n; i++) dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 10000; printf(\u0026#34;%d\\n\u0026#34;, dp[n]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1990/","summary":"题目大意 有 I 形和 L 形两种砖头，分别能覆盖 2 个单元和 3 个单元。求 $2 \\times n$ 的墙有多少不重复的覆盖方式，结果对 $10^4$ 取模。\n分析 其中 I 形砖块仅有横放和竖放两种。关键在于 L 形，两个 L 形之间可以用 I 形填充，这让情况变得复杂起来。\n对于 $F_n$ 的递推，我们可以想到\n 在 $F_{n-1}$ 后放一个 I 形砖块。 在 $F_{n-2}$ 后放两个横着的 I 形砖块。 对于更前面的递推，较为复杂。  两个 L 形砖块对齐，上下翻转也可以，即 $2 F_{n-3}$。 两个 L 形砖块可以对顶放，空缺恰用一个 I 填充，即 $2 F_{n-4}$。 类似 $2F_{n-3}$，中间可以再插入两个 I 形，即 $2 F_{n-5}$。 …… 直到 I 形和 L 形砖块恰好铺满墙壁，即 $2F_{0}$。    容易得到我们的递推式","title":"P1990 覆盖墙壁"},{"content":"题目大意 给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$ ，求最耗体力的路径。\n分析 容易猜到贪心结论，是不断的在剩余石头中最大最小的来回跳。\n考虑证明结论，设 $h_i$ 是将要跳的序列，展开求和式\n $$ S = \\sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \\sum_{k=1}^nh_k^2 - 2\\sum_{k=1}^{n-1}h_kh_{k+1} $$ 注意到平方和为一个定值，重点在后半式。记 $H_k = h_{k+1}$，有\n $$ \\sum_{k=1}^{n-1}h_kH_k $$ 利用高中时学的排序不等式，有\n $$ \\text{反序和} \\leqslant \\text{乱序和} \\leqslant \\text{顺序和} $$ 于是有反序最小。双指针维护即可。\nll nn[310]; int main() { ll n = rr(); for (ll i = 1; i \u0026lt;= n; i++) nn[i] = rr(); sort(nn + 1, nn + n + 1); ll l = 0, r = n, sum = 0; while (l \u0026lt; r) { ll t1 = nn[l] - nn[r], t2 = nn[l + 1] - nn[r]; sum += t1 * t1 + t2 * t2; l++, r--; } printf(\u0026#34;%lld\\n\u0026#34;, sum); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p4995/","summary":"题目大意 给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$ ，求最耗体力的路径。\n分析 容易猜到贪心结论，是不断的在剩余石头中最大最小的来回跳。\n考虑证明结论，设 $h_i$ 是将要跳的序列，展开求和式\n $$ S = \\sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \\sum_{k=1}^nh_k^2 - 2\\sum_{k=1}^{n-1}h_kh_{k+1} $$ 注意到平方和为一个定值，重点在后半式。记 $H_k = h_{k+1}$，有\n $$ \\sum_{k=1}^{n-1}h_kH_k $$ 利用高中时学的排序不等式，有\n $$ \\text{反序和} \\leqslant \\text{乱序和} \\leqslant \\text{顺序和} $$ 于是有反序最小。双指针维护即可。\nll nn[310]; int main() { ll n = rr(); for (ll i = 1; i \u0026lt;= n; i++) nn[i] = rr(); sort(nn + 1, nn + n + 1); ll l = 0, r = n, sum = 0; while (l \u0026lt; r) { ll t1 = nn[l] - nn[r], t2 = nn[l + 1] - nn[r]; sum += t1 * t1 + t2 * t2; l++, r--; } printf(\u0026#34;%lld\\n\u0026#34;, sum); return 0; } ","title":"P4995 跳跳！"},{"content":"题目大意 在三维空间中，HKE 只能往上走，求攀爬总长。\n分析 对所有座标的 $z$ 分量排序即可。\nstruct POINT { double x, y, z; bool operator\u0026lt;(POINT p) { return z \u0026gt; p.z; } } nn[50010]; double dis(POINT \u0026amp;p1, POINT \u0026amp;p2) { double t1 = p1.x - p2.x, t2 = p1.y - p2.y, t3 = p1.z - p2.z; return sqrt(t1 * t1 + t2 * t2 + t3 * t3); } int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; nn[i].x \u0026gt;\u0026gt; nn[i].y \u0026gt;\u0026gt; nn[i].z; sort(nn + 1, nn + n + 1); double len = 0; for (ll i = 2; i \u0026lt;= n; i++) len += dis(nn[i], nn[i-1]); printf(\u0026#34;%.3lf\\n\u0026#34;, len); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p5143/","summary":"题目大意 在三维空间中，HKE 只能往上走，求攀爬总长。\n分析 对所有座标的 $z$ 分量排序即可。\nstruct POINT { double x, y, z; bool operator\u0026lt;(POINT p) { return z \u0026gt; p.z; } } nn[50010]; double dis(POINT \u0026amp;p1, POINT \u0026amp;p2) { double t1 = p1.x - p2.x, t2 = p1.y - p2.y, t3 = p1.z - p2.z; return sqrt(t1 * t1 + t2 * t2 + t3 * t3); } int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; nn[i].","title":"P5143 攀爬者"},{"content":"P1095 守望者的逃离 题目大意 守望者的可以在一秒逃出 $17 {\\rm m}$，或者消耗 $10$ 点魔法值闪现 $60 {\\rm m}$。原地休息时每秒回复 $4$ 点魔法值。\n守望者开始有 $M$ 点魔法，需要在 $T$ 秒内逃离距离 $S$。若能逃离则求最短逃离时间，否则求最远距离。\n分析 设 $s_1$为一直走路，$s_2$ 为一直闪现恢复。当 $s_2$ 快了就把 $s_1$ 更新为 $s_2$。\nint main() { int m = rr(), s = rr(), t = rr(); int time = t, s1 = 0, s2 = 0; while (time \u0026gt; 0 \u0026amp;\u0026amp; s1 \u0026lt; s) { s1 += 17; if (m \u0026gt;= 10) m -= 10, s2 += 60; else m += 4; s1 = max(s1, s2); time--; } if (s1 \u0026lt; s) printf(\u0026#34;No\\n%d\\n\u0026#34;, s1); else printf(\u0026#34;Yes\\n%d\\n\u0026#34;, t - time); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1095/","summary":"P1095 守望者的逃离 题目大意 守望者的可以在一秒逃出 $17 {\\rm m}$，或者消耗 $10$ 点魔法值闪现 $60 {\\rm m}$。原地休息时每秒回复 $4$ 点魔法值。\n守望者开始有 $M$ 点魔法，需要在 $T$ 秒内逃离距离 $S$。若能逃离则求最短逃离时间，否则求最远距离。\n分析 设 $s_1$为一直走路，$s_2$ 为一直闪现恢复。当 $s_2$ 快了就把 $s_1$ 更新为 $s_2$。\nint main() { int m = rr(), s = rr(), t = rr(); int time = t, s1 = 0, s2 = 0; while (time \u0026gt; 0 \u0026amp;\u0026amp; s1 \u0026lt; s) { s1 += 17; if (m \u0026gt;= 10) m -= 10, s2 += 60; else m += 4; s1 = max(s1, s2); time--; } if (s1 \u0026lt; s) printf(\u0026#34;No\\n%d\\n\u0026#34;, s1); else printf(\u0026#34;Yes\\n%d\\n\u0026#34;, t - time); return 0; } ","title":"P1095 守望者的逃离"},{"content":"题目大意 赢 11 分并且压对手两分以上则一局结束，否则要追分至压对手两分。\n给定 $\\texttt{WL}$ 序列，分别求 11 分制和 21 分制下每场比分，$\\texttt{E}$ 是结束符。\n分析 这是一道比较烦的模拟题，很绕。\nchar ch[62510]; int solve(int win, int len) { int w = 0, l = 0; for (ll i = 0; i \u0026lt; len; i++) { w += ch[i] == \u0026#39;W\u0026#39;; l += ch[i] == \u0026#39;L\u0026#39;; if (max(w, l) \u0026gt;= win \u0026amp;\u0026amp; abs(w - l) \u0026gt;= 2) { printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); w = l = 0; } } printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); } int main() { char ccc; int len = 0; while (scanf(\u0026#34;%c\u0026#34;, \u0026amp;ccc) != EOF) { if (ccc != \u0026#39;E\u0026#39;) ch[len++] = ccc; else break; } solve(11, len); LN; solve(21, len); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1042/","summary":"题目大意 赢 11 分并且压对手两分以上则一局结束，否则要追分至压对手两分。\n给定 $\\texttt{WL}$ 序列，分别求 11 分制和 21 分制下每场比分，$\\texttt{E}$ 是结束符。\n分析 这是一道比较烦的模拟题，很绕。\nchar ch[62510]; int solve(int win, int len) { int w = 0, l = 0; for (ll i = 0; i \u0026lt; len; i++) { w += ch[i] == \u0026#39;W\u0026#39;; l += ch[i] == \u0026#39;L\u0026#39;; if (max(w, l) \u0026gt;= win \u0026amp;\u0026amp; abs(w - l) \u0026gt;= 2) { printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); w = l = 0; } } printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); } int main() { char ccc; int len = 0; while (scanf(\u0026#34;%c\u0026#34;, \u0026amp;ccc) !","title":"P1042 乒乓球"},{"content":"题目大意 凸 $n$ 边形中，任意三条对角线不共点，求所有对角线交点的个数。\n分析 注意到一个交点对应凸多边形 $4$ 个定点，于是等价于 $n$ 个点任选 $4$ 个点的选法种数，即\n $$ \\binom{n}{4} = \\frac{n(n-1)(n-2)(n-3)}{24} $$ 注意爆 long long，需要写成 n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4。\nint main() { unsigned long long n; scanf(\u0026#34;%llu\u0026#34;, \u0026amp;n); n = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4; printf(\u0026#34;%llu\u0026#34;, n); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p2181/","summary":"题目大意 凸 $n$ 边形中，任意三条对角线不共点，求所有对角线交点的个数。\n分析 注意到一个交点对应凸多边形 $4$ 个定点，于是等价于 $n$ 个点任选 $4$ 个点的选法种数，即\n $$ \\binom{n}{4} = \\frac{n(n-1)(n-2)(n-3)}{24} $$ 注意爆 long long，需要写成 n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4。\nint main() { unsigned long long n; scanf(\u0026#34;%llu\u0026#34;, \u0026amp;n); n = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4; printf(\u0026#34;%llu\u0026#34;, n); return 0; } ","title":"P2181 对角线"},{"content":"题目大意 海里每一个位置都有一个深度，而且水里随着时间有锯齿状周期为 $2k$ 的潮汐。\n当潮汐与深度之和大于给定值 $l$ 时 Koa 会溺水，游泳、海岸、岛上永远是安全的。\n在任意时间 Koa 可以选择游到 $x+1$ 或停留在 $x$，试问 Koa 是否能够安全的从海岸 $0$ 到达岛上 $n+1$。\n分析 开始的想法是随着时间 DP，更好的解法是贪心。\n若一个位置在水位最高时仍不会溺水，则称这个位置是安全的，并且可以任意选择出发时机。\n即安全位置之间是相互独立的，我们只需判断可达性，尽量到达每一个安全位置。若之后 $2k$ 个位置没有安全位置，必死。\nKoa 的最优决策是在刚退潮时出发，如果能走就尽量往前走，不能走就等，等到涨潮就说明不存在通过方法。\nint main() { int ttt = rr(); while (ttt--) { int n = rr(), k = rr(), l = rr(); int flag = 0; int last = k; for (ll i = 1; i \u0026lt;= n; i++) { int d = rr(); flag += l \u0026lt; d; if (l - d \u0026gt;= k) last = k; else last = min(last - 1, l - d); flag += abs(last) \u0026gt; l - d; } if (flag) printf(\u0026#34;No\\n\u0026#34;); else printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/cf1384b2/","summary":"题目大意 海里每一个位置都有一个深度，而且水里随着时间有锯齿状周期为 $2k$ 的潮汐。\n当潮汐与深度之和大于给定值 $l$ 时 Koa 会溺水，游泳、海岸、岛上永远是安全的。\n在任意时间 Koa 可以选择游到 $x+1$ 或停留在 $x$，试问 Koa 是否能够安全的从海岸 $0$ 到达岛上 $n+1$。\n分析 开始的想法是随着时间 DP，更好的解法是贪心。\n若一个位置在水位最高时仍不会溺水，则称这个位置是安全的，并且可以任意选择出发时机。\n即安全位置之间是相互独立的，我们只需判断可达性，尽量到达每一个安全位置。若之后 $2k$ 个位置没有安全位置，必死。\nKoa 的最优决策是在刚退潮时出发，如果能走就尽量往前走，不能走就等，等到涨潮就说明不存在通过方法。\nint main() { int ttt = rr(); while (ttt--) { int n = rr(), k = rr(), l = rr(); int flag = 0; int last = k; for (ll i = 1; i \u0026lt;= n; i++) { int d = rr(); flag += l \u0026lt; d; if (l - d \u0026gt;= k) last = k; else last = min(last - 1, l - d); flag += abs(last) \u0026gt; l - d; } if (flag) printf(\u0026#34;No\\n\u0026#34;); else printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } ","title":"CF1384B2 Koa and the Beach"},{"content":"题目大意 在 $n \\times n$ 的方格（$n \\leqslant 9$）中存在一些正整数，经过格子时获得格子上的数，但只能获得一次。\n某人只能向右或向下走，从格子的左上角走到到右下角，共走两次，求最大能取得的数字。\n分析 考虑把先走后走转化为两个人同时走，只需要处理遇到两次的值即可。\n考虑四维 DP，用 $dp[x_1,y_1,x_2,y_2]$ 表示第一个人走到 $(x_1,y_1)$ 和第二个人走到 $(x_2,y_2)$。\n再考虑转移，每一个位置仅可能从其左面或上面转移来，于是可以写出（$x_1 \\ne y_1$ 或 $x_2 \\ne y_2$ 时）\n $$ dp[x_1,y_1,x_2,y_2] = \\max\\left\\{ \\begin{matrix} dp[x_1-1,y_1,x_2-1,y_2] \\\\ dp[x_1,y_1-1,x_2-1,y_2] \\\\ dp[x_1-1,y_1,x_2,y_2-1] \\\\ dp[x_1,y_1-1,x_2,y_2-1] \\end{matrix}\\right\\} + a[x_1,y_1] + a[x_2,y_2] $$ 当 $x_1=y_1,x_2=y_2$ 时，只加一次即可。到这里 $O(n^4)$ 其实已经可以过题了，但还可以优化。\n注意到一些状态是不可达的，因为 $x_1+y_1 = x_2+y_2$，因此存在 $O(n^3)$ 的 DP。\n考虑当前已走长度 $h=x_1+y_1=x_2+y_2$，于是可以把两个人的座标表示为 $(x_1,h-x_1)$ 和 $(x_2,h-x_2)$。\n于是记状态为 $dp[h,x_1,x_2]$，当 $x_1 \\ne x_2$ 时有\n $$ dp[h,x_1,x_2] = \\max\\left\\{ \\begin{matrix} dp[h-1,x_1,x_2] \\\\ dp[h-1,x_1,x_2-1] \\\\ dp[h-1,x_1-1,x_2] \\\\ dp[h-1,x_1-1,x_2-1] \\end{matrix}\\right\\} + a[x_1,h-x_1] + a[x_2,h-x_2] $$ 再注意到可以使用滚动数组，因此有\nll mtx[10][10], dp[10][10]; int main() { ll N = rr(); while (true) { ll a = rr(), b = rr(), c = rr(); if (a + b + c == 0) break; mtx[a][b] = c; } for (ll ss = 2; ss \u0026lt;= 2 * N; ss++) { ll max_x1 = min(N, ss - 1), min_x1 = max(1ll, ss - N); for (ll x1 = max_x1; x1 \u0026gt;= min_x1; x1--) { ll max_x2 = min(N, ss - 1), min_x2 = max(1ll, ss - N); for (ll x2 = max_x2; x2 \u0026gt;= min_x2; x2--) { dp[x1][x2] = max4( dp[x1 - 1][x2 - 1], dp[x1][x2 - 1], dp[x1 - 1][x2], dp[x1][x2] ); dp[x1][x2] += mtx[x1][ss - x1] + mtx[x2][ss - x2]; if (x1 == x2) dp[x1][x2] -= mtx[x1][ss - x1]; } } } printf(\u0026#34;%lld\\n\u0026#34;, dp[N][N]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1004/","summary":"题目大意 在 $n \\times n$ 的方格（$n \\leqslant 9$）中存在一些正整数，经过格子时获得格子上的数，但只能获得一次。\n某人只能向右或向下走，从格子的左上角走到到右下角，共走两次，求最大能取得的数字。\n分析 考虑把先走后走转化为两个人同时走，只需要处理遇到两次的值即可。\n考虑四维 DP，用 $dp[x_1,y_1,x_2,y_2]$ 表示第一个人走到 $(x_1,y_1)$ 和第二个人走到 $(x_2,y_2)$。\n再考虑转移，每一个位置仅可能从其左面或上面转移来，于是可以写出（$x_1 \\ne y_1$ 或 $x_2 \\ne y_2$ 时）\n $$ dp[x_1,y_1,x_2,y_2] = \\max\\left\\{ \\begin{matrix} dp[x_1-1,y_1,x_2-1,y_2] \\\\ dp[x_1,y_1-1,x_2-1,y_2] \\\\ dp[x_1-1,y_1,x_2,y_2-1] \\\\ dp[x_1,y_1-1,x_2,y_2-1] \\end{matrix}\\right\\} + a[x_1,y_1] + a[x_2,y_2] $$ 当 $x_1=y_1,x_2=y_2$ 时，只加一次即可。到这里 $O(n^4)$ 其实已经可以过题了，但还可以优化。\n注意到一些状态是不可达的，因为 $x_1+y_1 = x_2+y_2$，因此存在 $O(n^3)$ 的 DP。\n考虑当前已走长度 $h=x_1+y_1=x_2+y_2$，于是可以把两个人的座标表示为 $(x_1,h-x_1)$ 和 $(x_2,h-x_2)$。\n于是记状态为 $dp[h,x_1,x_2]$，当 $x_1 \\ne x_2$ 时有\n $$ dp[h,x_1,x_2] = \\max\\left\\{ \\begin{matrix} dp[h-1,x_1,x_2] \\\\ dp[h-1,x_1,x_2-1] \\\\ dp[h-1,x_1-1,x_2] \\\\ dp[h-1,x_1-1,x_2-1] \\end{matrix}\\right\\} + a[x_1,h-x_1] + a[x_2,h-x_2] $$ 再注意到可以使用滚动数组，因此有","title":"P1004 方格取数"},{"content":"","permalink":"https://rogeryoungh.github.io/code-of-acm/post/log/jump/","summary":"","title":"OJ 题目跳转"},{"content":"","permalink":"https://rogeryoungh.github.io/code-of-acm/post/log/template-gen/","summary":"","title":"模板生成"}]