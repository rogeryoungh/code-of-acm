[{"content":"过于简单的题不记录。\n洛谷：更新至：2021.08.25(\u0026ndash;.\u0026ndash;)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2021 年 08 月 P4721 分治 FFT\nP4238 多项式乘法逆\nP4245 任意模数多项式乘法\nP4213 杜教筛\nP5325 Min_25筛\nLOJ6053 简单的函数\n2021 年 07 月 P4173 残缺的字符串\nHDU多校2021-2\n HDU6961 I love cube HDU6965 I love string HDU6971 I love max and multiply HUD6972 I love 114514  P3803 多项式乘法（FFT）\nP1762 偶数 ==DONE==\n2021 年 06 月 P3805 manacher 算法\nP5104 红包发红包\nP3802 小魔女帕琪\n2021 年 05 月 P1886 滑动窗口 / 单调队列\nP4781 拉格朗日插值\nP2568 GCD\nP4139 上帝与集合的正确用法\nP2303 Longge 的问题\nP2257 YY 的 GCD ==DONE==\nP3455 ZAP-Queries\nP2350 外星人 ==DONE==\nP5091 扩展欧拉定理\nP2303 Longge 的问题 ==DONE==\nP2158 仪仗队\nP2613 有理数取余\nP1082 同余方程\nP2522 Problem B ==DONE==\n2021 年 04 月 P2261 余数求和 ==DONE==\nP3372 线段树 1\nP5410 扩展 KMP（Z 函数）\nP4838 P哥破解密码\nP1314 聪明的质检员 ==DONE==\nP1902 刺杀大使\nP1706 全排列问题\nP1495 中国剩余定理(CRT)/曹冲养猪\n2021 年 03 月 P2602 数字计数\nP1908 逆序对\nP2678 跳石头 ==DONE==\nP1177 快速排序\nP3368 树状数组 2\nP3374 树状数组 1\nP3375 KMP 字符串匹配\nP3370 字符串哈希\nP1014 Cantor 表\nP1019 单词接龙 ==DONE==\nP1162 填涂颜色\nP3865 ST 表\nP3382 三分法\n2021 年 02 月 P1216 数字三角形\n2021 年 01 月 P3378 堆\n2021 年 02 月 P1216 数字三角形\n2021 年 01 月 P3378 堆\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/log/log2021/","summary":"过于简单的题不记录。\n洛谷：更新至：2021.08.25(\u0026ndash;.\u0026ndash;)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2021 年 08 月 P4721 分治 FFT\nP4238 多项式乘法逆\nP4245 任意模数多项式乘法\nP4213 杜教筛\nP5325 Min_25筛\nLOJ6053 简单的函数\n2021 年 07 月 P4173 残缺的字符串\nHDU多校2021-2\n HDU6961 I love cube HDU6965 I love string HDU6971 I love max and multiply HUD6972 I love 114514  P3803 多项式乘法（FFT）\nP1762 偶数 ==DONE==\n2021 年 06 月 P3805 manacher 算法\nP5104 红包发红包\nP3802 小魔女帕琪\n2021 年 05 月 P1886 滑动窗口 / 单调队列","title":"2021 年刷题日志"},{"content":"题目大意 给定积性函数 $f(p^c) = p \\oplus c$。对 $1000000007$ 取模求前缀和。\n分析 Min25 板子题。\nconst ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n \u0026lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi \u0026lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.01); m = cnt = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { w[++m] = r = n / (n / l); ll mr = mo(r); s[m] = mr * (mr + 1) % mod * inv2 % mod - 1; c[m] = mr - 1; } for (ll p = 2; p \u0026lt;= sqrt_n; p++) { if (c[p] != c[p - 1]) { prime[++cnt] = p; for (ll j = m; w[j] \u0026gt;= p * p; j--) { s[j] = mo(s[j] - p * mo(s[id(w[j] / p)] - s[p - 1])); c[j] = mo(c[j] - (c[id(w[j] / p)] - c[p - 1])); } } } for (int i = 2; i \u0026lt;= m; i++) s[i] = mo(s[i] - c[i] + 2); printf(\u0026#34;%lld\u0026#34;, F(n, 0) + 1); } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-08/loj6053/","summary":"题目大意 给定积性函数 $f(p^c) = p \\oplus c$。对 $1000000007$ 取模求前缀和。\n分析 Min25 板子题。\nconst ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n \u0026lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi \u0026lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.","title":"LOJ6053 简单的函数"},{"content":"Todo\nchar a[MAXN], b[MAXN]; ll ts[MAXN], tb[MAXN]; Comp B[MAXN], S[MAXN]; Comp ANS[MAXN]; int stk[MAXN], cnt = 0; int main() { ll m = rr(), n = rr(); int lim = 1, lim_2; while (lim \u0026lt;= n + m) lim \u0026lt;\u0026lt;= 1; lim_2 = lim \u0026gt;\u0026gt; 1; for (int i = 0; i \u0026lt; lim; ++i) { rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) * lim_2); } scanf(\u0026#34;%s\u0026#34;, a); // 模式串  scanf(\u0026#34;%s\u0026#34;, b); // 文本串  _fora (i, 1, m) { ll j = m - i; ll t = a[j] - \u0026#39;a\u0026#39; + 1; if (a[j] == \u0026#39;*\u0026#39;) t = 0; ts[i] = t; } _fora (i, 0, n - 1) { ll t = b[i] - \u0026#39;a\u0026#39; + 1; if (b[i] == \u0026#39;*\u0026#39;) t = 0; tb[i] = t; } _fora (i, 0, lim - 1) { S[i] = Comp(ts[i], 0); B[i] = Comp(tb[i] * tb[i] * tb[i], 0); } FFT(S, lim, 1); FFT(B, lim, 1); _fora (i, 0, lim - 1) ANS[i] = S[i] * B[i]; _fora (i, 0, lim - 1) { S[i] = Comp(ts[i] * ts[i] * ts[i], 0); B[i] = Comp(tb[i], 0); } FFT(S, lim, 1); FFT(B, lim, 1); _fora (i, 0, lim - 1) ANS[i] = ANS[i] + S[i] * B[i]; _fora (i, 0, lim - 1) { S[i] = Comp(ts[i] * ts[i], 0); B[i] = Comp(tb[i] * tb[i], 0); } FFT(S, lim, 1); FFT(B, lim, 1); _fora (i, 0, lim - 1) ANS[i] = ANS[i] - S[i] * B[i] * Comp(2, 0); FFT(ANS, lim, -1); _fora (i, m, n) { if (fabs(ANS[i].x) \u0026lt; 1) stk[++cnt] = i - m + 1; } printf(\u0026#34;%d\\n\u0026#34;, cnt); _fora (i, 1, cnt) printf(\u0026#34;%d \u0026#34;, stk[i]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/p4173/","summary":"Todo\nchar a[MAXN], b[MAXN]; ll ts[MAXN], tb[MAXN]; Comp B[MAXN], S[MAXN]; Comp ANS[MAXN]; int stk[MAXN], cnt = 0; int main() { ll m = rr(), n = rr(); int lim = 1, lim_2; while (lim \u0026lt;= n + m) lim \u0026lt;\u0026lt;= 1; lim_2 = lim \u0026gt;\u0026gt; 1; for (int i = 0; i \u0026lt; lim; ++i) { rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) * lim_2); } scanf(\u0026#34;%s\u0026#34;, a); // 模式串  scanf(\u0026#34;%s\u0026#34;, b); // 文本串  _fora (i, 1, m) { ll j = m - i; ll t = a[j] - \u0026#39;a\u0026#39; + 1; if (a[j] == \u0026#39;*\u0026#39;) t = 0; ts[i] = t; } _fora (i, 0, n - 1) { ll t = b[i] - \u0026#39;a\u0026#39; + 1; if (b[i] == \u0026#39;*\u0026#39;) t = 0; tb[i] = t; } _fora (i, 0, lim - 1) { S[i] = Comp(ts[i], 0); B[i] = Comp(tb[i] * tb[i] * tb[i], 0); } FFT(S, lim, 1); FFT(B, lim, 1); _fora (i, 0, lim - 1) ANS[i] = S[i] * B[i]; _fora (i, 0, lim - 1) { S[i] = Comp(ts[i] * ts[i] * ts[i], 0); B[i] = Comp(tb[i], 0); } FFT(S, lim, 1); FFT(B, lim, 1); _fora (i, 0, lim - 1) ANS[i] = ANS[i] + S[i] * B[i]; _fora (i, 0, lim - 1) { S[i] = Comp(ts[i] * ts[i], 0); B[i] = Comp(tb[i] * tb[i], 0); } FFT(S, lim, 1); FFT(B, lim, 1); _fora (i, 0, lim - 1) ANS[i] = ANS[i] - S[i] * B[i] * Comp(2, 0); FFT(ANS, lim, -1); _fora (i, m, n) { if (fabs(ANS[i].","title":"P4173 残缺的字符串"},{"content":"题目大意 求杨辉三角形前 $n$ 行的偶数个数，对 $1000003$ 取模。\n分析 对杨辉三角奇数打表。\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 于是递推公式\n $$ f(2^t+n) = f(2^t) + 2f(n) $$ 就是显然的了，那么偶数即是全部的减去奇数个数。\nconst ll MOD = 1000003; ll nn[10086]; int main() { ll n = rr(); nn[1] = 1; _fora (i, 2, 100) nn[i] = nn[i - 1] * 3 % MOD; ll t = 1; ll ans = 0; _fora (i, 1, 100) { if ((t \u0026amp; n) \u0026gt; 0) ans = (ans * 2 + nn[i]) % MOD; t = t \u0026lt;\u0026lt; 1; if (t \u0026gt; n) break; } n = n % MOD; ll sum = n * (n + 1) % MOD; sum = sum * inv(2) % MOD; printf(\u0026#34;%lld\\n\u0026#34;, (sum - ans + MOD) % MOD); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/p1762/","summary":"题目大意 求杨辉三角形前 $n$ 行的偶数个数，对 $1000003$ 取模。\n分析 对杨辉三角奇数打表。\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 于是递推公式","title":"P1762 偶数"},{"content":"题目大意 即求\n $$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] $$ 分析 先转化一下\n $$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] = \\sum_{p}\\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) = p] $$ 在 P2522 中得到\n $$ \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tk} \\right\\rfloor \\left\\lfloor \\frac{y}{tk} \\right\\rfloor $$ 代入有\n $$ \\sum_{p} \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tp} \\right\\rfloor \\left\\lfloor \\frac{y}{tp} \\right\\rfloor $$ 令 $T = tp$，$T$ 的上界应还是 $\\min(x,y)$，代入有\n $$ \\sum_{T=1}^{\\min(x,y)} \\left\\lfloor \\frac{x}{T} \\right\\rfloor \\left\\lfloor \\frac{y}{T} \\right\\rfloor \\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right) $$ 后面那个在 Euler 筛后再求和一下，是可以预处理的。\nconst ll MN = 1e7 + 100; int mu[MN], f[MN], dp[MN]; bool notp[MN]; int prime[MN/10], cnt; void sieve(int n) { mu[1] = 1; _fora (i, 2, n) { if (!notp[i]) prime[++cnt] = i, mu[i] = -1; int t = n / i; _fora (j, 1, cnt) { if (prime[j] \u0026gt; t) break; notp[i * prime[j]] = true; if (i % prime[j] == 0) { mu[i * prime[j]] = 0; break; } mu[i * prime[j]] = - mu[i]; } } _fora (i, 1, n) { _fora (j, 1, cnt) { ll t = i * prime[j]; if(t \u0026gt; n) break; dp[t] += mu[i]; } } _fora (i, 1, n) f[i] = f[i - 1] + dp[i]; } 此时 $dp(T)$ 中存的是 $\\displaystyle\\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right)$，$f_i$ 是其前缀和。\n之后整数分块即可\nll calc(ll a, ll b) { ll mab = min(a, b); ll sum = 0; for (ll l = 1, r; l \u0026lt;= mab; l = r + 1) { r = min(a / (a / l), b / (b / l)); sum += (f[r] - f[l - 1]) * (a / l) * (b / l); } return sum; } int main() { ll ttt = rr(); sieve(MN - 10); _fora (i, 1, ttt) { ll a = rr(), b = rr(); printf(\u0026#34;%lld\\n\u0026#34;, calc(a,b)); } return 0; } 相似题目 P2568 GCD 即 $M = N = n$ 的特殊情况，可以再优化。即求\n $$ \\sum_{i=1}^n \\sum_{j=1}^n [\\gcd(i,j) \\in \\mathbb{P}] $$ 化简有\n $$ \\begin{aligned} \\sum_{p} \\sum_{i=1}^n \\sum_{j=1}^n [\\gcd(i,j) = p] \u0026= \\sum_{p} \\sum_{i=1}^{\\lfloor n/p\\rfloor} \\sum_{j=1}^{\\lfloor n/p\\rfloor} [\\gcd(i,j) = 1]\\\\\\\\ \u0026= \\sum_{p} \\left(2\\sum_{j=1}^{\\lfloor n/p\\rfloor} \\sum_{j=1}^{i} [\\gcd(i,j) = p] - 1\\right)\\\\\\\\ \u0026= \\sum_{p}\\left( 2\\sum_{i=1}^{\\lfloor n/p \\rfloor} \\varphi(i) - 1 \\right) \\end{aligned} $$ 预处理出 $\\varphi(i)$ 的前缀和后，对每个素数筛一遍即可。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2257/","summary":"题目大意 即求\n $$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] $$ 分析 先转化一下\n $$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] = \\sum_{p}\\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) = p] $$ 在 P2522 中得到\n $$ \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tk} \\right\\rfloor \\left\\lfloor \\frac{y}{tk} \\right\\rfloor $$ 代入有\n $$ \\sum_{p} \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tp} \\right\\rfloor \\left\\lfloor \\frac{y}{tp} \\right\\rfloor $$ 令 $T = tp$，$T$ 的上界应还是 $\\min(x,y)$，代入有\n $$ \\sum_{T=1}^{\\min(x,y)} \\left\\lfloor \\frac{x}{T} \\right\\rfloor \\left\\lfloor \\frac{y}{T} \\right\\rfloor \\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right) $$ 后面那个在 Euler 筛后再求和一下，是可以预处理的。","title":"P2257 YY 的 GCD"},{"content":"题目大意 设\n $$ \\varphi_{x+1}(m) = \\varphi(\\varphi_x(m)) $$ 求最小的 $x$ 使得 $\\varphi_x(m) = 1$。\n其中 $\\varphi(m)$ 是欧拉函数。\n分析 注意到仅有 $\\varphi(1) = \\varphi(2) = 1$，再有公式\n $$ \\varphi\\left(\\prod_{i=1}^mp_i^{q_i}\\right) = \\prod_{i=1}^m(p_i-1)p_i^{q_i-1} $$ 因此从唯一分解形式的角度来看，迭代一次消去了一个 $2$，也生成了一些 $2$。\n考虑设 $f(n)$ 为 $\\varphi(n)$ 中因子 $2$ 的个数。\n设 $\\gcd(a,b) = 1$，可以证明 $f(ab) = f(a) f(b)$。同时 $f(p) = f(p-1)$。\n这说明 $f(x)$ 是一个积性函数，可以用 Euler 筛递推。\nconst ll MN = 1e5 + 10; bool notp[1000001]; int prime[200001], cnt; int phi[1000001]; void sieve(int n) { phi[1] = 1; _fora (i, 2, n) { if (!notp[i]) { prime[++cnt] = i; phi[i] = phi[i - 1]; } int t = n / i; _fora (j, 1, cnt) { if (prime[j] \u0026gt; t) break; int ti = i * prime[j]; notp[ti] = true; phi[ti] = phi[i] + phi[prime[j]]; if (i % prime[j] == 0) break; } } } 然后在 main 中输出即可。注意若没有质因子 $2$，则答案需要加 $1$。\nint main() { sieve(MN - 10); ll ttt = rr(); _fora (iii, 1, ttt) { ll m = rr(); ll ans = 1; _fora (i, 1, m) { ll p = rr(), q = rr(); if (p == 2) ans--; ans += phi[p] * q; } printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2350/","summary":"题目大意 设\n $$ \\varphi_{x+1}(m) = \\varphi(\\varphi_x(m)) $$ 求最小的 $x$ 使得 $\\varphi_x(m) = 1$。\n其中 $\\varphi(m)$ 是欧拉函数。\n分析 注意到仅有 $\\varphi(1) = \\varphi(2) = 1$，再有公式\n $$ \\varphi\\left(\\prod_{i=1}^mp_i^{q_i}\\right) = \\prod_{i=1}^m(p_i-1)p_i^{q_i-1} $$ 因此从唯一分解形式的角度来看，迭代一次消去了一个 $2$，也生成了一些 $2$。\n考虑设 $f(n)$ 为 $\\varphi(n)$ 中因子 $2$ 的个数。\n设 $\\gcd(a,b) = 1$，可以证明 $f(ab) = f(a) f(b)$。同时 $f(p) = f(p-1)$。\n这说明 $f(x)$ 是一个积性函数，可以用 Euler 筛递推。\nconst ll MN = 1e5 + 10; bool notp[1000001]; int prime[200001], cnt; int phi[1000001]; void sieve(int n) { phi[1] = 1; _fora (i, 2, n) { if (!","title":"P2350 外星人"},{"content":"Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。\n若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。\n求一年有几对。\n $$ xd+y \\equiv yd+x \\pmod w $$ 即\n $$ (x-y)(d-1) \\equiv 0 \\Rightarrow (x-y)(d-1) \\in w\\mathbb{Z} $$ 于是有\n $$ y-x = \\frac{wk}{\\gcd(w,d-1)} $$ 又 $x \u0026lt; y \\leqslant \\min(m,d)$​，\nint main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/cf1389e/","summary":"Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。\n若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。\n求一年有几对。\n $$ xd+y \\equiv yd+x \\pmod w $$ 即\n $$ (x-y)(d-1) \\equiv 0 \\Rightarrow (x-y)(d-1) \\in w\\mathbb{Z} $$ 于是有\n $$ y-x = \\frac{wk}{\\gcd(w,d-1)} $$ 又 $x \u0026lt; y \\leqslant \\min(m,d)$​，\nint main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","title":"CF1389E Calendar Ambiguity"},{"content":"题目大意 即求\n $$ \\sum_{i=1}^n \\gcd(i,n) $$ 分析 联想到\n $$ \\varphi(n) = \\sum_{i=1}^n [\\gcd(i,n) = 1] $$ 尝试凑这个形式\n $$ \\begin{aligned} \\sum_{i=1}^n \\gcd(i,n) \u0026= \\sum_{d \\mid n} d \\sum_{i=1}^n [\\gcd(i,n) = d] \\\\ \u0026= \\sum_{d \\mid n} d \\sum_{i=1}^{n/d} [\\gcd(i,n/d) = 1] \\\\ \u0026= \\sum_{d \\mid n} d \\varphi(n/d) \\end{aligned} $$ 这里其实已经可以过题了，但还可以再瞎搞一下，令\n $$ nf(n) = \\sum_{d \\mid n} d \\varphi(n/d) = n\\sum_{d \\mid n} \\frac{\\varphi(d)}{d} $$ 尝试证明 $f(n)$ 是一个积性函数。设 $\\gcd(a,b) = 1$，有\n $$ \\begin{aligned} f(a)f(b) \u0026= \\left(\\sum_{d_1 \\mid a} \\frac{\\varphi(d_1)}{d_1}\\right) \\left(\\sum_{d_2 \\mid b} \\frac{\\varphi(d_2)}{d_2}\\right)\\\\ \u0026= \\sum_{d_1 \\mid a} \\sum_{d_2 \\mid b} \\frac{\\varphi(d_1)}{d_1} \\frac{\\varphi(d_2)}{d_2}\\\\ \u0026= \\sum_{d_1 \\mid a} \\sum_{d_2 \\mid b} \\frac{\\varphi(d_1d_2)}{d_1d_2}\\\\ \u0026= f(ab) \\end{aligned} $$ 再来推一下素数，注意 $1 \\mid p^k$，有\n $$ f(p^k) = \\sum_{d \\mid p^k} \\frac{\\varphi(d)}{d} = \\sum_{i=0}^k \\frac{\\varphi(p^i)}{p^i} = k\\left(1 - \\frac{1}{p}\\right) + 1 $$ 类似于 $\\varphi(m)$ 唯一分解形式，我们还有\n $$ f(n) = \\prod_{i=1}^sf(p_i^{k_i}) = \\prod_{i=1}^s \\frac{k_ip_i - k_i + p_i}{p_i} $$ 于是答案即为 $nf(n)$，复杂度 $O(\\sqrt{n})$。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2303/","summary":"题目大意 即求\n $$ \\sum_{i=1}^n \\gcd(i,n) $$ 分析 联想到\n $$ \\varphi(n) = \\sum_{i=1}^n [\\gcd(i,n) = 1] $$ 尝试凑这个形式\n $$ \\begin{aligned} \\sum_{i=1}^n \\gcd(i,n) \u0026= \\sum_{d \\mid n} d \\sum_{i=1}^n [\\gcd(i,n) = d] \\\\ \u0026= \\sum_{d \\mid n} d \\sum_{i=1}^{n/d} [\\gcd(i,n/d) = 1] \\\\ \u0026= \\sum_{d \\mid n} d \\varphi(n/d) \\end{aligned} $$ 这里其实已经可以过题了，但还可以再瞎搞一下，令\n $$ nf(n) = \\sum_{d \\mid n} d \\varphi(n/d) = n\\sum_{d \\mid n} \\frac{\\varphi(d)}{d} $$ 尝试证明 $f(n)$ 是一个积性函数。设 $\\gcd(a,b) = 1$，有","title":"P2303 Longge 的问题"},{"content":"题目大意 给定 $g[1], \\cdots, g[m]$，求序列 $f$。\n $$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$ 分析 不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程\n $$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$ 这个形式看似卷积，但实际上它缺了一项。对 $n \u0026gt; 0$ 凑卷积\n $$ f [n] (h [0] + 1) = \\sum_{j = 0}^n f [n - j] h [j] = (f \\ast h) [n] $$ 又 $f [0] = 1$，有\n $$ f \\ast (1 + h [0]) - f \\ast h = f [0] (1 + h [0]) - f [0] h [0] = f [0] $$ 解得\n $$ f (x) = \\frac{f [0]}{1 + h [0] - h (x)} = \\frac{1}{1 - g (x)} $$ 于是求逆即可\npoly_t ff, ans; int main() { ll n = rr() - 1; for (int i = 1; i \u0026lt;= n; i++) ff[i] = -rr(); ff[0] = 1; int lim = 1; while (lim \u0026lt;= n) lim \u0026lt;\u0026lt;= 1; poly::poly_inv(ff, ans, lim); for (int i = 0; i \u0026lt;= n; i++) printf(\u0026#34;%lld \u0026#34;, ans[i]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p4721/","summary":"题目大意 给定 $g[1], \\cdots, g[m]$，求序列 $f$。\n $$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$ 分析 不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程\n $$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$ 这个形式看似卷积，但实际上它缺了一项。对 $n \u0026gt; 0$ 凑卷积","title":"P4721 分治 FFT"},{"content":"题目大意 即求\n $$ \\sum_{i=a}^b \\sum_{j=c}^d [\\gcd(i,j) = k] $$ 分析 容易想到，独立出函数 $f(k)$ 使得\n $$ f(k) = \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] $$ 利用 Mobius 反演化简，设 $F(d)$\n $$ F(n) = \\sum_{n \\mid d} f(d) = \\sum_{i=1}^x \\sum_{j=1}^y [n \\mid i][n \\mid j] = \\left\\lfloor \\frac{x}{n} \\right\\rfloor \\left\\lfloor \\frac{y}{n} \\right\\rfloor $$ 反演化简有\n $$ f(n) = \\sum_{n \\mid d} \\mu\\left(\\frac{d}{n}\\right)F(d) = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tn} \\right\\rfloor \\left\\lfloor \\frac{y}{tn} \\right\\rfloor $$ 预处理出 $\\mu(t)$ 的前缀和，剩下的就是一个二重分块了。\nll f(ll a, ll b) { ll mab = min(a, b); ll sum = 0; for (ll l = 1, r; l \u0026lt;= mab; l = r + 1) { r = min(a / (a / l), b / (b / l)); sum += (mu[r] - mu[l - 1]) * (a / l) * (b / l); } return sum; } int main() { ll ttt = rr(); sieve(MN - 1); // 筛 mu 并求前缀和  _fora (i, 1, ttt) { ll a = rr(), b = rr(), c = rr(), d = rr(); ll k = rr(); a--, c--; a /= k, b /= k, c /= k, d /= k; ll ans = f(b, d) - f(a, d) - f(b, c) + f(a, c); printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } 类似题目 P2158 仪仗队：即 $k = 1$ 的特殊情况。\nP3455 ZAP-Queries：几乎一样。\nP2257 YY 的 GCD：比这题难，单独开篇。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2522/","summary":"题目大意 即求\n $$ \\sum_{i=a}^b \\sum_{j=c}^d [\\gcd(i,j) = k] $$ 分析 容易想到，独立出函数 $f(k)$ 使得\n $$ f(k) = \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] $$ 利用 Mobius 反演化简，设 $F(d)$\n $$ F(n) = \\sum_{n \\mid d} f(d) = \\sum_{i=1}^x \\sum_{j=1}^y [n \\mid i][n \\mid j] = \\left\\lfloor \\frac{x}{n} \\right\\rfloor \\left\\lfloor \\frac{y}{n} \\right\\rfloor $$ 反演化简有\n $$ f(n) = \\sum_{n \\mid d} \\mu\\left(\\frac{d}{n}\\right)F(d) = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tn} \\right\\rfloor \\left\\lfloor \\frac{y}{tn} \\right\\rfloor $$ 预处理出 $\\mu(t)$ 的前缀和，剩下的就是一个二重分块了。","title":"P2522 Problem B"},{"content":"题目大意 给出正整数 $n$ 和 $k$，请计算\n $$ G(n, k) = \\sum_{i = 1}^n k \\bmod i $$ 分析 因为\n $$ k \\bmod i = k - i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$ 因此有\n $$ G(n,k) = nk - \\sum_{i=1}^n i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$ 后面需要整数分块。\nint main() { ll n = rr(); ll k = rr(); ll sum = n * k; n = min(n, k); for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = min(n, k / (k / l)); ll t = (l + r) * (r - l + 1) / 2; sum -= t * (k / l); } printf(\u0026#34;%lld\u0026#34;, sum); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-04/p2261/","summary":"题目大意 给出正整数 $n$ 和 $k$，请计算\n $$ G(n, k) = \\sum_{i = 1}^n k \\bmod i $$ 分析 因为\n $$ k \\bmod i = k - i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$ 因此有\n $$ G(n,k) = nk - \\sum_{i=1}^n i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$ 后面需要整数分块。\nint main() { ll n = rr(); ll k = rr(); ll sum = n * k; n = min(n, k); for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = min(n, k / (k / l)); ll t = (l + r) * (r - l + 1) / 2; sum -= t * (k / l); } printf(\u0026#34;%lld\u0026#34;, sum); return 0; } ","title":"P2261 余数求和"},{"content":"题目大意 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：\n $$ y_i=\\sum_{j=l_i}^{r_i}[w_j \\geqslant W] \\times \\sum_{j=l_i}^{r_i}[w_j \\geqslant W]v_j $$ 记检验结果为 $y=\\sum y_i$，对于给定的 $s$，求 $|y-s|$ 的最小值。\n分析 注意到 $y(w)$ 是关于 $W$ 的递减函数，对 $w$ 在 $[w_{\\min},w_{\\max}]$ 上进行二分。\nconst ll MN = 2e5+10; ll vv[MN], ww[MN], li[MN], ri[MN]; int main() { n = rr(), m = rr(), s = rr(); ll minw = 0x3f3f3f3f, maxw = 0; f1[0] = f2[0] = 0; _fora (i, 1, n) { ww[i] = rr(), vv[i] = rr(); maxw = max(ww[i], maxw); minw = min(ww[i], minw); } _fora (i, 1, m) { li[i] = rr(), ri[i] = rr(); } ll l = minw, r = maxw + 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (sum(mid) \u0026lt;= s) r = mid; else l = mid + 1; } ll rst = min(sum(l - 1) - s , s - sum(l)); printf(\u0026#34;%lld\u0026#34;, rst); return 0; } 区间求和可以用前缀和优化。\nll f1[MN], f2[MN]; ll sum(ll w) { _fora (i, 1, n) { ll f = ww[i] \u0026gt;= w; f1[i] = f1[i-1] + f; f2[i] = f2[i-1] + f * vv[i]; } ll sum = 0; _fora (k, 1, m) { ll l = li[k], r = ri[k]; sum += (f1[r] - f1[l-1]) * (f2[r] - f2[l-1]); } return sum; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-04/p1314/","summary":"题目大意 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：\n $$ y_i=\\sum_{j=l_i}^{r_i}[w_j \\geqslant W] \\times \\sum_{j=l_i}^{r_i}[w_j \\geqslant W]v_j $$ 记检验结果为 $y=\\sum y_i$，对于给定的 $s$，求 $|y-s|$ 的最小值。\n分析 注意到 $y(w)$ 是关于 $W$ 的递减函数，对 $w$ 在 $[w_{\\min},w_{\\max}]$ 上进行二分。\nconst ll MN = 2e5+10; ll vv[MN], ww[MN], li[MN], ri[MN]; int main() { n = rr(), m = rr(), s = rr(); ll minw = 0x3f3f3f3f, maxw = 0; f1[0] = f2[0] = 0; _fora (i, 1, n) { ww[i] = rr(), vv[i] = rr(); maxw = max(ww[i], maxw); minw = min(ww[i], minw); } _fora (i, 1, m) { li[i] = rr(), ri[i] = rr(); } ll l = minw, r = maxw + 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (sum(mid) \u0026lt;= s) r = mid; else l = mid + 1; } ll rst = min(sum(l - 1) - s , s - sum(l)); printf(\u0026#34;%lld\u0026#34;, rst); return 0; } 区间求和可以用前缀和优化。","title":"P1314 聪明的质检员"},{"content":"题目链接：Link 。\nA. ABC String 这么水的题竟然 wa 了 4 发。。\n题目大意 给定一个长 $n$ 的字符串 $a$，仅由 A，B，C 组成，$n$ 为偶数。\n对于仅含 ( 和 ) 的括号序列，当我们能够在其中添加 1 使得其为合法的表达式，则序列合法。\n构造合法的长为 $n$ 的括号序列 $b$，要求在 $a$ 同为 A 的，在 $b$ 中也要相同；B，C 也是如此。\n分析 序列合法的定义即对任意位置，其左侧的 ) 总比 ( 少，且整体左右括号数相等。\n首个字母必为左括号，末尾字母必为右括号。剩下的那个讨论一下即可。\nint main() { ll ttt = rr(); char ss[60]; while (ttt--) { scanf(\u0026#34;%s\u0026#34;, ss + 1); ll len = strlen(ss + 1); if (ss[1] == ss[len]) { printf(\u0026#34;NO\\n\u0026#34;); continue; } ll sa[3] = {0, 0, 0}; _fora (i, 1, len) sa[ss[i] - \u0026#39;A\u0026#39;]++; ll sl = ss[1] - \u0026#39;A\u0026#39;, sr = ss[len] - \u0026#39;A\u0026#39;; ll sm = 3ll - sl - sr; int flag = FALSE; sa[0] = sa[1] = sa[2] = 0; if (sa[sl] + sa[sm] == sa[sr]) { _fora (i, 1, len) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag += (sa[sl] + sa[sm] \u0026lt; sa[sr]); } } else if (sa[sl] == sa[sm] + sa[sr]) { _fora (i, 1, len) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag += (sa[sl] \u0026lt; sa[sm] + sa[sr]); } } else { printf(\u0026#34;NO\\n\u0026#34;); continue; } if (flag) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); } return 0; } B. Berland Crossword 题目大意 对于一个边长为 $n$ 的正方形黑白棋盘，指定其最顶行的黑色块数为 $u$，最左列、最右侧、最底行的黑色块数分别为 $l,r,d$。\n判断棋盘是否存在。\n分析 关键点在于四个角，然而也就只有 $16$ 种可能，枚举即可。\nll ff[10], aa[10]; int main() { ll ttt = rr(); while (ttt--) { ll n = rr(); _fora (i, 0, 3) aa[i] = rr(); int flag = 0; _fora (k, 0, 15) { memset(ff, 0, sizeof(ff)); int f = 1; _fora (j, 0, 3) { ff[j] = ((k \u0026amp; f) \u0026gt; 0); f = f \u0026lt;\u0026lt; 1; } f = 0; _fora (j, 0, 3) { ll u = aa[j] - ff[j] - ff[(j + 1) % 4]; f += (u \u0026lt; 0) + (u \u0026gt; n - 2); } flag += !f; } if (flag) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } C. 1D Sokoban 题目大意 假设一个直线上的推箱子游戏，你的出生点位于 $0$，在 $a_i$ 处有 $n$ 个箱子，在 $b_i$ 处有 $m$ 个目标点。箱子可能初始化在目标点，但不会在 $0$。\n就像推箱子一样，你可以把箱子推到目标点而不能越过箱子。求最多能使目标点上有几个箱子。\n分析 首先看正半轴，推的时候箱子会积起来，关注点在“箱子队列”的右端。\n容易发现，当右端未碰到新目标点时，结果是不可能变多的。分类讨论\n 当右端碰到恰在目标点的新箱子时，ans+1，计算此时覆盖个数，取最值，len+1。 当右端碰到箱子时，len+1。 当右端碰到目标点时，计算此时覆盖个数，取最值。  计算箱子下覆盖目标点个数可以用双指针法维护。\n有些地方可以用二分？但好像没有变快啊\nll aa[200086]; ll bb[200086]; int main() { ll ttt = rr(); while(ttt--) { ll n = rr(); ll m = rr(); ll a0 = 0, b0 = 0; _fora(i,1,n) aa[i] = rr(); _fora(i,1,m) bb[i] = rr(); a0 = lower_bound(aa+1,aa+n+1,0) - aa-1; b0 = lower_bound(bb+1,bb+m+1,0) - bb-1; aa[0] = -_inf; bb[0] = -_inf; aa[n+1] = _inf; bb[m+1] = _inf; ll ra1 = a0+1, rb1 = b0+1; ll sum = 0,ans = 0, len = 0; ll sl,sr; sl = sr = rb1; while(ra1\u0026lt;=n || rb1\u0026lt;=m) { if(aa[ra1]\u0026lt;bb[rb1]) { len++; ra1++; continue; } sr++; ll tsum = sr-sl; if(aa[ra1]\u0026gt;bb[rb1]) { while(bb[sl]\u0026lt;=bb[rb1]-len \u0026amp;\u0026amp; tsum\u0026gt;0) sl++, tsum--; } else { ans++; while(bb[sl]\u0026lt;=bb[rb1]-len-1 \u0026amp;\u0026amp; tsum\u0026gt;0) sl++, tsum--; len++; ra1++; } rb1++; ans = max(ans,tsum); } sum += ans; ra1 = a0; sl = sr = rb1 = b0; len = 0; ans = 0; while(ra1\u0026gt;=1 || rb1\u0026gt;=1) { if(aa[ra1]\u0026gt;bb[rb1]) { len++; ra1--; continue; } sl--; ll tsum = sr-sl; if(aa[ra1]\u0026lt;bb[rb1]) { while(bb[sr]\u0026gt;=bb[rb1]+len \u0026amp;\u0026amp; tsum\u0026gt;0) sr--, tsum--; } else { ans++; while(bb[sr]\u0026gt;=bb[rb1]+len+1 \u0026amp;\u0026amp; tsum\u0026gt;0) sr--, tsum--; len++; ra1--; } rb1--; ans = max(ans,tsum); } sum += ans; printf(\u0026#34;%lld\\n\u0026#34;,sum); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/cfedu105/","summary":"题目链接：Link 。\nA. ABC String 这么水的题竟然 wa 了 4 发。。\n题目大意 给定一个长 $n$ 的字符串 $a$，仅由 A，B，C 组成，$n$ 为偶数。\n对于仅含 ( 和 ) 的括号序列，当我们能够在其中添加 1 使得其为合法的表达式，则序列合法。\n构造合法的长为 $n$ 的括号序列 $b$，要求在 $a$ 同为 A 的，在 $b$ 中也要相同；B，C 也是如此。\n分析 序列合法的定义即对任意位置，其左侧的 ) 总比 ( 少，且整体左右括号数相等。\n首个字母必为左括号，末尾字母必为右括号。剩下的那个讨论一下即可。\nint main() { ll ttt = rr(); char ss[60]; while (ttt--) { scanf(\u0026#34;%s\u0026#34;, ss + 1); ll len = strlen(ss + 1); if (ss[1] == ss[len]) { printf(\u0026#34;NO\\n\u0026#34;); continue; } ll sa[3] = {0, 0, 0}; _fora (i, 1, len) sa[ss[i] - \u0026#39;A\u0026#39;]++; ll sl = ss[1] - \u0026#39;A\u0026#39;, sr = ss[len] - \u0026#39;A\u0026#39;; ll sm = 3ll - sl - sr; int flag = FALSE; sa[0] = sa[1] = sa[2] = 0; if (sa[sl] + sa[sm] == sa[sr]) { _fora (i, 1, len) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag += (sa[sl] + sa[sm] \u0026lt; sa[sr]); } } else if (sa[sl] == sa[sm] + sa[sr]) { _fora (i, 1, len) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag += (sa[sl] \u0026lt; sa[sm] + sa[sr]); } } else { printf(\u0026#34;NO\\n\u0026#34;); continue; } if (flag) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); } return 0; } B.","title":"CF1494 Educational Round 105 (Rated for Div. 2)"},{"content":"题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。\n给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。\n分析 我是没想出来，经题解提示了拼接函数才写出来的。\n设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。\nchar s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; _fora (i, 1, ml) { int flag = 1; _fora (j, 0, i - 1) { if (s[x][len[x] + j - i] != s[y][j]) { flag = 0; break; } } if (flag) { mt[x][y] = i; break; } } } 然后回溯 dfs，搜索即可。\nll n; int vis[30]; ll dfs(int x) { if (vis[x] \u0026gt;= 2) return 0; vis[x]++; ll maxlen = 0; _fora (i, 1, n) { if (mt[x][i] \u0026gt; 0) { maxlen = max(maxlen, dfs(i) - mt[x][i]); } } vis[x]--; return maxlen + len[x]; } int main() { n = rr(); _fora (i, 1, n) { scanf(\u0026#34;%s\u0026#34;, s[i]); len[i] = strlen(s[i]); } _fora (i, 1, n) { _fora (j, 1, n) { init(i, j); } } ll maxlen = 0; scanf(\u0026#34;%s\u0026#34;, s[0]); _fora (i, 1, n) { if (s[i][0] == s[0][0]) { maxlen = max(maxlen, dfs(i)); } } printf(\u0026#34;%lld\\n\u0026#34;, maxlen); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/p1019/","summary":"题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。\n给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。\n分析 我是没想出来，经题解提示了拼接函数才写出来的。\n设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。\nchar s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; _fora (i, 1, ml) { int flag = 1; _fora (j, 0, i - 1) { if (s[x][len[x] + j - i] != s[y][j]) { flag = 0; break; } } if (flag) { mt[x][y] = i; break; } } } 然后回溯 dfs，搜索即可。","title":"P1019 单词接龙"},{"content":"题目大意 在 $0$ 到 $L$ 的位置间，有 $N$ 块岩石。若要使得岩石间距最小值最大，允许移除 $M$ 块，求此时间距最小值。\n分析 定义函数 $f(x)$，输入为最小值，输出为被移除岩石的个数，实现如下\nll f(ll x) { ll ans = 0; ll l = 0, r = 1; while (r \u0026lt;= N) { if (aa[r] - aa[l] \u0026gt;= x) l = r; else ans++; r++; } return ans; } 显然 $f(x)$ 是单调递减的函数，二分查找即可。\nint main() { L = rr(), N = rr(), M = rr(); _fora (i, 1, N) aa[i] = rr(); aa[++N] = L; ll l = 1, r = L; while (l \u0026lt; r) { ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; ll fm = f(mid); if (fm \u0026lt;= M) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/p2678/","summary":"题目大意 在 $0$ 到 $L$ 的位置间，有 $N$ 块岩石。若要使得岩石间距最小值最大，允许移除 $M$ 块，求此时间距最小值。\n分析 定义函数 $f(x)$，输入为最小值，输出为被移除岩石的个数，实现如下\nll f(ll x) { ll ans = 0; ll l = 0, r = 1; while (r \u0026lt;= N) { if (aa[r] - aa[l] \u0026gt;= x) l = r; else ans++; r++; } return ans; } 显然 $f(x)$ 是单调递减的函数，二分查找即可。\nint main() { L = rr(), N = rr(), M = rr(); _fora (i, 1, N) aa[i] = rr(); aa[++N] = L; ll l = 1, r = L; while (l \u0026lt; r) { ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; ll fm = f(mid); if (fm \u0026lt;= M) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } ","title":"P2678 跳石头"},{"content":"过于简单的题不记录。\n洛谷：更新至：2020.12.31(2020.10)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2020 年 12 月 P5656 二元一次不定方程 (exgcd)\nP4779 单源最短路径（标准版）\nP1629 邮递员送信\nP1359 租用游艇\nP2016 战略游戏\nP3884 二叉树问题\nP3379 最近公共祖先（LCA）\nP2052 道路修建\nP1352 没有上司的舞会\nP3371 单源最短路径（弱化版）\nP3146 248 G\n2020 年 11 月 P1880 石子合并 ==DONE==\nP1636 Einstein 学画画\nP3383 线性筛素数\nP1226 快速幂 || 取余运算\nP3367 并查集\nP4913 二叉树深度\nP4715 淘汰赛\nP2058 海港\nP1106 删数问题\nP1160 队列安排\nP1941 飞扬的小鸟\nP1064 金明的预算方案\nP1833 樱花\nP1541 乌龟棋\nP3842 线段\n2020 年 10 月 P1077 摆花 ==DONE==\nP4995 跳跳！ ==DONE==\nP1090 合并果子 ==DONE==\nP1990 覆盖墙壁 ==DONE==\nP1928 外星密码 ==DONE==\nP1923 求第 $k$ 小的数 ==DONE==\nP5143 攀爬者 ==X==\nP1095 守望者的逃离 ==DONE==\n2020 年 09 月 开始 ACM。不记录 HDU 150 的基础题。\nP1042 乒乓球 ==X==\nP2181 对角线 ==DONE==\nP1004 方格取数 ==DONE==\nCF1384B2 Koa and the Beach ==DONE==\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/log/log2020/","summary":"过于简单的题不记录。\n洛谷：更新至：2020.12.31(2020.10)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2020 年 12 月 P5656 二元一次不定方程 (exgcd)\nP4779 单源最短路径（标准版）\nP1629 邮递员送信\nP1359 租用游艇\nP2016 战略游戏\nP3884 二叉树问题\nP3379 最近公共祖先（LCA）\nP2052 道路修建\nP1352 没有上司的舞会\nP3371 单源最短路径（弱化版）\nP3146 248 G\n2020 年 11 月 P1880 石子合并 ==DONE==\nP1636 Einstein 学画画\nP3383 线性筛素数\nP1226 快速幂 || 取余运算\nP3367 并查集\nP4913 二叉树深度\nP4715 淘汰赛\nP2058 海港\nP1106 删数问题\nP1160 队列安排\nP1941 飞扬的小鸟\nP1064 金明的预算方案\nP1833 樱花\nP1541 乌龟棋\nP3842 线段","title":"2020 年刷题日志"},{"content":"题目大意 环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。\n求最终分数的最小值和最大值。\n分析 考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为\n $$ dp(i,j) = \\max_{i \\leqslant k \\leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j)) $$ 其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。\n然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。\n细节：前缀和、循环开两倍。\nint dmax[205][205], dmin[205][205]; int f[205], s[205]; int main() { int n = rr(); _fora (i, 1, n) f[i + n] = f[i] = rr(); _fora (i, 1, n * 2) s[i] = s[i - 1] + f[i]; _fora (len, 2, n) { _fora (i, 1, 2 * n - len + 1) { int j = i + len - 1; int mmax = 0, mmin = 0x3f3f3f3f; int ss = s[j] - s[i - 1]; _fora (k, i, j - 1) { mmax = max(mmax, dmax[i][k] + dmax[k + 1][j] + ss); mmin = min(mmin, dmin[i][k] + dmin[k + 1][j] + ss); } dmax[i][j] = mmax; dmin[i][j] = mmin; } } int rst = 0x3f3f3f3f; _fora (p, 0, n - 1) rst = min(rst, dmin[p + 1][p + n]); printf(\u0026#34;%d\\n\u0026#34;, rst); rst = 0; _fora (p, 0, n - 1) rst = max(rst, dmax[p + 1][p + n]); printf(\u0026#34;%d\\n\u0026#34;, rst); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1880/","summary":"题目大意 环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。\n求最终分数的最小值和最大值。\n分析 考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为\n $$ dp(i,j) = \\max_{i \\leqslant k \\leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j)) $$ 其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。\n然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。\n细节：前缀和、循环开两倍。\nint dmax[205][205], dmin[205][205]; int f[205], s[205]; int main() { int n = rr(); _fora (i, 1, n) f[i + n] = f[i] = rr(); _fora (i, 1, n * 2) s[i] = s[i - 1] + f[i]; _fora (len, 2, n) { _fora (i, 1, 2 * n - len + 1) { int j = i + len - 1; int mmax = 0, mmin = 0x3f3f3f3f; int ss = s[j] - s[i - 1]; _fora (k, i, j - 1) { mmax = max(mmax, dmax[i][k] + dmax[k + 1][j] + ss); mmin = min(mmin, dmin[i][k] + dmin[k + 1][j] + ss); } dmax[i][j] = mmax; dmin[i][j] = mmin; } } int rst = 0x3f3f3f3f; _fora (p, 0, n - 1) rst = min(rst, dmin[p + 1][p + n]); printf(\u0026#34;%d\\n\u0026#34;, rst); rst = 0; _fora (p, 0, n - 1) rst = max(rst, dmax[p + 1][p + n]); printf(\u0026#34;%d\\n\u0026#34;, rst); return 0; } ","title":"P1880 石子合并"},{"content":"题目大意 要从 $n$ 种花中挑出 $m$ 盆展览，其中第 $i$ 种花不得多于 $a_i$ 种。求有几种选法。\n分析 考虑动态规划，记状态 $dp[i,j]$ 为摆完前 $i$ 种花，共 $j$ 盆时的方案数。容易得到递推式\n $$ dp[i,j] = \\sum_{k = j - \\min(a_i, j)}^j dp[i-1,k] $$ 边界条件是 $dp[0,0] = 1$。可以用滚动数组、前缀和优化。\nconst ll mod = 1e6 + 7; ll dp[110], aa[110], sum[110]; int main() { ll n = rr(), m = rr(); sum[0] = dp[0] = 1; _fora (i, 1, n) aa[i] = rr(); _fora (i, 1, n) { _fora (j, 1, m) sum[j] = (sum[j - 1] + dp[j]) % mod; _forz (j, m, 0) { int t = j - 1 - min(aa[i], j); if (t \u0026gt; 0) dp[j] = (dp[j] + sum[j - 1] - sum[t]) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, (dp[m] + mod) % mod); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1077/","summary":"题目大意 要从 $n$ 种花中挑出 $m$ 盆展览，其中第 $i$ 种花不得多于 $a_i$ 种。求有几种选法。\n分析 考虑动态规划，记状态 $dp[i,j]$ 为摆完前 $i$ 种花，共 $j$ 盆时的方案数。容易得到递推式\n $$ dp[i,j] = \\sum_{k = j - \\min(a_i, j)}^j dp[i-1,k] $$ 边界条件是 $dp[0,0] = 1$。可以用滚动数组、前缀和优化。\nconst ll mod = 1e6 + 7; ll dp[110], aa[110], sum[110]; int main() { ll n = rr(), m = rr(); sum[0] = dp[0] = 1; _fora (i, 1, n) aa[i] = rr(); _fora (i, 1, n) { _fora (j, 1, m) sum[j] = (sum[j - 1] + dp[j]) % mod; _forz (j, m, 0) { int t = j - 1 - min(aa[i], j); if (t \u0026gt; 0) dp[j] = (dp[j] + sum[j - 1] - sum[t]) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, (dp[m] + mod) % mod); return 0; } ","title":"P1077 摆花"},{"content":"题目大意 可以合并两堆果子成一堆新果子，消耗两堆果子数目之和的体力。给定 $n$ 堆果子的数目 $a_i$，求体力耗费最小的方案。\n分析 很容易猜到贪心结论，不断选取两个最小的堆进行合并。\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; int main() { int n = rr(); _fora (i, 1, n) { int t = rr() q.push(); } int sum = 0; while (q.size() \u0026gt;= 2) { int x = q.top(); q.pop(); int y = q.top(); q.pop(); sum += x + y; q.push(x + y); } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } 本质上是证明 Huffman 树的构造的正确性，有点复杂。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1090/","summary":"题目大意 可以合并两堆果子成一堆新果子，消耗两堆果子数目之和的体力。给定 $n$ 堆果子的数目 $a_i$，求体力耗费最小的方案。\n分析 很容易猜到贪心结论，不断选取两个最小的堆进行合并。\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; int main() { int n = rr(); _fora (i, 1, n) { int t = rr() q.push(); } int sum = 0; while (q.size() \u0026gt;= 2) { int x = q.top(); q.pop(); int y = q.top(); q.pop(); sum += x + y; q.push(x + y); } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } 本质上是证明 Huffman 树的构造的正确性，有点复杂。","title":"P1090 合并果子"},{"content":"题目大意 给定数列，求第 $k$ 小的数。\n分析 模板题。考虑分治，随便选一个数 $x$，然后把比 $x$ 大的数移到右边，比 $x$ 小的数移到左边。因此得到了数 $x$ 的排位，若恰为第 $k$ 个则返回，否则根据大小在左右寻找。\n该算法是不稳定的，期望复杂度 $O(n)$，最坏复杂度 $O(n^2)$。\n实际上存在最坏复杂度为 $O(n)$ 的 BFPTR 算法，但因为其常数过大实现复杂而很少应用。\nll nn[5000010], k, n; ll quicksort(ll l, ll r) { ll i = l, j = r; ll x = nn[(l + r) / 2]; while (i \u0026lt;= j) { while (nn[j] \u0026gt; x) j--; while (nn[i] \u0026lt; x) i++; if (i \u0026lt;= j) { swap(nn[i], nn[j]); i++, j--; } } // l \u0026lt;= j \u0026lt;= i \u0026lt;=r  if (k \u0026lt;= j) return quicksort(l, j); else if (k \u0026gt;= i) return quicksort(i, r); else return nn[k + 1]; } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); _fora (i, 1, n) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;nn[i]); printf(\u0026#34;%lld\u0026#34;, quicksort(1, n)); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1923/","summary":"题目大意 给定数列，求第 $k$ 小的数。\n分析 模板题。考虑分治，随便选一个数 $x$，然后把比 $x$ 大的数移到右边，比 $x$ 小的数移到左边。因此得到了数 $x$ 的排位，若恰为第 $k$ 个则返回，否则根据大小在左右寻找。\n该算法是不稳定的，期望复杂度 $O(n)$，最坏复杂度 $O(n^2)$。\n实际上存在最坏复杂度为 $O(n)$ 的 BFPTR 算法，但因为其常数过大实现复杂而很少应用。\nll nn[5000010], k, n; ll quicksort(ll l, ll r) { ll i = l, j = r; ll x = nn[(l + r) / 2]; while (i \u0026lt;= j) { while (nn[j] \u0026gt; x) j--; while (nn[i] \u0026lt; x) i++; if (i \u0026lt;= j) { swap(nn[i], nn[j]); i++, j--; } } // l \u0026lt;= j \u0026lt;= i \u0026lt;=r  if (k \u0026lt;= j) return quicksort(l, j); else if (k \u0026gt;= i) return quicksort(i, r); else return nn[k + 1]; } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); _fora (i, 1, n) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;nn[i]); printf(\u0026#34;%lld\u0026#34;, quicksort(1, n)); return 0; } ","title":"P1923 求第 $k$ 小的数"},{"content":"题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。\n分析 我考虑用类似状态机的方式解析字符串。\n 当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$  写成 BNF 更直观一点\n\u0026lt;pwd\u0026gt; ::= \u0026lt;EMPTY\u0026gt; | {\u0026lt;ALPHA\u0026gt;} | \u0026lt;pwd\u0026gt; \u0026#34;[\u0026#34; \u0026lt;NUMBER\u0026gt; \u0026lt;pwd\u0026gt; \u0026#34;]\u0026#34; \u0026lt;pwd\u0026gt; string read() { string s = \u0026#34;\u0026#34;; char c; while (cin \u0026gt;\u0026gt; c) { if (c == \u0026#39;[\u0026#39;) { int n; cin \u0026gt;\u0026gt; n; string ts = read(); while (n--) s += ts; } else if (c == \u0026#39;]\u0026#39;) { return s; } else { s += c; } } return s; } int main() { cout \u0026lt;\u0026lt; read(); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1928/","summary":"题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。\n分析 我考虑用类似状态机的方式解析字符串。\n 当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$  写成 BNF 更直观一点\n\u0026lt;pwd\u0026gt; ::= \u0026lt;EMPTY\u0026gt; | {\u0026lt;ALPHA\u0026gt;} | \u0026lt;pwd\u0026gt; \u0026#34;[\u0026#34; \u0026lt;NUMBER\u0026gt; \u0026lt;pwd\u0026gt; \u0026#34;]\u0026#34; \u0026lt;pwd\u0026gt; string read() { string s = \u0026#34;\u0026#34;; char c; while (cin \u0026gt;\u0026gt; c) { if (c == \u0026#39;[\u0026#39;) { int n; cin \u0026gt;\u0026gt; n; string ts = read(); while (n--) s += ts; } else if (c == \u0026#39;]\u0026#39;) { return s; } else { s += c; } } return s; } int main() { cout \u0026lt;\u0026lt; read(); return 0; } ","title":"P1928 外星密码"},{"content":"题目大意 有 I 形和 L 形两种砖头，分别能覆盖 2 个单元和 3 个单元。求 $2 \\times n$ 的墙有多少不重复的覆盖方式，结果对 $10^4$ 取模。\n分析 其中 I 形砖块仅有横放和竖放两种。关键在于 L 形，两个 L 形之间可以用 I 形填充，这让情况变得复杂起来。\n对于 $F_n$ 的递推，我们可以想到\n 在 $F_{n-1}$ 后放一个 I 形砖块。 在 $F_{n-2}$ 后放两个横着的 I 形砖块。 对于更前面的递推，较为复杂。  两个 L 形砖块对齐，上下翻转也可以，即 $2 F_{n-3}$。 两个 L 形砖块可以对顶放，空缺恰用一个 I 填充，即 $2 F_{n-4}$。 类似 $2F_{n-3}$，中间可以再插入两个 I 形，即 $2 F_{n-5}$。 …… 直到 I 形和 L 形砖块恰好铺满墙壁，即 $2F_{0}$。    容易得到我们的递推式\n $$ F_n = F_{n-1} + F_{n-2} + 2 \\sum_{i=0}^{n-3} F_i $$ 利用错位相减法，不难化简得到\n $$ F_n = 2 F_{n-1} + F_{n-3} $$ 于是代码有\nint dp[1000000]; int main() { int n = rr(); dp[1] = 1, dp[2] = 2, dp[3] = 5; _fora (i, 4, n) { dp[i] = (dp[i-1] * 2 + dp[i-3]) % 10000; } printf(\u0026#34;%d\\n\u0026#34;, dp[n]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1990/","summary":"题目大意 有 I 形和 L 形两种砖头，分别能覆盖 2 个单元和 3 个单元。求 $2 \\times n$ 的墙有多少不重复的覆盖方式，结果对 $10^4$ 取模。\n分析 其中 I 形砖块仅有横放和竖放两种。关键在于 L 形，两个 L 形之间可以用 I 形填充，这让情况变得复杂起来。\n对于 $F_n$ 的递推，我们可以想到\n 在 $F_{n-1}$ 后放一个 I 形砖块。 在 $F_{n-2}$ 后放两个横着的 I 形砖块。 对于更前面的递推，较为复杂。  两个 L 形砖块对齐，上下翻转也可以，即 $2 F_{n-3}$。 两个 L 形砖块可以对顶放，空缺恰用一个 I 填充，即 $2 F_{n-4}$。 类似 $2F_{n-3}$，中间可以再插入两个 I 形，即 $2 F_{n-5}$。 …… 直到 I 形和 L 形砖块恰好铺满墙壁，即 $2F_{0}$。    容易得到我们的递推式","title":"P1990 覆盖墙壁"},{"content":"题目大意 给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$ ，求最耗体力的路径。\n分析 容易猜到贪心结论，是不断的在剩余石头中最大最小的来回跳。\n考虑证明结论，设 $h_i$ 是将要跳的序列，展开求和式\n $$ S = \\sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \\sum_{k=1}^nh_k^2 - 2\\sum_{k=1}^{n-1}h_kh_{k+1} $$ 注意到平方和为一个定值，重点在后半式。记 $H_k = h_{k+1}$，有\n $$ \\sum_{k=1}^{n-1}h_kH_k $$ 利用高中时学的排序不等式，有\n $$ \\text{反序和} \\leqslant \\text{乱序和} \\leqslant \\text{顺序和} $$ 于是有反序最小。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p4995/","summary":"题目大意 给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$ ，求最耗体力的路径。\n分析 容易猜到贪心结论，是不断的在剩余石头中最大最小的来回跳。\n考虑证明结论，设 $h_i$ 是将要跳的序列，展开求和式\n $$ S = \\sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \\sum_{k=1}^nh_k^2 - 2\\sum_{k=1}^{n-1}h_kh_{k+1} $$ 注意到平方和为一个定值，重点在后半式。记 $H_k = h_{k+1}$，有\n $$ \\sum_{k=1}^{n-1}h_kH_k $$ 利用高中时学的排序不等式，有\n $$ \\text{反序和} \\leqslant \\text{乱序和} \\leqslant \\text{顺序和} $$ 于是有反序最小。","title":"P4995 跳跳！"},{"content":"题目大意 在三维空间中，HKE 只能往上走，求攀爬总长。\n分析 对所有座标的 $z$ 分量排序即可。\nstruct POINT { double x, y, z; bool operator\u0026lt;(POINT p) { return z \u0026gt; p.z; } } nn[50010]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); _fora (i, 1, n) scanf(\u0026#34;%lf%lf%lf\u0026#34;, \u0026amp;(nn[i].x), \u0026amp;(nn[i].y), \u0026amp;(nn[i].z)); sort(nn + 1, nn + n + 1); double len = 0; _fora (i, 2, n) { double t = (nn[i].x - nn[i - 1].x) * (nn[i].x - nn[i - 1].x); t += (nn[i].y - nn[i - 1].y) * (nn[i].y - nn[i - 1].y); t += (nn[i].z - nn[i - 1].z) * (nn[i].z - nn[i - 1].z); len += sqrt(t); } printf(\u0026#34;%.3lf\\n\u0026#34;, len); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p5143/","summary":"题目大意 在三维空间中，HKE 只能往上走，求攀爬总长。\n分析 对所有座标的 $z$ 分量排序即可。\nstruct POINT { double x, y, z; bool operator\u0026lt;(POINT p) { return z \u0026gt; p.z; } } nn[50010]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); _fora (i, 1, n) scanf(\u0026#34;%lf%lf%lf\u0026#34;, \u0026amp;(nn[i].x), \u0026amp;(nn[i].y), \u0026amp;(nn[i].z)); sort(nn + 1, nn + n + 1); double len = 0; _fora (i, 2, n) { double t = (nn[i].x - nn[i - 1].x) * (nn[i].x - nn[i - 1].","title":"P5143 攀爬者"},{"content":"P1095 守望者的逃离 题目大意 守望者的可以在一秒逃出 $17 {\\rm m}$，或者消耗 $10$ 点魔法值闪现 $60 {\\rm m}$。原地休息时每秒回复 $4$ 点魔法值。\n守望者开始有 $M$ 点魔法，需要在 $T$ 秒内逃离距离 $S$。若能逃离则求最短逃离时间，否则求最远距离。\n分析 设 $s_1$为一直走路，$s_2$ 为一直闪现恢复。当 $s_2$ 快了就把 $s_1$ 更新为 $s_2$。\nint main() { int m, s, t; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;m, \u0026amp;s, \u0026amp;t); int time = t; int s1, s2; s1 = s2 = 0; while (time \u0026gt; 0 \u0026amp;\u0026amp; s1 \u0026lt; s) { s1 += 17; if (m \u0026gt;= 10) { m -= 10; s2 += 60; } else { m += 4; } s1 = max(s1, s2); time--; } if (s1 \u0026lt; s) printf(\u0026#34;No\\n%d\\n\u0026#34;, s1); else printf(\u0026#34;Yes\\n%d\\n\u0026#34;, t - time); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1095/","summary":"P1095 守望者的逃离 题目大意 守望者的可以在一秒逃出 $17 {\\rm m}$，或者消耗 $10$ 点魔法值闪现 $60 {\\rm m}$。原地休息时每秒回复 $4$ 点魔法值。\n守望者开始有 $M$ 点魔法，需要在 $T$ 秒内逃离距离 $S$。若能逃离则求最短逃离时间，否则求最远距离。\n分析 设 $s_1$为一直走路，$s_2$ 为一直闪现恢复。当 $s_2$ 快了就把 $s_1$ 更新为 $s_2$。\nint main() { int m, s, t; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;m, \u0026amp;s, \u0026amp;t); int time = t; int s1, s2; s1 = s2 = 0; while (time \u0026gt; 0 \u0026amp;\u0026amp; s1 \u0026lt; s) { s1 += 17; if (m \u0026gt;= 10) { m -= 10; s2 += 60; } else { m += 4; } s1 = max(s1, s2); time--; } if (s1 \u0026lt; s) printf(\u0026#34;No\\n%d\\n\u0026#34;, s1); else printf(\u0026#34;Yes\\n%d\\n\u0026#34;, t - time); return 0; } ","title":"P1095 守望者的逃离"},{"content":"题目大意 赢 11 分并且压对手两分以上则一局结束，否则要追分至压对手两分。\n给定 $\\texttt{WL}$ 序列，分别求 11 分制和 21 分制下每场比分，$\\texttt{E}$ 是结束符。\n分析 这是一道比较烦的模拟题，很绕。\nchar ch[62510]; int solve(int win, int len) { int w = 0, l = 0; _fora (i, 0, len-1) { w += ch[i] == \u0026#39;W\u0026#39;; l += ch[i] == \u0026#39;L\u0026#39;; if (max(w, l) \u0026gt;= win \u0026amp;\u0026amp;abs(w - l) \u0026gt;= 2) { printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); w = l = 0; } } printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); } int main() { char ccc; int len = 0; while(scanf(\u0026#34;%c\u0026#34;, \u0026amp;ccc) != EOF) { if(ccc != \u0026#39;E\u0026#39;) ch[len++] = ccc; else break; } solve(11, len); LN; solve(21, len); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1042/","summary":"题目大意 赢 11 分并且压对手两分以上则一局结束，否则要追分至压对手两分。\n给定 $\\texttt{WL}$ 序列，分别求 11 分制和 21 分制下每场比分，$\\texttt{E}$ 是结束符。\n分析 这是一道比较烦的模拟题，很绕。\nchar ch[62510]; int solve(int win, int len) { int w = 0, l = 0; _fora (i, 0, len-1) { w += ch[i] == \u0026#39;W\u0026#39;; l += ch[i] == \u0026#39;L\u0026#39;; if (max(w, l) \u0026gt;= win \u0026amp;\u0026amp;abs(w - l) \u0026gt;= 2) { printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); w = l = 0; } } printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); } int main() { char ccc; int len = 0; while(scanf(\u0026#34;%c\u0026#34;, \u0026amp;ccc) !","title":"P1042 乒乓球"},{"content":"题目大意 凸 $n$ 边形中，任意三条对角线不共点，求所有对角线交点的个数。\n分析 注意到一个交点对应凸多边形 $4$ 个定点，于是等价于 $n$ 个点任选 $4$ 个点的选法种数，即\n $$ \\binom{n}{4} = \\frac{n(n-1)(n-2)(n-3)}{24} $$ 注意爆 long long，需要写成 n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4。\nint main() { unsigned long long n; scanf(\u0026#34;%llu\u0026#34;, \u0026amp;n); n = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4; printf(\u0026#34;%llu\u0026#34;, n); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p2181/","summary":"题目大意 凸 $n$ 边形中，任意三条对角线不共点，求所有对角线交点的个数。\n分析 注意到一个交点对应凸多边形 $4$ 个定点，于是等价于 $n$ 个点任选 $4$ 个点的选法种数，即\n $$ \\binom{n}{4} = \\frac{n(n-1)(n-2)(n-3)}{24} $$ 注意爆 long long，需要写成 n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4。\nint main() { unsigned long long n; scanf(\u0026#34;%llu\u0026#34;, \u0026amp;n); n = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4; printf(\u0026#34;%llu\u0026#34;, n); return 0; } ","title":"P2181 对角线"},{"content":"题目大意 海里每一个位置都有一个深度，而且水里随着时间有锯齿状周期为 $2k$ 的潮汐。\n当潮汐与深度之和大于给定值 $l$ 时 Koa 会溺水，游泳、海岸、岛上永远是安全的。\n在任意时间 Koa 可以选择游到 $x+1$ 或停留在 $x$，试问 Koa 是否能够安全的从海岸 $0$ 到达岛上 $n+1$。\n分析 开始的想法是随着时间 DP，更好的解法是贪心。\n若一个位置在水位最高时仍不会溺水，则称这个位置是安全的，并且可以任意选择出发时机。\n即安全位置之间是相互独立的，我们只需判断可达性，尽量到达每一个安全位置。若之后 $2k$ 个位置没有安全位置，必死。\nKoa 的最优决策是在刚退潮时出发，如果能走就尽量往前走，不能走就等，等到涨潮就说明不存在通过方法。\nint main() { int ttt = rr(); while (ttt--) { int n = rr(), k = rr(), l = rr(); int flag = 0; int last = k; _fora (i, 1, n) { int d = rr(); flag += l \u0026lt; d; if (l - d \u0026gt;= k) last = k; else last = min(last - 1, l - d); flag += abs(last) \u0026gt; l - d; } if (flag) printf(\u0026#34;No\\n\u0026#34;); else printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/cf1384b2/","summary":"题目大意 海里每一个位置都有一个深度，而且水里随着时间有锯齿状周期为 $2k$ 的潮汐。\n当潮汐与深度之和大于给定值 $l$ 时 Koa 会溺水，游泳、海岸、岛上永远是安全的。\n在任意时间 Koa 可以选择游到 $x+1$ 或停留在 $x$，试问 Koa 是否能够安全的从海岸 $0$ 到达岛上 $n+1$。\n分析 开始的想法是随着时间 DP，更好的解法是贪心。\n若一个位置在水位最高时仍不会溺水，则称这个位置是安全的，并且可以任意选择出发时机。\n即安全位置之间是相互独立的，我们只需判断可达性，尽量到达每一个安全位置。若之后 $2k$ 个位置没有安全位置，必死。\nKoa 的最优决策是在刚退潮时出发，如果能走就尽量往前走，不能走就等，等到涨潮就说明不存在通过方法。\nint main() { int ttt = rr(); while (ttt--) { int n = rr(), k = rr(), l = rr(); int flag = 0; int last = k; _fora (i, 1, n) { int d = rr(); flag += l \u0026lt; d; if (l - d \u0026gt;= k) last = k; else last = min(last - 1, l - d); flag += abs(last) \u0026gt; l - d; } if (flag) printf(\u0026#34;No\\n\u0026#34;); else printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } ","title":"CF1384B2 Koa and the Beach"},{"content":"题目大意 在 $n \\times n$ 的方格（$n \\leqslant 9$）中存在一些正整数，经过格子时获得格子上的数，但只能获得一次。\n某人只能向右或向下走，从格子的左上角走到到右下角，共走两次，求最大能取得的数字。\n分析 考虑把先走后走转化为两个人同时走，只需要处理遇到两次的值即可。\n考虑四维 DP，用 $dp[x_1,y_1,x_2,y_2]$ 表示第一个人走到 $(x_1,y_1)$ 和第二个人走到 $(x_2,y_2)$。\n再考虑转移，每一个位置仅可能从其左面或上面转移来，于是可以写出（$x_1 \\ne y_1$ 或 $x_2 \\ne y_2$ 时）\n $$ dp[x_1,y_1,x_2,y_2] = \\max\\left\\{ \\begin{matrix} dp[x_1-1,y_1,x_2-1,y_2] \\\\ dp[x_1,y_1-1,x_2-1,y_2] \\\\ dp[x_1-1,y_1,x_2,y_2-1] \\\\ dp[x_1,y_1-1,x_2,y_2-1] \\end{matrix}\\right\\} + a[x_1,y_1] + a[x_2,y_2] $$ 当 $x_1=y_1,x_2=y_2$ 时，只加一次即可。到这里 $O(n^4)$ 其实已经可以过题了，但还可以优化。\n注意到一些状态是不可达的，因为 $x_1+y_1 = x_2+y_2$，因此存在 $O(n^3)$ 的 DP。\n考虑当前已走长度 $h=x_1+y_1=x_2+y_2$，于是可以把两个人的座标表示为 $(x_1,h-x_1)$ 和 $(x_2,h-x_2)$。\n于是记状态为 $dp[h,x_1,x_2]$，当 $x_1 \\ne x_2$ 时有\n $$ dp[h,x_1,x_2] = \\max\\left\\{ \\begin{matrix} dp[h-1,x_1,x_2] \\\\ dp[h-1,x_1,x_2-1] \\\\ dp[h-1,x_1-1,x_2] \\\\ dp[h-1,x_1-1,x_2-1] \\end{matrix}\\right\\} + a[x_1,h-x_1] + a[x_2,h-x_2] $$ 再注意到可以使用滚动数组，因此有\nll mtx[10][10], dp[10][10]; int main() { ll N = rr(); while (1) { ll a = rr(), b = rr(), c = rr(); if (a + b + c == 0) break; mtx[a][b] = c; } _fora (ss, 2, 2 * N) { ll max_x1 = min(N, ss - 1), min_x1 = max(1ll, ss - N); _forz (x1, max_x1, min_x1) { ll max_x2 = min(N, ss - 1), min_x2 = max(1ll, ss - N); _forz (x2, max_x2, min_x2) { dp[x1][x2] = max4( dp[x1 - 1][x2 - 1], dp[x1][x2 - 1], dp[x1 - 1][x2], dp[x1][x2] ); dp[x1][x2] += mtx[x1][ss - x1] + mtx[x2][ss - x2]; if (x1 == x2) dp[x1][x2] -= mtx[x1][ss - x1]; } } } printf(\u0026#34;%lld\\n\u0026#34;, dp[N][N]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1004/","summary":"题目大意 在 $n \\times n$ 的方格（$n \\leqslant 9$）中存在一些正整数，经过格子时获得格子上的数，但只能获得一次。\n某人只能向右或向下走，从格子的左上角走到到右下角，共走两次，求最大能取得的数字。\n分析 考虑把先走后走转化为两个人同时走，只需要处理遇到两次的值即可。\n考虑四维 DP，用 $dp[x_1,y_1,x_2,y_2]$ 表示第一个人走到 $(x_1,y_1)$ 和第二个人走到 $(x_2,y_2)$。\n再考虑转移，每一个位置仅可能从其左面或上面转移来，于是可以写出（$x_1 \\ne y_1$ 或 $x_2 \\ne y_2$ 时）\n $$ dp[x_1,y_1,x_2,y_2] = \\max\\left\\{ \\begin{matrix} dp[x_1-1,y_1,x_2-1,y_2] \\\\ dp[x_1,y_1-1,x_2-1,y_2] \\\\ dp[x_1-1,y_1,x_2,y_2-1] \\\\ dp[x_1,y_1-1,x_2,y_2-1] \\end{matrix}\\right\\} + a[x_1,y_1] + a[x_2,y_2] $$ 当 $x_1=y_1,x_2=y_2$ 时，只加一次即可。到这里 $O(n^4)$ 其实已经可以过题了，但还可以优化。\n注意到一些状态是不可达的，因为 $x_1+y_1 = x_2+y_2$，因此存在 $O(n^3)$ 的 DP。\n考虑当前已走长度 $h=x_1+y_1=x_2+y_2$，于是可以把两个人的座标表示为 $(x_1,h-x_1)$ 和 $(x_2,h-x_2)$。\n于是记状态为 $dp[h,x_1,x_2]$，当 $x_1 \\ne x_2$ 时有\n $$ dp[h,x_1,x_2] = \\max\\left\\{ \\begin{matrix} dp[h-1,x_1,x_2] \\\\ dp[h-1,x_1,x_2-1] \\\\ dp[h-1,x_1-1,x_2] \\\\ dp[h-1,x_1-1,x_2-1] \\end{matrix}\\right\\} + a[x_1,h-x_1] + a[x_2,h-x_2] $$ 再注意到可以使用滚动数组，因此有","title":"P1004 方格取数"}]