[{"content":"新的一年，一样的菜。\n过于简单的题不记录。\n2022 年 01 月 01-14 |  UOJ50 链式反应\n01-21 |  ZAFU 2022.01.18 个人赛题解\n01-27 |  P3373 线段树 2\n01-27 |  P2023 维护序列\n01-28 |  P1531 I Hate It\n01-28 |  P5057 简单题\n01-28 |  P4588 数学计算\n01-28 |  P1637 三元上升子序列\n01-29 |  P5431 乘法逆元 2\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/log2022/","summary":"新的一年，一样的菜。\n过于简单的题不记录。\n2022 年 01 月 01-14 |  UOJ50 链式反应\n01-21 |  ZAFU 2022.01.18 个人赛题解\n01-27 |  P3373 线段树 2\n01-27 |  P2023 维护序列\n01-28 |  P1531 I Hate It\n01-28 |  P5057 简单题\n01-28 |  P4588 数学计算\n01-28 |  P1637 三元上升子序列\n01-29 |  P5431 乘法逆元 2","title":"2021 年刷题日志"},{"content":"题目大意 给定 $n$ 个正整数 $\\{a_i\\}$ 和 $k$，求在模 $p$ 意义下的\n$$ \\sum_{i=1}^n \\frac{k^i}{a_i} \\bmod p $$\n分析 逐个求逆元是 $O(n \\log p)$ 的，肯定会 T，需要想想别的办法。\n批量求逆元的一个技巧，先求出 $a_i$ 的前缀积，然后求出全部积的逆元，再逐个往前推。即\n$$ (a_n)^{-1} = \\left(\\prod_{i=1}^{n-1} a_i\\right) \\left(\\prod_{i=1}^n a_i\\right)^{-1} $$\n显然，$\\{a_n\\}$ 中不能有 $0$。\nvi get_inv(const vi \u0026amp;a, int p) { int n = a.size() - 1; vi prod(n + 1); prod[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { prod[i] = 1ll * prod[i - 1] * a[i] % p; } prod[n] = qpow(prod[n], p - 2, p); vi iva(n + 1); for (int i = n; i \u0026gt;= 1; i--) { iva[i] = 1ll * prod[i] * prod[i - 1] % p; prod[i - 1] = 1ll * prod[i] * a[i] % p; } return iva; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p5431/","summary":"题目大意 给定 $n$ 个正整数 $\\{a_i\\}$ 和 $k$，求在模 $p$ 意义下的\n$$ \\sum_{i=1}^n \\frac{k^i}{a_i} \\bmod p $$\n分析 逐个求逆元是 $O(n \\log p)$ 的，肯定会 T，需要想想别的办法。\n批量求逆元的一个技巧，先求出 $a_i$ 的前缀积，然后求出全部积的逆元，再逐个往前推。即\n$$ (a_n)^{-1} = \\left(\\prod_{i=1}^{n-1} a_i\\right) \\left(\\prod_{i=1}^n a_i\\right)^{-1} $$\n显然，$\\{a_n\\}$ 中不能有 $0$。\nvi get_inv(const vi \u0026amp;a, int p) { int n = a.size() - 1; vi prod(n + 1); prod[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { prod[i] = 1ll * prod[i - 1] * a[i] % p; } prod[n] = qpow(prod[n], p - 2, p); vi iva(n + 1); for (int i = n; i \u0026gt;= 1; i--) { iva[i] = 1ll * prod[i] * prod[i - 1] % p; prod[i - 1] = 1ll * prod[i] * a[i] % p; } return iva; } ","title":"P5431 乘法逆元 2"},{"content":"题目大意 给定一个序列，求其中三元上升子序列的个数\n 对于 $i,j,k$，若 $a_i \u0026lt; a_j \u0026lt; a_k$，则是一个满足要求的三元对。  分析 考虑枚举中间的数 $j$，设其左边有 $a$ 个数比它小，右边有 $b$ 个数比它大，则中间为 $j$ 的三元对个数为 $ab$。\n至此就和逆序对类似了，离散化后用树状数组即可。\n#include \u0026#34;template/ds/fwtree/0.hpp\u0026#34; struct Node { ll x, y; bool operator\u0026lt;(const Node \u0026amp;o) const { if (x == o.x) return y \u0026gt; o.y; return x \u0026lt; o.x; } }; int main() { int n = rr(); vector\u0026lt;Node\u0026gt; v(n + 1); for (int i = 1; i \u0026lt;= n; i++) { v[i].x = rr(), v[i].y = i; } sort(v.begin(), v.end()); fwtree_1\u0026lt;int\u0026gt; tr(n + 1); vector\u0026lt;ll\u0026gt; al(n + 1), ar(n + 1); for (int i = 1; i \u0026lt;= n; i++) { al[i] = tr.query(1, v[i].y); tr.modify(v[i].y, 1); } tr = fwtree_1\u0026lt;int\u0026gt;(n + 1); for (int i = n; i \u0026gt;= 1; i--) { ar[i] = tr.query(v[i].y, n); tr.modify(v[i].y, 1); } ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) ans += 1ll * al[i] * ar[i]; printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p1637/","summary":"题目大意 给定一个序列，求其中三元上升子序列的个数\n 对于 $i,j,k$，若 $a_i \u0026lt; a_j \u0026lt; a_k$，则是一个满足要求的三元对。  分析 考虑枚举中间的数 $j$，设其左边有 $a$ 个数比它小，右边有 $b$ 个数比它大，则中间为 $j$ 的三元对个数为 $ab$。\n至此就和逆序对类似了，离散化后用树状数组即可。\n#include \u0026#34;template/ds/fwtree/0.hpp\u0026#34; struct Node { ll x, y; bool operator\u0026lt;(const Node \u0026amp;o) const { if (x == o.x) return y \u0026gt; o.y; return x \u0026lt; o.x; } }; int main() { int n = rr(); vector\u0026lt;Node\u0026gt; v(n + 1); for (int i = 1; i \u0026lt;= n; i++) { v[i].","title":"P1637 三元上升子序列"},{"content":"题目大意 给定一个数列，有如下操作：\n 将区间 $[l,r]$ 上的数乘上 $x$ 将区间 $[l,r]$ 上的数加上 $x$ 询问区间 $[l,r]$ 上的数之和  分析 很经典的线段树教学题，写完后对线段树的理解确实更深了。\n从一次函数的角度考虑问题感觉更清晰。我们实际上在对每个序列上的值做一次函数\n$$ f_i(x) = k_i x + m_i $$\n先来看本题线段树的结构\ntemplate \u0026lt;class T\u0026gt; struct SegmentTree { vector\u0026lt;Seg\u0026gt; tr; void pushup(int p); void pushdown(int p); void build(int l, int r, int p = 1); void modify(int l, int r, T k, T m, int p = 1); T query(int l, int r, int p = 1); }; 懒标记：在知道一段当前值的情况下，可以立刻知道该段被操作后的值，不必重新计算所有的数。因此可以把当前的操作存起来，询问的时候再对子节点做真实操作。\n真实操作也称永久化，操作后懒标记就被下放子节点。懒标记意味着当前节点已经完成了永久化，子节点没有完成，故询问子节点值前需要更新。\n pushup：当 $p$ 的子节点被改变时，需要用此方法对节点 $p$ 的值进行更新。 pushdown：当询问 $p$ 的子节点的值时，如果 $p$ 节点有懒标记，则下放到 $p$ 的子节点。 modify：对所有在 $[l,r]$ 区间内的节点做永久化，并打上懒标记。 query：询问在 $[l,r]$ 区间内的节点。  当子节点懒标记上已经有值时，下放标记需要合并，即是函数复合。\n$$ f_i(f_j(x)) = a_i(a_j x + b_j) + b_i = a_ia_j x + a_i b_j + b_i $$\n附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p3373/","summary":"题目大意 给定一个数列，有如下操作：\n 将区间 $[l,r]$ 上的数乘上 $x$ 将区间 $[l,r]$ 上的数加上 $x$ 询问区间 $[l,r]$ 上的数之和  分析 很经典的线段树教学题，写完后对线段树的理解确实更深了。\n从一次函数的角度考虑问题感觉更清晰。我们实际上在对每个序列上的值做一次函数\n$$ f_i(x) = k_i x + m_i $$\n先来看本题线段树的结构\ntemplate \u0026lt;class T\u0026gt; struct SegmentTree { vector\u0026lt;Seg\u0026gt; tr; void pushup(int p); void pushdown(int p); void build(int l, int r, int p = 1); void modify(int l, int r, T k, T m, int p = 1); T query(int l, int r, int p = 1); }; 懒标记：在知道一段当前值的情况下，可以立刻知道该段被操作后的值，不必重新计算所有的数。因此可以把当前的操作存起来，询问的时候再对子节点做真实操作。","title":"P3373 线段树 2"},{"content":"题目大意 初始是 $x=1$，我们每轮对 $x$ 做一个操作\n 将 $x$ 变为 $k x$，并输出 $x \\bmod M$。 将 $x$ 变为 $x / k_i$，即取消第 $i$ 次操作，并输出 $x \\bmod M$。  保证每个操作 1 的 $k$ 在操作 2 中至多被除一次。\n分析 $M$ 并不保证是质数，逆元可能不存在。\n可以把操作序列看作一个乘积式，初始情况下全为 $1$。\n 操作 1 即是把第 $i$ 个数变为 $k$。 操作 2 即是把第 $i$ 个数变回 $1$。  修改结束后，询问所有数的乘积。单点修改，区间查询，标准的线段树。\n因为只询问全体和，zkw 好写的多。\ntemplate \u0026lt;class T\u0026gt; struct SegmentTree { vector\u0026lt;T\u0026gt; tr; int N; SegmentTree(int l, int r) { int n = r - l + 1; N = 2 \u0026lt;\u0026lt; std::__lg(n); tr.resize(N * 2 + 2, 1); } void pushdown(int i) { tr[i] = 1ll * tr[i * 2] * tr[i * 2 + 1] % M; } void modify(int i, T x) { tr[i += N] = x; for (i /= 2; i; i /= 2) { pushdown(i); } } }; 附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p4588/","summary":"题目大意 初始是 $x=1$，我们每轮对 $x$ 做一个操作\n 将 $x$ 变为 $k x$，并输出 $x \\bmod M$。 将 $x$ 变为 $x / k_i$，即取消第 $i$ 次操作，并输出 $x \\bmod M$。  保证每个操作 1 的 $k$ 在操作 2 中至多被除一次。\n分析 $M$ 并不保证是质数，逆元可能不存在。\n可以把操作序列看作一个乘积式，初始情况下全为 $1$。\n 操作 1 即是把第 $i$ 个数变为 $k$。 操作 2 即是把第 $i$ 个数变回 $1$。  修改结束后，询问所有数的乘积。单点修改，区间查询，标准的线段树。\n因为只询问全体和，zkw 好写的多。\ntemplate \u0026lt;class T\u0026gt; struct SegmentTree { vector\u0026lt;T\u0026gt; tr; int N; SegmentTree(int l, int r) { int n = r - l + 1; N = 2 \u0026lt;\u0026lt; std::__lg(n); tr.","title":"P4588 数学计算"},{"content":"题目大意 给定一个 01 序列，有如下操作：\n 将区间 $[l,r]$ 上的数 01 翻转。 询问第 $i$ 个数的值。  分析 区间操作，单点查询，很自然的想到了差分。\n用异或或者加减代替翻转都可以，用树状数组维护。我选择了加减，这样询问时对 $2$ 取余即可。\n#include \u0026#34;template/ds/fwtree/0.hpp\u0026#34; int main() { int n = rr(), m = rr(); fwtree_1\u0026lt;int\u0026gt; tr(n + 2); while (m--) { int t = rr(); if (t == 1) { int l = rr() + 1, r = rr() + 1; tr.modify(l - 1, -1), tr.modify(r, 1); } else { int i = rr(); i = tr.query(i); printf(\u0026#34;%d\\n\u0026#34;, i \u0026amp; 1); } } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/p5057/","summary":"题目大意 给定一个 01 序列，有如下操作：\n 将区间 $[l,r]$ 上的数 01 翻转。 询问第 $i$ 个数的值。  分析 区间操作，单点查询，很自然的想到了差分。\n用异或或者加减代替翻转都可以，用树状数组维护。我选择了加减，这样询问时对 $2$ 取余即可。\n#include \u0026#34;template/ds/fwtree/0.hpp\u0026#34; int main() { int n = rr(), m = rr(); fwtree_1\u0026lt;int\u0026gt; tr(n + 2); while (m--) { int t = rr(); if (t == 1) { int l = rr() + 1, r = rr() + 1; tr.modify(l - 1, -1), tr.modify(r, 1); } else { int i = rr(); i = tr.","title":"P5057 简单题"},{"content":"我的代码模板依赖于我自定义的预处理器，它通过 DFS 把所有引入的模板展开。\n index.hpp：公共文件头。  我的模板风格是简单封装：在保持易用的同时，封装尽量的薄。\nData Struct 基础数据结构。\n fwtree/1.hpp：普通树状数组。 fwtree/2.hpp：支持区间修改、区间查询的树状数组。 SegmentTree/1.hpp：普通线段树示例，不可引入。 SegmentTree/2.hpp：带懒标记的线段树示例，不可引入。  Math 基础数学算法。\n qpow.hpp：快速幂。 qpow128.hpp：64 位类型的快速幂。  Basic 我也不知道这东西该放哪，就放到这里吧。\n modint：m32。  NTT-int 简化多项式板子，码量少，常数较大。\n fps/O.hpp：多项式基础结构，用牛顿迭代完成操作。 fps/F.hpp：与上面的相同，略卡常数。 cdq.hpp：非递归 CDQ 分治。 eval.hpp：多点插值，多点求值。  没有用的 NTT-mint 基于 modint 的多项式板子，注重易用性和常数，码量较大。\n每一种算法可能有多种实现。\n多项式类的定义\n poly/1.hpp：继承于 vector\u0026lt;m32\u0026gt;。  NTT\n ntt/1.hpp：无 rev 的 NTT。 ntt/2.hpp：略微卡常的 NTT。  多项式逆\n inv/1.hpp：12E 的牛顿迭代 inv，和 16E 的牛顿迭代 div。 inv/2.hpp：10E 的牛顿迭代 inv，和 13E 的牛顿迭代 div。 inv/3.hpp：24E 的牛顿迭代 inv，和 28E 的牛顿迭代 div。 inv/6.hpp：半在线卷积实现的 inv \u0026amp; div。 inv/7.hpp：全在线卷积实现的 inv \u0026amp; div。（没啥用） inv/8.hpp：10E 的分块牛顿迭代 inv，和 10E 的分块牛顿迭代 div。  多项式 exp\n exp/1.hpp：20E 的牛顿迭代 exp。 exp/2.hpp：17E 的牛顿迭代 exp。 exp/3.hpp：32E 的牛顿迭代 exp。 exp/5.hpp：半在线卷积实现的 exp。 exp/6.hpp：全在线卷积实现的 exp。（没啥用） exp/7.hpp：14E 的分块牛顿迭代 exp。  半在线卷积（CDQ 分治）\n cdq/3.hpp：2 叉的半在线卷积实现，不保存卷积结果。 cdq/4.hpp：B 叉的半在线卷积实现，不保存卷积结果。 cdq/5.hpp：2 叉的半在线卷积实现，保存卷积结果。 cdq/6.hpp：B 叉的半在线卷积实现，保存卷积结果。 cdq/7.hpp：略微卡常的 B 叉在线卷积实现。  全在线卷积\n oc/1.hpp：全在线卷积的实现。（感觉挺快的  多项式 sqrt\n sqrt/1.hpp：11E 的牛顿迭代 sqrt。 sqrt/5.hpp：全在线卷积实现的 sqrt。 sqrt/8.hpp：8E 的分块牛顿迭代 sqrt。  积分、求导、多点求值、多点插值、快速幂。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/docs/","summary":"我的代码模板依赖于我自定义的预处理器，它通过 DFS 把所有引入的模板展开。\n index.hpp：公共文件头。  我的模板风格是简单封装：在保持易用的同时，封装尽量的薄。\nData Struct 基础数据结构。\n fwtree/1.hpp：普通树状数组。 fwtree/2.hpp：支持区间修改、区间查询的树状数组。 SegmentTree/1.hpp：普通线段树示例，不可引入。 SegmentTree/2.hpp：带懒标记的线段树示例，不可引入。  Math 基础数学算法。\n qpow.hpp：快速幂。 qpow128.hpp：64 位类型的快速幂。  Basic 我也不知道这东西该放哪，就放到这里吧。\n modint：m32。  NTT-int 简化多项式板子，码量少，常数较大。\n fps/O.hpp：多项式基础结构，用牛顿迭代完成操作。 fps/F.hpp：与上面的相同，略卡常数。 cdq.hpp：非递归 CDQ 分治。 eval.hpp：多点插值，多点求值。  没有用的 NTT-mint 基于 modint 的多项式板子，注重易用性和常数，码量较大。\n每一种算法可能有多种实现。\n多项式类的定义\n poly/1.hpp：继承于 vector\u0026lt;m32\u0026gt;。  NTT\n ntt/1.hpp：无 rev 的 NTT。 ntt/2.hpp：略微卡常的 NTT。  多项式逆\n inv/1.hpp：12E 的牛顿迭代 inv，和 16E 的牛顿迭代 div。 inv/2.hpp：10E 的牛顿迭代 inv，和 13E 的牛顿迭代 div。 inv/3.","title":"代码模板"},{"content":"你好！\n如你所见，这里放的都是我的 ACM 刷题记录。主博客在 这里。\n刷题日志 2020 年刷题日志\n2021 年刷题日志\n2022 年刷题日志\n代码模板文档 代码模板\n小工具 展示代码\n题号跳转\n","permalink":"https://rogeryoungh.github.io/code-of-acm/about/","summary":"你好！\n如你所见，这里放的都是我的 ACM 刷题记录。主博客在 这里。\n刷题日志 2020 年刷题日志\n2021 年刷题日志\n2022 年刷题日志\n代码模板文档 代码模板\n小工具 展示代码\n题号跳转","title":"About"},{"content":"非常抱歉，本次比赛对难度估计不当，给大家造成了不好的体验，在此向大家致歉。\nA - CF1379A 题目大意 替换字符串 $s$ 中的 ?，使得出现且仅出现一次 abacaba。\n分析 本题较为难写，因为很难判断恰好出现了一次。但是数据规模很小，可以采用非常暴力的写法。\n一种想法是，枚举每个出现 abacaba 的位置 $i$，把当前 $s[i, i + 6]$ 中的 ? 设为给定串，这样就得到了字符串 $t$。\n然后判断字符串 $t$ 中只出现了一次 abacaba，可以通过 substr 枚举所有长为 $6$ 的子串。\nstring what = \u0026#34;abacaba\u0026#34;; void solve() { int len; string s; cin \u0026gt;\u0026gt; len \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; len - 6; i++) { string tmp = s; for (int j = 0; j \u0026lt; 7; j++) if (tmp[i + j] == \u0026#39;?\u0026#39;) tmp[i + j] = what[j]; for (auto \u0026amp;p : tmp) if (p == \u0026#39;?\u0026#39;) p = \u0026#39;z\u0026#39;; int cnt = 0; for (int j = 0; j \u0026lt; len - 6; j++) { if (tmp.substr(j, 7) == what) cnt++; } if (cnt == 1) { printf(\u0026#34;YES\\n%s\\n\u0026#34;, tmp.data()); return; } } printf(\u0026#34;NO\\n\u0026#34;); } B - CF1379B 题目大意 给定 $l,r,m$，找到正整数 $a,b,c,n$ 满足 $m = an + b - c$，且 $l \\leqslant a,b,c \\leqslant r$。\n分析 反解 $n$ 得到\n$$ \\frac{m - (b - c)}{a} = n $$\n我们可以把 $b - c$ 当作一个整体。注意到 $n$ 是正整数，说明 $m - (b - c)$ 必须要能够整除 $a$，而且 $a$ 的范围不是很大，因此我们可以枚举 $a$。\n再注意到 $b-c$ 的范围是 $[l-r,r-l]$，即判断 $m \\bmod a$ 是否在这个范围内。\nint main() { int T = rr(); while (T--) { ll l = rr(), r = rr(), m = rr(); for (ll a = l; a \u0026lt;= r; a++) { int b_c = (m + r - l) % a - (r - l); if (b_c \u0026gt; r - l) continue; if (b_c \u0026lt; 0) printf(\u0026#34;%lld %lld %lld\\n\u0026#34;, a, r + b_c, r); else printf(\u0026#34;%lld %lld %lld\\n\u0026#34;, a, l + b_c, l); break; } } return 0; } C - CF1313B 题目大意 有 $n$ 位参赛者参加两轮比赛，ff 获得的名次分别是 $x$ 和 $y$，其他人的名次是未知的，求 ff 最终可能的最高排名和最低排名。\n分析 结论是很容易猜到的，证明有些困难。\n首先构造最低排名，让尽量多的同学有总分 $x+y$，此时 ff 的排名为 $S_1 = \\min(n, x + y - 1)$。\n 证明\n如果某人的总分满足 $x_i + y_i \\leqslant x + y$，那么其两次排名一定满足 $$ x_i \\leqslant x+y-1\\ 且\\ y_i \\leqslant x+y-1$$ 这样的数对显然是不多于 $\\min(n, x + y - 1) = S_1$ 个的，而 $S_1$ 的构造已给出，故最多为 $S_1$ 个。\n 之后构造最高排名，让尽量多的同学有总分 $x+y+1$，此时 ff 的排名是 $S_2 = \\max(1, \\min(n, x + y - n + 1))$。\n 证明\n主要思路是把排名变成 $n-x$，这样又回到最低排名的问题了。\n如果某人的总分满足 $x_i + y_i \\geqslant x + y + 1$，即 $$n - x_i + n - y_i \\leqslant 2n - x - y - 1$$ 那么其两次排名一定满足 $$n - x_i \\leqslant 2n - x - y - 2\\ 且\\ n - y_i \\leqslant 2n - x - y - 2$$ 故这样的数对不会多于 $S_3 = \\min(n - 1, \\max(2n - x - y - 2, 1))$ 个。\n反过来，不大于 $x+y$ 的数对个数不会少于 $$n - S_3 = \\max(1, \\min(n, x + y - n + 1))$$\n D - CF1496E 见 CF Round 706(Div 2) 。\nE - 2020 ICPC Latin American D 题目大意 给定一些 $2$ 的幂，分成两组使得各组和都是二的幂。\n分析 首先判掉 $n=1$，只有一个盒子不可能的，我们只需关注 $n \\geqslant 2$。\n设两组的和分别为 $2^a, 2^b$，那么 $2^a+2^b$ 在二进制下最多只能有 $2$ 位是 $1$。\n于是我们可以用模拟二进制加法的方式，计算最后到底有几位有 $1$。\n 如果有 $2$ 位是 $1$，则统计这两位是由哪些盒子贡献的，即是分组方案。 如果有 $1$ 位是 $1$，那么少合并最后一步，也回归到 $2$ 个的情况。  注意有个坑点，进位可能多进 30 位，数组要预留够足够大的空间。\nint main() { int n = rr(); vector\u0026lt;int\u0026gt; aa(100086); if (n == 1) { printf(\u0026#34;N\\n\u0026#34;); return 0; } for (int i = 0; i \u0026lt; n; i++) { aa[rr()]++; } int tot = 0; for (int i = 0; i \u0026lt; N - 1; i++) { aa[i + 1] += aa[i] / 2; aa[i] %= 2; if (aa[i] \u0026gt; 0) tot++; } if (tot \u0026lt;= 2) printf(\u0026#34;Y\\n\u0026#34;); else printf(\u0026#34;N\\n\u0026#34;); return 0; } F - CF1382D 题目大意 定义 $\\operatorname{merge}(a,b)$ 函数为不断从 $a,b$ 的开头取出较小者放入答案数组的过程。\n问是否存在两个长为 $n$ 的数组 $a,b$，使得 $\\operatorname{merge}(a,b)$ 等于给定的排列 $P$。\n分析 注意到对于每个降序的序列，它不可能是两个序列交替得到的，只是另外一个序列首个数字比较大，所以一直是一个序列在输出，直到第一个比它大的数字。\n即每一段降序序列都可以打包起来，分配给 $a$ 和 $b$，判断最后是否能否分出两个长为 $n$ 的序列。\n对于 $a$ 来说，每一段序列有选和不选两种状态，我们可以用 01 背包来判断。\nint main() { int T = rr(); while (T--) { int n = rr(); vector\u0026lt;int\u0026gt; P(n * 2 + 1), v, dp(n + 1); for (int i = 0; i \u0026lt; n * 2; i++) P[i] = rr(); int m = 0; for (int i = 1; i \u0026lt; n * 2 + 1; i++) { if (P[i] \u0026gt; P[m]) { v.push_back(i - m); m = i; } } for (auto vi : v) { for (int j = n; j \u0026gt;= vi; j--) { dp[j] = max(dp[j], dp[j - vi] + vi); } } if (dp[n] == n) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } G - CF1384B2 见 CF1384B2 Koa and the Beach  。\nH - CF1382C1 题目大意 你可以对 01 串做一种操作：\n 对前 $p$ 个字符 01 翻转，并逆序。  在 $3n$ 复杂度内把 $a$ 串变成 $b$ 串。\n分析 我们对前 $p$ 项做操作是不会影响后面的，最简单的想法就是，从后往前依次使 $a$ 与 $b$ 相等。\n假如我们已经完成 $p+1$ 后面的操作，现在要使第 $p$ 位相等。\n 如果 $a,b$ 第 $p$ 位相等，无需操作。 如果 $a,b$ 第 $p$ 位不相等，但 $a_1 = \\neg b_p$，那么对前 $p$ 项做一次操作即可。 如果 $a,b$ 第 $p$ 位不相等，但 $a_1 = b_p$，那么先对第一项做操作，之后对前 $p$ 项做一次操作。  总之，我们对每一位最多花 $2$ 次操作使得 $a_i=b_i$，故总共操作次数为 $2n$。\nconst int N = 1e5 + 86; char A[N], B[N]; void op(int p) { for (int i = 0; i \u0026lt; p; i++) A[i] ^= 1; std::reverse(A, A + p); } int main() { int T = rr(); while (T--) { int n = rr(); scanf(\u0026#34;%s%s\u0026#34;, A, B); vector\u0026lt;int\u0026gt; ans; for (int i = n - 1; i \u0026gt;= 0; i--) { if (A[i] == B[i]) continue; if (A[i] == A[0]) { op(i + 1); ans.push_back(i + 1); } else { op(1); ans.push_back(1); op(i + 1); ans.push_back(i + 1); } } printf(\u0026#34;%zu \u0026#34;, ans.size()); for (int i = 0; i \u0026lt; ans.size(); i++) printf(\u0026#34;%d%c\u0026#34;, ans[i], \u0026#34; \\n\u0026#34;[i == ans.size() - 1]); } return 0; } 但是这还不够通过 C2，因为太慢了。注意到我们每次只需要取头和尾两个值，可以用 $l,r$ 加上一个翻转标记代替真实操作。\n这里考虑另一种方式，把 $a$ 变成全为 $0$ 或者 $1$ 的序列，再变成序列 $b$。\n而把一个序列变成全为 $1$ 或 $0$ 是容易的，只需要从开头遍历每个字符即可。\nconst int N = 1e5 + 86; char A[N], B[N]; int main() { int T = rr(); while (T--) { int n = rr(); scanf(\u0026#34;%s%s\u0026#34;, A, B); vector\u0026lt;int\u0026gt; op1, op2; for (int i = 1; i \u0026lt; n; i++) { if (A[i] != A[i - 1]) op1.push_back(i); if (B[i] != B[i - 1]) op2.push_back(i); } if (A[n - 1] != B[n - 1]) op1.push_back(n); reverse(op2.begin(), op2.end()); printf(\u0026#34;%zu \u0026#34;, op1.size() + op2.size()); for (auto i : op1) printf(\u0026#34;%d \u0026#34;, i); for (auto i : op2) printf(\u0026#34;%d \u0026#34;, i); printf(\u0026#34;\\n\u0026#34;); } return 0; } I - CF1382A 题目大意 找到数组 $a,b$ 的最短公共子序列 $c$。\n分析 最短即长度为 $1$，只需找 $a,b$ 中是否出现过相同的元素即可。\nJ - CF1382B 题目大意 两人轮流从下标最小的非空堆中任意的拿取石子，谁拿到最后一个石头谁赢。\n分析 本题非常适合拿来学习 SG 函数，推起来不用动脑子，感兴趣的可以自行了解。这里我们只讲普通推法。\n如果只有一堆石头，先手必胜。\n假设对于给定的石头个数序列 $A_n : a_1,a_2,\\cdots, a_n$，其胜负态是已知的。\n那么在前面插一个 $a_0$，分类讨论有：\n 如果 $a_0 = 1$，没有变数，发生一次先手后手转化。 如果 $a_0 \u0026gt; 1$，如果 $A_n$ 必输，先手可以拿走 $n$ 个，后手承担必输结局。 如果 $A_n$ 必胜，先手可以拿走 $n-1$ 个，自己必胜。  总之，答案之和前缀的 $1$ 的个数有关。\nint main() { int T = rr(); while (T--) { int n = rr(), cnt = 0; bool all_1 = true; for (int i = 0; i \u0026lt; n; i++) { int a = rr(); if (all_1) { if (a != 1) all_1 = false; else cnt++; } } if (all_1) cnt++; printf(\u0026#34;%s\\n\u0026#34;, cnt % 2 == 0 ? \u0026#34;First\u0026#34; : \u0026#34;Second\u0026#34;); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2022-01/hj1/","summary":"非常抱歉，本次比赛对难度估计不当，给大家造成了不好的体验，在此向大家致歉。\nA - CF1379A 题目大意 替换字符串 $s$ 中的 ?，使得出现且仅出现一次 abacaba。\n分析 本题较为难写，因为很难判断恰好出现了一次。但是数据规模很小，可以采用非常暴力的写法。\n一种想法是，枚举每个出现 abacaba 的位置 $i$，把当前 $s[i, i + 6]$ 中的 ? 设为给定串，这样就得到了字符串 $t$。\n然后判断字符串 $t$ 中只出现了一次 abacaba，可以通过 substr 枚举所有长为 $6$ 的子串。\nstring what = \u0026#34;abacaba\u0026#34;; void solve() { int len; string s; cin \u0026gt;\u0026gt; len \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; len - 6; i++) { string tmp = s; for (int j = 0; j \u0026lt; 7; j++) if (tmp[i + j] == \u0026#39;?","title":"ZAFU 2022.01.18 个人赛题解"},{"content":"D. Let's Go Hiking 两人在序列上移动，Qingshan 只能往值更高的地方走，Daniel 只能往低处走。两人不能重叠，求 Qingshan 中有多少可以赢的位置。\n分析 其实我们只用关注上升和下降的序列有多长，而不必关心它们具体是几。\n如果 Qingshan 选边界上的坡，或者不选在坡顶，那么 Daniel 可以紧挨着它，从而必输。\n如果 Qingshan 不选最长的坡，则 Danniel 可以选最长的坡，从而必输。\n如果最长的坡存在没有公共最高点的两个，Danniel 可以避开 Qingshan 选，从而必输。\n剩下的情况只有两种：\n 最长的坡只有一个，Qingshan 只能选在此坡坡顶，Danniel 可以选在靠近坡底的地方，使得两人碰面，从而必输。 最长的坡有两个且有公共最高点，Qingshan 选在坡顶，则可以选择避开 Danniel 下坡，从而必胜。  附：代码，展开\nE. Garden of the Sun 在棋盘的格子中有不连续的 X，请连接使得其满足如下条件\n X 组成的图案是连通的。 X 组成的图案不存在环。  分析 X 不连续是一个比较强的性质。\n构造类似 丰 字形的图案，横与横之间空两行，这样可以使得所有 X 都附在一条横上，且互相不连接。\n接下来考虑如何把横连起来，可以发现只用在第一列、第二列中选一列进行连接即可。\n附：代码，展开\nF. BFS Trees  第一次补题补到 F 耶！什么时候才能在赛中做到 F 呢……\n 我们定义一个图上的生成树是以 $s$ 点为根的 BFS 树，当且仅当：对于任意的节点 $t$，$s\\to t$ 在 BFS 树上的最短路等于图上的最短路。\n定义 $f(i,j)$ 为根可以在 $i$ 且可以在 $j$ 的 BFS 树的个数，求所有的 $f(i,j) \\bmod P$。\n分析 题目有点绕，要好好的读一读。\n注意到一个关键点：若 $i \\to j$ 最短路有两条，而在生成树中只能有一条，则这些被断掉的节点到 $i,j$ 的最短路一定不能同时取到最小值，故答案不存在，即 $f(i,j) = 0$。\n因此 $i \\to j$ 只能有一条路。想象 $i$ 侧剩余的点按照到 $i$ 的距离分成层级，每个点 $k$ 满足 BFS 树条件的接入方式就是连到更近一层的点 $e$，即判据为\n$$ dis(i, e) + 1 = dis(i, k)\\ \\text{且}\\ dis(j, e) + 1 = dis(j, k) $$\n注意到每次接入是独立的，答案即用乘法合并。\n至于判最短路的条数，注意到 $dis(i,k) + dis(k,j) = dis(i,j)$ 即意味着 $k$ 在 $i \\to j$ 的最短路上，计算满足条件的点数是否是 $dis(i,j) + 1$ 即可。\nfor (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026lt;= n; j++) { ll tans = 1, cnt = 0; for (int k = 1; k \u0026lt;= n; k++) { if (f[i][k] + f[j][k] == f[i][j]) { cnt++; } else { int s = 0; for (auto e : G[k]) { s += f[i][e] + 1 == f[i][k] \u0026amp;\u0026amp; f[e][j] + 1 == f[k][j]; } tans = tans * s % P; } } if (cnt != f[i][j] + 1) { tans = 0; } ans[i][j] = ans[j][i] = tans; } } 附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-11/cf1496/","summary":"D. Let's Go Hiking 两人在序列上移动，Qingshan 只能往值更高的地方走，Daniel 只能往低处走。两人不能重叠，求 Qingshan 中有多少可以赢的位置。\n分析 其实我们只用关注上升和下降的序列有多长，而不必关心它们具体是几。\n如果 Qingshan 选边界上的坡，或者不选在坡顶，那么 Daniel 可以紧挨着它，从而必输。\n如果 Qingshan 不选最长的坡，则 Danniel 可以选最长的坡，从而必输。\n如果最长的坡存在没有公共最高点的两个，Danniel 可以避开 Qingshan 选，从而必输。\n剩下的情况只有两种：\n 最长的坡只有一个，Qingshan 只能选在此坡坡顶，Danniel 可以选在靠近坡底的地方，使得两人碰面，从而必输。 最长的坡有两个且有公共最高点，Qingshan 选在坡顶，则可以选择避开 Danniel 下坡，从而必胜。  附：代码，展开\nE. Garden of the Sun 在棋盘的格子中有不连续的 X，请连接使得其满足如下条件\n X 组成的图案是连通的。 X 组成的图案不存在环。  分析 X 不连续是一个比较强的性质。\n构造类似 丰 字形的图案，横与横之间空两行，这样可以使得所有 X 都附在一条横上，且互相不连接。\n接下来考虑如何把横连起来，可以发现只用在第一列、第二列中选一列进行连接即可。\n附：代码，展开\nF. BFS Trees  第一次补题补到 F 耶！什么时候才能在赛中做到 F 呢……\n 我们定义一个图上的生成树是以 $s$ 点为根的 BFS 树，当且仅当：对于任意的节点 $t$，$s\\to t$ 在 BFS 树上的最短路等于图上的最短路。","title":"CF Round 706(Div 2)"},{"content":"过于简单的题不记录。\n洛谷：更新至：2021.11.10(\u0026ndash;.\u0026ndash;)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2021 年 01 月 01-25 |  P3378 堆\n2021 年 02 月 02-28 |  P1216 数字三角形\n2021 年 03 月 03-02 |  P3382 三分法\n03-06 |  P3865 ST 表\n03-17 |  P1162 填涂颜色\n03-17 |  P1019 单词接龙\n03-19 |  P1014 Cantor 表\n03-19 |  P3370 字符串哈希\n03-20 |  P3375 KMP 字符串匹配\n03-20 |  P3374 树状数组 1\n03-20 |  P3368 树状数组 2\n03-28 |  P1177 快速排序\n03-29 |  P2678 跳石头\n03-29 |  P1908 逆序对\n03-30 |  P2602 数字计数\n2021 年 04 月 04-09 |  P1495 中国剩余定理(CRT)/曹冲养猪\n04-11 |  P1706 全排列问题\n04-11 |  P1902 刺杀大使\n04-13 |  P1314 聪明的质检员\n04-13 |  P4838 P哥破解密码\n04-15 |  P5410 扩展 KMP（Z 函数）\n04-22 |  P3372 线段树 1\n04-26 |  P5638 光骓者的荣耀\n04-30 |  P2261 余数求和\n2021 年 05 月 05-19 |  P2522 Problem B\n05-20 |  P1082 同余方程\n05-20 |  P2613 有理数取余\n05-20 |  P2158 仪仗队\n05-24 |  P2303 Longge 的问题\n05-25 |  P5091 扩展欧拉定理\n05-25 |  P2350 外星人\n05-26 |  P3455 ZAP-Queries\n05-26 |  P2257 YY 的 GCD\n05-27 |  P4139 上帝与集合的正确用法\n05-27 |  P2568 GCD\n05-29 |  P4781 拉格朗日插值\n05-30 |  P1886 滑动窗口 / 单调队列\n2021 年 06 月 06-01 |  P3802 小魔女帕琪\n06-01 |  P5104 红包发红包\n06-01 |  P3805 manacher 算法\n2021 年 07 月 07-12 |  P1762 偶数\n07-20 |  P3803 多项式乘法（FFT）\n07-23 |  HDU多校2021-2\n HUD6972 I love 114514 HDU6971 I love max and multiply HDU6965 I love string HDU6961 I love cube  07-28 |  P4173 残缺的字符串\n2021 年 08 月 08-15 |  LOJ6053 简单的函数\n08-15 |  P5325 Min_25筛\n08-15 |  P4213 杜教筛\n08-21 |  P4245 任意模数多项式乘法\n08-24 |  P4238 多项式乘法逆\n08-24 |  P4721 分治 FFT\n2021 年 09 月 09-09 |  P4725 多项式对数函数\n09-09 |  P4726 多项式指数函数\n09-09 |  P5349 幂\n09-22 |  HDU6750 Function\n09-22 |  HDU6537 Neko and function\n09-23 |  HDU6755 Fibonacci Sum\n09-24 |  HDU6833 A Very Easy Math Problem\n09-28 |  P5205 多项式开根\n2021 年 10 月 10-11 |  HDU6955 Xor sum\n10-17 |  P4059 找爸爸\n10-18 |  P3052 Cows in a Skyscraper G\n10-19 |  NC11255B Sample Game\n10-26 |  P5170 类欧几里得算法\n10-28 |  P5171 Earthquake\n10-31 |  P5179 Fraction\n2021 年 11 月 11-02 |  P1393 Mivik 的标题\n11-02 |  P5491 二次剩余\n11-02 |  P5277 多项式开根（加强版）\n11-03 |  P4718 Pollard-Rho 算法\n11-03 |  P5245 多项式快速幂\n11-04 |  P4512 多项式除法\n11-06 |  P5050 多项式多点求值\n11-07 |  P5158 多项式快速插值\n11-08 |  P3846 可爱的质数/BSGS\n11-09 |  P3846 常系数齐次线性递推\n11-10 |  P2657 windy 数\n11-17 |  P3586 LOG\n11-18 |  P4777 扩展中国剩余定理\n2021 年 12 月 12-10 |  P3369 普通平衡树\n12-18 |  P6613 一阶微分方程\n12-20 |  P5748 集合划分计数\n这段时间大概被出题人卡多项式搞自闭了，猛卡常数，甚至读了些论文。现在想想纯属浪费时间。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/log2021/","summary":"过于简单的题不记录。\n洛谷：更新至：2021.11.10(\u0026ndash;.\u0026ndash;)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2021 年 01 月 01-25 |  P3378 堆\n2021 年 02 月 02-28 |  P1216 数字三角形\n2021 年 03 月 03-02 |  P3382 三分法\n03-06 |  P3865 ST 表\n03-17 |  P1162 填涂颜色\n03-17 |  P1019 单词接龙\n03-19 |  P1014 Cantor 表\n03-19 |  P3370 字符串哈希\n03-20 |  P3375 KMP 字符串匹配\n03-20 |  P3374 树状数组 1","title":"2021 年刷题日志"},{"content":"题目大意 在字符集中有 $m$ 个不同的字符，求给定字符串 $S$ 在长度为 $n$ 的字符串的全集中出现的概率。\n分析 参考 Mivik 的字符串公开赛。\n定义 $A$ 类字符串为，在整个字符串中 $S$ 只出现过一次，且恰好 $S$ 出现在末尾的字符串。\n设 $\\{f_i\\}$ 是长度为 $i$ 的字符串中 $A$ 类字符串的个数。再定义 $\\{g_i\\}$ 是长度为 $i$ 的字符串中没有出现过 $S$ 的个数。\n在长为 $i$ 的没有出现过 $S$ 的字符串后面加上一个字符，则可能出现 $S$ 也可能没有出现 $S$。\n$$ m g_i = f_{i+1} + g_{i+1} $$\n定义关于 $S$ 的数列 $\\{s_i\\}$ 为\n$$ s_i = [i \\ \\text{is a period of}\\ S] $$\n即当 $i$ 是 $S$ 的一个循环节时，$s_i$ 为 $1$，否则为 $0$。\n我们在所有未出现过 $S$ 的长为 $n - |S|$ 的字符串后面拼接上 $S$，当 $i$ 是 $S$ 的周期时 $n-i$ 是其完整出现 $S$ 的位置。有\n$$ g_{n - |S|} = \\sum_{i=0}^n f_{n - i} s_{i} $$\n写成生成函数形式，可以得到 $f_i$ 的生成函数\n$$ f(x) = \\frac{x^{|S|}}{x^{|S|} + (1 - m x) s(x)} $$\n我们要计算的是长为 $n$ 的符合要求的字符串总数，即是把字符串填充至 $n$ 的长度即可，即\n$$ E(x) = \\frac{f(x)}{1 - m x} $$\n我们只需计算 $E[n]/m^n$ 即可。循环节可以用 KMP 预处理。\n附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-11/p1393/","summary":"题目大意 在字符集中有 $m$ 个不同的字符，求给定字符串 $S$ 在长度为 $n$ 的字符串的全集中出现的概率。\n分析 参考 Mivik 的字符串公开赛。\n定义 $A$ 类字符串为，在整个字符串中 $S$ 只出现过一次，且恰好 $S$ 出现在末尾的字符串。\n设 $\\{f_i\\}$ 是长度为 $i$ 的字符串中 $A$ 类字符串的个数。再定义 $\\{g_i\\}$ 是长度为 $i$ 的字符串中没有出现过 $S$ 的个数。\n在长为 $i$ 的没有出现过 $S$ 的字符串后面加上一个字符，则可能出现 $S$ 也可能没有出现 $S$。\n$$ m g_i = f_{i+1} + g_{i+1} $$\n定义关于 $S$ 的数列 $\\{s_i\\}$ 为\n$$ s_i = [i \\ \\text{is a period of}\\ S] $$\n即当 $i$ 是 $S$ 的一个循环节时，$s_i$ 为 $1$，否则为 $0$。","title":"P1393 Mivik 的标题"},{"content":"题目大意 求最简分数 $p/q$ 满足\n$$ \\frac{a}{b} \u0026lt; \\frac{p}{q} \u0026lt; \\frac{c}{d} $$\n若有多组解，输出 $q$ 最小的；仍有多组解，输出 $p$ 最小的一组。\n分析 分类讨论：\n 首先当 $\\lfloor a/b \\rfloor + 1 \\leqslant \\lceil c/d \\rceil - 1$ 时，说明两个数之间存在一个整数，直接返回 $p = 1, q = \\lfloor a / b \\rfloor + 1$ 即可。 其次当 $a = 0$ 时，直接解得 $p = 1, q = \\lfloor d / c \\rfloor + 1$。 当 $a \u0026lt; b$ 时，这意味着我们无法直接求解。考虑翻转，转化问题为 $$ \\frac{d}{c} \u0026lt; \\frac{q}{p} \u0026lt; \\frac{b}{a} $$ 递归即可。 当 $a \u0026gt; b$ 时，考虑求解 $$ \\frac{a}{b} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor \u0026lt; \\frac{p}{q} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor \u0026lt; \\frac{c}{d} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor $$ 也是递归即可，还原出结果以后返回。  唯一需要确认的就是，翻转后仍是最优解，考虑反证。\n设存在 $p_0 \\geqslant p$ 且 $q_0 \u0026lt; q$ 使得 $p_0/q_0$ 在翻转前不是最优解，但是翻转后是最优解。从而有 $$ \\frac{d}{c} \u0026lt; \\frac{p_0}{q_0} \u0026lt; \\frac{p_0}{q} \\leqslant \\frac{p}{q} \u0026lt; \\frac{b}{a} $$ 即 $p_0/q$ 是翻转前的更优解，与 $p/q$ 是最优解矛盾。\nvoid solve(ll a, ll b, ll \u0026amp;p, ll \u0026amp;q, ll c, ll d) { ll x = a / b, y = (c - 1) / d; if (x \u0026lt; y) { p = x + 1, q = 1; } else if (a == 0) { p = 1, q = d / c + 1; } else if (a \u0026lt; b) { solve(d, c, q, p, b, a); } else { solve(a - b * x, b, p, q, c - d * x, d); p += q * x; } } 附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5179/","summary":"题目大意 求最简分数 $p/q$ 满足\n$$ \\frac{a}{b} \u0026lt; \\frac{p}{q} \u0026lt; \\frac{c}{d} $$\n若有多组解，输出 $q$ 最小的；仍有多组解，输出 $p$ 最小的一组。\n分析 分类讨论：\n 首先当 $\\lfloor a/b \\rfloor + 1 \\leqslant \\lceil c/d \\rceil - 1$ 时，说明两个数之间存在一个整数，直接返回 $p = 1, q = \\lfloor a / b \\rfloor + 1$ 即可。 其次当 $a = 0$ 时，直接解得 $p = 1, q = \\lfloor d / c \\rfloor + 1$。 当 $a \u0026lt; b$ 时，这意味着我们无法直接求解。考虑翻转，转化问题为 $$ \\frac{d}{c} \u0026lt; \\frac{q}{p} \u0026lt; \\frac{b}{a} $$ 递归即可。 当 $a \u0026gt; b$ 时，考虑求解 $$ \\frac{a}{b} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor \u0026lt; \\frac{p}{q} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor \u0026lt; \\frac{c}{d} - \\left\\lfloor\\frac{a}{b}\\right\\rfloor $$ 也是递归即可，还原出结果以后返回。  唯一需要确认的就是，翻转后仍是最优解，考虑反证。","title":"P5179 Fraction"},{"content":"题目大意 给定 $a,b,c$，求满足方程 $ax + by \\leqslant c$ 的非负整数解的个数。\n分析 令 $n = \\lfloor c / a \\rfloor$，容易推出让我们求的是\n$$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{c - ax}{b} \\right\\rfloor $$\n直接套类欧是不行的，因为系数有负数。其他题解感觉推麻烦了，直接考虑水平翻转，令 $x \\to (n - x)$，代入有\n$$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{ax + c - an}{b} \\right\\rfloor $$\n显然 $c - an$ 是 c % a，于是套类欧即可\n附：代码，展开\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5171/","summary":"题目大意 给定 $a,b,c$，求满足方程 $ax + by \\leqslant c$ 的非负整数解的个数。\n分析 令 $n = \\lfloor c / a \\rfloor$，容易推出让我们求的是\n$$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{c - ax}{b} \\right\\rfloor $$\n直接套类欧是不行的，因为系数有负数。其他题解感觉推麻烦了，直接考虑水平翻转，令 $x \\to (n - x)$，代入有\n$$ n + 1 + \\sum_{x = 0}^{n} \\left\\lfloor \\frac{ax + c - an}{b} \\right\\rfloor $$\n显然 $c - an$ 是 c % a，于是套类欧即可\n附：代码，展开","title":"P5171 Earthquake"},{"content":"题目大意 给定生成 $1$ 到 $n$ 数字的概率分布，不断生成随机数 $x$ 直到 $x$ 不是已经生成过的最大的数停止，求生成次数平方的期望。\n分析 设期望的随机次数为 $f_x = E(x)$，我们需要计算的次数为 $g_x = E(x^2)$。\n关于 $f_i$ 的 DP 是显然的，计算有\n$$ f_x = \\sum_{i = 1}^{x - 1} p_i + \\sum_{i = x}^n p_i(1 + f_i) = 1 + \\sum_{i = x}^n p_i f_i $$\n容易观察到\n$$ f_{x + 1} =(1 - p_x) f_x \\Rightarrow f_x = \\prod_{i = x}^n \\frac{1}{1 - p_x} $$\n接下来需要一个套路\n$$ E((x + 1)^2) = E(x^2) + 2 E(x) + 1 $$\n类似的可以推得\n$$ g_x = \\sum_{i = 1}^{x - 1} p_i + \\sum_{i = x}^n p_i(g_i + 2 f_i + 1) = 1\n \\sum_{i = x}^n p_i g_i + 2 \\sum_{i = x}^n p_i f_i = \\sum_{i = x}^n p_i g_i + 2 f_x - 1 $$  最终答案即是\n$$ ans = \\sum_{i = 1}^n p_i(g_i + 2 f_i + 1) = g_1 $$\n至此，倒着递推已经可以线性求解了。但是我们还可以继续优化，逐项相减有\n$$ g_{x + 1} - g_x = 2(f_{x + 1} - f_x) - p_x g_x = - 2 p_x f_x - p_x g_x $$\n即\n$$ \\frac{g_x}{f_x} - \\frac{g_{x + 1}}{f_{x + 1}} = \\frac{2}{1 - p_x} - 2 $$\n因此\n$$ {\\rm ans} = g_1 = f_1 \\left( \\frac{g_n}{f_n} - 2(n - 1) + 2 \\sum_{i = 1}^{n - 1} \\frac{1}{1 - p_x} \\right) = \\left( \\prod_{i = x}^n \\frac{1}{1 - p_x} \\right) \\left( 1 + 2 \\sum_{i = 1}^n \\frac{1}{1 - p_x} - 2 n \\right) $$\n至此，我们可以 $O(n)$ 的解决问题。\n#define ACM_MOD 998244353 const ll mod = ACM_MOD; #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34; ll p[10086]; int main() { ll n = rr(), sum = 0; for (int i = 1; i \u0026lt;= n; i++) p[i] = rr(), sum = (sum + p[i]) % mod; sum = inv(sum); for (int i = 1; i \u0026lt;= n; i++) { p[i] = p[i] * sum % mod; p[i] = inv(mod + 1 - p[i]); } ll ans = 1, w = mod - n; for (int i = 1; i \u0026lt;= n; i++) { ans = ans * p[i] % mod; w = (w + p[i]) % mod; } ans = ans * (1 + 2 * w) % mod; printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 我们经过了很长的化简过程才导出这一结果，实际上生成函数更为快捷。\n设 $f(x)$ 是生成长度为 $i$ 的非递减序列的生成函数，即 $P(len \u0026gt; i)$，可以推出\n$$ f(x) = \\prod_{i = 1}^n \\frac{1}{1 - p_i x} $$\n而我们需要求\n$$ \\sum_{i = 1}^{\\infty} (f_{i - 1} - f_i) i^2 = \\sum_{i = 0}^{\\infty} f_i (2 i + 1) = 2 f'(1) + f(1) $$\n化简即可得到上式。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/nc11255b/","summary":"题目大意 给定生成 $1$ 到 $n$ 数字的概率分布，不断生成随机数 $x$ 直到 $x$ 不是已经生成过的最大的数停止，求生成次数平方的期望。\n分析 设期望的随机次数为 $f_x = E(x)$，我们需要计算的次数为 $g_x = E(x^2)$。\n关于 $f_i$ 的 DP 是显然的，计算有\n$$ f_x = \\sum_{i = 1}^{x - 1} p_i + \\sum_{i = x}^n p_i(1 + f_i) = 1 + \\sum_{i = x}^n p_i f_i $$\n容易观察到\n$$ f_{x + 1} =(1 - p_x) f_x \\Rightarrow f_x = \\prod_{i = x}^n \\frac{1}{1 - p_x} $$\n接下来需要一个套路\n$$ E((x + 1)^2) = E(x^2) + 2 E(x) + 1 $$","title":"NC11255B Sample Game"},{"content":"题目大意 有 $n$ 头牛坐电梯，重量分别为 $c_i$，电梯的最大限额是 $W$，求最少分多少次能够全部上去。\n分析 注意 $n \\leqslant 18$，枚举全排列是不行的。考虑用状态压缩，将第 $j$ 头奶牛的选和不选用状态 $i$ 的第 $j$ 位数字表示。设 $f_i$ 表示状态为 $i$ 时最小乘电梯次数，$g_i$ 表示此状态下最新那个电梯已经有的重量。\n 首先令 cow = i \u0026lt;\u0026lt; (j - 1)，若 i \u0026amp; cow 为 $1$ 则说明这个奶牛已经坐上电梯了，不计算。 当 $W - g_i \\geqslant c_i$ 时，最后那个电梯坐的下这头牛。 当 $W - g_i \u0026lt; c_i$ 时，只能新开一个电梯。  还是代码更清晰\nconst int maxn = 18; ll ci[maxn]; ll ff[1 \u0026lt;\u0026lt; maxn], gg[1 \u0026lt;\u0026lt; maxn]; int main() { ll n = rr(), W = rr(); for (int i = 1; i \u0026lt;= n; i++) ci[i] = rr(); fill_n(ff, 1 \u0026lt;\u0026lt; maxn, n); fill_n(gg, 1 \u0026lt;\u0026lt; maxn, W); ff[0] = 1, gg[0] = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { for (int j = 1; j \u0026lt;= n; j++) { ll cow = 1 \u0026lt;\u0026lt; (j - 1); if (i \u0026amp; cow) continue; if (W - gg[i] \u0026gt;= ci[j]) { ff[i | cow] = ff[i]; gg[i | cow] = min(gg[i | cow], gg[i] + ci[j]); } else if (W - gg[i] \u0026lt; ci[j] \u0026amp;\u0026amp; ff[i | cow] \u0026gt;= ff[i] + 1) { ff[i | cow] = ff[i] + 1; gg[i | cow] = min(gg[i | cow], ci[j]); } } } printf(\u0026#34;%lld\u0026#34;, ff[(1 \u0026lt;\u0026lt; n) - 1]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p3052/","summary":"题目大意 有 $n$ 头牛坐电梯，重量分别为 $c_i$，电梯的最大限额是 $W$，求最少分多少次能够全部上去。\n分析 注意 $n \\leqslant 18$，枚举全排列是不行的。考虑用状态压缩，将第 $j$ 头奶牛的选和不选用状态 $i$ 的第 $j$ 位数字表示。设 $f_i$ 表示状态为 $i$ 时最小乘电梯次数，$g_i$ 表示此状态下最新那个电梯已经有的重量。\n 首先令 cow = i \u0026lt;\u0026lt; (j - 1)，若 i \u0026amp; cow 为 $1$ 则说明这个奶牛已经坐上电梯了，不计算。 当 $W - g_i \\geqslant c_i$ 时，最后那个电梯坐的下这头牛。 当 $W - g_i \u0026lt; c_i$ 时，只能新开一个电梯。  还是代码更清晰\nconst int maxn = 18; ll ci[maxn]; ll ff[1 \u0026lt;\u0026lt; maxn], gg[1 \u0026lt;\u0026lt; maxn]; int main() { ll n = rr(), W = rr(); for (int i = 1; i \u0026lt;= n; i++) ci[i] = rr(); fill_n(ff, 1 \u0026lt;\u0026lt; maxn, n); fill_n(gg, 1 \u0026lt;\u0026lt; maxn, W); ff[0] = 1, gg[0] = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { for (int j = 1; j \u0026lt;= n; j++) { ll cow = 1 \u0026lt;\u0026lt; (j - 1); if (i \u0026amp; cow) continue; if (W - gg[i] \u0026gt;= ci[j]) { ff[i | cow] = ff[i]; gg[i | cow] = min(gg[i | cow], gg[i] + ci[j]); } else if (W - gg[i] \u0026lt; ci[j] \u0026amp;\u0026amp; ff[i | cow] \u0026gt;= ff[i] + 1) { ff[i | cow] = ff[i] + 1; gg[i | cow] = min(gg[i | cow], ci[j]); } } } printf(\u0026#34;%lld\u0026#34;, ff[(1 \u0026lt;\u0026lt; n) - 1]); return 0; } ","title":"P3052 Cows in a Skyscraper G"},{"content":"题目大意 给定两串 DNA 序列，可以在其中任意插空格，然后逐位比较，当两位都是字母时查表得到相似度。\n长度为 $k$ 的空格有额外相似度 $- A - B(k - 1)$。求两序列的最大相似度。\n分析 若不考虑空格的贡献，容易想到二维 DP，记 ${\\rm DP}[i,j]$ 是 $A$ 串到位置 $i$ 同时 $B$ 串到位置 $j$ 时最大的相似度，有\n$$ {\\rm DP}[i, j] = \\max\\{ {\\rm DP}[i - 1, j - 1] + D[i, j], {\\rm DP}[i - 1, j], {\\rm DP}[i, j - 1] \\} $$\n当我们考虑空格的贡献时，可以发现空格的额外贡献只与前面一位有关。若两个序列此位都是空格，则把去掉后相似度一定会增加，故只有三种可能：设 ${\\rm DP}_0$ 是结尾没有空格；${\\rm DP}_1$ 是空格在 $A$ 串；${\\rm DP}_2$ 是空格在 $B$ 串。\n思考最后一个空格的转移方式，自然有方程\n$$ \\begin{aligned} {\\rm DP}_0[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i - 1, j - 1], {\\rm DP}_1[i - 1, j - 1], {\\rm DP}_2[i - 1, j - 1] \\} + D[i, j] \\\\ {\\rm DP}_1[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i, j - 1] - A, {\\rm DP}_1[i, j - 1]- B, {\\rm DP}_2[i, j - 1] - A\\} \\\\ {\\rm DP}_2[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i - 1, j] - A, {\\rm DP}_1[i - 1, j] - A, {\\rm DP}_2[i, j - 1] - B \\} \\\\ \\end{aligned} $$\n随手加滚动数组 WA 了好久，发现每次都要清空为 -INF，否则会 WA。\n#include \u0026#34;template/index.hpp\u0026#34; const int maxn = 3000 + 10; int dp_1[maxn][3], dp_2[maxn][3]; char sa[maxn], sb[maxn]; int D[5][5]; int DNA(char c); // AGTC -\u0026gt; 1..4  int main() { scanf(\u0026#34;%s %s\u0026#34;, sa + 1, sb + 1); int n = strlen(sa + 1), m = strlen(sb + 1); for (int i = 1; i \u0026lt;= 4; i++) for (int j = 1; j \u0026lt;= 4; j++) D[i][j] = rr(); int A = rr(), B = rr(), *p; memset(dp_1, -0x7f, sizeof(dp_1)); memset(dp_2, -0x7f, sizeof(dp_2)); auto \u0026amp;dp1 = dp_1, \u0026amp;dp2 = dp_2; dp2[0][0] = 0; for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { int da = DNA(sa[i]), db = DNA(sb[j]); if (i \u0026gt; 0 \u0026amp;\u0026amp; j \u0026gt; 0) { p = dp1[j - 1]; dp2[j][0] = max3(p[0], p[1], p[2]) + D[da][db]; } if (i \u0026gt; 0) { p = dp1[j]; dp2[j][2] = max3(p[0] - A, p[1] - A, p[2] - B); } if (j \u0026gt; 0) { p = dp2[j - 1]; dp2[j][1] = max3(p[0] - A, p[1] - B, p[2] - A); } } swap(dp1, dp2); memset(dp2, -0x7f, sizeof(dp2)); } p = dp1[m]; int ans = max3(p[0], p[1], p[2]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/p4059/","summary":"题目大意 给定两串 DNA 序列，可以在其中任意插空格，然后逐位比较，当两位都是字母时查表得到相似度。\n长度为 $k$ 的空格有额外相似度 $- A - B(k - 1)$。求两序列的最大相似度。\n分析 若不考虑空格的贡献，容易想到二维 DP，记 ${\\rm DP}[i,j]$ 是 $A$ 串到位置 $i$ 同时 $B$ 串到位置 $j$ 时最大的相似度，有\n$$ {\\rm DP}[i, j] = \\max\\{ {\\rm DP}[i - 1, j - 1] + D[i, j], {\\rm DP}[i - 1, j], {\\rm DP}[i, j - 1] \\} $$\n当我们考虑空格的贡献时，可以发现空格的额外贡献只与前面一位有关。若两个序列此位都是空格，则把去掉后相似度一定会增加，故只有三种可能：设 ${\\rm DP}_0$ 是结尾没有空格；${\\rm DP}_1$ 是空格在 $A$ 串；${\\rm DP}_2$ 是空格在 $B$ 串。\n思考最后一个空格的转移方式，自然有方程\n$$ \\begin{aligned} {\\rm DP}_0[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i - 1, j - 1], {\\rm DP}_1[i - 1, j - 1], {\\rm DP}_2[i - 1, j - 1] \\} + D[i, j] \\\\ {\\rm DP}_1[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i, j - 1] - A, {\\rm DP}_1[i, j - 1]- B, {\\rm DP}_2[i, j - 1] - A\\} \\\\ {\\rm DP}_2[i, j] \u0026amp;= \\max\\{ {\\rm DP}_0[i - 1, j] - A, {\\rm DP}_1[i - 1, j] - A, {\\rm DP}_2[i, j - 1] - B \\} \\\\ \\end{aligned} $$","title":"P4059 找爸爸"},{"content":"题目大意 给定整数序列 $\\{a_n\\}$，寻找满足区间异或和大于等于 $k$ 的连续序列中最短的。\n若有多个同样长度的答案，输出位置靠前的，若不存在输出 -1。\n分析 看到异或最值就应该想到 01trie。做前缀异或和，这样我们的问题就变成找到最靠近的两个数，其异或大于等于 $k$。\n因为要求位置最靠前的，所以我选择倒着遍历。当遍历到第 $i$ 个数 $a_i$ 时，字典树已经维护好此位置之后的数据，即每个值出现最左边的位置。\nconst int maxn = 1e5 + 10, o = 30 - 1; int trie[maxn * 30][2], val[maxn * 30], tot, n, k; void insert(int ai, int i) { int p = 1; for (int j = o; j \u0026gt;= 0; j--) { int ch = (ai \u0026gt;\u0026gt; j) \u0026amp; 1; if (trie[p][ch] == 0) trie[p][ch] = ++tot; p = trie[p][ch]; val[p] = i; } } 我们只需从高位到低位遍历第 $j$ 位，分类讨论：\n 若 $k[j] = 1$，则说明 $a_i[j] \\oplus a_u[j]$ 只能为 $1$，在字典树中选择 $a_i[j] \\oplus 1$ 深入（什么都不做）。 若 $k[j] = 0$，那么若 $a_i[j] \\oplus a_u[j] = 1$ 则一定大于 $k$，记录字典树中 $a_i[j] \\oplus 1$ 的值，然后在字典树中选择 $a_i[j]$ 深入。  int search(int ai, int i) { int p = 1, res = -1; for (int j = o; j \u0026gt;= 0; j--) { int x1 = (k \u0026gt;\u0026gt; j) \u0026amp; 1, x2 = (ai \u0026gt;\u0026gt; j) \u0026amp; 1; if (x1 == 0) { int tp = trie[p][x2 ^ 1]; if (tp \u0026gt; 0) res = max(res, val[tp]); } p = trie[p][x1 ^ x2]; if (p == 0) break; } if (p \u0026gt; 0) res = max(res, val[p]); return res; } 因为我们是从前往后查的，因此同样长度中总是先查到考前的，汇总有\nint main() { int ttt = rr(); while (ttt--) { n = rr(), k = rr(), tot = 1; int anl = -1, anr = n + 1, pre_sum = 0; fill_n(trie[0], 2 * o * n, 0); for (int i = 1; i \u0026lt;= n; i++) { int ai = pre_sum ^ rr(); int res = search(ai, i); if (res \u0026gt;= 0 \u0026amp;\u0026amp; i - res \u0026lt; anr - anl) anl = res, anr = i; insert(ai, i); pre_sum = ai; } if (anl \u0026gt;= 0) printf(\u0026#34;%d %d\\n\u0026#34;, anl + 1, anr); else printf(\u0026#34;-1\\n\u0026#34;); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-10/hdu6955/","summary":"题目大意 给定整数序列 $\\{a_n\\}$，寻找满足区间异或和大于等于 $k$ 的连续序列中最短的。\n若有多个同样长度的答案，输出位置靠前的，若不存在输出 -1。\n分析 看到异或最值就应该想到 01trie。做前缀异或和，这样我们的问题就变成找到最靠近的两个数，其异或大于等于 $k$。\n因为要求位置最靠前的，所以我选择倒着遍历。当遍历到第 $i$ 个数 $a_i$ 时，字典树已经维护好此位置之后的数据，即每个值出现最左边的位置。\nconst int maxn = 1e5 + 10, o = 30 - 1; int trie[maxn * 30][2], val[maxn * 30], tot, n, k; void insert(int ai, int i) { int p = 1; for (int j = o; j \u0026gt;= 0; j--) { int ch = (ai \u0026gt;\u0026gt; j) \u0026amp; 1; if (trie[p][ch] == 0) trie[p][ch] = ++tot; p = trie[p][ch]; val[p] = i; } } 我们只需从高位到低位遍历第 $j$ 位，分类讨论：","title":"HDU6955 Xor sum"},{"content":"题目大意 即求\n$$ S (n) = \\sum^n_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k f (\\gcd \\{ a_x \\}) \\gcd \\{ a_x \\} $$\n我自己随便简写了，全打太麻烦了。\n分析 这东西看着很吓人，其实是纸老虎。首先 $f(x) = \\mu(x)^2$。提出 $\\gcd$ 有\n$$ \\begin{aligned} S (n) \u0026amp; =\\sum_{d=1}^{n}\\sum^{n}_{\\{ a_{x}\\}=1}(\\prod_{j=1}^{x}a_{j})^{k}{\\mu}(d)^{2}d [gcd \\{ a_{x}\\} =d]\\\\ \u0026amp; =\\sum_{d=1}^{n}{\\mu}(d)^{2}d^{k x+1}\\sum^{n/d}_{\\{ a_{x}\\} =1}(\\prod_{j=1}^{x}a_{j})^{k}[gcd \\{ a_{x}\\} =1] \\end{aligned} $$\n对后面这部分反演有\n$$ \\begin{aligned} \u0026amp; \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t \\mid \\gcd \\{ a_x \\}} \\mu (t) \\right)\\\\ = \u0026amp; \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t = 1}^{n / d} [t \\mid \\gcd \\{ a_x \\}] \\mu (t) \\right)\\\\ = \u0026amp; \\sum_{t = 1}^{n / d} \\mu (t) t^{k x} \\sum^{n / d t}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\end{aligned} $$\n代回去，枚举 $T = d t$\n$$ \\begin{aligned} S (n) \u0026amp; = \\sum_{d = 1}^n d \\mu (d)^2 (d t)^{k x} \\sum_{t = 1}^{n / d} \\mu (t) \\sum^{n / d t}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k\\\\ \u0026amp; = \\sum_{T = 1}^n \\sum_{d \\mid T} d \\mu (d)^2 T^{k x} \\mu \\left(\\frac{T}{d} \\right) \\sum^{n / T}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k\\\\ \u0026amp; = \\sum_{T = 1}^n T^{k x} \\left( \\sum^{n / T}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\right) \\sum_{d \\mid T} d \\mu (d)^2 \\mu \\left( \\frac{T}{d} \\right)\\\\ \u0026amp; = \\sum_{T = 1}^n T^{k x} \\left( \\sum^{n / T}_{i = 1} i^k \\right)^x \\sum_{d \\mid T} d \\mu (d)^2 \\mu \\left( \\frac{T}{d} \\right) \\end{aligned} $$\n到这里已经差不多化完了。令\n$$ G (x) = \\sum^x_{i = 1} i^k, H (x) = \\sum_{d \\mid x} d \\mu (d)^2 \\mu \\left( \\frac{x}{d} \\right) $$\n其中 $G (x)$ 显然可以预处理，而 $H (x)$ 是积性函数的卷积，故也是积性函数，其中\n$$ H (p^c) = \\begin{cases} p - 1,\u0026amp; c = 1\\\\ -p, \u0026amp; c = 2 \\\\ 0, \u0026amp; c \u0026gt; 2 \\end{cases} $$\n可以线性筛得到。\nconst ll maxn = 2e5 + 86; const ll mod = 1e9 + 7; #define ACM_MOD mod  bool notp[maxn + 10]; int prime[maxn/10 + 10], cnt; ll hh[maxn + 10]; void sieve(int n) { hh[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { if (!notp[i]) { prime[++cnt] = i; hh[i] = i - 1; } int t = n / i; for (int j = 1; j \u0026lt;= cnt;j++) { int pj = prime[j], ti = i * pj; if (pj \u0026gt; t) break; notp[ti] = true; if (i % pj == 0) { int tj = i / pj; if (tj % pj != 0) { hh[ti] = hh[tj] * (mod - pj) % mod; } else { hh[ti] = 0; } break; } hh[ti] = hh[i] * hh[pj] % mod; } } } 总之\n$$ S (n) = \\sum_{T = 1}^n T^{k x} H (T) G \\left( \\left\\lfloor \\frac{n}{T} \\right\\rfloor \\right)^x $$\n可以用整数分块。\n#include \u0026#34;template/basic/qpow.hpp\u0026#34; ll gg[maxn + 10]; void pre(ll k, ll x) { sieve(maxn); for (ll i = 1; i \u0026lt;= maxn; i++) { gg[i] = (gg[i - 1] + qpow(i, k)) % mod; } for (ll i = 1; i \u0026lt;= maxn; i++) { hh[i] = (hh[i - 1] + qpow(i, k * x % (mod - 1)) * hh[i]) % mod; gg[i] = qpow(gg[i], x); } } int main() { ll ttt = rr(), k = rr(), x = rr(); pre(k, x); while(ttt--) { ll n = rr(); ll ans = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ll tsum = hh[r] - hh[l - 1] + mod; tsum = tsum * gg[n / l] % mod; ans = ans + tsum; } printf(\u0026#34;%lld\\n\u0026#34;, ans % mod); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6833/","summary":"题目大意 即求\n$$ S (n) = \\sum^n_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k f (\\gcd \\{ a_x \\}) \\gcd \\{ a_x \\} $$\n我自己随便简写了，全打太麻烦了。\n分析 这东西看着很吓人，其实是纸老虎。首先 $f(x) = \\mu(x)^2$。提出 $\\gcd$ 有\n$$ \\begin{aligned} S (n) \u0026amp; =\\sum_{d=1}^{n}\\sum^{n}_{\\{ a_{x}\\}=1}(\\prod_{j=1}^{x}a_{j})^{k}{\\mu}(d)^{2}d [gcd \\{ a_{x}\\} =d]\\\\ \u0026amp; =\\sum_{d=1}^{n}{\\mu}(d)^{2}d^{k x+1}\\sum^{n/d}_{\\{ a_{x}\\} =1}(\\prod_{j=1}^{x}a_{j})^{k}[gcd \\{ a_{x}\\} =1] \\end{aligned} $$\n对后面这部分反演有\n$$ \\begin{aligned} \u0026amp; \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t \\mid \\gcd \\{ a_x \\}} \\mu (t) \\right)\\\\ = \u0026amp; \\sum^{n / d}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\left( \\sum_{t = 1}^{n / d} [t \\mid \\gcd \\{ a_x \\}] \\mu (t) \\right)\\\\ = \u0026amp; \\sum_{t = 1}^{n / d} \\mu (t) t^{k x} \\sum^{n / d t}_{\\{ a_x \\} = 1} \\left( \\prod_{j = 1}^x a_j \\right)^k \\end{aligned} $$","title":"HDU6833 A Very Easy Math Problem"},{"content":"题目大意 设 Fibonacci 数列第 $i$ 项为 $F_i$，求\n$$ S = \\sum_{i = 0}^n (F_{i c})^k $$\n分析 由特征方程法，设\n$$ x^2 + x - 1 = 0 \\Longrightarrow A, B = \\frac{1 \\pm \\sqrt{5}}{2} $$\n因此 Fibonacci 通项公式即可表示为\n$$ F_n = \\frac{A^n - B^n}{A - B} $$\n根据二次剩余的知识，模意义下是可以开方的。因此\n$$ (F_{i c})^k = \\left( \\frac{A^{i c} - B^{i c}}{A - B} \\right)^k = \\frac{1}{(A - B)^k} \\sum_{j = 0}^k \\binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$\n求和有\n$$ (A - B)^k S = (A - B)^k \\sum_{i = 0}^n (F_{i c})^k = \\sum_{i = 0}^n \\sum_{j = 0}^k \\binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$\n换序求和，即是等比数列（公比可能为 $1$，需要特判）\n$$ \\begin{aligned} (A-B)^{k}S \u0026amp; =\\sum_{j=0}^{k}\\binom{k}{j}(-1)^{k-j}\\sum_{i=0}^{n}(A^{j}B^{k-j})^{ic}\\\\ \u0026amp; =\\sum_{j=0}^{k}\\binom{k}{j}(-1)^{k-j}{\\frac{(A^{j}B^{k-j})^{c(n+1)}-1}{(A^{j}B^{k-j})^{c}-1}} \\end{aligned} $$\n直接计算会 TLE，需要用中间变量简化\n$$ \\frac{(A^j B^{k - j})^{c (n + 1)} - 1}{(A^j B^{k - j})^c - 1} = \\frac{B^{k c (n + 1)} {(A B^{- 1})^{c (n + 1) j}} - 1}{B^{k c} (A B^{- 1})^{c j} - 1} $$\n用中间变量在循环中递推，再加上 Euler 降幂，就可以过题了。\nconst ll mod = 1e9 + 9, phi_mod = mod - 1; const ll maxn = 1e5 + 10; #define ACM_MOD mod  #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34; const ll sqrt_5 = 383008016; const ll A = (1 + sqrt_5) * inv(2) % mod, B = (1 - sqrt_5 + mod) * inv(2) % mod; ll euler_pow(ll a, ll b) { return qpow(a, b % phi_mod); } ll fac[maxn], ind[maxn]; void pre(ll n) { fac[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) { fac[i] = fac[i - 1] * i % mod; } ind[n] = inv(fac[n]); for (ll i = n - 1; i \u0026gt;= 0; i--) { ind[i] = ind[i + 1] * (i + 1) % mod; } } ll binom(ll a, ll b) { if (b \u0026gt; a) b = a - b; return fac[a] * ind[b] % mod * ind[a - b] % mod; } int main() { pre(1e5 + 1); ll ttt = rr(); while (ttt--) { ll n = rr(), c = rr(), k = rr(); ll step1 = euler_pow(A * inv(B) % mod, c), step2 = euler_pow(step1, n + 1); ll T1 = euler_pow(B, c % phi_mod * k), T2 = euler_pow(T1, n + 1); ll ans = 0; for (ll j = 0; j \u0026lt;= k; j++) { ll tsum = binom(k, j); if (T1 != 1) { tsum = tsum * (T2 - 1) % mod * inv(T1 - 1) % mod; } else { tsum = (n + 1) % mod * tsum % mod; } if ((k - j) % 2 == 1) tsum *= -1; ans = (ans + tsum + mod) % mod; T1 = T1 * step1 % mod, T2 = T2 * step2 % mod; } ans = ans % mod * euler_pow(inv(A - B), k) % mod; printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6755/","summary":"题目大意 设 Fibonacci 数列第 $i$ 项为 $F_i$，求\n$$ S = \\sum_{i = 0}^n (F_{i c})^k $$\n分析 由特征方程法，设\n$$ x^2 + x - 1 = 0 \\Longrightarrow A, B = \\frac{1 \\pm \\sqrt{5}}{2} $$\n因此 Fibonacci 通项公式即可表示为\n$$ F_n = \\frac{A^n - B^n}{A - B} $$\n根据二次剩余的知识，模意义下是可以开方的。因此\n$$ (F_{i c})^k = \\left( \\frac{A^{i c} - B^{i c}}{A - B} \\right)^k = \\frac{1}{(A - B)^k} \\sum_{j = 0}^k \\binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$","title":"HDU6755 Fibonacci Sum"},{"content":"题目大意 定义 $f(n, k)$ 为满足如下要求的，长度为 $k$ 的数列 $\\\\{a_i\\\\}$ 个数：\n 要求每个数字都大于 $1$； 数列各项之积恰为 $n$。  求其前缀和 $S(n, k) = \\sum f(i, k)$。\n分析 多组输入好坑啊。\n先允许 $a_i=1$，将结果记为 $g(n,k)$，容易利用隔板法求得\n$$ g (p^c, k) = \\binom{t + k - 1}{k - 1} $$\n对于多个质因数，显然其贡献是相互独立的，即 $g$ 是积性函数。考虑选取 $i$ 个数令其 $a_i\u0026gt;1$，枚举有\n$$ g (n, k) = \\sum_{i = 1}^k \\binom{n}{i} f (n, i) $$\n二项式反演（或者直接容斥）有\n$$ f (n, k) = \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} g (n, i) $$\n求和并换序\n$$ \\begin{aligned} \\sum_{i = 1}^x f (i, k) \u0026amp;= \\sum_{n = 1}^x \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} g (n, i) \\\\ \u0026amp;= \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} \\sum_{n = 1}^x g (n, i) \\end{aligned} $$\n后面即是 $g$ 的前缀和，可以用 Min25 筛。\nconst ll mod = 1e9 + 7; const int maxn = 1e6 + 5; ll cc[70][70]; void pre_binom(ll n) { for (ll i = 0; i \u0026lt;= n; i++) { cc[i][0] = 1; for (ll j = 1; j \u0026lt;= i; j++) { cc[i][j] = (cc[i - 1][j - 1] + cc[i - 1][j]) % mod; } } } namespace min25 { ll n, prime[maxn], cnt, w[maxn], c[maxn]; ll sqrt_n, m, kkk; ll f_p(ll e, ll k) { return cc[e + k - 1][k - 1]; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } void pre(ll _n) { n = _n, sqrt_n = sqrt(n + 0.01); m = cnt = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { w[++m] = r = n / (n / l); c[m] = r - 1; } for (ll p = 2; p \u0026lt;= sqrt_n; p++) { if (c[p] != c[p - 1]) { prime[++cnt] = p; for (ll j = m; w[j] \u0026gt;= p * p; j--) { c[j] -= c[id(w[j] / p)] - c[p - 1]; } } } } ll F(ll n, int k, int tk) { if (n \u0026lt;= prime[k]) return 0; ll ret = (c[id(n)] - c[prime[k]]) * tk; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int e = 1; pk * pi \u0026lt;= n; e++, pk *= pi) ret = (ret + f_p(e, tk) * F(n / pk, i, tk) + f_p(e + 1, tk)); } return ret % mod; } ll solve(ll n, ll k) { return F(n, 0, k); } } // namespace min25  int main() { ll x, k; pre_binom(70); while (scanf(\u0026#34;%lld %lld\u0026#34;, \u0026amp;x, \u0026amp;k) != EOF) { min25::pre(x); ll ans = 0; for (ll i = 1; i \u0026lt;= k; i++) { if (cc[k][i] == 0) continue; ll tsum = cc[k][i] * min25::solve(x, i); if ((k - i) % 2 == 1) tsum *= -1; ans += tsum; } printf(\u0026#34;%lld\\n\u0026#34;, (ans % mod + mod) % mod); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6537/","summary":"题目大意 定义 $f(n, k)$ 为满足如下要求的，长度为 $k$ 的数列 $\\\\{a_i\\\\}$ 个数：\n 要求每个数字都大于 $1$； 数列各项之积恰为 $n$。  求其前缀和 $S(n, k) = \\sum f(i, k)$。\n分析 多组输入好坑啊。\n先允许 $a_i=1$，将结果记为 $g(n,k)$，容易利用隔板法求得\n$$ g (p^c, k) = \\binom{t + k - 1}{k - 1} $$\n对于多个质因数，显然其贡献是相互独立的，即 $g$ 是积性函数。考虑选取 $i$ 个数令其 $a_i\u0026gt;1$，枚举有\n$$ g (n, k) = \\sum_{i = 1}^k \\binom{n}{i} f (n, i) $$\n二项式反演（或者直接容斥）有\n$$ f (n, k) = \\sum_{i = 1}^k (- 1)^{k - i} \\binom{k}{i} g (n, i) $$","title":"HDU6537 Neko and function"},{"content":"题目大意 定义\n$$ f (n) = \\sum_{d \\mid n} d \\left[ \\gcd \\left( d, \\frac{n}{d} \\right) = 1 \\right] $$\n求其前缀和 $S(n)$。\n分析 首先 Min25 筛是过不了的，内存不够。先推式子\n$$ \\begin{aligned} S (n) \u0026amp;= \\sum_{i = 1}^n \\sum_{d \\mid i} d \\left[ \\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026amp;= \\sum_{d = 1}^n \\sum_{i = 1}^n d [d \\mid i] \\left[\\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026amp;= \\sum_{d = 1}^n \\sum_{i = 1}^{n / d} d [\\gcd (i, d) = 1] \\end{aligned} $$\n看到 $\\gcd = 1$ 就应该想起来 Mobius 反演，容易化简有\n$$ S (n) = \\sum_{d = 1}^n \\sum_{i = 1}^{n / d} d \\sum_{u \\mid \\gcd (i, d)} \\mu(u) = \\sum_{u = 1}^{\\sqrt{n}} u \\mu (u) \\sum_{d = 1}^{n / u^2} d \\left\\lfloor \\frac{n}{d u^2} \\right\\rfloor $$\n用数论分块即可，计算复杂度 $O ( \\sqrt{n} \\log n )$。\nconst ll maxn = 1e6 + 20; const ll mod = 1e9 + 7; bool notp[maxn]; int prime[maxn / 10], cnt; ll mu[maxn]; void sieve(int n); // 筛 Mobius 函数  ll g[maxn]; ll G(ll n) { if (n \u0026lt;= 1e6 \u0026amp;\u0026amp; g[n] \u0026gt; 0) return g[n]; // 不做记忆化会 T  __int128_t ret = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = n / (n / l); __int128_t t = __int128_t(l + r) * (r - l + 1) / 2; ret += t * (n / l); } if (n \u0026lt;= 1e6) g[n] = ret % mod; return ret % mod; } int main() { ll ttt = rr(); sieve(1e6 + 1); for (ll i = 1; i \u0026lt;= 1e6+1; i++) { mu[i] = (mu[i - 1] + mu[i] * i) % mod; } while (ttt--) { ll n = rr(), sn = sqrt(n * 1.0); __int128_t ans = 0; for (ll l = 1, r; l \u0026lt;= sn; l = r + 1) { ll t = n / l / l; r = sqrt(n / (n / l / l) * 1.0); ans += (mu[r] - mu[l - 1]) * G(n / l / l); } ans = (ans % mod + mod) % mod; printf(\u0026#34;%lld\\n\u0026#34;, ll(ans)); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6750/","summary":"题目大意 定义\n$$ f (n) = \\sum_{d \\mid n} d \\left[ \\gcd \\left( d, \\frac{n}{d} \\right) = 1 \\right] $$\n求其前缀和 $S(n)$。\n分析 首先 Min25 筛是过不了的，内存不够。先推式子\n$$ \\begin{aligned} S (n) \u0026amp;= \\sum_{i = 1}^n \\sum_{d \\mid i} d \\left[ \\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026amp;= \\sum_{d = 1}^n \\sum_{i = 1}^n d [d \\mid i] \\left[\\gcd \\left( d, \\frac{i}{d} \\right) = 1 \\right] \\\\ \u0026amp;= \\sum_{d = 1}^n \\sum_{i = 1}^{n / d} d [\\gcd (i, d) = 1] \\end{aligned} $$","title":"HDU6750 Function"},{"content":"题目大意 即求\n$$ S = \\sum_{n=0}^\\infty f(n)r^n $$\n分析 换序\n$$ S = \\sum_{n = 0}^{\\infty} \\left( \\sum_{i = 0}^m f_i n^i \\right) r^n = \\sum_{i = 0}^m f_i \\sum_{n = 0}^{\\infty} n^i r^n $$\n令\n$$ S_i = \\sum_{n = 0}^{\\infty} n^i r^n $$\n套路的逐项相减，主动的凑二项式\n$$ (1 - r) S_i = 1 + \\sum_{n = 1}^{\\infty} n^i r^n - \\sum_{n = 1}^{\\infty} (n - 1)^i r^n = 1 + \\sum_{n = 0}^{\\infty} r^{n + 1} \\sum_{j = 0}^{i - 1} \\binom{k}{j} n^j $$\n交换求和顺序\n$$ (1 - r) S_i = 1 + \\sum_{j = 0}^{i - 1} \\binom{k}{j} \\sum_{n = 0}^{\\infty}r^{n + 1} n^j = 1 + \\sum_{j = 0}^{i - 1} \\binom{k}{j} r S_j $$\n再凑成完整的二项式卷积\n$$ \\frac{S_i - 1}{r} = \\sum_{j = 0}^i \\binom{k}{j} S_j $$\n我们设 $\\{ S_i \\}$ 的 EGF 为 $g(x)$，可以得到方程\n$$ \\frac{g(x) - 1}{r} = {\\rm e}^x g(x) $$\n解得\n$$ g(x) = \\frac{1}{1 - r {\\rm e}^x} $$\n因此最终多项式逆即可，EGF 和 OGF 的转化就是点乘阶乘。\nint main() { int m = rr() + 1, r = rr(); int lim = get_lim(m, m); w = pre_w(lim); Inv = pre_inv(lim); fac = pre_fac(lim); ifac = pre_ifac(fac); poly_t gg(lim, 1); // 初始化为 1  gg = ntt_ogf2egf(gg, lim); for (int i = 0; i \u0026lt; lim; i++) gg[i] = Mint(0) - gg[i] * r; gg[0] += 1; gg = ntt_inv(gg, lim); gg = ntt_egf2ogf(gg, lim); Mint ans = 0; for (int i = 0; i \u0026lt; m; i++) { int fi = rr(); ans += gg[i] * fi; } printf(\u0026#34;%d\u0026#34;, ans.v); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-09/p5349/","summary":"题目大意 即求\n$$ S = \\sum_{n=0}^\\infty f(n)r^n $$\n分析 换序\n$$ S = \\sum_{n = 0}^{\\infty} \\left( \\sum_{i = 0}^m f_i n^i \\right) r^n = \\sum_{i = 0}^m f_i \\sum_{n = 0}^{\\infty} n^i r^n $$\n令\n$$ S_i = \\sum_{n = 0}^{\\infty} n^i r^n $$\n套路的逐项相减，主动的凑二项式\n$$ (1 - r) S_i = 1 + \\sum_{n = 1}^{\\infty} n^i r^n - \\sum_{n = 1}^{\\infty} (n - 1)^i r^n = 1 + \\sum_{n = 0}^{\\infty} r^{n + 1} \\sum_{j = 0}^{i - 1} \\binom{k}{j} n^j $$","title":"P5349 幂"},{"content":"题目大意 给定积性函数 $f(p^c) = p \\oplus c$。对 $1000000007$ 取模求前缀和。\n分析 Min25 板子题。\nconst ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n \u0026lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi \u0026lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.01); m = cnt = 0; for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { w[++m] = r = n / (n / l); ll mr = mo(r); s[m] = mr * (mr + 1) % mod * inv2 % mod - 1; c[m] = mr - 1; } for (ll p = 2; p \u0026lt;= sqrt_n; p++) { if (c[p] != c[p - 1]) { prime[++cnt] = p; for (ll j = m; w[j] \u0026gt;= p * p; j--) { s[j] = mo(s[j] - p * mo(s[id(w[j] / p)] - s[p - 1])); c[j] = mo(c[j] - (c[id(w[j] / p)] - c[p - 1])); } } } for (int i = 2; i \u0026lt;= m; i++) s[i] = mo(s[i] - c[i] + 2); printf(\u0026#34;%lld\u0026#34;, F(n, 0) + 1); } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-08/loj6053/","summary":"题目大意 给定积性函数 $f(p^c) = p \\oplus c$。对 $1000000007$ 取模求前缀和。\n分析 Min25 板子题。\nconst ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x \u0026lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n \u0026lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i \u0026lt;= cnt \u0026amp;\u0026amp; prime[i] * prime[i] \u0026lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi \u0026lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.","title":"LOJ6053 简单的函数"},{"content":"题目大意 给定文本串 $S$ 和模式串 $T$，对每个位置进行匹配，得到失配次数。\n统计此失配次数，计算前缀和。\n分析 我是没料到 HDOJ 没有 M_PI，CE 了几发。\nFFT 字符串匹配模板题，我在 ZAFU Wiki 中讲过，即对每个字符卷积。\n#include \u0026#34;template/basic/complex.hpp\u0026#34; const int maxn = 1 \u0026lt;\u0026lt; 20; using img = Complex\u0026lt;double\u0026gt;; using poly_t = vector\u0026lt;img\u0026gt;; poly_t w; #include \u0026#34;template/poly-fft/fft_init.hpp\u0026#34;#include \u0026#34;template/poly-fft/fft.hpp\u0026#34; char a[maxn], b[maxn]; int sum[maxn], ans[maxn]; char ch[] = \u0026#34;0123456789*\u0026#34;; int main() { w = fft_init(maxn); int ttt = rr(); while (ttt--) { int n = rr(), m = rr(); fill(sum, sum + m + n + 12, 0); fill(ans, ans + m + 12, 0); int lim = getlim(m, n); scanf(\u0026#34;%s %s\u0026#34;, b, a); int tsum = 0; for (int i = 0; i \u0026lt; m - 1; i++) { tsum += b[i] == \u0026#39;*\u0026#39;; tsum += a[i] == \u0026#39;*\u0026#39;; } tsum += a[m - 1] == \u0026#39;*\u0026#39;; reverse(a, a + m + 1); for (int k = 0; k \u0026lt;= 10; k++) { poly_t SS(lim); for (int i = 0; i \u0026lt; n; i++) SS[i].x = b[i] == ch[k]; for (int i = 1; i \u0026lt;= m; i++) SS[i].y = a[i] == ch[k]; fft(SS); for (int i = 0; i \u0026lt; lim; i++) SS[i] = SS[i] * SS[i]; ifft(SS); if (k == 10) { for (int i = 0; i \u0026lt;= m + n; i++) sum[i] -= int(SS[i].y / 2 + 0.5); } else { for (int i = 0; i \u0026lt;= m + n; i++) sum[i] += int(SS[i].y / 2 + 0.5); } } for (int i = m; i \u0026lt;= n; i++) { tsum += (b[i - 1] == \u0026#39;*\u0026#39;) - (b[i - m - 1] == \u0026#39;*\u0026#39;); int tans = tsum + sum[i]; ans[m - tans]++; } tsum = 0; for (int i = 0; i \u0026lt;= m; i++) { tsum += ans[i]; printf(\u0026#34;%d\\n\u0026#34;, tsum); } } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/hdu6975/","summary":"题目大意 给定文本串 $S$ 和模式串 $T$，对每个位置进行匹配，得到失配次数。\n统计此失配次数，计算前缀和。\n分析 我是没料到 HDOJ 没有 M_PI，CE 了几发。\nFFT 字符串匹配模板题，我在 ZAFU Wiki 中讲过，即对每个字符卷积。\n#include \u0026#34;template/basic/complex.hpp\u0026#34; const int maxn = 1 \u0026lt;\u0026lt; 20; using img = Complex\u0026lt;double\u0026gt;; using poly_t = vector\u0026lt;img\u0026gt;; poly_t w; #include \u0026#34;template/poly-fft/fft_init.hpp\u0026#34;#include \u0026#34;template/poly-fft/fft.hpp\u0026#34; char a[maxn], b[maxn]; int sum[maxn], ans[maxn]; char ch[] = \u0026#34;0123456789*\u0026#34;; int main() { w = fft_init(maxn); int ttt = rr(); while (ttt--) { int n = rr(), m = rr(); fill(sum, sum + m + n + 12, 0); fill(ans, ans + m + 12, 0); int lim = getlim(m, n); scanf(\u0026#34;%s %s\u0026#34;, b, a); int tsum = 0; for (int i = 0; i \u0026lt; m - 1; i++) { tsum += b[i] == \u0026#39;*\u0026#39;; tsum += a[i] == \u0026#39;*\u0026#39;; } tsum += a[m - 1] == \u0026#39;*\u0026#39;; reverse(a, a + m + 1); for (int k = 0; k \u0026lt;= 10; k++) { poly_t SS(lim); for (int i = 0; i \u0026lt; n; i++) SS[i].","title":"HDU6975 Forgiving Matching"},{"content":"魔改 KMP 大概是不行的，卷积在这里出现的很妙。\n卷积处理匹配 定义匹配函数\n$$ d(x,y) = [x = y] $$\n给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义\n$$ f(k) = \\sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k}) $$\n即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算\n$$ d(x,y) = (x - y)^2 $$\n再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有\n$$ \\begin{aligned} f(k) \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\\\ \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k} \\end{aligned} $$\n前面两项能够预处理，最后一项是卷积。于是最终复杂度是 $O(n \\log n)$。\n考虑通配符 仅令通配符的字符值为 $0$，再搓个匹配函数\n$$ d(x,y) = xy(x-y)^2 $$\n然后大力展开\n$$ \\begin{aligned} f(k) \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^3B_{i-m+k} + \\sum_{i=0}^{m-1}A_{i}B_{i-m+k}^3 - 2\\sum_{i=0}^{m-1} A_{i}^2B_{i-m+k}^2\\\\ \u0026amp;= \\sum_{i=0}^{m-1}S_{m-i}^3B_{i-m+k} + \\sum_{i=0}^{m-1}S_{m-i}B_{i-m+k}^3 - 2\\sum_{i=0}^{m-1} S_{m-i}^2B_{i-m+k}^2 \\end{aligned} $$\n注意到三个都是卷积，于是最终复杂度是 $O(n \\log n)$。\n 记得优化取模。我换 NTT 之后 TLE 了好几次，最后发现是 NTT 里取模写多了。。\n #define ACM_MOD 998244353 const int mod = ACM_MOD; #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34;#include \u0026#34;template/basic/mint.hpp\u0026#34; using poly_t = vector\u0026lt;Mint\u0026gt;; poly_t w; #include \u0026#34;template/poly-ntt/pre_w.hpp\u0026#34;#include \u0026#34;template/poly-ntt/ntt.hpp\u0026#34; const int maxn = 1 \u0026lt;\u0026lt; 21; char a[maxn], b[maxn]; int stk[maxn], cnt = 0; int main() { int m = rr(), n = rr(); int lim = get_lim(m, n); w = pre_w(lim); poly_t B1(lim), B2(lim), B3(lim), S1(lim), S2(lim), S3(lim); scanf(\u0026#34;%s %s\u0026#34;, a, b); for (int i = 1; i \u0026lt;= m; i++) { int j = m - i, t = a[j] - \u0026#39;a\u0026#39; + 1; if (a[j] == \u0026#39;*\u0026#39;) t = 0; S1[i] = t; S2[i] = S1[i] * S1[i]; S3[i] = S2[i] * S1[i]; } for (int i = 0; i \u0026lt; n; i++) { int t = b[i] - \u0026#39;a\u0026#39; + 1; if (b[i] == \u0026#39;*\u0026#39;) t = 0; B1[i] = t; B2[i] = B1[i] * B1[i]; B3[i] = B2[i] * B1[i]; } ntt(S1), ntt(S2), ntt(S3); ntt(B1), ntt(B2), ntt(B3); for (int i = 0; i \u0026lt; lim; i++) S1[i] = S1[i] * B3[i] + S3[i] * B1[i] - S2[i] * B2[i] * 2; intt(S1); for (int i = m; i \u0026lt;= n; i++) { if (S1[i].v == 0) stk[++cnt] = i - m + 1; } printf(\u0026#34;%d\\n\u0026#34;, cnt); for (int i = 1; i \u0026lt;= cnt; i++) { printf(\u0026#34;%d \u0026#34;, stk[i]); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/p4173/","summary":"魔改 KMP 大概是不行的，卷积在这里出现的很妙。\n卷积处理匹配 定义匹配函数\n$$ d(x,y) = [x = y] $$\n给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义\n$$ f(k) = \\sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k}) $$\n即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算\n$$ d(x,y) = (x - y)^2 $$\n再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有\n$$ \\begin{aligned} f(k) \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\\\ \u0026amp;= \\sum_{i=0}^{m-1}A_{i}^2 + \\sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k} \\end{aligned} $$","title":"P4173 残缺的字符串"},{"content":"题目大意 求杨辉三角形前 $n$ 行的偶数个数，对 $1000003$ 取模。\n分析 对杨辉三角奇数打表。\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 于是递推公式\n$$ f(2^t+n) = f(2^t) + 2f(n) $$\n就是显然的了，那么偶数即是全部的减去奇数个数。\nconst ll MOD = 1000003; ll nn[10086]; #define ACM_MOD MOD  #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34; int main() { ll n = rr(); nn[1] = 1; for (ll i = 2; i \u0026lt;= 100; i++) nn[i] = nn[i - 1] * 3 % MOD; ll t = 1, ans = 0; for (ll i = 1; i \u0026lt;= 100; i++) { if ((t \u0026amp; n) \u0026gt; 0) ans = (ans * 2 + nn[i]) % MOD; t = t \u0026lt;\u0026lt; 1; if (t \u0026gt; n) break; } n = n % MOD; ll sum = n * (n + 1) % MOD * inv(2) % MOD; printf(\u0026#34;%lld\\n\u0026#34;, (sum - ans + MOD) % MOD); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-07/p1762/","summary":"题目大意 求杨辉三角形前 $n$ 行的偶数个数，对 $1000003$ 取模。\n分析 对杨辉三角奇数打表。\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 于是递推公式","title":"P1762 偶数"},{"content":"题目大意 即求\n$$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] $$\n分析 先转化一下\n$$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] = \\sum_{p}\\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) = p] $$\n在 P2522 中得到\n$$ \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tk} \\right\\rfloor \\left\\lfloor \\frac{y}{tk} \\right\\rfloor $$\n代入有\n$$ \\sum_{p} \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tp} \\right\\rfloor \\left\\lfloor \\frac{y}{tp} \\right\\rfloor $$\n令 $T = tp$，$T$ 的上界应还是 $\\min(x,y)$，代入有\n$$ \\sum_{T=1}^{\\min(x,y)} \\left\\lfloor \\frac{x}{T} \\right\\rfloor \\left\\lfloor \\frac{y}{T} \\right\\rfloor \\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right) $$\n后面那个在 Euler 筛后再求和一下，是可以预处理的。\nconst ll MN = 1e7 + 100; int mu[MN], f[MN], dp[MN]; bool notp[MN]; int prime[MN/10], cnt; void sieve(int n) { mu[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { if (!notp[i]) prime[++cnt] = i, mu[i] = -1; int t = n / i; for (ll j = 1; j \u0026lt;= cnt; j++) { if (prime[j] \u0026gt; t) break; notp[i * prime[j]] = true; if (i % prime[j] == 0) { mu[i * prime[j]] = 0; break; } mu[i * prime[j]] = - mu[i]; } } for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= cnt; j++) { ll t = i * prime[j]; if(t \u0026gt; n) break; dp[t] += mu[i]; } } for (ll i = 1; i \u0026lt;= n; i++) f[i] = f[i - 1] + dp[i]; } 此时 $dp(T)$ 中存的是 $\\displaystyle\\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right)$，$f_i$ 是其前缀和。\n之后整数分块即可\nll calc(ll a, ll b) { ll mab = min(a, b); ll sum = 0; for (ll l = 1, r; l \u0026lt;= mab; l = r + 1) { r = min(a / (a / l), b / (b / l)); sum += (f[r] - f[l - 1]) * (a / l) * (b / l); } return sum; } int main() { ll ttt = rr(); sieve(MN - 10); for (ll i = 1; i \u0026lt;= ttt; i++) { ll a = rr(), b = rr(); printf(\u0026#34;%lld\\n\u0026#34;, calc(a,b)); } return 0; } 相似题目 P2568 GCD 即 $M = N = n$ 的特殊情况，可以再优化。即求\n$$ \\sum_{i=1}^n \\sum_{j=1}^n [\\gcd(i,j) \\in \\mathbb{P}] $$\n化简有\n$$ \\begin{aligned} \\sum_{p} \\sum_{i=1}^n \\sum_{j=1}^n [\\gcd(i,j) = p] \u0026amp;= \\sum_{p} \\sum_{i=1}^{\\lfloor n/p\\rfloor} \\sum_{j=1}^{\\lfloor n/p\\rfloor} [\\gcd(i,j) = 1]\\\\\\\\ \u0026amp;= \\sum_{p} \\left(2\\sum_{j=1}^{\\lfloor n/p\\rfloor} \\sum_{j=1}^{i} [\\gcd(i,j) = p] - 1\\right)\\\\\\\\ \u0026amp;= \\sum_{p}\\left( 2\\sum_{i=1}^{\\lfloor n/p \\rfloor} \\varphi(i) - 1 \\right) \\end{aligned} $$\n预处理出 $\\varphi(i)$ 的前缀和后，对每个素数筛一遍即可。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2257/","summary":"题目大意 即求\n$$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] $$\n分析 先转化一下\n$$ \\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) \\in \\mathbb{P}] = \\sum_{p}\\sum_{i=1}^N \\sum_{j=1}^M [\\gcd(i,j) = p] $$\n在 P2522 中得到\n$$ \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tk} \\right\\rfloor \\left\\lfloor \\frac{y}{tk} \\right\\rfloor $$\n代入有\n$$ \\sum_{p} \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tp} \\right\\rfloor \\left\\lfloor \\frac{y}{tp} \\right\\rfloor $$\n令 $T = tp$，$T$ 的上界应还是 $\\min(x,y)$，代入有\n$$ \\sum_{T=1}^{\\min(x,y)} \\left\\lfloor \\frac{x}{T} \\right\\rfloor \\left\\lfloor \\frac{y}{T} \\right\\rfloor \\sum_{p \\mid T} \\mu\\left(\\frac{T}{p}\\right) $$","title":"P2257 YY 的 GCD"},{"content":"题目大意 设\n$$ \\varphi_{x+1}(m) = \\varphi(\\varphi_x(m)) $$\n求最小的 $x$ 使得 $\\varphi_x(m) = 1$。\n其中 $\\varphi(m)$ 是欧拉函数。\n分析 注意到仅有 $\\varphi(1) = \\varphi(2) = 1$，再有公式\n$$ \\varphi\\left(\\prod_{i=1}^mp_i^{q_i}\\right) = \\prod_{i=1}^m(p_i-1)p_i^{q_i-1} $$\n因此从唯一分解形式的角度来看，迭代一次消去了一个 $2$，也生成了一些 $2$。\n考虑设 $f(n)$ 为 $\\varphi(n)$ 中因子 $2$ 的个数。\n设 $\\gcd(a,b) = 1$，可以证明 $f(ab) = f(a) f(b)$。同时 $f(p) = f(p-1)$。\n这说明 $f(x)$ 是一个积性函数，可以用 Euler 筛递推。\nconst ll MN = 1e5 + 10; bool notp[1000001]; int prime[200001], cnt, phi[1000001]; void sieve(int n) { phi[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { if (!notp[i]) { prime[++cnt] = i; phi[i] = phi[i - 1]; } int t = n / i; for (ll j = 1; j \u0026lt;= cnt; j++) { if (prime[j] \u0026gt; t) break; int ti = i * prime[j]; notp[ti] = true; phi[ti] = phi[i] + phi[prime[j]]; if (i % prime[j] == 0) break; } } } 然后在 main 中输出即可。注意若没有质因子 $2$，则答案需要加 $1$。\nint main() { sieve(MN - 10); ll ttt = rr(); while (ttt--) { ll m = rr(), ans = 1; for (ll i = 1; i \u0026lt;= m; i++) { ll p = rr(), q = rr(); if (p == 2) ans--; ans += phi[p] * q; } printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2350/","summary":"题目大意 设\n$$ \\varphi_{x+1}(m) = \\varphi(\\varphi_x(m)) $$\n求最小的 $x$ 使得 $\\varphi_x(m) = 1$。\n其中 $\\varphi(m)$ 是欧拉函数。\n分析 注意到仅有 $\\varphi(1) = \\varphi(2) = 1$，再有公式\n$$ \\varphi\\left(\\prod_{i=1}^mp_i^{q_i}\\right) = \\prod_{i=1}^m(p_i-1)p_i^{q_i-1} $$\n因此从唯一分解形式的角度来看，迭代一次消去了一个 $2$，也生成了一些 $2$。\n考虑设 $f(n)$ 为 $\\varphi(n)$ 中因子 $2$ 的个数。\n设 $\\gcd(a,b) = 1$，可以证明 $f(ab) = f(a) f(b)$。同时 $f(p) = f(p-1)$。\n这说明 $f(x)$ 是一个积性函数，可以用 Euler 筛递推。\nconst ll MN = 1e5 + 10; bool notp[1000001]; int prime[200001], cnt, phi[1000001]; void sieve(int n) { phi[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { if (!","title":"P2350 外星人"},{"content":"Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。\n若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。\n求一年有几对。\n$$ xd+y \\equiv yd+x \\pmod w $$\n即\n$$ (x-y)(d-1) \\equiv 0 \\Rightarrow (x-y)(d-1) \\in w\\mathbb{Z} $$\n于是有\n$$ y-x = \\frac{wk}{\\gcd(w,d-1)} $$\n又 $x \u0026lt; y \\leqslant \\min(m,d)$​，\nint main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/cf1389e/","summary":"Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。\n若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。\n求一年有几对。\n$$ xd+y \\equiv yd+x \\pmod w $$\n即\n$$ (x-y)(d-1) \\equiv 0 \\Rightarrow (x-y)(d-1) \\in w\\mathbb{Z} $$\n于是有\n$$ y-x = \\frac{wk}{\\gcd(w,d-1)} $$\n又 $x \u0026lt; y \\leqslant \\min(m,d)$​，\nint main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","title":"CF1389E Calendar Ambiguity"},{"content":"题目大意 即求\n$$ \\sum_{i=1}^n \\gcd(i,n) $$\n分析 联想到\n$$ \\varphi(n) = \\sum_{i=1}^n [\\gcd(i,n) = 1] $$\n尝试凑这个形式\n$$ \\begin{aligned} \\sum_{i=1}^n \\gcd(i,n) \u0026amp;= \\sum_{d \\mid n} d \\sum_{i=1}^n [\\gcd(i,n) = d] \\\\ \u0026amp;= \\sum_{d \\mid n} d \\sum_{i=1}^{n/d} [\\gcd(i,n/d) = 1] \\\\ \u0026amp;= \\sum_{d \\mid n} d \\varphi(n/d) \\end{aligned} $$\n这里其实已经可以过题了，但还可以再瞎搞一下，令\n$$ nf(n) = \\sum_{d \\mid n} d \\varphi(n/d) = n\\sum_{d \\mid n} \\frac{\\varphi(d)}{d} $$\n尝试证明 $f(n)$ 是一个积性函数。设 $\\gcd(a,b) = 1$，有\n$$ \\begin{aligned} f(a)f(b) \u0026amp;= \\left(\\sum_{d_1 \\mid a} \\frac{\\varphi(d_1)}{d_1}\\right) \\left(\\sum_{d_2 \\mid b} \\frac{\\varphi(d_2)}{d_2}\\right)\\\\ \u0026amp;= \\sum_{d_1 \\mid a} \\sum_{d_2 \\mid b} \\frac{\\varphi(d_1)}{d_1} \\frac{\\varphi(d_2)}{d_2}\\\\ \u0026amp;= \\sum_{d_1 \\mid a} \\sum_{d_2 \\mid b} \\frac{\\varphi(d_1d_2)}{d_1d_2}\\\\ \u0026amp;= f(ab) \\end{aligned} $$\n再来推一下素数，注意 $1 \\mid p^k$，有\n$$ f(p^k) = \\sum_{d \\mid p^k} \\frac{\\varphi(d)}{d} = \\sum_{i=0}^k \\frac{\\varphi(p^i)}{p^i} = k\\left(1 - \\frac{1}{p}\\right) + 1 $$\n类似于 $\\varphi(m)$ 唯一分解形式，我们还有\n$$ f(n) = \\prod_{i=1}^sf(p_i^{k_i}) = \\prod_{i=1}^s \\frac{k_ip_i - k_i + p_i}{p_i} $$\n于是答案即为 $nf(n)$，复杂度 $O(\\sqrt{n})$。\nint main() { ll n = rr(), ans = n; for (ll i = 2; i * i \u0026lt;= n; i++) { ll k = 0; while (n % i == 0) k++, n /= i; if (k \u0026gt; 0) ans += ans / i * k * (i - 1); } if (n \u0026gt; 1) ans += ans / n * (n - 1); printf(\u0026#34;%lld\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2303/","summary":"题目大意 即求\n$$ \\sum_{i=1}^n \\gcd(i,n) $$\n分析 联想到\n$$ \\varphi(n) = \\sum_{i=1}^n [\\gcd(i,n) = 1] $$\n尝试凑这个形式\n$$ \\begin{aligned} \\sum_{i=1}^n \\gcd(i,n) \u0026amp;= \\sum_{d \\mid n} d \\sum_{i=1}^n [\\gcd(i,n) = d] \\\\ \u0026amp;= \\sum_{d \\mid n} d \\sum_{i=1}^{n/d} [\\gcd(i,n/d) = 1] \\\\ \u0026amp;= \\sum_{d \\mid n} d \\varphi(n/d) \\end{aligned} $$\n这里其实已经可以过题了，但还可以再瞎搞一下，令\n$$ nf(n) = \\sum_{d \\mid n} d \\varphi(n/d) = n\\sum_{d \\mid n} \\frac{\\varphi(d)}{d} $$\n尝试证明 $f(n)$ 是一个积性函数。设 $\\gcd(a,b) = 1$，有","title":"P2303 Longge 的问题"},{"content":"题目大意 给定 $g[1], \\cdots, g[m]$，求序列 $f$。\n$$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$\n分析 不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程\n$$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$\n这个形式看似卷积，但实际上它缺了一项。对 $n \u0026gt; 0$ 凑卷积\n$$ f [n] (h [0] + 1) = \\sum_{j = 0}^n f [n - j] h [j] = (f \\ast h) [n] $$\n又 $f [0] = 1$，有\n$$ f \\ast (1 + h [0]) - f \\ast h = f [0] (1 + h [0]) - f [0] h [0] = f [0] $$\n解得\n$$ f (x) = \\frac{f [0]}{1 + h [0] - h (x)} = \\frac{1}{1 - g (x)} $$\n于是求逆即可\n#define ACM_MOD 998244353 const int mod = ACM_MOD; using poly_t = vector\u0026lt;int\u0026gt;; poly_t w; #include \u0026#34;template/basic/qpow.hpp\u0026#34;#include \u0026#34;template/basic/mint.hpp\u0026#34;#include \u0026#34;template/basic/inv.hpp\u0026#34; #include \u0026#34;template/poly-ntt/ntt_init.hpp\u0026#34;#include \u0026#34;template/poly-ntt/ntt.hpp\u0026#34;#include \u0026#34;template/poly-ntt/ntt_inv.hpp\u0026#34; int main() { int n = rr(); int lim = getlin(n, n); w = ntt_init(lim); poly_t ans, ff(lim); for (int i = 1; i \u0026lt; n; i++) ff[i] = mod - rr(); ff[0] = 1; ans = ntt_inv(ff, lim); for (int i = 0; i \u0026lt; n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p4721/","summary":"题目大意 给定 $g[1], \\cdots, g[m]$，求序列 $f$。\n$$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$\n分析 不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程\n$$ f [n] = \\sum_{j = 1}^n f [n - j] g [j] = \\sum_{j = 1}^n f [n - j] h [j] $$\n这个形式看似卷积，但实际上它缺了一项。对 $n \u0026gt; 0$ 凑卷积","title":"P4721 分治 FFT"},{"content":"题目大意 即求\n$$ \\sum_{i=a}^b \\sum_{j=c}^d [\\gcd(i,j) = k] $$\n分析 容易想到，独立出函数 $f(k)$ 使得\n$$ f(k) = \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] $$\n利用 Mobius 反演化简，设 $F(d)$\n$$ F(n) = \\sum_{n \\mid d} f(d) = \\sum_{i=1}^x \\sum_{j=1}^y [n \\mid i][n \\mid j] = \\left\\lfloor \\frac{x}{n} \\right\\rfloor \\left\\lfloor \\frac{y}{n} \\right\\rfloor $$\n反演化简有\n$$ f(n) = \\sum_{n \\mid d} \\mu\\left(\\frac{d}{n}\\right)F(d) = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tn} \\right\\rfloor \\left\\lfloor \\frac{y}{tn} \\right\\rfloor $$\n预处理出 $\\mu(t)$ 的前缀和，剩下的就是一个二重分块了。\nconst ll MN = 50000; bool notp[1000001]; int prime[200001], cnt, mu[MN]; void Mobius(int n); // 预处理 Mobius 函数  ll f(ll a, ll b) { ll mab = min(a, b); ll sum = 0; for (ll l = 1, r; l \u0026lt;= mab; l = r + 1) { r = min(a / (a / l), b / (b / l)); sum += (mu[r] - mu[l - 1]) * (a / l) * (b / l); } return sum; } int main() { ll ttt = rr(); Mobius(MN - 1); for (ll i = 1; i \u0026lt;= MN - 1; i++) mu[i] += mu[i - 1]; for (ll i = 1; i \u0026lt;= ttt; i++) { ll a = rr(), b = rr(), c = rr(), d = rr(); ll k = rr(); a--, c--; a /= k, b /= k, c /= k, d /= k; ll ans = f(b, d) - f(a, d) - f(b, c) + f(a, c); printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } 类似题目 P2158 仪仗队：即 $k = 1$ 的特殊情况。\nP3455 ZAP-Queries：几乎一样。\nP2257 YY 的 GCD：比这题难，单独开篇。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2522/","summary":"题目大意 即求\n$$ \\sum_{i=a}^b \\sum_{j=c}^d [\\gcd(i,j) = k] $$\n分析 容易想到，独立出函数 $f(k)$ 使得\n$$ f(k) = \\sum_{i=1}^x \\sum_{j=1}^y [\\gcd(i,j) = k] $$\n利用 Mobius 反演化简，设 $F(d)$\n$$ F(n) = \\sum_{n \\mid d} f(d) = \\sum_{i=1}^x \\sum_{j=1}^y [n \\mid i][n \\mid j] = \\left\\lfloor \\frac{x}{n} \\right\\rfloor \\left\\lfloor \\frac{y}{n} \\right\\rfloor $$\n反演化简有\n$$ f(n) = \\sum_{n \\mid d} \\mu\\left(\\frac{d}{n}\\right)F(d) = \\sum_{t=1}^{\\min(x,y)} \\mu(t) \\left\\lfloor \\frac{x}{tn} \\right\\rfloor \\left\\lfloor \\frac{y}{tn} \\right\\rfloor $$\n预处理出 $\\mu(t)$ 的前缀和，剩下的就是一个二重分块了。","title":"P2522 Problem B"},{"content":"题目大意 给出正整数 $n$ 和 $k$，请计算\n$$ G(n, k) = \\sum_{i = 1}^n k \\bmod i $$\n分析 因为\n$$ k \\bmod i = k - i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$\n因此有\n$$ G(n,k) = nk - \\sum_{i=1}^n i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$\n后面需要整数分块。\nint main() { ll n = rr(); ll k = rr(); ll sum = n * k; n = min(n, k); for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = min(n, k / (k / l)); ll t = (l + r) * (r - l + 1) / 2; sum -= t * (k / l); } printf(\u0026#34;%lld\u0026#34;, sum); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-04/p2261/","summary":"题目大意 给出正整数 $n$ 和 $k$，请计算\n$$ G(n, k) = \\sum_{i = 1}^n k \\bmod i $$\n分析 因为\n$$ k \\bmod i = k - i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$\n因此有\n$$ G(n,k) = nk - \\sum_{i=1}^n i \\left\\lfloor \\frac{k}{i} \\right\\rfloor $$\n后面需要整数分块。\nint main() { ll n = rr(); ll k = rr(); ll sum = n * k; n = min(n, k); for (ll l = 1, r; l \u0026lt;= n; l = r + 1) { r = min(n, k / (k / l)); ll t = (l + r) * (r - l + 1) / 2; sum -= t * (k / l); } printf(\u0026#34;%lld\u0026#34;, sum); return 0; } ","title":"P2261 余数求和"},{"content":"题目大意 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：\n$$ y_i=\\sum_{j=l_i}^{r_i}[w_j \\geqslant W] \\times \\sum_{j=l_i}^{r_i}[w_j \\geqslant W]v_j $$\n记检验结果为 $y=\\sum y_i$，对于给定的 $s$，求 $|y-s|$ 的最小值。\n分析 注意到 $y(w)$ 是关于 $W$ 的递减函数，对 $w$ 在 $[w_{\\min},w_{\\max}]$ 上进行二分。\nconst ll MN = 2e5 + 10; ll vv[MN], ww[MN], li[MN], ri[MN], f1[MN], f2[MN]; ll n, m, s; int main() { n = rr(), m = rr(), s = rr(); ll minw = 0x3f3f3f3f, maxw = 0; f1[0] = f2[0] = 0; for (ll i = 1; i \u0026lt;= n; i++) { ww[i] = rr(), vv[i] = rr(); maxw = max(ww[i], maxw); minw = min(ww[i], minw); } for (ll i = 1; i \u0026lt;= m; i++) { li[i] = rr(), ri[i] = rr(); } ll l = minw, r = maxw + 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (sum(mid) \u0026lt;= s) r = mid; else l = mid + 1; } ll rst = min(sum(l - 1) - s, s - sum(l)); printf(\u0026#34;%lld\u0026#34;, rst); return 0; } 区间求和可以用前缀和优化。\nll f1[MN], f2[MN]; ll sum(ll w) { for (ll i = 1; i \u0026lt;= n; i++) { ll f = ww[i] \u0026gt;= w; f1[i] = f1[i - 1] + f; f2[i] = f2[i - 1] + f * vv[i]; } ll sum = 0; for (ll k = 1; k \u0026lt;= m; k++) { ll l = li[k], r = ri[k]; sum += (f1[r] - f1[l - 1]) * (f2[r] - f2[l - 1]); } return sum; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-04/p1314/","summary":"题目大意 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：\n$$ y_i=\\sum_{j=l_i}^{r_i}[w_j \\geqslant W] \\times \\sum_{j=l_i}^{r_i}[w_j \\geqslant W]v_j $$\n记检验结果为 $y=\\sum y_i$，对于给定的 $s$，求 $|y-s|$ 的最小值。\n分析 注意到 $y(w)$ 是关于 $W$ 的递减函数，对 $w$ 在 $[w_{\\min},w_{\\max}]$ 上进行二分。\nconst ll MN = 2e5 + 10; ll vv[MN], ww[MN], li[MN], ri[MN], f1[MN], f2[MN]; ll n, m, s; int main() { n = rr(), m = rr(), s = rr(); ll minw = 0x3f3f3f3f, maxw = 0; f1[0] = f2[0] = 0; for (ll i = 1; i \u0026lt;= n; i++) { ww[i] = rr(), vv[i] = rr(); maxw = max(ww[i], maxw); minw = min(ww[i], minw); } for (ll i = 1; i \u0026lt;= m; i++) { li[i] = rr(), ri[i] = rr(); } ll l = minw, r = maxw + 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (sum(mid) \u0026lt;= s) r = mid; else l = mid + 1; } ll rst = min(sum(l - 1) - s, s - sum(l)); printf(\u0026#34;%lld\u0026#34;, rst); return 0; } 区间求和可以用前缀和优化。","title":"P1314 聪明的质检员"},{"content":"题目链接：Link 。\nA. ABC String 这么水的题竟然 wa 了 4 发。。\n题目大意 给定一个长 $n$ 的字符串 $a$，仅由 A，B，C 组成，$n$ 为偶数。\n对于仅含 ( 和 ) 的括号序列，当我们能够在其中添加 1 使得其为合法的表达式，则序列合法。\n构造合法的长为 $n$ 的括号序列 $b$，要求在 $a$ 同为 A 的，在 $b$ 中也要相同；B，C 也是如此。\n分析 序列合法的定义即对任意位置，其左侧的 ) 总比 ( 少，且整体左右括号数相等。\n首个字母必为左括号，末尾字母必为右括号。剩下的那个讨论一下即可。\nchar ss[60]; int main() { ll ttt = rr(); while (ttt--) { scanf(\u0026#34;%s\u0026#34;, ss + 1); ll len = strlen(ss + 1); if (ss[1] == ss[len]) { printf(\u0026#34;NO\\n\u0026#34;); continue; } ll sa[3] = {0, 0, 0}; for (ll i = 1; i \u0026lt;= len; i++) sa[ss[i] - \u0026#39;A\u0026#39;]++; ll sl = ss[1] - \u0026#39;A\u0026#39;, sr = ss[len] - \u0026#39;A\u0026#39;; ll sm = 3ll - sl - sr; bool flag = false; sa[0] = sa[1] = sa[2] = 0; if (sa[sl] + sa[sm] == sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] + sa[sm] \u0026lt; sa[sr]; } } else if (sa[sl] == sa[sm] + sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] \u0026lt; sa[sm] + sa[sr]; } } else { printf(\u0026#34;NO\\n\u0026#34;); continue; } if (flag) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); } return 0; } B. Berland Crossword 题目大意 对于一个边长为 $n$ 的正方形黑白棋盘，指定其最顶行的黑色块数为 $u$，最左列、最右侧、最底行的黑色块数分别为 $l,r,d$。\n判断棋盘是否存在。\n分析 关键点在于四个角，然而也就只有 $16$ 种可能，枚举即可。\nll ff[10], aa[10]; int main() { ll ttt = rr(); while (ttt--) { ll n = rr(); for (ll i = 0; i \u0026lt;= 3; i++) aa[i] = rr(); bool flag = false; for (ll k = 0; k \u0026lt;= 15; k++) { memset(ff, 0, sizeof(ff)); int f = 1; for (ll j = 0; j \u0026lt;= 3; j++) { ff[j] = ((k \u0026amp; f) \u0026gt; 0); f = f \u0026lt;\u0026lt; 1; } bool tflag = false; for (ll j = 0; j \u0026lt;= 3; j++) { ll u = aa[j] - ff[j] - ff[(j + 1) % 4]; tflag = tflag || u \u0026lt; 0 || u \u0026gt; n - 2; } flag = flag || !tflag; } if (flag) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } C. 1D Sokoban 题目大意 假设一个直线上的推箱子游戏，你的出生点位于 $0$，在 $a_i$ 处有 $n$ 个箱子，在 $b_i$ 处有 $m$ 个目标点。箱子可能初始化在目标点，但不会在 $0$。\n就像推箱子一样，你可以把箱子推到目标点而不能越过箱子。求最多能使目标点上有几个箱子。\n分析 首先看正半轴，推的时候箱子会积起来，关注点在“箱子队列”的右端。\n容易发现，当右端未碰到新目标点时，结果是不可能变多的。分类讨论\n 当右端碰到恰在目标点的新箱子时，ans+1，计算此时覆盖个数，取最值，len+1。 当右端碰到箱子时，len+1。 当右端碰到目标点时，计算此时覆盖个数，取最值。  计算箱子下覆盖目标点个数可以用双指针法维护。\n有些地方可以用二分？但好像没有变快啊\nconst ll inf = 0x3f3f3f3f3f3f3f3f; ll aa[200086], bb[200086]; int main() { ll ttt = rr(); while (ttt--) { ll n = rr(); ll m = rr(); ll a0 = 0, b0 = 0; for (ll i = 1; i \u0026lt;= n; i++) aa[i] = rr(); for (ll i = 1; i \u0026lt;= m; i++) bb[i] = rr(); a0 = lower_bound(aa + 1, aa + n + 1, 0) - aa - 1; b0 = lower_bound(bb + 1, bb + m + 1, 0) - bb - 1; aa[0] = bb[0] = -inf; aa[n + 1] = bb[m + 1] = inf; ll ra1 = a0 + 1, rb1 = b0 + 1; ll sum = 0, ans = 0, len = 0; ll sl = rb1, sr = rb1; while (ra1 \u0026lt;= n || rb1 \u0026lt;= m) { if (aa[ra1] \u0026lt; bb[rb1]) { len++, ra1++; continue; } sr++; ll tsum = sr - sl; if (aa[ra1] \u0026gt; bb[rb1]) { while (bb[sl] \u0026lt;= bb[rb1] - len \u0026amp;\u0026amp; tsum \u0026gt; 0) sl++, tsum--; } else { ans++; while (bb[sl] \u0026lt;= bb[rb1] - len - 1 \u0026amp;\u0026amp; tsum \u0026gt; 0) sl++, tsum--; len++, ra1++; } rb1++; ans = max(ans, tsum); } sum += ans; ra1 = a0; sl = sr = rb1 = b0; ans = len = 0; while (ra1 \u0026gt;= 1 || rb1 \u0026gt;= 1) { if (aa[ra1] \u0026gt; bb[rb1]) { len++, ra1--; continue; } sl--; ll tsum = sr - sl; if (aa[ra1] \u0026lt; bb[rb1]) { while (bb[sr] \u0026gt;= bb[rb1] + len \u0026amp;\u0026amp; tsum \u0026gt; 0) sr--, tsum--; } else { ans++; while (bb[sr] \u0026gt;= bb[rb1] + len + 1 \u0026amp;\u0026amp; tsum \u0026gt; 0) sr--, tsum--; len++, ra1--; } rb1--; ans = max(ans, tsum); } sum += ans; printf(\u0026#34;%lld\\n\u0026#34;, sum); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/cfedu105/","summary":"题目链接：Link 。\nA. ABC String 这么水的题竟然 wa 了 4 发。。\n题目大意 给定一个长 $n$ 的字符串 $a$，仅由 A，B，C 组成，$n$ 为偶数。\n对于仅含 ( 和 ) 的括号序列，当我们能够在其中添加 1 使得其为合法的表达式，则序列合法。\n构造合法的长为 $n$ 的括号序列 $b$，要求在 $a$ 同为 A 的，在 $b$ 中也要相同；B，C 也是如此。\n分析 序列合法的定义即对任意位置，其左侧的 ) 总比 ( 少，且整体左右括号数相等。\n首个字母必为左括号，末尾字母必为右括号。剩下的那个讨论一下即可。\nchar ss[60]; int main() { ll ttt = rr(); while (ttt--) { scanf(\u0026#34;%s\u0026#34;, ss + 1); ll len = strlen(ss + 1); if (ss[1] == ss[len]) { printf(\u0026#34;NO\\n\u0026#34;); continue; } ll sa[3] = {0, 0, 0}; for (ll i = 1; i \u0026lt;= len; i++) sa[ss[i] - \u0026#39;A\u0026#39;]++; ll sl = ss[1] - \u0026#39;A\u0026#39;, sr = ss[len] - \u0026#39;A\u0026#39;; ll sm = 3ll - sl - sr; bool flag = false; sa[0] = sa[1] = sa[2] = 0; if (sa[sl] + sa[sm] == sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] + sa[sm] \u0026lt; sa[sr]; } } else if (sa[sl] == sa[sm] + sa[sr]) { for (ll i = 1; i \u0026lt;= len; i++) { sa[ss[i] - \u0026#39;A\u0026#39;]++; flag = flag || sa[sl] \u0026lt; sa[sm] + sa[sr]; } } else { printf(\u0026#34;NO\\n\u0026#34;); continue; } if (flag) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); } return 0; } B.","title":"CF1494 Educational Round 105 (Rated for Div. 2)"},{"content":"题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。\n给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。\n分析 我是没想出来，经题解提示了拼接函数才写出来的。\n设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。\nchar s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; for (ll i = 1; i \u0026lt;= ml; i++) { int flag = 1; for (ll j = 0; j \u0026lt;= i - 1; j++) { if (s[x][len[x] + j - i] != s[y][j]) { flag = 0; break; } } if (flag) { mt[x][y] = i; break; } } } 然后回溯 dfs，搜索即可。\nll n; int vis[30]; ll dfs(int x) { if (vis[x] \u0026gt;= 2) return 0; vis[x]++; ll maxlen = 0; for (ll i = 1; i \u0026lt;= n; i++) { if (mt[x][i] \u0026gt; 0) { maxlen = max(maxlen, dfs(i) - mt[x][i]); } } vis[x]--; return maxlen + len[x]; } int main() { n = rr(); for (ll i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%s\u0026#34;, s[i]); len[i] = strlen(s[i]); } for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= n; j++) { init(i, j); } } ll maxlen = 0; scanf(\u0026#34;%s\u0026#34;, s[0]); for (ll i = 1; i \u0026lt;= n; i++) { if (s[i][0] == s[0][0]) { maxlen = max(maxlen, dfs(i)); } } printf(\u0026#34;%lld\\n\u0026#34;, maxlen); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/p1019/","summary":"题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。\n给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。\n分析 我是没想出来，经题解提示了拼接函数才写出来的。\n设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。\nchar s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; for (ll i = 1; i \u0026lt;= ml; i++) { int flag = 1; for (ll j = 0; j \u0026lt;= i - 1; j++) { if (s[x][len[x] + j - i] !","title":"P1019 单词接龙"},{"content":"题目大意 在 $0$ 到 $L$ 的位置间，有 $N$ 块岩石。若要使得岩石间距最小值最大，允许移除 $M$ 块，求此时间距最小值。\n分析 定义函数 $f(x)$，输入为最小值，输出为被移除岩石的个数，实现如下\nll L, N, M, aa[100086]; ll f(ll x) { ll ans = 0; ll l = 0, r = 1; while (r \u0026lt;= N) { if (aa[r] - aa[l] \u0026gt;= x) l = r; else ans++; r++; } return ans; } 显然 $f(x)$ 是单调递减的函数，二分查找即可。\nint main() { L = rr(), N = rr(), M = rr(); for (ll i = 1; i \u0026lt;= N; i++) aa[i] = rr(); aa[++N] = L; ll l = 1, r = L; while (l \u0026lt; r) { ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; ll fm = f(mid); if (fm \u0026lt;= M) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2021-03/p2678/","summary":"题目大意 在 $0$ 到 $L$ 的位置间，有 $N$ 块岩石。若要使得岩石间距最小值最大，允许移除 $M$ 块，求此时间距最小值。\n分析 定义函数 $f(x)$，输入为最小值，输出为被移除岩石的个数，实现如下\nll L, N, M, aa[100086]; ll f(ll x) { ll ans = 0; ll l = 0, r = 1; while (r \u0026lt;= N) { if (aa[r] - aa[l] \u0026gt;= x) l = r; else ans++; r++; } return ans; } 显然 $f(x)$ 是单调递减的函数，二分查找即可。\nint main() { L = rr(), N = rr(), M = rr(); for (ll i = 1; i \u0026lt;= N; i++) aa[i] = rr(); aa[++N] = L; ll l = 1, r = L; while (l \u0026lt; r) { ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; ll fm = f(mid); if (fm \u0026lt;= M) l = mid; else r = mid - 1; } printf(\u0026#34;%lld\\n\u0026#34;, l); return 0; } ","title":"P2678 跳石头"},{"content":"过于简单的题不记录。\n洛谷：更新至：2020.12.31(2020.10)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2020 年 09 月 开始 ACM。不记录 HDU 150 的基础题。\n09-20 |  CF1384B2 Koa and the Beach\n09-20 |  P1004 方格取数\n09-22 |  P2181 对角线\n09-23 |  P1042 乒乓球\n2020 年 10 月 10-09 |  P1095 守望者的逃离\n10-13 |  P5143 攀爬者\n10-16 |  P1923 求第 $k$ 小的数\n10-16 |  P1928 外星密码\n10-16 |  P1990 覆盖墙壁\n10-16 |  P1090 合并果子\n10-16 |  P4995 跳跳！\n10-16 |  P1077 摆花\n2020 年 11 月 11-10 |  P3842 线段\n11-10 |  P1541 乌龟棋\n11-11 |  P1833 樱花\n11-11 |  P1064 金明的预算方案\n11-12 |  P1941 飞扬的小鸟\n11-16 |  P1160 队列安排\n11-17 |  P1106 删数问题\n11-17 |  P2058 海港\n11-17 |  P4715 淘汰赛\n11-17 |  P4913 二叉树深度\n11-26 |  P3367 并查集\n11-26 |  P1226 快速幂 || 取余运算\n11-26 |  P3383 线性筛素数\n11-27 |  P1636 Einstein 学画画\n11-30 |  P1880 石子合并\n2020 年 12 月 12-01 |  P3146 248 G\n12-01 |  P3371 单源最短路径（弱化版）\n12-01 |  P1352 没有上司的舞会\n12-02 |  P2052 道路修建\n12-02 |  P3379 最近公共祖先（LCA）\n12-02 |  P3884 二叉树问题\n12-03 |  P2016 战略游戏\n12-03 |  P1359 租用游艇\n12-04 |  P1629 邮递员送信\n12-14 |  P4779 单源最短路径（标准版）\n12-17 |  P5656 二元一次不定方程 (exgcd)\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/log2020/","summary":"过于简单的题不记录。\n洛谷：更新至：2020.12.31(2020.10)\nCodeForces：更新至：\u0026ndash;.\u0026ndash;\n牛客：更新至：\u0026ndash;.\u0026ndash;\nHDU：更新至：\u0026ndash;.\u0026ndash;\n2020 年 09 月 开始 ACM。不记录 HDU 150 的基础题。\n09-20 |  CF1384B2 Koa and the Beach\n09-20 |  P1004 方格取数\n09-22 |  P2181 对角线\n09-23 |  P1042 乒乓球\n2020 年 10 月 10-09 |  P1095 守望者的逃离\n10-13 |  P5143 攀爬者\n10-16 |  P1923 求第 $k$ 小的数\n10-16 |  P1928 外星密码\n10-16 |  P1990 覆盖墙壁\n10-16 |  P1090 合并果子","title":"2020 年刷题日志"},{"content":"题目大意 环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。\n求最终分数的最小值和最大值。\n分析 考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为\n$$ dp(i,j) = \\max_{i \\leqslant k \\leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j)) $$\n其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。\n然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。\n细节：前缀和、循环开两倍。\nint dmax[205][205], dmin[205][205]; int f[205], s[205]; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) f[i + n] = f[i] = rr(); for (ll i = 1; i \u0026lt;= n * 2; i++) s[i] = s[i - 1] + f[i]; for (ll len = 2; len \u0026lt;= n; len++) { for (ll i = 1; i \u0026lt;= 2 * n - len + 1; i++) { int j = i + len - 1; int tmax = 0, tmin = 0x3f3f3f3f; int ss = s[j] - s[i - 1]; for (ll k = i; k \u0026lt;= j - 1; k++) { tmax = max(tmax, dmax[i][k] + dmax[k + 1][j] + ss); tmin = min(tmin, dmin[i][k] + dmin[k + 1][j] + ss); } dmax[i][j] = tmax; dmin[i][j] = tmin; } } int mmin = 0x3f3f3f3f, mmax = 0; for (ll p = 0; p \u0026lt;= n - 1; p++) { mmin = min(mmin, dmin[p + 1][p + n]); mmax = max(mmax, dmax[p + 1][p + n]); } printf(\u0026#34;%d\\n%d\\n\u0026#34;, mmin, mmax); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1880/","summary":"题目大意 环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。\n求最终分数的最小值和最大值。\n分析 考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为\n$$ dp(i,j) = \\max_{i \\leqslant k \\leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j)) $$\n其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。\n然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。\n细节：前缀和、循环开两倍。\nint dmax[205][205], dmin[205][205]; int f[205], s[205]; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) f[i + n] = f[i] = rr(); for (ll i = 1; i \u0026lt;= n * 2; i++) s[i] = s[i - 1] + f[i]; for (ll len = 2; len \u0026lt;= n; len++) { for (ll i = 1; i \u0026lt;= 2 * n - len + 1; i++) { int j = i + len - 1; int tmax = 0, tmin = 0x3f3f3f3f; int ss = s[j] - s[i - 1]; for (ll k = i; k \u0026lt;= j - 1; k++) { tmax = max(tmax, dmax[i][k] + dmax[k + 1][j] + ss); tmin = min(tmin, dmin[i][k] + dmin[k + 1][j] + ss); } dmax[i][j] = tmax; dmin[i][j] = tmin; } } int mmin = 0x3f3f3f3f, mmax = 0; for (ll p = 0; p \u0026lt;= n - 1; p++) { mmin = min(mmin, dmin[p + 1][p + n]); mmax = max(mmax, dmax[p + 1][p + n]); } printf(\u0026#34;%d\\n%d\\n\u0026#34;, mmin, mmax); return 0; } ","title":"P1880 石子合并"},{"content":"题目大意 混合背包。每棵树都有美学值 $C_i$，共有三种：\n 一种只能看一遍。 一种最多看 $A_i$ 遍。 一种可以看无数遍。  分析 对于混合背包，我们可以对物品拆分，得到多个物品。\nll dp[1086], tt[100086], cc[100086]; int main() { int tsh = rr(), tsm = rr(), teh = rr(), tem = rr(); int tsum = (teh - tsh) * 60 + tem - tsm; int n = rr(); int tp = 1; for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(), c = rr(), p = rr(); if (p == 1) { tt[tp] = t, cc[tp] = c; tp++; } else { p = p != 0 ? p : 99999; int b = 1; while (b \u0026lt; p) { tt[tp] = t * b, cc[tp] = c * b; p -= b, b *= 2; tp++; } tt[tp] = t * p, cc[tp] = c * p; tp++; } } for (ll i = 1; i \u0026lt;= tp - 1; i++) { for (ll j = tsum; j \u0026gt;= tt[i]; j--) { dp[j] = max(dp[j], dp[j - tt[i]] + cc[i]); } } ll ans = 0; for (ll ic = 0; ic \u0026lt;= tsum; ic++) { ans = max(dp[ic], ans); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1833/","summary":"题目大意 混合背包。每棵树都有美学值 $C_i$，共有三种：\n 一种只能看一遍。 一种最多看 $A_i$ 遍。 一种可以看无数遍。  分析 对于混合背包，我们可以对物品拆分，得到多个物品。\nll dp[1086], tt[100086], cc[100086]; int main() { int tsh = rr(), tsm = rr(), teh = rr(), tem = rr(); int tsum = (teh - tsh) * 60 + tem - tsm; int n = rr(); int tp = 1; for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(), c = rr(), p = rr(); if (p == 1) { tt[tp] = t, cc[tp] = c; tp++; } else { p = p !","title":"P1833 樱花"},{"content":"题目大意 初始有四种卡片，消耗后分别可以前进 $1$、$2$、$3$ 和 $4$ 格。棋盘上每个点都有个分数，求从第 $1$ 格到达第 $N$ 格途径分数的最大值。\n分析 设状态 $F[i, j, k, w]$ 为使用 $i$ 张前进 $1$、……、$w$ 张前进 $4$ 之后的状态，容易得到转移方程\n$$ F[i, j, k, w] = \\max\\left\\{ \\begin{matrix} dp[i - 1, j, k, w] \\\\ dp[i, j - 1, k, w] \\\\ dp[i, j, k - 1, w] \\\\ dp[i, j, k, w - 1] \\end{matrix}\\right\\} + a[i + 2j + 3k + 4w] $$\n处理一下边界情况，滚动数组即可。\nll dp[50][50][50], aa[400], tt[10]; int main() { ll n = rr(), m = rr(); for (ll i = 1; i \u0026lt;= n; i++) { aa[i] = rr(); } for (ll i = 1; i \u0026lt;= m; i++) { tt[rr()]++; } for (ll i = 0; i \u0026lt;= tt[1]; i++) { for (ll j = 0; j \u0026lt;= tt[2]; j++) { for (ll k = 0; k \u0026lt;= tt[3]; k++) { for (ll w = 0; w \u0026lt;= tt[4]; w++) { dp[j][k][w] = aa[i * 1 + j * 2 + k * 3 + w * 4 + 1] + max4( j == 0 ? 0 : dp[j - 1][k][w], k == 0 ? 0 : dp[j][k - 1][w], w == 0 ? 0 : dp[j][k][w - 1], dp[j][k][w]); } } } } printf(\u0026#34;%lld\\n\u0026#34;, dp[tt[2]][tt[3]][tt[4]]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1541/","summary":"题目大意 初始有四种卡片，消耗后分别可以前进 $1$、$2$、$3$ 和 $4$ 格。棋盘上每个点都有个分数，求从第 $1$ 格到达第 $N$ 格途径分数的最大值。\n分析 设状态 $F[i, j, k, w]$ 为使用 $i$ 张前进 $1$、……、$w$ 张前进 $4$ 之后的状态，容易得到转移方程\n$$ F[i, j, k, w] = \\max\\left\\{ \\begin{matrix} dp[i - 1, j, k, w] \\\\ dp[i, j - 1, k, w] \\\\ dp[i, j, k - 1, w] \\\\ dp[i, j, k, w - 1] \\end{matrix}\\right\\} + a[i + 2j + 3k + 4w] $$\n处理一下边界情况，滚动数组即可。\nll dp[50][50][50], aa[400], tt[10]; int main() { ll n = rr(), m = rr(); for (ll i = 1; i \u0026lt;= n; i++) { aa[i] = rr(); } for (ll i = 1; i \u0026lt;= m; i++) { tt[rr()]++; } for (ll i = 0; i \u0026lt;= tt[1]; i++) { for (ll j = 0; j \u0026lt;= tt[2]; j++) { for (ll k = 0; k \u0026lt;= tt[3]; k++) { for (ll w = 0; w \u0026lt;= tt[4]; w++) { dp[j][k][w] = aa[i * 1 + j * 2 + k * 3 + w * 4 + 1] + max4( j == 0 ?","title":"P1541 乌龟棋"},{"content":"题目大意 在 $n \\times n$ 的格上，在每行中各有一条线段 $(i, l_i) \\to (i, r_i)$。\n你从 $(1,1)$ 出发，只能沿着格子直走，最终走到 $(n,n)$。要求沿途经过所有的线段，且所走路程长度尽量的短。\n分析 显然是一行一行的递推。维护两个数据，一个是走完该行后停留在左侧的，记作 ${\\rm DP}_l$，相应的停留在右侧的记作 ${\\rm DP}_r$。\n若停在左侧，可能从上一行的右侧走来，也可能是由左侧走来，故转移方程有\n$$ {\\rm DP}_l[i] = r_i - l_i + \\min\\{{\\rm DP}_l[i - 1] + |l_{i-1} - r_i|, {\\rm DP}_r[i - 1] + |r_{i - 1} - r_i|\\} $$\n右侧类似，故可以写出代码\nint main() { int n = rr(); ll past_l = 1, past_r = 1, dpl = 0, dpr = 0; for (ll i = 1; i \u0026lt;= n; i++) { ll l = rr(), r = rr(); ll tl = min(dpl + abs(past_l - r), dpr + abs(past_r - r)) + r - l; ll tr = min(dpl + abs(past_l - l), dpr + abs(past_r - l)) + r - l; dpl = tl, dpr = tr; past_l = l, past_r = r; } printf(\u0026#34;%lld\\n\u0026#34;, min(dpl + n - past_l, dpr + n - past_r) + n - 1); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-11/p3842/","summary":"题目大意 在 $n \\times n$ 的格上，在每行中各有一条线段 $(i, l_i) \\to (i, r_i)$。\n你从 $(1,1)$ 出发，只能沿着格子直走，最终走到 $(n,n)$。要求沿途经过所有的线段，且所走路程长度尽量的短。\n分析 显然是一行一行的递推。维护两个数据，一个是走完该行后停留在左侧的，记作 ${\\rm DP}_l$，相应的停留在右侧的记作 ${\\rm DP}_r$。\n若停在左侧，可能从上一行的右侧走来，也可能是由左侧走来，故转移方程有\n$$ {\\rm DP}_l[i] = r_i - l_i + \\min\\{{\\rm DP}_l[i - 1] + |l_{i-1} - r_i|, {\\rm DP}_r[i - 1] + |r_{i - 1} - r_i|\\} $$\n右侧类似，故可以写出代码\nint main() { int n = rr(); ll past_l = 1, past_r = 1, dpl = 0, dpr = 0; for (ll i = 1; i \u0026lt;= n; i++) { ll l = rr(), r = rr(); ll tl = min(dpl + abs(past_l - r), dpr + abs(past_r - r)) + r - l; ll tr = min(dpl + abs(past_l - l), dpr + abs(past_r - l)) + r - l; dpl = tl, dpr = tr; past_l = l, past_r = r; } printf(\u0026#34;%lld\\n\u0026#34;, min(dpl + n - past_l, dpr + n - past_r) + n - 1); return 0; } ","title":"P3842 线段"},{"content":"题目大意 要从 $n$ 种花中挑出 $m$ 盆展览，其中第 $i$ 种花不得多于 $a_i$ 种。求有几种选法。\n分析 考虑动态规划，记状态 $dp[i,j]$ 为摆完前 $i$ 种花，共 $j$ 盆时的方案数。容易得到递推式\n$$ dp[i,j] = \\sum_{k = j - \\min(a_i, j)}^j dp[i-1,k] $$\n边界条件是 $dp[0,0] = 1$。可以用滚动数组、前缀和优化。\nconst ll mod = 1e6 + 7; ll dp[110], aa[110], sum[110]; int main() { ll n = rr(), m = rr(); sum[0] = dp[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) aa[i] = rr(); for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= m; j++) sum[j] = (sum[j - 1] + dp[j]) % mod; for (ll j = m; j \u0026gt;= 0; j--) { int t = j - 1 - min(aa[i], j); if (t \u0026gt; 0) dp[j] = (dp[j] + sum[j - 1] - sum[t]) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, (dp[m] + mod) % mod); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1077/","summary":"题目大意 要从 $n$ 种花中挑出 $m$ 盆展览，其中第 $i$ 种花不得多于 $a_i$ 种。求有几种选法。\n分析 考虑动态规划，记状态 $dp[i,j]$ 为摆完前 $i$ 种花，共 $j$ 盆时的方案数。容易得到递推式\n$$ dp[i,j] = \\sum_{k = j - \\min(a_i, j)}^j dp[i-1,k] $$\n边界条件是 $dp[0,0] = 1$。可以用滚动数组、前缀和优化。\nconst ll mod = 1e6 + 7; ll dp[110], aa[110], sum[110]; int main() { ll n = rr(), m = rr(); sum[0] = dp[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) aa[i] = rr(); for (ll i = 1; i \u0026lt;= n; i++) { for (ll j = 1; j \u0026lt;= m; j++) sum[j] = (sum[j - 1] + dp[j]) % mod; for (ll j = m; j \u0026gt;= 0; j--) { int t = j - 1 - min(aa[i], j); if (t \u0026gt; 0) dp[j] = (dp[j] + sum[j - 1] - sum[t]) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, (dp[m] + mod) % mod); return 0; } ","title":"P1077 摆花"},{"content":"题目大意 可以合并两堆果子成一堆新果子，消耗两堆果子数目之和的体力。给定 $n$ 堆果子的数目 $a_i$，求体力耗费最小的方案。\n分析 很容易猜到贪心结论，不断选取两个最小的堆进行合并。\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(); q.push(t); } int sum = 0; while (q.size() \u0026gt;= 2) { int x = q.top(); q.pop(); int y = q.top(); q.pop(); sum += x + y; q.push(x + y); } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } 本质上是证明 Huffman 树的构造的正确性，有点复杂。\n","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1090/","summary":"题目大意 可以合并两堆果子成一堆新果子，消耗两堆果子数目之和的体力。给定 $n$ 堆果子的数目 $a_i$，求体力耗费最小的方案。\n分析 很容易猜到贪心结论，不断选取两个最小的堆进行合并。\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) { int t = rr(); q.push(t); } int sum = 0; while (q.size() \u0026gt;= 2) { int x = q.top(); q.pop(); int y = q.top(); q.pop(); sum += x + y; q.push(x + y); } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } 本质上是证明 Huffman 树的构造的正确性，有点复杂。","title":"P1090 合并果子"},{"content":"题目大意 给定数列，求第 $k$ 小的数。\n分析 模板题。考虑分治，随便选一个数 $x$，然后把比 $x$ 大的数移到右边，比 $x$ 小的数移到左边。因此得到了数 $x$ 的排位，若恰为第 $k$ 个则返回，否则根据大小在左右寻找。\n该算法是不稳定的，期望复杂度 $O(n)$，最坏复杂度 $O(n^2)$。\n实际上存在最坏复杂度为 $O(n)$ 的 BFPTR 算法，但因为其常数过大实现复杂而很少应用。\nll nn[5000010], k, n; ll quicksort(ll l, ll r) { ll i = l, j = r; ll x = nn[(l + r) / 2]; while (i \u0026lt;= j) { while (nn[j] \u0026gt; x) j--; while (nn[i] \u0026lt; x) i++; if (i \u0026lt;= j) { swap(nn[i], nn[j]); i++, j--; } } // l \u0026lt;= j \u0026lt;= i \u0026lt;=r  if (k \u0026lt;= j) return quicksort(l, j); else if (k \u0026gt;= i) return quicksort(i, r); else return nn[k + 1]; } int main() { n = rr(), k = rr(); for (ll i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;nn[i]); printf(\u0026#34;%lld\u0026#34;, quicksort(1, n)); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1923/","summary":"题目大意 给定数列，求第 $k$ 小的数。\n分析 模板题。考虑分治，随便选一个数 $x$，然后把比 $x$ 大的数移到右边，比 $x$ 小的数移到左边。因此得到了数 $x$ 的排位，若恰为第 $k$ 个则返回，否则根据大小在左右寻找。\n该算法是不稳定的，期望复杂度 $O(n)$，最坏复杂度 $O(n^2)$。\n实际上存在最坏复杂度为 $O(n)$ 的 BFPTR 算法，但因为其常数过大实现复杂而很少应用。\nll nn[5000010], k, n; ll quicksort(ll l, ll r) { ll i = l, j = r; ll x = nn[(l + r) / 2]; while (i \u0026lt;= j) { while (nn[j] \u0026gt; x) j--; while (nn[i] \u0026lt; x) i++; if (i \u0026lt;= j) { swap(nn[i], nn[j]); i++, j--; } } // l \u0026lt;= j \u0026lt;= i \u0026lt;=r  if (k \u0026lt;= j) return quicksort(l, j); else if (k \u0026gt;= i) return quicksort(i, r); else return nn[k + 1]; } int main() { n = rr(), k = rr(); for (ll i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;nn[i]); printf(\u0026#34;%lld\u0026#34;, quicksort(1, n)); return 0; } ","title":"P1923 求第 $k$ 小的数"},{"content":"题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。\n分析 我考虑用类似状态机的方式解析字符串。\n 当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$  写成 BNF 更直观一点\n\u0026lt;pwd\u0026gt; ::= \u0026lt;EMPTY\u0026gt; | {\u0026lt;ALPHA\u0026gt;} | \u0026lt;pwd\u0026gt; \u0026#34;[\u0026#34; \u0026lt;NUMBER\u0026gt; \u0026lt;pwd\u0026gt; \u0026#34;]\u0026#34; \u0026lt;pwd\u0026gt; string read() { string s = \u0026#34;\u0026#34;; char c; while (cin \u0026gt;\u0026gt; c) { if (c == \u0026#39;[\u0026#39;) { int n; cin \u0026gt;\u0026gt; n; string ts = read(); while (n--) s += ts; } else if (c == \u0026#39;]\u0026#39;) { return s; } else { s += c; } } return s; } int main() { cout \u0026lt;\u0026lt; read(); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1928/","summary":"题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。\n分析 我考虑用类似状态机的方式解析字符串。\n 当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$  写成 BNF 更直观一点\n\u0026lt;pwd\u0026gt; ::= \u0026lt;EMPTY\u0026gt; | {\u0026lt;ALPHA\u0026gt;} | \u0026lt;pwd\u0026gt; \u0026#34;[\u0026#34; \u0026lt;NUMBER\u0026gt; \u0026lt;pwd\u0026gt; \u0026#34;]\u0026#34; \u0026lt;pwd\u0026gt; string read() { string s = \u0026#34;\u0026#34;; char c; while (cin \u0026gt;\u0026gt; c) { if (c == \u0026#39;[\u0026#39;) { int n; cin \u0026gt;\u0026gt; n; string ts = read(); while (n--) s += ts; } else if (c == \u0026#39;]\u0026#39;) { return s; } else { s += c; } } return s; } int main() { cout \u0026lt;\u0026lt; read(); return 0; } ","title":"P1928 外星密码"},{"content":"题目大意 有 I 形和 L 形两种砖头，分别能覆盖 2 个单元和 3 个单元。求 $2 \\times n$ 的墙有多少不重复的覆盖方式，结果对 $10^4$ 取模。\n分析 其中 I 形砖块仅有横放和竖放两种。关键在于 L 形，两个 L 形之间可以用 I 形填充，这让情况变得复杂起来。\n对于 $F_n$ 的递推，我们可以想到\n 在 $F_{n-1}$ 后放一个 I 形砖块。 在 $F_{n-2}$ 后放两个横着的 I 形砖块。 对于更前面的递推，较为复杂。  两个 L 形砖块对齐，上下翻转也可以，即 $2 F_{n-3}$。 两个 L 形砖块可以对顶放，空缺恰用一个 I 填充，即 $2 F_{n-4}$。 类似 $2F_{n-3}$，中间可以再插入两个 I 形，即 $2 F_{n-5}$。 …… 直到 I 形和 L 形砖块恰好铺满墙壁，即 $2F_{0}$。    容易得到我们的递推式\n$$ F_n = F_{n-1} + F_{n-2} + 2 \\sum_{i=0}^{n-3} F_i $$\n利用错位相减法，不难化简得到\n$$ F_n = 2 F_{n-1} + F_{n-3} $$\n于是代码有\nint dp[1000000]; int main() { int n = rr(); dp[1] = 1, dp[2] = 2, dp[3] = 5; for (ll i = 4; i \u0026lt;= n; i++) dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 10000; printf(\u0026#34;%d\\n\u0026#34;, dp[n]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1990/","summary":"题目大意 有 I 形和 L 形两种砖头，分别能覆盖 2 个单元和 3 个单元。求 $2 \\times n$ 的墙有多少不重复的覆盖方式，结果对 $10^4$ 取模。\n分析 其中 I 形砖块仅有横放和竖放两种。关键在于 L 形，两个 L 形之间可以用 I 形填充，这让情况变得复杂起来。\n对于 $F_n$ 的递推，我们可以想到\n 在 $F_{n-1}$ 后放一个 I 形砖块。 在 $F_{n-2}$ 后放两个横着的 I 形砖块。 对于更前面的递推，较为复杂。  两个 L 形砖块对齐，上下翻转也可以，即 $2 F_{n-3}$。 两个 L 形砖块可以对顶放，空缺恰用一个 I 填充，即 $2 F_{n-4}$。 类似 $2F_{n-3}$，中间可以再插入两个 I 形，即 $2 F_{n-5}$。 …… 直到 I 形和 L 形砖块恰好铺满墙壁，即 $2F_{0}$。    容易得到我们的递推式","title":"P1990 覆盖墙壁"},{"content":"题目大意 给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$ ，求最耗体力的路径。\n分析 容易猜到贪心结论，是不断的在剩余石头中最大最小的来回跳。\n考虑证明结论，设 $h_i$ 是将要跳的序列，展开求和式\n$$ S = \\sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \\sum_{k=1}^nh_k^2 - 2\\sum_{k=1}^{n-1}h_kh_{k+1} $$\n注意到平方和为一个定值，重点在后半式。记 $H_k = h_{k+1}$，有\n$$ \\sum_{k=1}^{n-1}h_kH_k $$\n利用高中时学的排序不等式，有\n$$ \\text{反序和} \\leqslant \\text{乱序和} \\leqslant \\text{顺序和} $$\n于是有反序最小。双指针维护即可。\nll nn[310]; int main() { ll n = rr(); for (ll i = 1; i \u0026lt;= n; i++) nn[i] = rr(); sort(nn + 1, nn + n + 1); ll l = 0, r = n, sum = 0; while (l \u0026lt; r) { ll t1 = nn[l] - nn[r], t2 = nn[l + 1] - nn[r]; sum += t1 * t1 + t2 * t2; l++, r--; } printf(\u0026#34;%lld\\n\u0026#34;, sum); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p4995/","summary":"题目大意 给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$ ，求最耗体力的路径。\n分析 容易猜到贪心结论，是不断的在剩余石头中最大最小的来回跳。\n考虑证明结论，设 $h_i$ 是将要跳的序列，展开求和式\n$$ S = \\sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \\sum_{k=1}^nh_k^2 - 2\\sum_{k=1}^{n-1}h_kh_{k+1} $$\n注意到平方和为一个定值，重点在后半式。记 $H_k = h_{k+1}$，有\n$$ \\sum_{k=1}^{n-1}h_kH_k $$\n利用高中时学的排序不等式，有\n$$ \\text{反序和} \\leqslant \\text{乱序和} \\leqslant \\text{顺序和} $$\n于是有反序最小。双指针维护即可。\nll nn[310]; int main() { ll n = rr(); for (ll i = 1; i \u0026lt;= n; i++) nn[i] = rr(); sort(nn + 1, nn + n + 1); ll l = 0, r = n, sum = 0; while (l \u0026lt; r) { ll t1 = nn[l] - nn[r], t2 = nn[l + 1] - nn[r]; sum += t1 * t1 + t2 * t2; l++, r--; } printf(\u0026#34;%lld\\n\u0026#34;, sum); return 0; } ","title":"P4995 跳跳！"},{"content":"题目大意 在三维空间中，HKE 只能往上走，求攀爬总长。\n分析 对所有座标的 $z$ 分量排序即可。\nstruct POINT { double x, y, z; bool operator\u0026lt;(POINT p) { return z \u0026gt; p.z; } } nn[50010]; double dis(POINT \u0026amp;p1, POINT \u0026amp;p2) { double t1 = p1.x - p2.x, t2 = p1.y - p2.y, t3 = p1.z - p2.z; return sqrt(t1 * t1 + t2 * t2 + t3 * t3); } int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; nn[i].x \u0026gt;\u0026gt; nn[i].y \u0026gt;\u0026gt; nn[i].z; sort(nn + 1, nn + n + 1); double len = 0; for (ll i = 2; i \u0026lt;= n; i++) len += dis(nn[i], nn[i-1]); printf(\u0026#34;%.3lf\\n\u0026#34;, len); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p5143/","summary":"题目大意 在三维空间中，HKE 只能往上走，求攀爬总长。\n分析 对所有座标的 $z$ 分量排序即可。\nstruct POINT { double x, y, z; bool operator\u0026lt;(POINT p) { return z \u0026gt; p.z; } } nn[50010]; double dis(POINT \u0026amp;p1, POINT \u0026amp;p2) { double t1 = p1.x - p2.x, t2 = p1.y - p2.y, t3 = p1.z - p2.z; return sqrt(t1 * t1 + t2 * t2 + t3 * t3); } int main() { int n = rr(); for (ll i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; nn[i].","title":"P5143 攀爬者"},{"content":"P1095 守望者的逃离 题目大意 守望者的可以在一秒逃出 $17 {\\rm m}$，或者消耗 $10$ 点魔法值闪现 $60 {\\rm m}$。原地休息时每秒回复 $4$ 点魔法值。\n守望者开始有 $M$ 点魔法，需要在 $T$ 秒内逃离距离 $S$。若能逃离则求最短逃离时间，否则求最远距离。\n分析 设 $s_1$为一直走路，$s_2$ 为一直闪现恢复。当 $s_2$ 快了就把 $s_1$ 更新为 $s_2$。\nint main() { int m = rr(), s = rr(), t = rr(); int time = t, s1 = 0, s2 = 0; while (time \u0026gt; 0 \u0026amp;\u0026amp; s1 \u0026lt; s) { s1 += 17; if (m \u0026gt;= 10) m -= 10, s2 += 60; else m += 4; s1 = max(s1, s2); time--; } if (s1 \u0026lt; s) printf(\u0026#34;No\\n%d\\n\u0026#34;, s1); else printf(\u0026#34;Yes\\n%d\\n\u0026#34;, t - time); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1095/","summary":"P1095 守望者的逃离 题目大意 守望者的可以在一秒逃出 $17 {\\rm m}$，或者消耗 $10$ 点魔法值闪现 $60 {\\rm m}$。原地休息时每秒回复 $4$ 点魔法值。\n守望者开始有 $M$ 点魔法，需要在 $T$ 秒内逃离距离 $S$。若能逃离则求最短逃离时间，否则求最远距离。\n分析 设 $s_1$为一直走路，$s_2$ 为一直闪现恢复。当 $s_2$ 快了就把 $s_1$ 更新为 $s_2$。\nint main() { int m = rr(), s = rr(), t = rr(); int time = t, s1 = 0, s2 = 0; while (time \u0026gt; 0 \u0026amp;\u0026amp; s1 \u0026lt; s) { s1 += 17; if (m \u0026gt;= 10) m -= 10, s2 += 60; else m += 4; s1 = max(s1, s2); time--; } if (s1 \u0026lt; s) printf(\u0026#34;No\\n%d\\n\u0026#34;, s1); else printf(\u0026#34;Yes\\n%d\\n\u0026#34;, t - time); return 0; } ","title":"P1095 守望者的逃离"},{"content":"题目大意 赢 11 分并且压对手两分以上则一局结束，否则要追分至压对手两分。\n给定 $\\texttt{WL}$ 序列，分别求 11 分制和 21 分制下每场比分，$\\texttt{E}$ 是结束符。\n分析 这是一道比较烦的模拟题，很绕。\nchar ch[62510]; int solve(int win, int len) { int w = 0, l = 0; for (ll i = 0; i \u0026lt; len; i++) { w += ch[i] == \u0026#39;W\u0026#39;; l += ch[i] == \u0026#39;L\u0026#39;; if (max(w, l) \u0026gt;= win \u0026amp;\u0026amp; abs(w - l) \u0026gt;= 2) { printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); w = l = 0; } } printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); } int main() { char ccc; int len = 0; while (scanf(\u0026#34;%c\u0026#34;, \u0026amp;ccc) != EOF) { if (ccc != \u0026#39;E\u0026#39;) ch[len++] = ccc; else break; } solve(11, len); LN; solve(21, len); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1042/","summary":"题目大意 赢 11 分并且压对手两分以上则一局结束，否则要追分至压对手两分。\n给定 $\\texttt{WL}$ 序列，分别求 11 分制和 21 分制下每场比分，$\\texttt{E}$ 是结束符。\n分析 这是一道比较烦的模拟题，很绕。\nchar ch[62510]; int solve(int win, int len) { int w = 0, l = 0; for (ll i = 0; i \u0026lt; len; i++) { w += ch[i] == \u0026#39;W\u0026#39;; l += ch[i] == \u0026#39;L\u0026#39;; if (max(w, l) \u0026gt;= win \u0026amp;\u0026amp; abs(w - l) \u0026gt;= 2) { printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); w = l = 0; } } printf(\u0026#34;%d:%d\\n\u0026#34;, w, l); } int main() { char ccc; int len = 0; while (scanf(\u0026#34;%c\u0026#34;, \u0026amp;ccc) !","title":"P1042 乒乓球"},{"content":"题目大意 凸 $n$ 边形中，任意三条对角线不共点，求所有对角线交点的个数。\n分析 注意到一个交点对应凸多边形 $4$ 个定点，于是等价于 $n$ 个点任选 $4$ 个点的选法种数，即\n$$ \\binom{n}{4} = \\frac{n(n-1)(n-2)(n-3)}{24} $$\n注意爆 long long，需要写成 n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4。\nint main() { unsigned long long n; scanf(\u0026#34;%llu\u0026#34;, \u0026amp;n); n = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4; printf(\u0026#34;%llu\u0026#34;, n); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p2181/","summary":"题目大意 凸 $n$ 边形中，任意三条对角线不共点，求所有对角线交点的个数。\n分析 注意到一个交点对应凸多边形 $4$ 个定点，于是等价于 $n$ 个点任选 $4$ 个点的选法种数，即\n$$ \\binom{n}{4} = \\frac{n(n-1)(n-2)(n-3)}{24} $$\n注意爆 long long，需要写成 n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4。\nint main() { unsigned long long n; scanf(\u0026#34;%llu\u0026#34;, \u0026amp;n); n = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4; printf(\u0026#34;%llu\u0026#34;, n); return 0; } ","title":"P2181 对角线"},{"content":"题目大意 海里每一个位置都有一个深度，而且水里随着时间有锯齿状周期为 $2k$ 的潮汐。\n当潮汐与深度之和大于给定值 $l$ 时 Koa 会溺水，游泳、海岸、岛上永远是安全的。\n在任意时间 Koa 可以选择游到 $x+1$ 或停留在 $x$，试问 Koa 是否能够安全的从海岸 $0$ 到达岛上 $n+1$。\n分析 开始的想法是随着时间 DP，更好的解法是贪心。\n若一个位置在水位最高时仍不会溺水，则称这个位置是安全的，并且可以任意选择出发时机。\n即安全位置之间是相互独立的，我们只需判断可达性，尽量到达每一个安全位置。若之后 $2k$ 个位置没有安全位置，必死。\nKoa 的最优决策是在刚退潮时出发，如果能走就尽量往前走，不能走就等，等到涨潮就说明不存在通过方法。\nint main() { int ttt = rr(); while (ttt--) { int n = rr(), k = rr(), l = rr(); int flag = 0; int last = k; for (ll i = 1; i \u0026lt;= n; i++) { int d = rr(); flag += l \u0026lt; d; if (l - d \u0026gt;= k) last = k; else last = min(last - 1, l - d); flag += abs(last) \u0026gt; l - d; } if (flag) printf(\u0026#34;No\\n\u0026#34;); else printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/cf1384b2/","summary":"题目大意 海里每一个位置都有一个深度，而且水里随着时间有锯齿状周期为 $2k$ 的潮汐。\n当潮汐与深度之和大于给定值 $l$ 时 Koa 会溺水，游泳、海岸、岛上永远是安全的。\n在任意时间 Koa 可以选择游到 $x+1$ 或停留在 $x$，试问 Koa 是否能够安全的从海岸 $0$ 到达岛上 $n+1$。\n分析 开始的想法是随着时间 DP，更好的解法是贪心。\n若一个位置在水位最高时仍不会溺水，则称这个位置是安全的，并且可以任意选择出发时机。\n即安全位置之间是相互独立的，我们只需判断可达性，尽量到达每一个安全位置。若之后 $2k$ 个位置没有安全位置，必死。\nKoa 的最优决策是在刚退潮时出发，如果能走就尽量往前走，不能走就等，等到涨潮就说明不存在通过方法。\nint main() { int ttt = rr(); while (ttt--) { int n = rr(), k = rr(), l = rr(); int flag = 0; int last = k; for (ll i = 1; i \u0026lt;= n; i++) { int d = rr(); flag += l \u0026lt; d; if (l - d \u0026gt;= k) last = k; else last = min(last - 1, l - d); flag += abs(last) \u0026gt; l - d; } if (flag) printf(\u0026#34;No\\n\u0026#34;); else printf(\u0026#34;Yes\\n\u0026#34;); } return 0; } ","title":"CF1384B2 Koa and the Beach"},{"content":"题目大意 在 $n \\times n$ 的方格（$n \\leqslant 9$）中存在一些正整数，经过格子时获得格子上的数，但只能获得一次。\n某人只能向右或向下走，从格子的左上角走到到右下角，共走两次，求最大能取得的数字。\n分析 考虑把先走后走转化为两个人同时走，只需要处理遇到两次的值即可。\n考虑四维 DP，用 $dp[x_1,y_1,x_2,y_2]$ 表示第一个人走到 $(x_1,y_1)$ 和第二个人走到 $(x_2,y_2)$。\n再考虑转移，每一个位置仅可能从其左面或上面转移来，于是可以写出（$x_1 \\ne y_1$ 或 $x_2 \\ne y_2$ 时）\n$$ dp[x_1,y_1,x_2,y_2] = \\max\\left\\{ \\begin{matrix} dp[x_1-1,y_1,x_2-1,y_2] \\\\ dp[x_1,y_1-1,x_2-1,y_2] \\\\ dp[x_1-1,y_1,x_2,y_2-1] \\\\ dp[x_1,y_1-1,x_2,y_2-1] \\end{matrix}\\right\\} + a[x_1,y_1] + a[x_2,y_2] $$\n当 $x_1=y_1,x_2=y_2$ 时，只加一次即可。到这里 $O(n^4)$ 其实已经可以过题了，但还可以优化。\n注意到一些状态是不可达的，因为 $x_1+y_1 = x_2+y_2$，因此存在 $O(n^3)$ 的 DP。\n考虑当前已走长度 $h=x_1+y_1=x_2+y_2$，于是可以把两个人的座标表示为 $(x_1,h-x_1)$ 和 $(x_2,h-x_2)$。\n于是记状态为 $dp[h,x_1,x_2]$，当 $x_1 \\ne x_2$ 时有\n$$ dp[h,x_1,x_2] = \\max\\left\\{ \\begin{matrix} dp[h-1,x_1,x_2] \\\\ dp[h-1,x_1,x_2-1] \\\\ dp[h-1,x_1-1,x_2] \\\\ dp[h-1,x_1-1,x_2-1] \\end{matrix}\\right\\} + a[x_1,h-x_1] + a[x_2,h-x_2] $$\n再注意到可以使用滚动数组，因此有\nll mtx[10][10], dp[10][10]; int main() { ll N = rr(); while (true) { ll a = rr(), b = rr(), c = rr(); if (a + b + c == 0) break; mtx[a][b] = c; } for (ll ss = 2; ss \u0026lt;= 2 * N; ss++) { ll max_x1 = min(N, ss - 1), min_x1 = max(1ll, ss - N); for (ll x1 = max_x1; x1 \u0026gt;= min_x1; x1--) { ll max_x2 = min(N, ss - 1), min_x2 = max(1ll, ss - N); for (ll x2 = max_x2; x2 \u0026gt;= min_x2; x2--) { dp[x1][x2] = max4( dp[x1 - 1][x2 - 1], dp[x1][x2 - 1], dp[x1 - 1][x2], dp[x1][x2] ); dp[x1][x2] += mtx[x1][ss - x1] + mtx[x2][ss - x2]; if (x1 == x2) dp[x1][x2] -= mtx[x1][ss - x1]; } } } printf(\u0026#34;%lld\\n\u0026#34;, dp[N][N]); return 0; } ","permalink":"https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1004/","summary":"题目大意 在 $n \\times n$ 的方格（$n \\leqslant 9$）中存在一些正整数，经过格子时获得格子上的数，但只能获得一次。\n某人只能向右或向下走，从格子的左上角走到到右下角，共走两次，求最大能取得的数字。\n分析 考虑把先走后走转化为两个人同时走，只需要处理遇到两次的值即可。\n考虑四维 DP，用 $dp[x_1,y_1,x_2,y_2]$ 表示第一个人走到 $(x_1,y_1)$ 和第二个人走到 $(x_2,y_2)$。\n再考虑转移，每一个位置仅可能从其左面或上面转移来，于是可以写出（$x_1 \\ne y_1$ 或 $x_2 \\ne y_2$ 时）\n$$ dp[x_1,y_1,x_2,y_2] = \\max\\left\\{ \\begin{matrix} dp[x_1-1,y_1,x_2-1,y_2] \\\\ dp[x_1,y_1-1,x_2-1,y_2] \\\\ dp[x_1-1,y_1,x_2,y_2-1] \\\\ dp[x_1,y_1-1,x_2,y_2-1] \\end{matrix}\\right\\} + a[x_1,y_1] + a[x_2,y_2] $$\n当 $x_1=y_1,x_2=y_2$ 时，只加一次即可。到这里 $O(n^4)$ 其实已经可以过题了，但还可以优化。\n注意到一些状态是不可达的，因为 $x_1+y_1 = x_2+y_2$，因此存在 $O(n^3)$ 的 DP。\n考虑当前已走长度 $h=x_1+y_1=x_2+y_2$，于是可以把两个人的座标表示为 $(x_1,h-x_1)$ 和 $(x_2,h-x_2)$。\n于是记状态为 $dp[h,x_1,x_2]$，当 $x_1 \\ne x_2$ 时有\n$$ dp[h,x_1,x_2] = \\max\\left\\{ \\begin{matrix} dp[h-1,x_1,x_2] \\\\ dp[h-1,x_1,x_2-1] \\\\ dp[h-1,x_1-1,x_2] \\\\ dp[h-1,x_1-1,x_2-1] \\end{matrix}\\right\\} + a[x_1,h-x_1] + a[x_2,h-x_2] $$","title":"P1004 方格取数"},{"content":"","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/jump/","summary":"","title":"OJ 题目跳转"},{"content":"","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/template-gen/","summary":"","title":"模板生成"},{"content":"","permalink":"https://rogeryoungh.github.io/code-of-acm/post/other/code/","summary":"","title":"贴代码"}]