<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Roger Young</title>
    <link>https://rogeryoungh.github.io/code-of-acm/post/</link>
    <description>Recent content in Posts on Roger Young</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>© 2021 [Roger Young](https://rogeryoungh.github.io/blog/about/)</copyright>
    <lastBuildDate>Mon, 14 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://rogeryoungh.github.io/code-of-acm/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ZAFU 2022.02.14 个人赛题解</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2022-02/hj5/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2022-02/hj5/</guid>
      <description>本次比赛翻译出现了大问题，想大家道歉。
同时一些同学反映已经做过，下次个人赛会再拉更早的题目。
A - ABC222A 签到，不讲。
int main() { int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); printf(&amp;#34;%04d&amp;#34;, x); return 0; } B - CF1395A 题目大意 给定四种颜色的球，允许把三个红、绿、蓝的球转换为三个白色的，问是否存在方法使得能够排成回文的一列。
分析 注意到四种颜色个数只有 $0$ 个或 $1$ 个奇数时，才能够摆成回文的一列。
而转换对四种颜色都意味着奇数变偶数，偶数变奇数。即转换两次又回到原先的奇偶序列，故只用变换一次。
bool check(const vector&amp;lt;int&amp;gt; &amp;amp;v) { vector&amp;lt;int&amp;gt; cnt(2); for (auto i : v) { if (i &amp;lt; 0) return false; cnt[i % 2]++; } return cnt[1] &amp;lt;= 1; } int main() { int T; cin &amp;gt;&amp;gt; T; while (T--) { vector&amp;lt;int&amp;gt; v1(4), v2(4); for (int i = 0; i &amp;lt; 4; i++) cin &amp;gt;&amp;gt; v1[i], v2[i] = v1[i]; v2[0]--, v2[1]--, v2[2]--, v2[3] += 3; if (check(v1) || check(v2)) { printf(&amp;#34;Yes\n&amp;#34;); } else { printf(&amp;#34;No\n&amp;#34;); } } return 0; } C - CF1393B 题目大意 给定一些长度，问是否能够组成一个长方形和一个正方形。</description>
    </item>
    
    <item>
      <title>2022 年刷题日志</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/other/log2022/</link>
      <pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/other/log2022/</guid>
      <description>新的一年，一样的菜。
过于简单的题不记录。
2022 年 01 月 01-14 |  UOJ50 链式反应
01-21 |  ZAFU 2022.01.18 个人赛题解
01-27 |  P3373 线段树 2
01-27 |  P2023 维护序列
01-28 |  P1531 I Hate It
01-28 |  P5057 简单题
01-28 |  P4588 数学计算
01-28 |  P1637 三元上升子序列
01-29 |  P5431 乘法逆元 2
2022 年 02 月 02-11 |  P6186 冒泡排序
02-14 |  ZAFU 2022.02.14 个人赛题解</description>
    </item>
    
    <item>
      <title>P6186 冒泡排序</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2022-02/p6186/</link>
      <pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2022-02/p6186/</guid>
      <description>题目大意 给定一个长为 $n$ 的排列 $p$，有如下操作
 交换 $p_{x}, p_{x+1}$。 询问排列经过 $k$ 轮冒泡排序后的逆序数。  分析 难点在观察冒泡排序对逆序数的影响，考虑一个数 $p_i$ 受其前面的数影响：
 如果 $p_i$ 前面没有比 $p_i$ 大的，冒泡后 $p_{i&#39;}$ 仍不贡献逆序数。 如果 $p_i$ 前面有 $j$ 个比当前数大的，冒泡后有且仅有一个数穿过了 $p_{i&#39;}$，贡献的逆序数减 $1$。  故第 $k$ 轮冒泡后，即每个数贡献的逆序数都要减 $k$。又因为不应减到负数，因此需要用两个树状数组维护。
#include &amp;#34;template/ds/fwtree/1.hpp&amp;#34; int main() { int n = rr(), m = rr(); vector&amp;lt;int&amp;gt; p(n); for (int i = 0; i &amp;lt; n; i++) p[i] = rr(); vector&amp;lt;ll&amp;gt; inver(n); { vector&amp;lt;pii&amp;gt; tp(n); for (int i = 0; i &amp;lt; n; i++) tp[i] = {p[i], i + 1}; sort(tp.</description>
    </item>
    
    <item>
      <title>P5431 乘法逆元 2</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p5431/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p5431/</guid>
      <description>题目大意 给定 $n$ 个正整数 $\{a_i\}$ 和 $k$，求在模 $p$ 意义下的
$$ \sum_{i=1}^n \frac{k^i}{a_i} \bmod p $$
分析 逐个求逆元是 $O(n \log p)$ 的，肯定会 T，需要想想别的办法。
批量求逆元的一个技巧，先求出 $a_i$ 的前缀积，然后求出全部积的逆元，再逐个往前推。即
$$ (a_n)^{-1} = \left(\prod_{i=1}^{n-1} a_i\right) \left(\prod_{i=1}^n a_i\right)^{-1} $$
显然，$\{a_n\}$ 中不能有 $0$。
vi get_inv(const vi &amp;amp;a, int p) { int n = a.size() - 1; vi prod(n + 1); prod[0] = 1; for (int i = 1; i &amp;lt;= n; i++) { prod[i] = 1ll * prod[i - 1] * a[i] % p; } prod[n] = qpow(prod[n], p - 2, p); vi iva(n + 1); for (int i = n; i &amp;gt;= 1; i--) { iva[i] = 1ll * prod[i] * prod[i - 1] % p; prod[i - 1] = 1ll * prod[i] * a[i] % p; } return iva; } </description>
    </item>
    
    <item>
      <title>P1637 三元上升子序列</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p1637/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p1637/</guid>
      <description>题目大意 给定一个序列，求其中三元上升子序列的个数
 对于 $i,j,k$，若 $a_i &amp;lt; a_j &amp;lt; a_k$，则是一个满足要求的三元对。  分析 考虑枚举中间的数 $j$，设其左边有 $a$ 个数比它小，右边有 $b$ 个数比它大，则中间为 $j$ 的三元对个数为 $ab$。
至此就和逆序对类似了，离散化后用树状数组即可。
#include &amp;#34;template/ds/fwtree/0.hpp&amp;#34; int main() { int n = rr(); vector&amp;lt;pii&amp;gt; v(n + 1); for (int i = 1; i &amp;lt;= n; i++) { v[i] = {rr(), i}; } sort(v.begin(), v.end(), [](pii a, pii b) { if (a.first == b.first) return a.second &amp;gt; b.second; return a.first &amp;lt; b.first; }); fwtree_1&amp;lt;int&amp;gt; tr(n + 1); vector&amp;lt;ll&amp;gt; al(n + 1), ar(n + 1); for (int i = 1; i &amp;lt;= n; i++) { al[i] = tr.</description>
    </item>
    
    <item>
      <title>P3373 线段树 2</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p3373/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p3373/</guid>
      <description>题目大意 给定一个数列，有如下操作：
 将区间 $[l,r]$ 上的数乘上 $x$ 将区间 $[l,r]$ 上的数加上 $x$ 询问区间 $[l,r]$ 上的数之和  分析 很经典的线段树教学题，写完后对线段树的理解确实更深了。
从一次函数的角度考虑问题感觉更清晰。我们实际上在对每个序列上的值做一次函数
$$ f_i(x) = k_i x + m_i $$
先来看本题线段树的结构
template &amp;lt;class T&amp;gt; struct SegmentTree { vector&amp;lt;Seg&amp;gt; tr; void pushup(int p); void pushdown(int p); void build(int l, int r, int p = 1); void modify(int l, int r, T k, T m, int p = 1); T query(int l, int r, int p = 1); }; 懒标记：在知道一段当前值的情况下，可以立刻知道该段被操作后的值，不必重新计算所有的数。因此可以把当前的操作存起来，询问的时候再对子节点做真实操作。</description>
    </item>
    
    <item>
      <title>P4588 数学计算</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p4588/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p4588/</guid>
      <description>题目大意 初始是 $x=1$，我们每轮对 $x$ 做一个操作
 将 $x$ 变为 $k x$，并输出 $x \bmod M$。 将 $x$ 变为 $x / k_i$，即取消第 $i$ 次操作，并输出 $x \bmod M$。  保证每个操作 1 的 $k$ 在操作 2 中至多被除一次。
分析 $M$ 并不保证是质数，逆元可能不存在。
可以把操作序列看作一个乘积式，初始情况下全为 $1$。
 操作 1 即是把第 $i$ 个数变为 $k$。 操作 2 即是把第 $i$ 个数变回 $1$。  修改结束后，询问所有数的乘积。单点修改，区间查询，标准的线段树。
因为只询问全体和，zkw 好写的多。
template &amp;lt;class T&amp;gt; struct SegmentTree { vector&amp;lt;T&amp;gt; tr; int N; SegmentTree(int l, int r) { int n = r - l + 1; N = 2 &amp;lt;&amp;lt; std::__lg(n); tr.</description>
    </item>
    
    <item>
      <title>P5057 简单题</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p5057/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2022-01/p5057/</guid>
      <description>题目大意 给定一个 01 序列，有如下操作：
 将区间 $[l,r]$ 上的数 01 翻转。 询问第 $i$ 个数的值。  分析 区间操作，单点查询，很自然的想到了差分。
用异或或者加减代替翻转都可以，用树状数组维护。我选择了加减，这样询问时对 $2$ 取余即可。
#include &amp;#34;template/ds/fwtree/0.hpp&amp;#34; int main() { int n = rr(), m = rr(); fwtree_1&amp;lt;int&amp;gt; tr(n + 2); while (m--) { int t = rr(); if (t == 1) { int l = rr() + 1, r = rr() + 1; tr.modify(l - 1, -1), tr.modify(r, 1); } else { int i = rr(); i = tr.</description>
    </item>
    
    <item>
      <title>代码模板</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/other/docs/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/other/docs/</guid>
      <description>我的代码模板依赖于我自定义的预处理器，它通过 DFS 把所有引入的模板展开。
 index.hpp：公共文件头。  我的模板风格是简单封装：在保持易用的同时，封装尽量的薄。
Data Struct 基础数据结构。
 fwtree/1.hpp：普通树状数组。 fwtree/2.hpp：支持区间修改、区间查询的树状数组。 SegmentTree/1.hpp：普通线段树示例，不可引入。 SegmentTree/2.hpp：带懒标记的线段树示例，不可引入。  Math 基础数学算法。
 qpow.hpp：快速幂。 qpow128.hpp：64 位类型的快速幂。  Basic 我也不知道这东西该放哪，就放到这里吧。
 modint：m32。  NTT-int 简化多项式板子，码量少，常数较大。
 fps/O.hpp：多项式基础结构，用牛顿迭代完成操作。 fps/F.hpp：与上面的相同，略卡常数。 cdq.hpp：非递归 CDQ 分治。 eval.hpp：多点插值，多点求值。  没有用的 NTT-mint 基于 modint 的多项式板子，注重易用性和常数，码量较大。
每一种算法可能有多种实现。
多项式类的定义
 poly/1.hpp：继承于 vector&amp;lt;m32&amp;gt;。  NTT
 ntt/1.hpp：无 rev 的 NTT。 ntt/2.hpp：略微卡常的 NTT。  多项式逆
 inv/1.hpp：12E 的牛顿迭代 inv，和 16E 的牛顿迭代 div。 inv/2.hpp：10E 的牛顿迭代 inv，和 13E 的牛顿迭代 div。 inv/3.</description>
    </item>
    
    <item>
      <title>ZAFU 2022.01.18 个人赛题解</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2022-01/hj1/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2022-01/hj1/</guid>
      <description>非常抱歉，本次比赛对难度估计不当，给大家造成了不好的体验，在此向大家致歉。
A - CF1379A 题目大意 替换字符串 $s$ 中的 ?，使得出现且仅出现一次 abacaba。
分析 本题较为难写，因为很难判断恰好出现了一次。但是数据规模很小，可以采用非常暴力的写法。
一种想法是，枚举每个出现 abacaba 的位置 $i$，把当前 $s[i, i + 6]$ 中的 ? 设为给定串，这样就得到了字符串 $t$。
然后判断字符串 $t$ 中只出现了一次 abacaba，可以通过 substr 枚举所有长为 $6$ 的子串。
string what = &amp;#34;abacaba&amp;#34;; void solve() { int len; string s; cin &amp;gt;&amp;gt; len &amp;gt;&amp;gt; s; for (int i = 0; i &amp;lt; len - 6; i++) { string tmp = s; for (int j = 0; j &amp;lt; 7; j++) if (tmp[i + j] == &amp;#39;?</description>
    </item>
    
    <item>
      <title>CF Round 706(Div 2)</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-11/cf1496/</link>
      <pubDate>Thu, 11 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-11/cf1496/</guid>
      <description>D. Let&#39;s Go Hiking 两人在序列上移动，Qingshan 只能往值更高的地方走，Daniel 只能往低处走。两人不能重叠，求 Qingshan 中有多少可以赢的位置。
分析 其实我们只用关注上升和下降的序列有多长，而不必关心它们具体是几。
如果 Qingshan 选边界上的坡，或者不选在坡顶，那么 Daniel 可以紧挨着它，从而必输。
如果 Qingshan 不选最长的坡，则 Danniel 可以选最长的坡，从而必输。
如果最长的坡存在没有公共最高点的两个，Danniel 可以避开 Qingshan 选，从而必输。
剩下的情况只有两种：
 最长的坡只有一个，Qingshan 只能选在此坡坡顶，Danniel 可以选在靠近坡底的地方，使得两人碰面，从而必输。 最长的坡有两个且有公共最高点，Qingshan 选在坡顶，则可以选择避开 Danniel 下坡，从而必胜。  附：代码，展开
E. Garden of the Sun 在棋盘的格子中有不连续的 X，请连接使得其满足如下条件
 X 组成的图案是连通的。 X 组成的图案不存在环。  分析 X 不连续是一个比较强的性质。
构造类似 丰 字形的图案，横与横之间空两行，这样可以使得所有 X 都附在一条横上，且互相不连接。
接下来考虑如何把横连起来，可以发现只用在第一列、第二列中选一列进行连接即可。
附：代码，展开
F. BFS Trees  第一次补题补到 F 耶！什么时候才能在赛中做到 F 呢……
 我们定义一个图上的生成树是以 $s$ 点为根的 BFS 树，当且仅当：对于任意的节点 $t$，$s\to t$ 在 BFS 树上的最短路等于图上的最短路。</description>
    </item>
    
    <item>
      <title>2021 年刷题日志</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/other/log2021/</link>
      <pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/other/log2021/</guid>
      <description>过于简单的题不记录。
洛谷：更新至：2021.11.10(&amp;ndash;.&amp;ndash;)
CodeForces：更新至：&amp;ndash;.&amp;ndash;
牛客：更新至：&amp;ndash;.&amp;ndash;
HDU：更新至：&amp;ndash;.&amp;ndash;
2021 年 01 月 01-25 |  P3378 堆
2021 年 02 月 02-28 |  P1216 数字三角形
2021 年 03 月 03-02 |  P3382 三分法
03-06 |  P3865 ST 表
03-17 |  P1162 填涂颜色
03-17 |  P1019 单词接龙
03-19 |  P1014 Cantor 表
03-19 |  P3370 字符串哈希
03-20 |  P3375 KMP 字符串匹配
03-20 |  P3374 树状数组 1</description>
    </item>
    
    <item>
      <title>P1393 Mivik 的标题</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-11/p1393/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-11/p1393/</guid>
      <description>题目大意 在字符集中有 $m$ 个不同的字符，求给定字符串 $S$ 在长度为 $n$ 的字符串的全集中出现的概率。
分析 参考 Mivik 的字符串公开赛。
定义 $A$ 类字符串为，在整个字符串中 $S$ 只出现过一次，且恰好 $S$ 出现在末尾的字符串。
设 $\{f_i\}$ 是长度为 $i$ 的字符串中 $A$ 类字符串的个数。再定义 $\{g_i\}$ 是长度为 $i$ 的字符串中没有出现过 $S$ 的个数。
在长为 $i$ 的没有出现过 $S$ 的字符串后面加上一个字符，则可能出现 $S$ 也可能没有出现 $S$。
$$ m g_i = f_{i+1} + g_{i+1} $$
定义关于 $S$ 的数列 $\{s_i\}$ 为
$$ s_i = [i \ \text{is a period of}\ S] $$
即当 $i$ 是 $S$ 的一个循环节时，$s_i$ 为 $1$，否则为 $0$。</description>
    </item>
    
    <item>
      <title>P5179 Fraction</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5179/</link>
      <pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5179/</guid>
      <description>题目大意 求最简分数 $p/q$ 满足
$$ \frac{a}{b} &amp;lt; \frac{p}{q} &amp;lt; \frac{c}{d} $$
若有多组解，输出 $q$ 最小的；仍有多组解，输出 $p$ 最小的一组。
分析 分类讨论：
 首先当 $\lfloor a/b \rfloor + 1 \leqslant \lceil c/d \rceil - 1$ 时，说明两个数之间存在一个整数，直接返回 $p = 1, q = \lfloor a / b \rfloor + 1$ 即可。 其次当 $a = 0$ 时，直接解得 $p = 1, q = \lfloor d / c \rfloor + 1$。 当 $a &amp;lt; b$ 时，这意味着我们无法直接求解。考虑翻转，转化问题为 $$ \frac{d}{c} &amp;lt; \frac{q}{p} &amp;lt; \frac{b}{a} $$ 递归即可。 当 $a &amp;gt; b$ 时，考虑求解 $$ \frac{a}{b} - \left\lfloor\frac{a}{b}\right\rfloor &amp;lt; \frac{p}{q} - \left\lfloor\frac{a}{b}\right\rfloor &amp;lt; \frac{c}{d} - \left\lfloor\frac{a}{b}\right\rfloor $$ 也是递归即可，还原出结果以后返回。  唯一需要确认的就是，翻转后仍是最优解，考虑反证。</description>
    </item>
    
    <item>
      <title>P5171 Earthquake</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5171/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-10/p5171/</guid>
      <description>题目大意 给定 $a,b,c$，求满足方程 $ax + by \leqslant c$ 的非负整数解的个数。
分析 令 $n = \lfloor c / a \rfloor$，容易推出让我们求的是
$$ n + 1 + \sum_{x = 0}^{n} \left\lfloor \frac{c - ax}{b} \right\rfloor $$
直接套类欧是不行的，因为系数有负数。其他题解感觉推麻烦了，直接考虑水平翻转，令 $x \to (n - x)$，代入有
$$ n + 1 + \sum_{x = 0}^{n} \left\lfloor \frac{ax + c - an}{b} \right\rfloor $$
显然 $c - an$ 是 c % a，于是套类欧即可
附：代码，展开</description>
    </item>
    
    <item>
      <title>NC11255B Sample Game</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-10/nc11255b/</link>
      <pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-10/nc11255b/</guid>
      <description>题目大意 给定生成 $1$ 到 $n$ 数字的概率分布，不断生成随机数 $x$ 直到 $x$ 不是已经生成过的最大的数停止，求生成次数平方的期望。
分析 设期望的随机次数为 $f_x = E(x)$，我们需要计算的次数为 $g_x = E(x^2)$。
关于 $f_i$ 的 DP 是显然的，计算有
$$ f_x = \sum_{i = 1}^{x - 1} p_i + \sum_{i = x}^n p_i(1 + f_i) = 1 + \sum_{i = x}^n p_i f_i $$
容易观察到
$$ f_{x + 1} =(1 - p_x) f_x \Rightarrow f_x = \prod_{i = x}^n \frac{1}{1 - p_x} $$
接下来需要一个套路
$$ E((x + 1)^2) = E(x^2) + 2 E(x) + 1 $$</description>
    </item>
    
    <item>
      <title>P3052 Cows in a Skyscraper G</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-10/p3052/</link>
      <pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-10/p3052/</guid>
      <description>题目大意 有 $n$ 头牛坐电梯，重量分别为 $c_i$，电梯的最大限额是 $W$，求最少分多少次能够全部上去。
分析 注意 $n \leqslant 18$，枚举全排列是不行的。考虑用状态压缩，将第 $j$ 头奶牛的选和不选用状态 $i$ 的第 $j$ 位数字表示。设 $f_i$ 表示状态为 $i$ 时最小乘电梯次数，$g_i$ 表示此状态下最新那个电梯已经有的重量。
 首先令 cow = i &amp;lt;&amp;lt; (j - 1)，若 i &amp;amp; cow 为 $1$ 则说明这个奶牛已经坐上电梯了，不计算。 当 $W - g_i \geqslant c_i$ 时，最后那个电梯坐的下这头牛。 当 $W - g_i &amp;lt; c_i$ 时，只能新开一个电梯。  还是代码更清晰
const int maxn = 18; ll ci[maxn]; ll ff[1 &amp;lt;&amp;lt; maxn], gg[1 &amp;lt;&amp;lt; maxn]; int main() { ll n = rr(), W = rr(); for (int i = 1; i &amp;lt;= n; i++) ci[i] = rr(); fill_n(ff, 1 &amp;lt;&amp;lt; maxn, n); fill_n(gg, 1 &amp;lt;&amp;lt; maxn, W); ff[0] = 1, gg[0] = 0; for (int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; n); i++) { for (int j = 1; j &amp;lt;= n; j++) { ll cow = 1 &amp;lt;&amp;lt; (j - 1); if (i &amp;amp; cow) continue; if (W - gg[i] &amp;gt;= ci[j]) { ff[i | cow] = ff[i]; gg[i | cow] = min(gg[i | cow], gg[i] + ci[j]); } else if (W - gg[i] &amp;lt; ci[j] &amp;amp;&amp;amp; ff[i | cow] &amp;gt;= ff[i] + 1) { ff[i | cow] = ff[i] + 1; gg[i | cow] = min(gg[i | cow], ci[j]); } } } printf(&amp;#34;%lld&amp;#34;, ff[(1 &amp;lt;&amp;lt; n) - 1]); return 0; } </description>
    </item>
    
    <item>
      <title>P4059 找爸爸</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-10/p4059/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-10/p4059/</guid>
      <description>题目大意 给定两串 DNA 序列，可以在其中任意插空格，然后逐位比较，当两位都是字母时查表得到相似度。
长度为 $k$ 的空格有额外相似度 $- A - B(k - 1)$。求两序列的最大相似度。
分析 若不考虑空格的贡献，容易想到二维 DP，记 ${\rm DP}[i,j]$ 是 $A$ 串到位置 $i$ 同时 $B$ 串到位置 $j$ 时最大的相似度，有
$$ {\rm DP}[i, j] = \max\{ {\rm DP}[i - 1, j - 1] + D[i, j], {\rm DP}[i - 1, j], {\rm DP}[i, j - 1] \} $$
当我们考虑空格的贡献时，可以发现空格的额外贡献只与前面一位有关。若两个序列此位都是空格，则把去掉后相似度一定会增加，故只有三种可能：设 ${\rm DP}_0$ 是结尾没有空格；${\rm DP}_1$ 是空格在 $A$ 串；${\rm DP}_2$ 是空格在 $B$ 串。
思考最后一个空格的转移方式，自然有方程
$$ \begin{aligned} {\rm DP}_0[i, j] &amp;amp;= \max\{ {\rm DP}_0[i - 1, j - 1], {\rm DP}_1[i - 1, j - 1], {\rm DP}_2[i - 1, j - 1] \} + D[i, j] \\ {\rm DP}_1[i, j] &amp;amp;= \max\{ {\rm DP}_0[i, j - 1] - A, {\rm DP}_1[i, j - 1]- B, {\rm DP}_2[i, j - 1] - A\} \\ {\rm DP}_2[i, j] &amp;amp;= \max\{ {\rm DP}_0[i - 1, j] - A, {\rm DP}_1[i - 1, j] - A, {\rm DP}_2[i, j - 1] - B \} \\ \end{aligned} $$</description>
    </item>
    
    <item>
      <title>HDU6955 Xor sum</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-10/hdu6955/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-10/hdu6955/</guid>
      <description>题目大意 给定整数序列 $\{a_n\}$，寻找满足区间异或和大于等于 $k$ 的连续序列中最短的。
若有多个同样长度的答案，输出位置靠前的，若不存在输出 -1。
分析 看到异或最值就应该想到 01trie。做前缀异或和，这样我们的问题就变成找到最靠近的两个数，其异或大于等于 $k$。
因为要求位置最靠前的，所以我选择倒着遍历。当遍历到第 $i$ 个数 $a_i$ 时，字典树已经维护好此位置之后的数据，即每个值出现最左边的位置。
const int maxn = 1e5 + 10, o = 30 - 1; int trie[maxn * 30][2], val[maxn * 30], tot, n, k; void insert(int ai, int i) { int p = 1; for (int j = o; j &amp;gt;= 0; j--) { int ch = (ai &amp;gt;&amp;gt; j) &amp;amp; 1; if (trie[p][ch] == 0) trie[p][ch] = ++tot; p = trie[p][ch]; val[p] = i; } } 我们只需从高位到低位遍历第 $j$ 位，分类讨论：</description>
    </item>
    
    <item>
      <title>HDU6833 A Very Easy Math Problem</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6833/</link>
      <pubDate>Fri, 24 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6833/</guid>
      <description>题目大意 即求
$$ S (n) = \sum^n_{\{ a_x \} = 1} \left( \prod_{j = 1}^x a_j \right)^k f (\gcd \{ a_x \}) \gcd \{ a_x \} $$
我自己随便简写了，全打太麻烦了。
分析 这东西看着很吓人，其实是纸老虎。首先 $f(x) = \mu(x)^2$。提出 $\gcd$ 有
$$ \begin{aligned} S (n) &amp;amp; =\sum_{d=1}^{n}\sum^{n}_{\{ a_{x}\}=1}(\prod_{j=1}^{x}a_{j})^{k}{\mu}(d)^{2}d [gcd \{ a_{x}\} =d]\\ &amp;amp; =\sum_{d=1}^{n}{\mu}(d)^{2}d^{k x+1}\sum^{n/d}_{\{ a_{x}\} =1}(\prod_{j=1}^{x}a_{j})^{k}[gcd \{ a_{x}\} =1] \end{aligned} $$
对后面这部分反演有
$$ \begin{aligned} &amp;amp; \sum^{n / d}_{\{ a_x \} = 1} \left( \prod_{j = 1}^x a_j \right)^k \left( \sum_{t \mid \gcd \{ a_x \}} \mu (t) \right)\\ = &amp;amp; \sum^{n / d}_{\{ a_x \} = 1} \left( \prod_{j = 1}^x a_j \right)^k \left( \sum_{t = 1}^{n / d} [t \mid \gcd \{ a_x \}] \mu (t) \right)\\ = &amp;amp; \sum_{t = 1}^{n / d} \mu (t) t^{k x} \sum^{n / d t}_{\{ a_x \} = 1} \left( \prod_{j = 1}^x a_j \right)^k \end{aligned} $$</description>
    </item>
    
    <item>
      <title>HDU6755 Fibonacci Sum</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6755/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6755/</guid>
      <description>题目大意 设 Fibonacci 数列第 $i$ 项为 $F_i$，求
$$ S = \sum_{i = 0}^n (F_{i c})^k $$
分析 由特征方程法，设
$$ x^2 + x - 1 = 0 \Longrightarrow A, B = \frac{1 \pm \sqrt{5}}{2} $$
因此 Fibonacci 通项公式即可表示为
$$ F_n = \frac{A^n - B^n}{A - B} $$
根据二次剩余的知识，模意义下是可以开方的。因此
$$ (F_{i c})^k = \left( \frac{A^{i c} - B^{i c}}{A - B} \right)^k = \frac{1}{(A - B)^k} \sum_{j = 0}^k \binom{k}{j} (- 1)^{k - j} (A^j B^{k - j})^{i c} $$</description>
    </item>
    
    <item>
      <title>HDU6537 Neko and function</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6537/</link>
      <pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6537/</guid>
      <description>题目大意 定义 $f(n, k)$ 为满足如下要求的，长度为 $k$ 的数列 $\\{a_i\\}$ 个数：
 要求每个数字都大于 $1$； 数列各项之积恰为 $n$。  求其前缀和 $S(n, k) = \sum f(i, k)$。
分析 多组输入好坑啊。
先允许 $a_i=1$，将结果记为 $g(n,k)$，容易利用隔板法求得
$$ g (p^c, k) = \binom{t + k - 1}{k - 1} $$
对于多个质因数，显然其贡献是相互独立的，即 $g$ 是积性函数。考虑选取 $i$ 个数令其 $a_i&amp;gt;1$，枚举有
$$ g (n, k) = \sum_{i = 1}^k \binom{n}{i} f (n, i) $$
二项式反演（或者直接容斥）有
$$ f (n, k) = \sum_{i = 1}^k (- 1)^{k - i} \binom{k}{i} g (n, i) $$</description>
    </item>
    
    <item>
      <title>HDU6750 Function</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6750/</link>
      <pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-09/hdu6750/</guid>
      <description>题目大意 定义
$$ f (n) = \sum_{d \mid n} d \left[ \gcd \left( d, \frac{n}{d} \right) = 1 \right] $$
求其前缀和 $S(n)$。
分析 首先 Min25 筛是过不了的，内存不够。先推式子
$$ \begin{aligned} S (n) &amp;amp;= \sum_{i = 1}^n \sum_{d \mid i} d \left[ \gcd \left( d, \frac{i}{d} \right) = 1 \right] \\ &amp;amp;= \sum_{d = 1}^n \sum_{i = 1}^n d [d \mid i] \left[\gcd \left( d, \frac{i}{d} \right) = 1 \right] \\ &amp;amp;= \sum_{d = 1}^n \sum_{i = 1}^{n / d} d [\gcd (i, d) = 1] \end{aligned} $$</description>
    </item>
    
    <item>
      <title>P5349 幂</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-09/p5349/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-09/p5349/</guid>
      <description>题目大意 即求
$$ S = \sum_{n=0}^\infty f(n)r^n $$
分析 换序
$$ S = \sum_{n = 0}^{\infty} \left( \sum_{i = 0}^m f_i n^i \right) r^n = \sum_{i = 0}^m f_i \sum_{n = 0}^{\infty} n^i r^n $$
令
$$ S_i = \sum_{n = 0}^{\infty} n^i r^n $$
套路的逐项相减，主动的凑二项式
$$ (1 - r) S_i = 1 + \sum_{n = 1}^{\infty} n^i r^n - \sum_{n = 1}^{\infty} (n - 1)^i r^n = 1 + \sum_{n = 0}^{\infty} r^{n + 1} \sum_{j = 0}^{i - 1} \binom{k}{j} n^j $$</description>
    </item>
    
    <item>
      <title>LOJ6053 简单的函数</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-08/loj6053/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-08/loj6053/</guid>
      <description>题目大意 给定积性函数 $f(p^c) = p \oplus c$。对 $1000000007$ 取模求前缀和。
分析 Min25 板子题。
const ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x &amp;lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n &amp;lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i &amp;lt;= cnt &amp;amp;&amp;amp; prime[i] * prime[i] &amp;lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi &amp;lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.</description>
    </item>
    
    <item>
      <title>HDU6975 Forgiving Matching</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-07/hdu6975/</link>
      <pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-07/hdu6975/</guid>
      <description>题目大意 给定文本串 $S$ 和模式串 $T$，对每个位置进行匹配，得到失配次数。
统计此失配次数，计算前缀和。
分析 我是没料到 HDOJ 没有 M_PI，CE 了几发。
FFT 字符串匹配模板题，我在 ZAFU Wiki 中讲过，即对每个字符卷积。
#include &amp;#34;template/basic/complex.hpp&amp;#34; const int maxn = 1 &amp;lt;&amp;lt; 20; using img = Complex&amp;lt;double&amp;gt;; using poly_t = vector&amp;lt;img&amp;gt;; poly_t w; #include &amp;#34;template/poly-fft/fft_init.hpp&amp;#34;#include &amp;#34;template/poly-fft/fft.hpp&amp;#34; char a[maxn], b[maxn]; int sum[maxn], ans[maxn]; char ch[] = &amp;#34;0123456789*&amp;#34;; int main() { w = fft_init(maxn); int ttt = rr(); while (ttt--) { int n = rr(), m = rr(); fill(sum, sum + m + n + 12, 0); fill(ans, ans + m + 12, 0); int lim = getlim(m, n); scanf(&amp;#34;%s %s&amp;#34;, b, a); int tsum = 0; for (int i = 0; i &amp;lt; m - 1; i++) { tsum += b[i] == &amp;#39;*&amp;#39;; tsum += a[i] == &amp;#39;*&amp;#39;; } tsum += a[m - 1] == &amp;#39;*&amp;#39;; reverse(a, a + m + 1); for (int k = 0; k &amp;lt;= 10; k++) { poly_t SS(lim); for (int i = 0; i &amp;lt; n; i++) SS[i].</description>
    </item>
    
    <item>
      <title>P4173 残缺的字符串</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-07/p4173/</link>
      <pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-07/p4173/</guid>
      <description>魔改 KMP 大概是不行的，卷积在这里出现的很妙。
卷积处理匹配 定义匹配函数
$$ d(x,y) = [x = y] $$
给定文本串 $B$ 和长为 $m$ 的模式串 $A$，要找出 $A$ 在 $B$ 的所有出现，可以定义
$$ f(k) = \sum_{i=0}^{m-1} d(A_{i}, B_{i-m+k}) $$
即 $f(k) = 0$ 时有完全匹配 $A = B[k-m\ldots k-1]$。考虑让 $d$ 函数更 “数学” 一点，以更好的计算
$$ d(x,y) = (x - y)^2 $$
再提供模式串 $A$ 的翻转 $S$，即 $A_i = S_{m-i}$，展开有
$$ \begin{aligned} f(k) &amp;amp;= \sum_{i=0}^{m-1}A_{i}^2 + \sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\sum_{i=0}^{m-1} A_{i}B_{i-m+k}\\ &amp;amp;= \sum_{i=0}^{m-1}A_{i}^2 + \sum_{i=0}^{m-1}B_{i-m+k}^2 - 2\sum_{i=0}^{m-1} S_{m-i}B_{i-m+k} \end{aligned} $$</description>
    </item>
    
    <item>
      <title>P1762 偶数</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-07/p1762/</link>
      <pubDate>Mon, 12 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-07/p1762/</guid>
      <description>题目大意 求杨辉三角形前 $n$ 行的偶数个数，对 $1000003$ 取模。
分析 对杨辉三角奇数打表。
1 1 1 1 1 1 1 1 1 1	1 1 1	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1	1 1 1	1 1 1 1	1 1 1 1 1 1	1 1 1 1 1	1	1	1 1 1	1 1	1 1	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1	1 1 1	1 1 1 1	1 1 1 1 1 1	1 1 1 1 1	1	1	1 1 1	1 1	1 1	1 1 1 1 1 1	1 1 1 1 1 1 1 1 1 1 1 1	1 1 1 1 1 1 1 1 1	1	1	1 1 1	1 1	1 1	1 1 1 1	1 1	1 1	1 1 1 1 1 1	1 1 1 1	1 1 1 1	1 1 1 1 1	1	1	1	1	1	1	1 1 1	1 1	1 1	1 1	1 1	1 1	1 1	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 于是递推公式</description>
    </item>
    
    <item>
      <title>P2257 YY 的 GCD</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2257/</link>
      <pubDate>Wed, 26 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2257/</guid>
      <description>题目大意 即求
$$ \sum_{i=1}^N \sum_{j=1}^M [\gcd(i,j) \in \mathbb{P}] $$
分析 先转化一下
$$ \sum_{i=1}^N \sum_{j=1}^M [\gcd(i,j) \in \mathbb{P}] = \sum_{p}\sum_{i=1}^N \sum_{j=1}^M [\gcd(i,j) = p] $$
在 P2522 中得到
$$ \sum_{i=1}^x \sum_{j=1}^y [\gcd(i,j) = k] = \sum_{t=1}^{\min(x,y)} \mu(t) \left\lfloor \frac{x}{tk} \right\rfloor \left\lfloor \frac{y}{tk} \right\rfloor $$
代入有
$$ \sum_{p} \sum_{t=1}^{\min(x,y)} \mu(t) \left\lfloor \frac{x}{tp} \right\rfloor \left\lfloor \frac{y}{tp} \right\rfloor $$
令 $T = tp$，$T$ 的上界应还是 $\min(x,y)$，代入有
$$ \sum_{T=1}^{\min(x,y)} \left\lfloor \frac{x}{T} \right\rfloor \left\lfloor \frac{y}{T} \right\rfloor \sum_{p \mid T} \mu\left(\frac{T}{p}\right) $$</description>
    </item>
    
    <item>
      <title>P2350 外星人</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2350/</link>
      <pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2350/</guid>
      <description>题目大意 设
$$ \varphi_{x+1}(m) = \varphi(\varphi_x(m)) $$
求最小的 $x$ 使得 $\varphi_x(m) = 1$。
其中 $\varphi(m)$ 是欧拉函数。
分析 注意到仅有 $\varphi(1) = \varphi(2) = 1$，再有公式
$$ \varphi\left(\prod_{i=1}^mp_i^{q_i}\right) = \prod_{i=1}^m(p_i-1)p_i^{q_i-1} $$
因此从唯一分解形式的角度来看，迭代一次消去了一个 $2$，也生成了一些 $2$。
考虑设 $f(n)$ 为 $\varphi(n)$ 中因子 $2$ 的个数。
设 $\gcd(a,b) = 1$，可以证明 $f(ab) = f(a) f(b)$。同时 $f(p) = f(p-1)$。
这说明 $f(x)$ 是一个积性函数，可以用 Euler 筛递推。
const ll MN = 1e5 + 10; bool notp[1000001]; int prime[200001], cnt, phi[1000001]; void sieve(int n) { phi[1] = 1; for (ll i = 2; i &amp;lt;= n; i++) { if (!</description>
    </item>
    
    <item>
      <title>CF1389E Calendar Ambiguity</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-05/cf1389e/</link>
      <pubDate>Mon, 24 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-05/cf1389e/</guid>
      <description>Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。
若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。
求一年有几对。
$$ xd+y \equiv yd+x \pmod w $$
即
$$ (x-y)(d-1) \equiv 0 \Rightarrow (x-y)(d-1) \in w\mathbb{Z} $$
于是有
$$ y-x = \frac{wk}{\gcd(w,d-1)} $$
又 $x &amp;lt; y \leqslant \min(m,d)$​，
int main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(&amp;#34;%lld\n&amp;#34;, sum); } return 0; } </description>
    </item>
    
    <item>
      <title>P2303 Longge 的问题</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2303/</link>
      <pubDate>Mon, 24 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2303/</guid>
      <description>题目大意 即求
$$ \sum_{i=1}^n \gcd(i,n) $$
分析 联想到
$$ \varphi(n) = \sum_{i=1}^n [\gcd(i,n) = 1] $$
尝试凑这个形式
$$ \begin{aligned} \sum_{i=1}^n \gcd(i,n) &amp;amp;= \sum_{d \mid n} d \sum_{i=1}^n [\gcd(i,n) = d] \\ &amp;amp;= \sum_{d \mid n} d \sum_{i=1}^{n/d} [\gcd(i,n/d) = 1] \\ &amp;amp;= \sum_{d \mid n} d \varphi(n/d) \end{aligned} $$
这里其实已经可以过题了，但还可以再瞎搞一下，令
$$ nf(n) = \sum_{d \mid n} d \varphi(n/d) = n\sum_{d \mid n} \frac{\varphi(d)}{d} $$
尝试证明 $f(n)$ 是一个积性函数。设 $\gcd(a,b) = 1$，有</description>
    </item>
    
    <item>
      <title>P4721 分治 FFT</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p4721/</link>
      <pubDate>Mon, 24 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p4721/</guid>
      <description>题目大意 给定 $g[1], \cdots, g[m]$，求序列 $f$。
$$ f [n] = \sum_{j = 1}^n f [n - j] g [j] = \sum_{j = 1}^n f [n - j] h [j] $$
分析 不妨令 $g [0] = 0$，$h (x) = g (x) + h [0]$，我们要解方程
$$ f [n] = \sum_{j = 1}^n f [n - j] g [j] = \sum_{j = 1}^n f [n - j] h [j] $$
这个形式看似卷积，但实际上它缺了一项。对 $n &amp;gt; 0$ 凑卷积</description>
    </item>
    
    <item>
      <title>P2522 Problem B</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2522/</link>
      <pubDate>Wed, 19 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-05/p2522/</guid>
      <description>题目大意 即求
$$ \sum_{i=a}^b \sum_{j=c}^d [\gcd(i,j) = k] $$
分析 容易想到，独立出函数 $f(k)$ 使得
$$ f(k) = \sum_{i=1}^x \sum_{j=1}^y [\gcd(i,j) = k] $$
利用 Mobius 反演化简，设 $F(d)$
$$ F(n) = \sum_{n \mid d} f(d) = \sum_{i=1}^x \sum_{j=1}^y [n \mid i][n \mid j] = \left\lfloor \frac{x}{n} \right\rfloor \left\lfloor \frac{y}{n} \right\rfloor $$
反演化简有
$$ f(n) = \sum_{n \mid d} \mu\left(\frac{d}{n}\right)F(d) = \sum_{t=1}^{\min(x,y)} \mu(t) \left\lfloor \frac{x}{tn} \right\rfloor \left\lfloor \frac{y}{tn} \right\rfloor $$
预处理出 $\mu(t)$ 的前缀和，剩下的就是一个二重分块了。</description>
    </item>
    
    <item>
      <title>P2261 余数求和</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-04/p2261/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-04/p2261/</guid>
      <description>题目大意 给出正整数 $n$ 和 $k$，请计算
$$ G(n, k) = \sum_{i = 1}^n k \bmod i $$
分析 因为
$$ k \bmod i = k - i \left\lfloor \frac{k}{i} \right\rfloor $$
因此有
$$ G(n,k) = nk - \sum_{i=1}^n i \left\lfloor \frac{k}{i} \right\rfloor $$
后面需要整数分块。
int main() { ll n = rr(); ll k = rr(); ll sum = n * k; n = min(n, k); for (ll l = 1, r; l &amp;lt;= n; l = r + 1) { r = min(n, k / (k / l)); ll t = (l + r) * (r - l + 1) / 2; sum -= t * (k / l); } printf(&amp;#34;%lld&amp;#34;, sum); return 0; } </description>
    </item>
    
    <item>
      <title>P1314 聪明的质检员</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-04/p1314/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-04/p1314/</guid>
      <description>题目大意 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：
$$ y_i=\sum_{j=l_i}^{r_i}[w_j \geqslant W] \times \sum_{j=l_i}^{r_i}[w_j \geqslant W]v_j $$
记检验结果为 $y=\sum y_i$，对于给定的 $s$，求 $|y-s|$ 的最小值。
分析 注意到 $y(w)$ 是关于 $W$ 的递减函数，对 $w$ 在 $[w_{\min},w_{\max}]$ 上进行二分。
const ll MN = 2e5 + 10; ll vv[MN], ww[MN], li[MN], ri[MN], f1[MN], f2[MN]; ll n, m, s; int main() { n = rr(), m = rr(), s = rr(); ll minw = 0x3f3f3f3f, maxw = 0; f1[0] = f2[0] = 0; for (ll i = 1; i &amp;lt;= n; i++) { ww[i] = rr(), vv[i] = rr(); maxw = max(ww[i], maxw); minw = min(ww[i], minw); } for (ll i = 1; i &amp;lt;= m; i++) { li[i] = rr(), ri[i] = rr(); } ll l = minw, r = maxw + 1; while (l &amp;lt; r) { int mid = (l + r) &amp;gt;&amp;gt; 1; if (sum(mid) &amp;lt;= s) r = mid; else l = mid + 1; } ll rst = min(sum(l - 1) - s, s - sum(l)); printf(&amp;#34;%lld&amp;#34;, rst); return 0; } 区间求和可以用前缀和优化。</description>
    </item>
    
    <item>
      <title>CF1494 Educational Round 105 (Rated for Div. 2)</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-03/cfedu105/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-03/cfedu105/</guid>
      <description>题目链接：Link 。
A. ABC String 这么水的题竟然 wa 了 4 发。。
题目大意 给定一个长 $n$ 的字符串 $a$，仅由 A，B，C 组成，$n$ 为偶数。
对于仅含 ( 和 ) 的括号序列，当我们能够在其中添加 1 使得其为合法的表达式，则序列合法。
构造合法的长为 $n$ 的括号序列 $b$，要求在 $a$ 同为 A 的，在 $b$ 中也要相同；B，C 也是如此。
分析 序列合法的定义即对任意位置，其左侧的 ) 总比 ( 少，且整体左右括号数相等。
首个字母必为左括号，末尾字母必为右括号。剩下的那个讨论一下即可。
char ss[60]; int main() { ll ttt = rr(); while (ttt--) { scanf(&amp;#34;%s&amp;#34;, ss + 1); ll len = strlen(ss + 1); if (ss[1] == ss[len]) { printf(&amp;#34;NO\n&amp;#34;); continue; } ll sa[3] = {0, 0, 0}; for (ll i = 1; i &amp;lt;= len; i++) sa[ss[i] - &amp;#39;A&amp;#39;]++; ll sl = ss[1] - &amp;#39;A&amp;#39;, sr = ss[len] - &amp;#39;A&amp;#39;; ll sm = 3ll - sl - sr; bool flag = false; sa[0] = sa[1] = sa[2] = 0; if (sa[sl] + sa[sm] == sa[sr]) { for (ll i = 1; i &amp;lt;= len; i++) { sa[ss[i] - &amp;#39;A&amp;#39;]++; flag = flag || sa[sl] + sa[sm] &amp;lt; sa[sr]; } } else if (sa[sl] == sa[sm] + sa[sr]) { for (ll i = 1; i &amp;lt;= len; i++) { sa[ss[i] - &amp;#39;A&amp;#39;]++; flag = flag || sa[sl] &amp;lt; sa[sm] + sa[sr]; } } else { printf(&amp;#34;NO\n&amp;#34;); continue; } if (flag) printf(&amp;#34;NO\n&amp;#34;); else printf(&amp;#34;YES\n&amp;#34;); } return 0; } B.</description>
    </item>
    
    <item>
      <title>P1019 单词接龙</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-03/p1019/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-03/p1019/</guid>
      <description>题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。
给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。
分析 我是没想出来，经题解提示了拼接函数才写出来的。
设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。
char s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; for (ll i = 1; i &amp;lt;= ml; i++) { int flag = 1; for (ll j = 0; j &amp;lt;= i - 1; j++) { if (s[x][len[x] + j - i] !</description>
    </item>
    
    <item>
      <title>P2678 跳石头</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2021-03/p2678/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2021-03/p2678/</guid>
      <description>题目大意 在 $0$ 到 $L$ 的位置间，有 $N$ 块岩石。若要使得岩石间距最小值最大，允许移除 $M$ 块，求此时间距最小值。
分析 定义函数 $f(x)$，输入为最小值，输出为被移除岩石的个数，实现如下
ll L, N, M, aa[100086]; ll f(ll x) { ll ans = 0; ll l = 0, r = 1; while (r &amp;lt;= N) { if (aa[r] - aa[l] &amp;gt;= x) l = r; else ans++; r++; } return ans; } 显然 $f(x)$ 是单调递减的函数，二分查找即可。
int main() { L = rr(), N = rr(), M = rr(); for (ll i = 1; i &amp;lt;= N; i++) aa[i] = rr(); aa[++N] = L; ll l = 1, r = L; while (l &amp;lt; r) { ll mid = (l + r + 1) &amp;gt;&amp;gt; 1; ll fm = f(mid); if (fm &amp;lt;= M) l = mid; else r = mid - 1; } printf(&amp;#34;%lld\n&amp;#34;, l); return 0; } </description>
    </item>
    
    <item>
      <title>2020 年刷题日志</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/other/log2020/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/other/log2020/</guid>
      <description>过于简单的题不记录。
洛谷：更新至：2020.12.31(2020.10)
CodeForces：更新至：&amp;ndash;.&amp;ndash;
牛客：更新至：&amp;ndash;.&amp;ndash;
HDU：更新至：&amp;ndash;.&amp;ndash;
2020 年 09 月 开始 ACM。不记录 HDU 150 的基础题。
09-20 |  CF1384B2 Koa and the Beach
09-20 |  P1004 方格取数
09-22 |  P2181 对角线
09-23 |  P1042 乒乓球
2020 年 10 月 10-09 |  P1095 守望者的逃离
10-13 |  P5143 攀爬者
10-16 |  P1923 求第 $k$ 小的数
10-16 |  P1928 外星密码
10-16 |  P1990 覆盖墙壁
10-16 |  P1090 合并果子</description>
    </item>
    
    <item>
      <title>P1880 石子合并</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1880/</link>
      <pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1880/</guid>
      <description>题目大意 环形队列上有 $n$ 堆石子，可以把相邻的两堆合成一堆，每次合并的得分是新一堆的石子数。
求最终分数的最小值和最大值。
分析 考虑 $dp(i,j)$ 是将区间 $[i,j]$ 的石子全部合并的最大值。于是状态转移方程为
$$ dp(i,j) = \max_{i \leqslant k \leqslant j}(dp(i,k) + dp(k+1,j) + s(i,j)) $$
其中 $s(i,j)$ 是 $[i,j]$ 中所有石子数。
然而不能通过先 $i$ 再 $j$ 再 $k$ 的循环来递推，运算顺序值得注意。
细节：前缀和、循环开两倍。
int dmax[205][205], dmin[205][205]; int f[205], s[205]; int main() { int n = rr(); for (ll i = 1; i &amp;lt;= n; i++) f[i + n] = f[i] = rr(); for (ll i = 1; i &amp;lt;= n * 2; i++) s[i] = s[i - 1] + f[i]; for (ll len = 2; len &amp;lt;= n; len++) { for (ll i = 1; i &amp;lt;= 2 * n - len + 1; i++) { int j = i + len - 1; int tmax = 0, tmin = 0x3f3f3f3f; int ss = s[j] - s[i - 1]; for (ll k = i; k &amp;lt;= j - 1; k++) { tmax = max(tmax, dmax[i][k] + dmax[k + 1][j] + ss); tmin = min(tmin, dmin[i][k] + dmin[k + 1][j] + ss); } dmax[i][j] = tmax; dmin[i][j] = tmin; } } int mmin = 0x3f3f3f3f, mmax = 0; for (ll p = 0; p &amp;lt;= n - 1; p++) { mmin = min(mmin, dmin[p + 1][p + n]); mmax = max(mmax, dmax[p + 1][p + n]); } printf(&amp;#34;%d\n%d\n&amp;#34;, mmin, mmax); return 0; } </description>
    </item>
    
    <item>
      <title>P1833 樱花</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1833/</link>
      <pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1833/</guid>
      <description>题目大意 混合背包。每棵树都有美学值 $C_i$，共有三种：
 一种只能看一遍。 一种最多看 $A_i$ 遍。 一种可以看无数遍。  分析 对于混合背包，我们可以对物品拆分，得到多个物品。
ll dp[1086], tt[100086], cc[100086]; int main() { int tsh = rr(), tsm = rr(), teh = rr(), tem = rr(); int tsum = (teh - tsh) * 60 + tem - tsm; int n = rr(); int tp = 1; for (ll i = 1; i &amp;lt;= n; i++) { int t = rr(), c = rr(), p = rr(); if (p == 1) { tt[tp] = t, cc[tp] = c; tp++; } else { p = p !</description>
    </item>
    
    <item>
      <title>P1541 乌龟棋</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1541/</link>
      <pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-11/p1541/</guid>
      <description>题目大意 初始有四种卡片，消耗后分别可以前进 $1$、$2$、$3$ 和 $4$ 格。棋盘上每个点都有个分数，求从第 $1$ 格到达第 $N$ 格途径分数的最大值。
分析 设状态 $F[i, j, k, w]$ 为使用 $i$ 张前进 $1$、……、$w$ 张前进 $4$ 之后的状态，容易得到转移方程
$$ F[i, j, k, w] = \max\left\{ \begin{matrix} dp[i - 1, j, k, w] \\ dp[i, j - 1, k, w] \\ dp[i, j, k - 1, w] \\ dp[i, j, k, w - 1] \end{matrix}\right\} + a[i + 2j + 3k + 4w] $$
处理一下边界情况，滚动数组即可。
ll dp[50][50][50], aa[400], tt[10]; int main() { ll n = rr(), m = rr(); for (ll i = 1; i &amp;lt;= n; i++) { aa[i] = rr(); } for (ll i = 1; i &amp;lt;= m; i++) { tt[rr()]++; } for (ll i = 0; i &amp;lt;= tt[1]; i++) { for (ll j = 0; j &amp;lt;= tt[2]; j++) { for (ll k = 0; k &amp;lt;= tt[3]; k++) { for (ll w = 0; w &amp;lt;= tt[4]; w++) { dp[j][k][w] = aa[i * 1 + j * 2 + k * 3 + w * 4 + 1] + max4( j == 0 ?</description>
    </item>
    
    <item>
      <title>P3842 线段</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-11/p3842/</link>
      <pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-11/p3842/</guid>
      <description>题目大意 在 $n \times n$ 的格上，在每行中各有一条线段 $(i, l_i) \to (i, r_i)$。
你从 $(1,1)$ 出发，只能沿着格子直走，最终走到 $(n,n)$。要求沿途经过所有的线段，且所走路程长度尽量的短。
分析 显然是一行一行的递推。维护两个数据，一个是走完该行后停留在左侧的，记作 ${\rm DP}_l$，相应的停留在右侧的记作 ${\rm DP}_r$。
若停在左侧，可能从上一行的右侧走来，也可能是由左侧走来，故转移方程有
$$ {\rm DP}_l[i] = r_i - l_i + \min\{{\rm DP}_l[i - 1] + |l_{i-1} - r_i|, {\rm DP}_r[i - 1] + |r_{i - 1} - r_i|\} $$
右侧类似，故可以写出代码
int main() { int n = rr(); ll past_l = 1, past_r = 1, dpl = 0, dpr = 0; for (ll i = 1; i &amp;lt;= n; i++) { ll l = rr(), r = rr(); ll tl = min(dpl + abs(past_l - r), dpr + abs(past_r - r)) + r - l; ll tr = min(dpl + abs(past_l - l), dpr + abs(past_r - l)) + r - l; dpl = tl, dpr = tr; past_l = l, past_r = r; } printf(&amp;#34;%lld\n&amp;#34;, min(dpl + n - past_l, dpr + n - past_r) + n - 1); return 0; } </description>
    </item>
    
    <item>
      <title>P1077 摆花</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1077/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1077/</guid>
      <description>题目大意 要从 $n$ 种花中挑出 $m$ 盆展览，其中第 $i$ 种花不得多于 $a_i$ 种。求有几种选法。
分析 考虑动态规划，记状态 $dp[i,j]$ 为摆完前 $i$ 种花，共 $j$ 盆时的方案数。容易得到递推式
$$ dp[i,j] = \sum_{k = j - \min(a_i, j)}^j dp[i-1,k] $$
边界条件是 $dp[0,0] = 1$。可以用滚动数组、前缀和优化。
const ll mod = 1e6 + 7; ll dp[110], aa[110], sum[110]; int main() { ll n = rr(), m = rr(); sum[0] = dp[0] = 1; for (ll i = 1; i &amp;lt;= n; i++) aa[i] = rr(); for (ll i = 1; i &amp;lt;= n; i++) { for (ll j = 1; j &amp;lt;= m; j++) sum[j] = (sum[j - 1] + dp[j]) % mod; for (ll j = m; j &amp;gt;= 0; j--) { int t = j - 1 - min(aa[i], j); if (t &amp;gt; 0) dp[j] = (dp[j] + sum[j - 1] - sum[t]) % mod; } } printf(&amp;#34;%lld\n&amp;#34;, (dp[m] + mod) % mod); return 0; } </description>
    </item>
    
    <item>
      <title>P1090 合并果子</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1090/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1090/</guid>
      <description>题目大意 可以合并两堆果子成一堆新果子，消耗两堆果子数目之和的体力。给定 $n$ 堆果子的数目 $a_i$，求体力耗费最小的方案。
分析 很容易猜到贪心结论，不断选取两个最小的堆进行合并。
priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; q; int main() { int n = rr(); for (ll i = 1; i &amp;lt;= n; i++) { int t = rr(); q.push(t); } int sum = 0; while (q.size() &amp;gt;= 2) { int x = q.top(); q.pop(); int y = q.top(); q.pop(); sum += x + y; q.push(x + y); } printf(&amp;#34;%d\n&amp;#34;, sum); return 0; } 本质上是证明 Huffman 树的构造的正确性，有点复杂。</description>
    </item>
    
    <item>
      <title>P1923 求第 $k$ 小的数</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1923/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1923/</guid>
      <description>题目大意 给定数列，求第 $k$ 小的数。
分析 模板题。考虑分治，随便选一个数 $x$，然后把比 $x$ 大的数移到右边，比 $x$ 小的数移到左边。因此得到了数 $x$ 的排位，若恰为第 $k$ 个则返回，否则根据大小在左右寻找。
该算法是不稳定的，期望复杂度 $O(n)$，最坏复杂度 $O(n^2)$。
实际上存在最坏复杂度为 $O(n)$ 的 BFPTR 算法，但因为其常数过大实现复杂而很少应用。
ll nn[5000010], k, n; ll quicksort(ll l, ll r) { ll i = l, j = r; ll x = nn[(l + r) / 2]; while (i &amp;lt;= j) { while (nn[j] &amp;gt; x) j--; while (nn[i] &amp;lt; x) i++; if (i &amp;lt;= j) { swap(nn[i], nn[j]); i++, j--; } } // l &amp;lt;= j &amp;lt;= i &amp;lt;=r 	if (k &amp;lt;= j) return quicksort(l, j); else if (k &amp;gt;= i) return quicksort(i, r); else return nn[k + 1]; } int main() { n = rr(), k = rr(); for (ll i = 1; i &amp;lt;= n; i++) scanf(&amp;#34;%lld&amp;#34;, &amp;amp;nn[i]); printf(&amp;#34;%lld&amp;#34;, quicksort(1, n)); return 0; } </description>
    </item>
    
    <item>
      <title>P1928 外星密码</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1928/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1928/</guid>
      <description>题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。
分析 我考虑用类似状态机的方式解析字符串。
 当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$  写成 BNF 更直观一点
&amp;lt;pwd&amp;gt; ::= &amp;lt;EMPTY&amp;gt; | {&amp;lt;ALPHA&amp;gt;} | &amp;lt;pwd&amp;gt; &amp;#34;[&amp;#34; &amp;lt;NUMBER&amp;gt; &amp;lt;pwd&amp;gt; &amp;#34;]&amp;#34; &amp;lt;pwd&amp;gt; string read() { string s = &amp;#34;&amp;#34;; char c; while (cin &amp;gt;&amp;gt; c) { if (c == &amp;#39;[&amp;#39;) { int n; cin &amp;gt;&amp;gt; n; string ts = read(); while (n--) s += ts; } else if (c == &amp;#39;]&amp;#39;) { return s; } else { s += c; } } return s; } int main() { cout &amp;lt;&amp;lt; read(); return 0; } </description>
    </item>
    
    <item>
      <title>P1990 覆盖墙壁</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1990/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1990/</guid>
      <description>题目大意 有 I 形和 L 形两种砖头，分别能覆盖 2 个单元和 3 个单元。求 $2 \times n$ 的墙有多少不重复的覆盖方式，结果对 $10^4$ 取模。
分析 其中 I 形砖块仅有横放和竖放两种。关键在于 L 形，两个 L 形之间可以用 I 形填充，这让情况变得复杂起来。
对于 $F_n$ 的递推，我们可以想到
 在 $F_{n-1}$ 后放一个 I 形砖块。 在 $F_{n-2}$ 后放两个横着的 I 形砖块。 对于更前面的递推，较为复杂。  两个 L 形砖块对齐，上下翻转也可以，即 $2 F_{n-3}$。 两个 L 形砖块可以对顶放，空缺恰用一个 I 填充，即 $2 F_{n-4}$。 类似 $2F_{n-3}$，中间可以再插入两个 I 形，即 $2 F_{n-5}$。 …… 直到 I 形和 L 形砖块恰好铺满墙壁，即 $2F_{0}$。    容易得到我们的递推式</description>
    </item>
    
    <item>
      <title>P4995 跳跳！</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p4995/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p4995/</guid>
      <description>题目大意 给定石头的高度 $h$，从第 $i$ 块石头跳到第 $j$ 块上耗费体力 $(h_i-h_j)^2$ ，求最耗体力的路径。
分析 容易猜到贪心结论，是不断的在剩余石头中最大最小的来回跳。
考虑证明结论，设 $h_i$ 是将要跳的序列，展开求和式
$$ S = \sum_{k=1}^{n-1}(h_k-h_{k+1})^2 = \sum_{k=1}^nh_k^2 - 2\sum_{k=1}^{n-1}h_kh_{k+1} $$
注意到平方和为一个定值，重点在后半式。记 $H_k = h_{k+1}$，有
$$ \sum_{k=1}^{n-1}h_kH_k $$
利用高中时学的排序不等式，有
$$ \text{反序和} \leqslant \text{乱序和} \leqslant \text{顺序和} $$
于是有反序最小。双指针维护即可。
ll nn[310]; int main() { ll n = rr(); for (ll i = 1; i &amp;lt;= n; i++) nn[i] = rr(); sort(nn + 1, nn + n + 1); ll l = 0, r = n, sum = 0; while (l &amp;lt; r) { ll t1 = nn[l] - nn[r], t2 = nn[l + 1] - nn[r]; sum += t1 * t1 + t2 * t2; l++, r--; } printf(&amp;#34;%lld\n&amp;#34;, sum); return 0; } </description>
    </item>
    
    <item>
      <title>P5143 攀爬者</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p5143/</link>
      <pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p5143/</guid>
      <description>题目大意 在三维空间中，HKE 只能往上走，求攀爬总长。
分析 对所有座标的 $z$ 分量排序即可。
struct POINT { double x, y, z; bool operator&amp;lt;(POINT p) { return z &amp;gt; p.z; } } nn[50010]; double dis(POINT &amp;amp;p1, POINT &amp;amp;p2) { double t1 = p1.x - p2.x, t2 = p1.y - p2.y, t3 = p1.z - p2.z; return sqrt(t1 * t1 + t2 * t2 + t3 * t3); } int main() { int n = rr(); for (ll i = 1; i &amp;lt;= n; i++) cin &amp;gt;&amp;gt; nn[i].</description>
    </item>
    
    <item>
      <title>P1095 守望者的逃离</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1095/</link>
      <pubDate>Fri, 09 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1095/</guid>
      <description>P1095 守望者的逃离 题目大意 守望者的可以在一秒逃出 $17 {\rm m}$，或者消耗 $10$ 点魔法值闪现 $60 {\rm m}$。原地休息时每秒回复 $4$ 点魔法值。
守望者开始有 $M$ 点魔法，需要在 $T$ 秒内逃离距离 $S$。若能逃离则求最短逃离时间，否则求最远距离。
分析 设 $s_1$为一直走路，$s_2$ 为一直闪现恢复。当 $s_2$ 快了就把 $s_1$ 更新为 $s_2$。
int main() { int m = rr(), s = rr(), t = rr(); int time = t, s1 = 0, s2 = 0; while (time &amp;gt; 0 &amp;amp;&amp;amp; s1 &amp;lt; s) { s1 += 17; if (m &amp;gt;= 10) m -= 10, s2 += 60; else m += 4; s1 = max(s1, s2); time--; } if (s1 &amp;lt; s) printf(&amp;#34;No\n%d\n&amp;#34;, s1); else printf(&amp;#34;Yes\n%d\n&amp;#34;, t - time); return 0; } </description>
    </item>
    
    <item>
      <title>P1042 乒乓球</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1042/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1042/</guid>
      <description>题目大意 赢 11 分并且压对手两分以上则一局结束，否则要追分至压对手两分。
给定 $\texttt{WL}$ 序列，分别求 11 分制和 21 分制下每场比分，$\texttt{E}$ 是结束符。
分析 这是一道比较烦的模拟题，很绕。
char ch[62510]; int solve(int win, int len) { int w = 0, l = 0; for (ll i = 0; i &amp;lt; len; i++) { w += ch[i] == &amp;#39;W&amp;#39;; l += ch[i] == &amp;#39;L&amp;#39;; if (max(w, l) &amp;gt;= win &amp;amp;&amp;amp; abs(w - l) &amp;gt;= 2) { printf(&amp;#34;%d:%d\n&amp;#34;, w, l); w = l = 0; } } printf(&amp;#34;%d:%d\n&amp;#34;, w, l); } int main() { char ccc; int len = 0; while (scanf(&amp;#34;%c&amp;#34;, &amp;amp;ccc) !</description>
    </item>
    
    <item>
      <title>P2181 对角线</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-09/p2181/</link>
      <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-09/p2181/</guid>
      <description>题目大意 凸 $n$ 边形中，任意三条对角线不共点，求所有对角线交点的个数。
分析 注意到一个交点对应凸多边形 $4$ 个定点，于是等价于 $n$ 个点任选 $4$ 个点的选法种数，即
$$ \binom{n}{4} = \frac{n(n-1)(n-2)(n-3)}{24} $$
注意爆 long long，需要写成 n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4。
int main() { unsigned long long n; scanf(&amp;#34;%llu&amp;#34;, &amp;amp;n); n = n * (n - 1) / 2 * (n - 2) / 3 * (n - 3) / 4; printf(&amp;#34;%llu&amp;#34;, n); return 0; } </description>
    </item>
    
    <item>
      <title>CF1384B2 Koa and the Beach</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-09/cf1384b2/</link>
      <pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-09/cf1384b2/</guid>
      <description>题目大意 海里每一个位置都有一个深度，而且水里随着时间有锯齿状周期为 $2k$ 的潮汐。
当潮汐与深度之和大于给定值 $l$ 时 Koa 会溺水，游泳、海岸、岛上永远是安全的。
在任意时间 Koa 可以选择游到 $x+1$ 或停留在 $x$，试问 Koa 是否能够安全的从海岸 $0$ 到达岛上 $n+1$。
分析 开始的想法是随着时间 DP，更好的解法是贪心。
若一个位置在水位最高时仍不会溺水，则称这个位置是安全的，并且可以任意选择出发时机。
即安全位置之间是相互独立的，我们只需判断可达性，尽量到达每一个安全位置。若之后 $2k$ 个位置没有安全位置，必死。
Koa 的最优决策是在刚退潮时出发，如果能走就尽量往前走，不能走就等，等到涨潮就说明不存在通过方法。
int main() { int ttt = rr(); while (ttt--) { int n = rr(), k = rr(), l = rr(); int flag = 0; int last = k; for (ll i = 1; i &amp;lt;= n; i++) { int d = rr(); flag += l &amp;lt; d; if (l - d &amp;gt;= k) last = k; else last = min(last - 1, l - d); flag += abs(last) &amp;gt; l - d; } if (flag) printf(&amp;#34;No\n&amp;#34;); else printf(&amp;#34;Yes\n&amp;#34;); } return 0; } </description>
    </item>
    
    <item>
      <title>P1004 方格取数</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1004/</link>
      <pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/2020-09/p1004/</guid>
      <description>题目大意 在 $n \times n$ 的方格（$n \leqslant 9$）中存在一些正整数，经过格子时获得格子上的数，但只能获得一次。
某人只能向右或向下走，从格子的左上角走到到右下角，共走两次，求最大能取得的数字。
分析 考虑把先走后走转化为两个人同时走，只需要处理遇到两次的值即可。
考虑四维 DP，用 $dp[x_1,y_1,x_2,y_2]$ 表示第一个人走到 $(x_1,y_1)$ 和第二个人走到 $(x_2,y_2)$。
再考虑转移，每一个位置仅可能从其左面或上面转移来，于是可以写出（$x_1 \ne y_1$ 或 $x_2 \ne y_2$ 时）
$$ dp[x_1,y_1,x_2,y_2] = \max\left\{ \begin{matrix} dp[x_1-1,y_1,x_2-1,y_2] \\ dp[x_1,y_1-1,x_2-1,y_2] \\ dp[x_1-1,y_1,x_2,y_2-1] \\ dp[x_1,y_1-1,x_2,y_2-1] \end{matrix}\right\} + a[x_1,y_1] + a[x_2,y_2] $$
当 $x_1=y_1,x_2=y_2$ 时，只加一次即可。到这里 $O(n^4)$ 其实已经可以过题了，但还可以优化。
注意到一些状态是不可达的，因为 $x_1+y_1 = x_2+y_2$，因此存在 $O(n^3)$ 的 DP。
考虑当前已走长度 $h=x_1+y_1=x_2+y_2$，于是可以把两个人的座标表示为 $(x_1,h-x_1)$ 和 $(x_2,h-x_2)$。
于是记状态为 $dp[h,x_1,x_2]$，当 $x_1 \ne x_2$ 时有
$$ dp[h,x_1,x_2] = \max\left\{ \begin{matrix} dp[h-1,x_1,x_2] \\ dp[h-1,x_1,x_2-1] \\ dp[h-1,x_1-1,x_2] \\ dp[h-1,x_1-1,x_2-1] \end{matrix}\right\} + a[x_1,h-x_1] + a[x_2,h-x_2] $$</description>
    </item>
    
    <item>
      <title>OJ 题目跳转</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/other/jump/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/other/jump/</guid>
      <description></description>
    </item>
    
    <item>
      <title>模板生成</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/other/template-gen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/other/template-gen/</guid>
      <description></description>
    </item>
    
    <item>
      <title>贴代码</title>
      <link>https://rogeryoungh.github.io/code-of-acm/post/other/code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rogeryoungh.github.io/code-of-acm/post/other/code/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
