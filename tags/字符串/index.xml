<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>字符串 on Roger Young</title><link>https://rogeryoungh.github.io/code-of-acm/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><description>Recent content in 字符串 on Roger Young</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>© 2021 [Roger Young](/code-of-acm)</copyright><lastBuildDate>Wed, 28 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://rogeryoungh.github.io/code-of-acm/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.xml" rel="self" type="application/rss+xml"/><item><title>P4173 残缺的字符串</title><link>https://rogeryoungh.github.io/code-of-acm/post/2021-07/p4173/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://rogeryoungh.github.io/code-of-acm/post/2021-07/p4173/</guid><description>Todo
char a[MAXN], b[MAXN]; ll ts[MAXN], tb[MAXN]; Comp B[MAXN], S[MAXN]; Comp ANS[MAXN]; int stk[MAXN], cnt = 0; int main() { ll m = rr(), n = rr(); int lim = 1, lim_2; while (lim &amp;lt;= n + m) lim &amp;lt;&amp;lt;= 1; lim_2 = lim &amp;gt;&amp;gt; 1; for (int i = 0; i &amp;lt; lim; ++i) { rev[i] = (rev[i &amp;gt;&amp;gt; 1] &amp;gt;&amp;gt; 1) | ((i &amp;amp; 1) * lim_2); } scanf(&amp;#34;%s&amp;#34;, a); // 模式串 scanf(&amp;#34;%s&amp;#34;, b); // 文本串 _fora (i, 1, m) { ll j = m - i; ll t = a[j] - &amp;#39;a&amp;#39; + 1; if (a[j] == &amp;#39;*&amp;#39;) t = 0; ts[i] = t; } _fora (i, 0, n - 1) { ll t = b[i] - &amp;#39;a&amp;#39; + 1; if (b[i] == &amp;#39;*&amp;#39;) t = 0; tb[i] = t; } _fora (i, 0, lim - 1) { S[i] = Comp(ts[i], 0); B[i] = Comp(tb[i] * tb[i] * tb[i], 0); } FFT(S, lim, 1); FFT(B, lim, 1); _fora (i, 0, lim - 1) ANS[i] = S[i] * B[i]; _fora (i, 0, lim - 1) { S[i] = Comp(ts[i] * ts[i] * ts[i], 0); B[i] = Comp(tb[i], 0); } FFT(S, lim, 1); FFT(B, lim, 1); _fora (i, 0, lim - 1) ANS[i] = ANS[i] + S[i] * B[i]; _fora (i, 0, lim - 1) { S[i] = Comp(ts[i] * ts[i], 0); B[i] = Comp(tb[i] * tb[i], 0); } FFT(S, lim, 1); FFT(B, lim, 1); _fora (i, 0, lim - 1) ANS[i] = ANS[i] - S[i] * B[i] * Comp(2, 0); FFT(ANS, lim, -1); _fora (i, m, n) { if (fabs(ANS[i].</description></item><item><title>P1928 外星密码</title><link>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1928/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://rogeryoungh.github.io/code-of-acm/post/2020-10/p1928/</guid><description>题目大意 我们将重复的 $n$ 个字符串 S 压缩为 [nS]，且存在多重压缩。给定一个压缩结果，展开它。
分析 我考虑用类似状态机的方式解析字符串。
当读到正常字符时，把它添到 $s$ 末尾 读到左括号时，则递归 read()，重复 $n$ 遍添到 $s$ 末尾 右括号或文本结束则返回 $s$ 写成 BNF 更直观一点
&amp;lt;pwd&amp;gt; ::= &amp;lt;EMPTY&amp;gt; | {&amp;lt;ALPHA&amp;gt;} | &amp;lt;pwd&amp;gt; &amp;#34;[&amp;#34; &amp;lt;NUMBER&amp;gt; &amp;lt;pwd&amp;gt; &amp;#34;]&amp;#34; &amp;lt;pwd&amp;gt; string read() { string s = &amp;#34;&amp;#34;; char c; while (cin &amp;gt;&amp;gt; c) { if (c == &amp;#39;[&amp;#39;) { int n; cin &amp;gt;&amp;gt; n; string ts = read(); while (n--) s += ts; } else if (c == &amp;#39;]&amp;#39;) { return s; } else { s += c; } } return s; } int main() { cout &amp;lt;&amp;lt; read(); return 0; }</description></item></channel></rss>