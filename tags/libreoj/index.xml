<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>LibreOJ on Roger Young</title><link>https://rogeryoungh.github.io/code-of-acm/tags/libreoj/</link><description>Recent content in LibreOJ on Roger Young</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>© 2021 [Roger Young](/code-of-acm)</copyright><lastBuildDate>Sun, 15 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://rogeryoungh.github.io/code-of-acm/tags/libreoj/index.xml" rel="self" type="application/rss+xml"/><item><title>LOJ6053 简单的函数</title><link>https://rogeryoungh.github.io/code-of-acm/post/2021-08/loj6053/</link><pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate><guid>https://rogeryoungh.github.io/code-of-acm/post/2021-08/loj6053/</guid><description>题目大意 给定积性函数 $f(p^c) = p \oplus c$。对 $1000000007$ 取模求前缀和。
分析 Min25 板子题。
const ll mod = 1000000007, inv2 = 500000004; const int maxn = 200001; ll n, prime[maxn], cnt, w[maxn], s[maxn], c[maxn]; ll sqrt_n, m; ll mo(ll x) { return (x + mod) % mod; } ll f_p(ll p, ll e) { return p ^ e; } int id(ll x) { return x &amp;lt;= sqrt_n ? x : m - (n / x) + 1; } ll F(long long n, int k) { if (n &amp;lt;= prime[k]) return 0; ll ret = s[id(n)] - s[prime[k]]; for (int i = k + 1; i &amp;lt;= cnt &amp;amp;&amp;amp; prime[i] * prime[i] &amp;lt;= n; i++) { ll pi = prime[i], pk = pi; for (int c = 1; pk * pi &amp;lt;= n; c++, pk *= pi) ret += f_p(pi, c) * F(n / pk, i) + f_p(pi, c + 1); } return mo(ret); } int main() { n = rr(); sqrt_n = sqrt(n + 0.</description></item><item><title>CF1389E Calendar Ambiguity</title><link>https://rogeryoungh.github.io/code-of-acm/post/2021-05/cf1389e/</link><pubDate>Mon, 24 May 2021 00:00:00 +0000</pubDate><guid>https://rogeryoungh.github.io/code-of-acm/post/2021-05/cf1389e/</guid><description>Berland 年有 $m$ 月，每月 $d$ 天。一周有 $w$ 天。
若第 $x$ 月的第 $y$ 天和第 $y$ 月的第 $x$ 天是同一个星期，则称 $(x,y)$ 是一对。
求一年有几对。
$$ xd+y \equiv yd+x \pmod w $$ 即
$$ (x-y)(d-1) \equiv 0 \Rightarrow (x-y)(d-1) \in w\mathbb{Z} $$ 于是有
$$ y-x = \frac{wk}{\gcd(w,d-1)} $$ 又 $x &amp;lt; y \leqslant \min(m,d)$​，
int main() { ll ttt = rr(); while (ttt--) { ll m = rr(), d = rr(), w = rr(); ll g = w / gcd(w, d - 1); ll max_y = min(m, d) - 1; ll div = (max_y + 1) / g, mod = (max_y + 1) % g; ll sum = (div - 1) * div / 2 * g + mod * div; printf(&amp;#34;%lld\n&amp;#34;, sum); } return 0; }</description></item></channel></rss>