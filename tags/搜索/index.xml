<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>搜索 on Roger Young</title><link>https://rogeryoungh.github.io/code-of-acm/tags/%E6%90%9C%E7%B4%A2/</link><description>Recent content in 搜索 on Roger Young</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>© 2021 [Roger Young](/code-of-acm)</copyright><lastBuildDate>Mon, 29 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://rogeryoungh.github.io/code-of-acm/tags/%E6%90%9C%E7%B4%A2/index.xml" rel="self" type="application/rss+xml"/><item><title>P1019 单词接龙</title><link>https://rogeryoungh.github.io/code-of-acm/post/2021-03/p1019/</link><pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate><guid>https://rogeryoungh.github.io/code-of-acm/post/2021-03/p1019/</guid><description>题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。
给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。
分析 我是没想出来，经题解提示了拼接函数才写出来的。
设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。
char s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; _fora (i, 1, ml) { int flag = 1; _fora (j, 0, i - 1) { if (s[x][len[x] + j - i] != s[y][j]) { flag = 0; break; } } if (flag) { mt[x][y] = i; break; } } } 然后回溯 dfs，搜索即可。</description></item></channel></rss>