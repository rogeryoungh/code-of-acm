<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>搜索 on Roger Young</title>
    <link>https://acm.rogery.dev/tags/%E6%90%9C%E7%B4%A2/</link>
    <description>Recent content in 搜索 on Roger Young</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>© 2021 [Roger Young](https://acm.rogery.dev)</copyright>
    <lastBuildDate>Mon, 29 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://acm.rogery.dev/tags/%E6%90%9C%E7%B4%A2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>P1019 单词接龙</title>
      <link>https://acm.rogery.dev/post/2021-03/p1019/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://acm.rogery.dev/post/2021-03/p1019/</guid>
      <description>题目大意 对于字符串 $a,b$，若 $a$ 的末尾与 $b$ 的开头有部分字符串相同，则其可以拼接起来。例如 at + tact = atact。
给定词典和初始字母，每个单词最多出现两次，求最大拼接长度。
分析 我是没想出来，经题解提示了拼接函数才写出来的。
设 $mt(x,y)$ 为第 $x$ 和 $y$ 个单词拼接后的最小重合长度，其可简单的通过匹配得到。
char s[30][100]; ll len[30]; ll mt[30][30]; void init(int x, int y) { ll ml = min(len[x], len[y]) - 1; for (ll i = 1; i &amp;lt;= ml; i++) { int flag = 1; for (ll j = 0; j &amp;lt;= i - 1; j++) { if (s[x][len[x] + j - i] !</description>
    </item>
    
  </channel>
</rss>
