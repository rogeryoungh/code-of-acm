using D = double;
const D PI = std::acos(-1.0), EPS = 1E-8;

int sgn(D a) {
	return a < -EPS ? -1 : a > EPS;
}
int sgn(D a, D b) {
	return sgn(a - b);
}

// clang-format off
#define OPERATOR(U, V, op)	\
friend inline U operator op(const U &l, const V &r) {	\
	return U(l) op##= r;	\
}
// clang-format on

struct P {
#define T (*this)
	D x{}, y{};
	P() = default;
	explicit P(D t) : x(std::cos(t)), y(std::sin(t)) {}
	P(D a, D b) : x(a), y(b) {}
	P &operator+=(const P &o) {
		return x += o.x, y += o.y, T;
	}
	P &operator-=(const P &o) {
		return x -= o.x, y -= o.y, T;
	}
	P &operator*=(const D &k) {
		return x *= k, y *= k, T;
	}
	P &operator/=(const D &k) {
		return x /= k, y /= k, T;
	}
	P operator-() const {
		return {-x, -y};
	}
	OPERATOR(P, P, +);
	OPERATOR(P, P, -);
	OPERATOR(P, D, *);
	OPERATOR(P, D, /);
	D norm() const {
		return x * x + y * y;
	}
	D abs() const {
		return std::sqrt(norm());
	}
	D rabs() const {
		return std::max(std::abs(x), std::abs(y));
	}
	D arg() const {
		return std::atan2(y, x);
	}
#undef T
};

int cmp(const P &l, const P &r) {
	return 2 * sgn(l.x, r.x) + sgn(l.y, r.y);
}

bool operator<(const P &l, const P &r) {
	return cmp(l, r) < 0;
}

bool operator==(const P &l, const P &r) {
	return cmp(l, r) == 0;
}

inline D crs(P a, P b) {
	return a.x * b.y - a.y * b.x;
}

inline D dot(P a, P b) {
	return a.x * b.x + a.y * b.y;
}

int sgn_crs(P a, P b) {
	D cr = crs(a, b);
	bool f = std::abs(cr) <= (a.rabs() + b.rabs()) * EPS;
	return f ? 0 : (cr < 0) ? -1 : 1;
}

// -2, -1, 0, 1, 2 : front, clock, on, cclock, back
int ccw(P b, P c) {
	int s = sgn_crs(b, c);
	if (s)
		return s;
	if (!sgn(c.rabs()) || !sgn((c - b).rabs()))
		return 0;
	if (dot(b, c) < 0)
		return 2;
	if (dot(-b, c - b) < 0)
		return -2;
	return 0;
}

int ccw(P a, P b, P c) {
	return ccw(b - a, c - a);
}

std::ostream &operator<<(std::ostream &os, const P &p) {
	return os << "P(" << p.x << ", " << p.y << ")";
}

struct L {
	P s, t;
	L(P a, P b) : s(a), t(b) {}
	P vec() const {
		return t - s;
	}
	D abs() const {
		return vec().abs();
	}
	D arg() const {
		return vec().arg();
	}
};

int ccw(L l, P p) {
	return ccw(l.s, l.t, p);
}

P proj(const L &l, const P &p) {
	P v = l.vec();
	return l.s + v * dot(v, p - l.s) / v.norm();
}

bool insSL(const L &s, const L &l) {
	int a = ccw(l, s.s), b = ccw(l, s.t);
	return (a % 2 == 0 || b % 2 == 0 || a != b);
}

bool insSS(const L &s, const L &t) {
	int a = ccw(s, t.s), b = ccw(s, t.t);
	int c = ccw(t, s.s), d = ccw(t, s.t);
	return a * b <= 0 && c * d <= 0;
}

D distLP(const L &l, const P &p) {
	return std::abs(crs(l.vec(), p - l.s)) / l.abs();
}

D distSP(const L &s, const P &p) {
	P q = proj(s, p);
	if (ccw(s, q) == 0)
		return (p - q).abs();
	else
		return std::min((s.s - p).abs(), (s.t - p).abs());
}

D distSS(const L &s, const L &t) {
	if (insSS(s, t))
		return 0;
	return std::min({
		distSP(s, t.s),
		distSP(s, t.t),
		distSP(t, s.s),
		distSP(t, s.t),
	});
}

int crossLL(const L &l, const L &m, P &r) {
	P lv = l.vec(), mv = m.vec();
	D cr1 = crs(lv, mv), cr2 = crs(lv, l.t - m.s);
	if (sgn_crs(lv, mv) == 0) {
		r = l.s;
		if (sgn_crs(lv, l.t - m.s))
			return 0;
		return -1;
	}
	r = m.s + mv * cr2 / cr1;
	return 1;
}

int crossSS(L l, L m, P &r) {
	int u = crossLL(l, m, r);
	if (u == 0)
		return 0;
	if (u == -1) {
		r = std::max(std::min(l.s, l.t), std::min(m.s, m.t));
		P q = std::min(std::max(l.s, l.t), std::max(m.s, m.t));
		return (q < r) ? 0 : (q == r ? 1 : -1);
	}
	if (ccw(l, r) == 0 && ccw(m, r) == 0)
		return 1;
	return 0;
}