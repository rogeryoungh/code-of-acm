---
author: "rogeryoungh"
title: "2021 牛客寒假算法基础集训营 1"
date: "2022-04-06"
katex: true
showtoc: true
---

复习一下。

## A. 串

计算长度不超过 $n$ 且蕴含 `us` 作为子串的字符串有多少个。

### 分析

读错题目了，还以为是容斥。对 “出现 us”、“出现 u”、“其他” 三种情况分别 DP。

```cpp
int main() {
    int n;
    cin >> n;
    ll ans = 0;
    ll dp0 = 1, dpu = 0, dps = 0;
    for (int i = 1; i <= n; i++) {
        ll t0 = dp0 * 25 % P;
        ll tu = (dpu * 25 + dp0) % P;
        ll ts = (dpu + dps * 26) % P;
        dp0 = t0, dpu = tu, dps = ts;
        ans = (ans + dps) % P;
    }
    cout << ans;
    return 0;
}
```

实际上计算可以做到 $\log n$。记三种情况分别为 $o_n, u_n, s_n$，可以解得

$$
o_n = 25^n, \quad u_n = n 25^{n-1}, \quad s_n = 26^n - o_n-u_n
$$

因此计算得

$$
\sum_{i=2}^n s_i = \frac{1}{14400}(576 \cdot 26^{n+1} - (599+24n)25^{n+1}-1)
$$

## B. 括号

构造长度不超过 $10^5$ 的括号串，使得恰好包含 $k$ 个括号对。

### 分析

考虑弄 $5 \times 10^4$ 个 `(`，再考虑如何把 $k$ 拆分成 $k_i$，在 $k_i$ 后加上右括号即可。

拆分可以从 $5\times10^4$ 开始，逐渐递减。若是从小到大，长度会超。

```cpp
int main() {
    ll k;
    cin >> k;
    vector<int> vis(N + 1);
    for (int i = N; i >= 1; i--) {
        if (k >= i) {
            k -= i;
            vis[i] = 1;
        }
    }
    string s;
    for (int i = 1; i <= N; i++) {
        s.push_back('(');
        if (vis[i])
            s.push_back(')');
    }
    cout << s;
	return 0;
}
```

## C. 红和蓝

给定一棵 $n$ 个节点的树，需要用红色和蓝色把树染色：

- 每个红点周围有且仅有一个红点，每个蓝点周围有且仅有一个蓝点。

### 分析

显然颜色是以二元对的形式分组。下证这样的分组形式唯一。

- 如果该点是叶子，其必须和父节点同色，形式唯一。
- 如果该点不是叶子，则只有两种可能：
- - 已经被子节点标记，形式唯一。
- - 未被标记，依 DFS 序知子节点全是已经标记，且确定唯一的。故只能和父节点同色。

对于每个叶子，其必须和其父节点同色，从而可以赋给他们相同的编号。如果某个叶子其父节点已经被标记，则说明此树不可染色。

```cpp
const int N = 1E5;

vector<int> G[N];

int main() {
	int n;
	cin >> n;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}

	vector<int> vis(n + 1), col(n + 1);
	int cnt = 0;
	std::function<void(int, int)> dfs1 = [&](int x, int fa) {
		for (auto u : G[x]) {
			if (u != fa)
				dfs1(u, x);
		}
		if (!vis[x]) {
			if (vis[fa]) {
				cout << "-1";
				exit(0);
			}
			vis[fa] = vis[x] = ++cnt;
		}
	};

	std::function<void(int, int)> dfs2 = [&](int x, int fa) {
		for (auto u : G[x]) {
			if (u == fa)
				continue;
			if (vis[u] == vis[x]) {
				col[u] = col[x];
			} else {
				col[u] = !col[x];
			}
			dfs2(u, x);
		}
	};

	vis[0] = 1, col[1] = 1;
	dfs1(1, 0), dfs2(1, 0);

	for (int i = 1; i <= n; i++) {
		cout << (col[i] ? 'R' : 'B');
	}

	return 0;
}
```

## D. 点一成零

给定一个 $n \times n$ 的 01 方阵，每次修改可以把一处格子由 $0$ 改为 $1$。

然后回答询问：每次点击可以把一个 $1$ 的连通块变为 $0$，问有几种操作能够全部为 $0$。

### 分析

若方阵中有 $a$ 个连通块，每个连通块的大小是 $b_i$，那么答案是

$$
ans = a! \prod b_i
$$

因此我们需要维护连通块的个数，和每个连通块的大小。用带权并查集实现即可。

同时需要维护连通块的乘积，在合并时维护乘积。

```cpp
const int N = 500 + 10;
char ss[N][N];

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> ss[i];
	}
	pre_all(n * n + 10);

	int cnt = 0, mul = 1;
	DSU dsu(n * n);

	auto merge = [&](int x1, int y1, int x2, int y2) {
		if (x2 < 0 || x2 >= n || y2 < 0 || y2 >= n)
			return;
		if (ss[x2][y2] == '0')
			return;
		int p1 = x1 * n + y1, p2 = x2 * n + y2;
		if (dsu.find(p1) != dsu.find(p2)) {
			mul = 1ll * mul * Inv[dsu.size(p1)] % P * Inv[dsu.size(p2)] % P;
			dsu.merge(p1, p2);
			mul = 1ll * mul * dsu.size(p1) % P;
			cnt--;
		}
	};

	auto change = [&](int i, int j) {
		if (ss[i][j] == '1')
			return;
		ss[i][j] = '1';
		cnt++;
		merge(i, j, i, j - 1);
		merge(i, j, i, j + 1);
		merge(i, j, i - 1, j);
		merge(i, j, i + 1, j);
	};

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (ss[i][j] == '0')
				continue;
			ss[i][j] = '0';
			change(i, j);
		}
	}

	int Q;
	cin >> Q;
	while (Q--) {
		int x, y;
		cin >> x >> y;
		change(x, y);
		cout << 1ll * mul * fac[cnt] % P << "\n";
	}

	return 0;
}
```


